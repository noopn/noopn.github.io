[{"title":"Service Worker 相关问题","url":"/posts/1998cddaf148/","content":"注册\nindex.html\n\nservice worker 的 scope 范围与 sw.js 所在的路径相关，只能对 sw.js 所在路径以及其子路径生效\nconst url = new URL(location.href);if (&quot;serviceWorker&quot; in navigator) &#123;  addEventListener(&quot;load&quot;, () =&gt; &#123;    navigator.serviceWorker      .register(&quot;./sw.js&quot;, &#123; scope: &quot;/&quot; &#125;)      .then((registration) =&gt; &#123;        var serviceWorker;        if (registration.installing) &#123;          serviceWorker = registration.installing;          // 这里可以处理正在安装状态        &#125; else if (registration.waiting) &#123;          serviceWorker = registration.waiting;          // 这里可以处理等待状态        &#125; else if (registration.active) &#123;          serviceWorker = registration.active;          emitCacheList(serviceWorker);        &#125;        if (serviceWorker) &#123;          serviceWorker.addEventListener(&quot;statechange&quot;, function (e) &#123;            if (e.target.state === &quot;activated&quot;) &#123;              // Service Worker 已经激活，可以发送消息              emitCacheList(serviceWorker);            &#125;          &#125;);        &#125;      &#125;)      .catch((err) =&gt; &#123;        console.warn(&quot;desktop_sw register fail.&quot;);      &#125;);  &#125;);&#125;\n\n安装this.addEventListener(&quot;install&quot;, function (event) &#123;  console.log(&quot;install&quot;);&#125;);\n\n激活不一定每次都能触发。前一个还在工作状态那么后一个就会进 waiting 阶段,只有等到前一个被 terminated 后,后一个才能完全替换 A 的工作\nthis.addEventListener(&quot;activate&quot;, function (event) &#123;  console.log(&quot;activate&quot;);&#125;);\n\n更新在这些条件中会执行更新操作\n主动在每次注册后执行更新\nnavigator.serviceWorker  .register(&quot;/sw.js&quot;, &#123;    scope: &quot;/&quot;,  &#125;)  .then((registration: any) =&gt; &#123;    registration.update();  &#125;);// 使用 workboxwb.register().then((registration: any) =&gt; &#123;  registration.update();&#125;);\n\n关闭\nterminated\n关闭浏览器一段时间\n手动清除 serviceworker\n在 sw 安装时直接跳过 waiting 阶段 self.skipWaiting();\n\n拦截请求拦截请求 只有 activate 之后才能工作\n页面本身的 URL 不在 Service Worker 的 scope 内时，Service Worker 并不会对该页面加载过程中的任何请求（包括在 scope 内的资源）有控制权。页面的控制权是从最顶层的文档开始的，如果顶层文档（页面）不在 Service Worker 的 scope 内，那么 Service Worker 就不能影响到从这个页面发出的任何请求，即使这些请求本身的目标 URL 是在 Service Worker 的 scope 范围内。\nthis.addEventListener(&quot;fetch&quot;, function (event) &#123;  // 返回jSON HTML  const json = JSON.stringify(&#123; a: 1 &#125;, null, 2);  return event.respondWith(    new Response(json, &#123;      headers: &#123;        &quot;content-type&quot;: &quot;application/json;charset=UTF-8&quot;,      &#125;,    &#125;)  );&#125;);\n\n// 拦击请求 只有activate之后才能工作this.addEventListener(&quot;fetch&quot;, function (event) &#123;  const html = &quot;&lt;html&gt;&lt;div&gt;html&lt;/div&gt;&lt;/html&gt;&quot;;  return event.respondWith(    new Response(html, &#123;      headers: &#123;        &quot;content-type&quot;: &quot;text/html;charset=UTF-8&quot;,      &#125;,    &#125;)  );  // 重定向  return event.respondWith(Response.redirect(&quot;https://baidu.com&quot;, 301));&#125;);\n\nthis.addEventListener(&quot;fetch&quot;, function (event) &#123;  const url = new URL(event.request.url);  if (location.origin !== url.origin) return;  return event.respondWith(    caches.match(event.request).then((res) =&gt; &#123;      if (res) return res;      return fetch(event.request).then((res) =&gt; &#123;        if (!res || res.status !== 200 || res.type !== &quot;basic&quot;) &#123;          return res;        &#125;        const clone = res.clone();        caches.open(config.CACHE_VERSION).then((caches) =&gt; &#123;          caches.put(event.request, clone);        &#125;);        return res;      &#125;);    &#125;)  );&#125;);\n\n通信客户端向 sw 发送消息，需要保证 sw 已经处于 activated 状态\n// index.htmlserviceWorker.postMessage(&#123; a: 1 &#125;);// sw.jsthis.addEventListener(&quot;message&quot;, function (event) &#123;  console.log(&quot;收到页面消息&quot;, event.data);&#125;);\n\n数据同步， sw 可以监听客户端发起的 sync 请求，当离线环境时，sw 在后台将任务挂起，当网络恢复会执行回调函数， 相同的 tag 在网络恢复后只会执行一次， tag 不能用于传输数据， 离线数据应该使用持久化保存。\n// index.htmlnavigator.serviceWorker.ready.then(function (registration) &#123;  document.body.addEventListener(&quot;click&quot;, () =&gt; &#123;    registration.sync      .register(&quot;data_sync&quot;)      .then(function () &#123;        console.log(&quot;后台同步已触发&quot;);      &#125;)      .catch(function (err) &#123;        console.log(&quot;后台同步触发失败&quot;, err);      &#125;);  &#125;);&#125;);// sw.jsself.addEventListener(&quot;sync&quot;, function (e) &#123;  switch (e.tag) &#123;    case &quot;data_sync&quot;:      break;    default:      return;  &#125;&#125;);\n\nworkboxworkbox docs\n\n注册\n// index.htmlif (&quot;serviceWorker&quot; in navigator) &#123;  const &#123; Workbox &#125; = await import(&quot;workbox-window&quot;);  const wb = new Workbox(&quot;sw.js&quot;);  // 实现 window 与 sw 通信  wb.addEventListener(&quot;activated&quot;, (event) =&gt; &#123;    const urlsToCache = [      location.href,      ...performance.getEntriesByType(&quot;resource&quot;).map((r) =&gt; r.name),    ];    wb.messageSW(&#123;      type: &quot;CACHE_URLS&quot;,      payload: urlsToCache,    &#125;);  &#125;);  wb.register();&#125;\n\n使用预设\n通常不需要手动设置 workbox-precaching， 应该使用 workbox-build 或 workbox-webpack-plugin 自动生成依赖文件\n// sw.jsimport &#123; pageCache, staticResourceCache, imageCache &#125; from &quot;workbox-recipes&quot;;import &#123; precacheAndRoute &#125; from &quot;workbox-precaching&quot;;pageCache();staticResourceCache();imageCache();// 表示缓存所有 webpack 打包的 manifest 文件precacheAndRoute(self.__WB_MANIFEST || []);\n\n使用 workbox-precaching 缓存\n当应用首次载入 install 事件中，workbox-precaching 会查看你要下载的资源，删除重复的并使用 SW 事件下载并缓存资源。资源的 URL 中已经包含了可以用作缓存 key 的信息\n\n使用 workbox-webpack-plugin\nGenerateSW : 适用与预缓存文件，或有简单的缓存需求。 不适用与使用其他的 SW 特新，例如 Web Push, 或有自定一的缓存逻辑\nInjectManifest： InjectManifest 插件将生成一个要预缓存的 url 列表，并将该预缓存清单添加到现有的 service worker 文件中。否则它将使文件保持原样。\n适用于想要更多的控制 SW，缓存文件，自定义路由策略，想要使用其他的 SW 特性，\n会在 output.path 中生成 sw.js 文件，需要手动在 index.html 中引入\n// webpack.config.jsconst &#123; InjectManifest &#125; = require(&quot;workbox-webpack-plugin&quot;);module.exports = &#123;  plugins: [    new InjectManifest(&#123;      swSrc: &quot;sw.js&quot;,      exclude: [        /\\.map$/,        /manifest$/,        /\\.htaccess$/,        /service-worker\\.js$/,        /sw\\.js$/,      ],    &#125;),  ],&#125;;\n\n什么是 Service Worker？它的作用是什么？Service Worker 是一种运行在浏览器后台的 JavaScript 脚本，独立于页面上下文，并且与页面的生命周期分离。它提供了拦截和处理网络请求的能力，从而使得网页能够支持离线工作、缓存资源和后台同步等功能。它是 渐进式 Web 应用（PWA）的关键组成部分。\n离线支持：缓存页面和资源，使得在没有网络连接时，应用仍能工作。网络请求拦截：可以拦截网络请求并提供自定义响应，例如从缓存中获取资源，或将请求转发给网络。后台同步：在应用有网络时自动同步数据。推送通知：支持推送通知，允许在用户不活跃时向其发送消息。\nService Worker 的生命周期是什么样的？注册：通过 navigator.serviceWorker.register() 方法注册 Service Worker。此时浏览器会检查是否需要安装新的 Service Worker。安装（Install）：注册后，如果没有有效的 Service Worker，浏览器会尝试安装它。在此阶段，通常会缓存一些静态资源。激活（Activate）：安装完成后，Service Worker 会激活。在此阶段，可以清理旧的缓存和控制页面。控制：Service Worker 激活后，能够控制所有符合条件的页面，开始拦截网络请求。更新：Service Worker 可能会定期检查更新，新的 Service Worker 安装并激活后，旧的 Service Worker 会被终止。\nService Worker 中的 fetch 事件是如何工作的？fetch 事件是 Service Worker 中用于拦截和处理网络请求的核心事件。每当页面发起请求时，Service Worker 会通过 fetch 事件捕获请求，允许开发者决定如何响应这些请求（例如，从缓存中获取、从网络获取或自定义响应）。\nself.addEventListener(&quot;fetch&quot;, function (event) &#123;  event.respondWith(    caches      .match(event.request) // 优先从缓存中获取      .then(function (response) &#123;        return response || fetch(event.request); // 如果缓存中没有，则从网络获取      &#125;)  );&#125;);\n\nevent.respondWith() 方法用于返回一个 Response 对象，覆盖默认的网络请求处理方式。\n什么是 Service Worker 的作用域？Service Worker 的作用域是指它可以控制的 URL 范围。在注册时，可以指定作用域，它决定了 Service Worker 可以拦截哪些请求。默认情况下，Service Worker 会控制它所在路径下的所有页面和资源。\n如果没有指定作用域，Service Worker 会默认控制当前路径及其子路径下的页面。\nnavigator.serviceWorker.register(&quot;/service-worker.js&quot;, &#123; scope: &quot;/&quot; &#125;);\n\n如何实现离线缓存？离线缓存的基本思路是在 install 事件中缓存需要的资源，然后在 fetch 事件中拦截请求，从缓存中提供响应。在安装时，将文件添加到缓存中，fetch 事件会拦截请求，优先从缓存中返回资源。\ncache.add()：将单个资源添加到缓存。cache.addAll()：将多个资源添加到缓存。cache.put()：将指定请求和响应对存入缓存。caches.delete()：删除指定缓存。\nself.addEventListener(&quot;install&quot;, function (event) &#123;  event.waitUntil(    caches.open(&quot;my-cache&quot;).then(function (cache) &#123;      return cache.addAll([        &quot;/index.html&quot;,        &quot;/styles.css&quot;,        &quot;/script.js&quot;,        &quot;/offline.html&quot;,      ]);    &#125;)  );&#125;);self.addEventListener(&quot;fetch&quot;, function (event) &#123;  event.respondWith(    caches.match(event.request).then(function (response) &#123;      return response || fetch(event.request); // 网络优先    &#125;)  );&#125;);\n\nself.skipWaiting() 和 self.clients.claim() 的作用是什么？self.skipWaiting()：在激活新的 Service Worker 时，跳过等待阶段，立即使新的 Service Worker 控制页面。这对实现即时更新非常有用。\nself.clients.claim()：在 Service Worker 激活后，立即接管当前打开的页面，使其受该 Service Worker 控制，避免等待页面重新加载。\nself.addEventListener(&quot;install&quot;, function (event) &#123;  self.skipWaiting(); // 立即激活&#125;);self.addEventListener(&quot;activate&quot;, function (event) &#123;  event.waitUntil(self.clients.claim()); // 立即接管控制&#125;);\n\n如何清理旧的缓存？在 Service Worker 的 activate 事件中，可以清理旧的缓存。例如，在更新时清理不再需要的缓存：\nself.addEventListener(&quot;activate&quot;, function (event) &#123;  var cacheWhitelist = [&quot;my-cache-v2&quot;]; // 新的缓存名称  event.waitUntil(    caches.keys().then(function (cacheNames) &#123;      return Promise.all(        cacheNames.map(function (cacheName) &#123;          if (!cacheWhitelist.includes(cacheName)) &#123;            return caches.delete(cacheName); // 删除不在白名单中的缓存          &#125;        &#125;)      );    &#125;)  );&#125;);\n\n如何使用 Service Worker 支持推送通知推送通知依赖于 Service Worker 的 push 事件。当接收到推送消息时，Service Worker 会在后台处理并显示通知。\nself.addEventListener(&quot;push&quot;, function (event) &#123;  var options = &#123;    body: event.data.text(),    icon: &quot;/icon.png&quot;,    badge: &quot;/badge.png&quot;,  &#125;;  event.waitUntil(    self.registration.showNotification(&quot;Push Notification&quot;, options)  );&#125;);\n\nService Worker 的缓存策略有哪些Cache-first：优先从缓存获取资源，如果没有，再从网络获取。Network-first：优先从网络获取资源，如果失败，再从缓存中获取。Stale-while-revalidate：先从缓存获取过时的资源，然后异步从网络获取最新的资源，并更新缓存。\n如何使用 Service Worker 实现离线数据同步？在网络恢复的时候，sync 会自动触发。\n//客户端，注册监听事件navigator.serviceWorker.ready.then((registration) =&gt; &#123;  registration.sync.register(&quot;syncData&quot;);&#125;);// service workerself.addEventListener(&quot;sync&quot;, (event) =&gt; &#123;  if (event.tag === &quot;syncData&quot;) &#123;    event.waitUntil(syncData());  &#125;&#125;);\n\nService Worker 如何与多个标签页共享数据Service Worker 可以通过 客户端 API 与多个标签页进行通信。clients.matchAll() 可以获取所有控制的页面客户端，postMessage 用于与页面通信。\n// 页面中self.addEventListener(&quot;message&quot;, function (event) &#123;  console.log(&quot;Message from client:&quot;, event.data);  event.ports[0].postMessage(&quot;Hello from Service Worker!&quot;);&#125;);// service workerif (navigator.serviceWorker.controller) &#123;  navigator.serviceWorker.controller.postMessage(&quot;Hello from the page!&quot;);  navigator.serviceWorker.addEventListener(&quot;message&quot;, function (event) &#123;    console.log(&quot;Message from service worker:&quot;, event.data);  &#125;);&#125;\n\n如何在 Service Worker 中使用 self.registration.update()self.registration.update() 用于强制浏览器检查 Service Worker 是否有更新。如果应用程序需要强制立即检查更新，可以调用该方法。\nself.addEventListener(&quot;activate&quot;, function (event) &#123;  event.waitUntil(    self.registration.update() // 强制更新 Service Worker  );&#125;);\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"v8引擎相关知识","url":"/posts/fcb40a9ae42d/","content":"作用域作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。\n全局作用域 函数作用域 块级作用域\n块级作用域通过 词法环境（Lexical Environment） 实现,通过 const let 声明的变量具有块级作用域,只能在包含他们的代码块中访问。如果在顶级使用 let const，他么们不会被添加到 window 对象上，但是会在全局作用域中\n词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。\n作用域链其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。\nJavaScript 引擎首先会在当前的执行上下文中查找该变量，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。\nfunction foo() &#123;  var a = 1;  let b = 2;  &#123;    let b = 3;    var c = 4;    let d = 5;    console.log(a);    console.log(b);  &#125;  console.log(b);  console.log(c);  console.log(d);&#125;foo();\n\n\n进行词法分析，a,c 加入到变量环境 Variable Environment = &#123;a:undefined,c:undefined&#125;b 会加入到词法环境,解析块级作用域中的代码，需要开辟新的词法环境 Lexical Environment =  &#123;b:不可达&#125;=&gt; &#123;b:不可达,d:不可达&#125;\nlet 只会在执行的时候赋值,在词法分析阶段会被识别，但是不能访问，也就是暂时性死区(TDZ，Temporal Dead Zone)\n\n函数执行，a,b 被赋值，Variable Environment = &#123;a:1,c:undefined&#125;，Lexical Environment =  &#123;b:2&#125; =&gt; &#123;b:3,d:5&#125;会先查找词法环境，在查找变量环境\n\n\n闭包在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。\n如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。\n执行上下文执行上下文负责运行时代码的管理，包括作用域，变量，对象，函数生命周期。\n\n创建阶段，确定 this，创建变量环境，创建词法环境。\n执行阶段，函数内部代码开始执行,变量赋值，函数引用和执行。\n回收阶段，当函数执行完毕后，从相应的栈中弹出，资源被释放。\n\n内存JavaScript 是一种弱类型的、动态的语言.\n\n弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。\n动态，意味着你可以使用同一个变量保存不同类型的数据。\n\n数据科技分为原始类型和引用类型\n原始类型的数据保存在环境变量或词法环境中,包含这两个区域的执行上下文又被压入调用栈中,所以可以说原始类型是保存在栈空间中的.\n字符串，symbol，bigint 虽然是原始类型，实际还是存放在堆空间的。\n如果是一个引用类型,会单独存放到堆空间中,在分配了引用类型数据之后会拿到一个堆中的地址,在把这个地址保存到环境变量中.\nJavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了.\n所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。\n原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。\n从内存的角度来理解闭包:\nfunction foo() &#123;  let name = &quot;one&quot;;  const obj = &#123;    getName() &#123;      return name;    &#125;,    setName(_name) &#123;      name = _name;    &#125;,  &#125;;  return obj;&#125;var bar = foo();bar.setName(&quot;two&quot;);bar.getName();\n\n当 foo 函数执行的时候,首先是编译的过程,当遇到对象的两个方法时还需要对两个方法进行词法分析, 发现引用了 name 变量.\nJavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 name 变量。并把堆空间的地址保存在 foo 执行上下文中的环境变量中.\n垃圾回收分为栈内存回收,堆内存回收\n栈内存回收需要用到一个记录当前执行状态的指针（称为 ESP）,指向的就是当前的执行上下文,JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。当下移之后如果有新的函数调用,原来的内存位置就会写入新的执行上下文.\n回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器,垃圾回收的策略都是建立代际假说的基础之上的\n代际假说有以下两个特点：\n\n第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；\n第二个是不死的对象，会活得更久。\n\n需要根据对象变量的不同生命周期长短使用不同的策略:\n在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。新生区通常只支持 1 ～ 8M 的容量.副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。\n垃圾回收大致都分为一下几个步骤:\n\n标记活动对象和非活动对象\n清楚非活动对象\n内存整理,并不是所有的回收策略都需要这一步\n\n副垃圾回收器主要负责新生区的垃圾回收. 大多数小的对象都会被分配到新生区，这个区域虽然不大，但是垃圾回收还是比较频繁的。用 Scavenge[ˈskævɪndʒ] 算法来处理.原理是:\n把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区.\n新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。\n完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。\n由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。\n也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。\n主垃圾回收器 主要负责老生区中的垃圾回收。\n除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。\n，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。\n标记阶段就是从一组根元素(调用栈)开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。\n因为清除部分内存会产生碎片,而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact）,这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n全停顿,内存回收过程过长,又因为 JS 为单线程而阻塞 JS 执行,这个问题叫全停顿.\n对于新生代的内存回收影响不大,因为内存比较小,可以全停顿等待执行完成.对于老生代会将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法\n使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。\nJS 如何执行由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。\n编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了\n\n字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。\n如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。\n字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。\n处理新任务当一个线程在执行任务的时候，如何可以处理新任务，最简单的办法就是通过一个循环，不断检测是否有新的任务产生。\n这样可以解决同一个线程中产生的新任务，但是无法解决其他线程中产生的新任务。因为没有办法直接检测其他线程是否有新任务的产生。\n通用的模型就是消息队列，息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。\n渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程\n任务类型任务类型包括， 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。\n除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。\n以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。\n高优先级任务一个典型的场景是监听 DOM 的改变做一些逻辑处理，如果不加入消息队列选择同步处理，在 DOM 频繁改变的时候，当前任务会被延长，导致后面的任务不能及时处理。\n如果加入到消息队尾部，又可能影响效率，因为可能已经有很多任务在排队了。\n针对这种情况微任务就产生了，通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。\n事件循环浏览器处理消息队列用到了事件循环系统，但这个事件循环与 nodejs 事件循环没有关系。\n\nV8: V8 引擎自己实现了一个事件循环，但是 nodejs 和 浏览器都没有采用\n浏览器： 不同的厂商实现可能不同，chrome 浏览器使用 libevent 实现事件循环。\nnodejs： 使用 libuv 实现事件循环。\n\nsetTimeout 如何实现从使用方式上能感觉到，setTimeout 需要等待指定时间才能执行，而消息队列中的任务是立即执行的，所以 setTimeout 中的回调函数不能立即加入到消息队列中。\n所以浏览器还维护着一个延时任务列表，包括定时器和内部一些延时任务，创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。这个回调任务包括，定义的回调函数，发起时间，延时时间。\n在处理消息队列的时候，会调用出延时任务的方法 ProcessTimerTask 。这个方法的调用时机是当前事件循环中一个任务处理结束后开始执行。\nProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。\n在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，在 5 次调用之后，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。\n未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。\nChrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。\nXMLHttpRequest 实现流程渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。\n宏任务和微任务前面已经介绍过微任务的由来。\n宏任务：\n\n渲染事件（如解析 DOM、计算布局、绘制）；\n用户交互事件（如鼠标点击、滚动页面、放大缩小等）；\nJavaScript 脚本执行事件；\n网络请求完成\n文件读写完成事件\n\nWHATWG 规范中定义事件循环机制：\n\n先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；\n然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；\n当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；\n最后统计执行完成的时长等信息。\n\n由于宏任务不能精细的控制执行的时机，因为两个红任务之间可能被插入了很多系统级的任务。\n微任务：\n微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。\n\nMutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。\nPromise 当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。\n\n在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。\n如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。\n\n微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。\n微任务的执行时长会影响到当前宏任务的时长。\n在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。\n\n通过异步操作解决了同步操作的性能问题；通过微任务解决了实时性的问题。\nW3C 最新解释:\n\n每一个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列，在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。\n\n浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行。\n\n\n因此现在 chrome 中至少有 3 个队列：\n\n延时队列： 用于存放定时器到达后的回调任务，优先级中\n交互任务： 用于存放用户交互产生的任务，优先级高\n微队列： 用于存放最快需要执行的任务，优先级最高\n\nPromise.then 返回 Promise 的行为当一个 promise.then 方法返回另一个 Promise 时，thenable 的状态会吸收返回的 promise 的状态，也就是说 thenable 的状态与返回的 promise 状态保持一致\n但是这种状态并不是立即吸收的，返回的 promise 会被使用 then 方法，包装成新的 promise 对象，并添加到微队列中\nPromise.resolve()  .then(() =&gt; &#123;    //1 添加到微队列    console.log(0);        //3 打印0    //4 包装成 (Promise.resolve(4).then(res=&gt;res)).then(res=&gt;res)  =&gt; p4.then(res=&gt;res)添加到微队列    //7 res=&gt;res 添加到微队列    return Promise.resolve(4).then((res) =&gt; res);    //10 完成状态  &#125;)  .then((res) =&gt; &#123;    //11 添加到微队列    console.log(res);    //14 打印4  &#125;);Promise.resolve()  .then(() =&gt; &#123;    //2 添加到微队列    console.log(1);    //5 打印1  &#125;)  .then(() =&gt; &#123;    //6 添加到微队列    console.log(2);    //8 打印2  &#125;)  .then(() =&gt; &#123;    //9 添加到微队列    console.log(3);    //12 打印3  &#125;)  .then(() =&gt; &#123;    //13 添加到微队列    console.log(5);    //15 打印3  &#125;);\n","categories":["浏览器"],"tags":["浏览器","HTTP"]},{"title":"浏览器渲染过程","url":"/posts/0d7c79d891ee/","content":"用户输入用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。\n搜索内容: 使用浏览器默认的搜索引擎合成新的带搜索关键字的 URL合法的 URL: 加上协议，合成为完整的 URL\n执行搜索交互后，会先执行 beforeunload 事件，可以通过此事件取消导航。此时浏览器的状态是在加载中，但是页面内容并没有被替换，因为需要等待提交文档阶段.\nURL 请求过程浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程。\n是否命中 DNS 缓存，如果命中缓存直接返回。接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。\n如果时通过链接打开页面,如果两个页面是同一站点，新页面会复用父页面的渲染进程。\n提交文档\n网络进程获取到响应之后，向渲染进程发起提交文档的消息\n渲染进程接收到提交文档的消息后，会和网络进程建立传输数据的管道\n等文档数据传输完成之后，渲染进程会返回确认提交的消息给浏览器进程\n浏览器进程在收到确认提交的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。\n\n页面渲染\n\n构建 DOM 树HTML 解析器（HTMLParser）负责将 HTML 字节流转换为 DOM 结构。网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型,如果这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。网络进程和渲染进程之间会建立一个共享数据的管道,网络进程加载了多少数据，HTML 解析器便解析多少数据。\n第一个阶段，通过分词器将字节流转换为 Token。\n\n第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。HTML 解析器维护了一个 Token 栈结构,使用栈解构实现了匹配算法。\n\n构建 StyleSheet属性标准化计算每个节点的样式，css 继承规则和层叠规则\n\n创建渲染树,遍历 DOM 树中的可见节点,计算出每个元素的样式（即 ComputedStyle）。这里的计算包括所有继承的样式和从 CSS 规则中继承来的样式。\n\n创建布局树计算布局信息，布局信息保存在布局树中。\n\n创建无障碍树\n\n分层，创建图层树定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素,需要被剪裁等，都拥有层叠上下文属性。可以通过 will-change 属性，让元素单独在合成线程中执行。\n\n图层绘制，渲染进程生成绘制指令,真实的绘制由渲染进程中的合成线程来完成。通常只绘制视口附近的图像，合成线程会将图层划分为图块。\n合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。\n合成过程会使用 GPU 加速生成，这涉及到块进程操作。渲染进程把生成指令发送给 GPU 进程，生成的位图保存在 GPU 内存中。\n一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。\n\n\n资源加载&#x2F;解析\nJS 在 Css 前面,且在 head 中，会阻塞 DOM 的解析\n&lt;html&gt;  &lt;head&gt;    &lt;script&gt;      console.log(document.querySelector(&quot;p&quot;));    &lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://localhost:8000/big.css&quot; /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p id=&quot;test&quot;&gt;xxx&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;\n\nJS 在 Css 后面，且在head 中，会等待 Css 加载，因为可能会通过 JS 获取样式，而且阻塞 DOM 解析, 也就是说只要在 Js 文件后面 DOM 解析都会被阻止。\n&lt;html&gt;  &lt;head&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://localhost:8000/big.css&quot; /&gt;    &lt;script&gt;      console.log(document.querySelector(&quot;p&quot;)); //null    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p id=&quot;test&quot;&gt;xxx?&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;\n\n在 Firefox, Chrome, Edge 中，如果 &lt;link rel=&quot;stylesheet&quot; href=&quot;xxx&quot;&gt; 后面跟着 &lt;script&gt;, 则 CSS 加载完成后, 才能触发 DOMContentLoaded\n\nCss 文件如果在 &lt;head&gt; 中，那么 Css 文件的加载不会影响 DOM 的解析，但是影响 DOM 的渲染。因为 Css 文件的加载可以放在预解析线程中，所以不会影响 DOM 解析，但是 DOM 解析完成后，必须等待样式文件被解析，才能渲染页面。\nCss 文件如果在 &lt;body&gt; 中，那么 Css 文件的加载会阻塞 Css 资源后面的 DOM 的解析(阻塞 DOMContentLoaded 执行的时机)。这种情况称为 FOUC(Flash of Unstyled Content) 样式闪烁。也就是说 Css 资源前面的 DOM 会被渲染，Css 后面的 DOM 必须要等待 Css 资源加载完成后才会被渲染，而之前已经渲染的 DOM 会在 Css 资源加载后重绘。\n\n\n","categories":["浏览器"],"tags":["浏览器","HTTP"]},{"title":"浏览器相关知识点","url":"/posts/fe6954b3445e/","content":"Web 应用趋势\n应用程序 Web 化,视频 , 音频 ,游戏的占比越来越高\n\n是 Web 应用移动化, Google 推出了 PWA 方案来整合 Web 和本地程序各自的优势\n\nWeb 操作系统化 ,可能以后浏览器会提供更多的模块给上层应用使用,如新支持的 WebAssembly；\n\n\nOSI 七层网络模型\n应用层： HTTP,HTTPS,FTP,NFS,FMTP,DHCP,SNMP,TELNET,POP3,IRC,NNTP 这些应用层协议为应用提供服务，可以执行用户活动。\n表示层： 从应用层接受数据，并将 ASCII 码转化为 EBCDIC 码(二进制),执行数据压缩（有损&#x2F;无损）,使用 SSL (加密&#x2F;解密)保证数据安全。\n会话层: 会话管理，身份验证，授权方面\n传输层：TCP,UDP, 流量控制，数据校验\n网络层：IP 逻辑寻址\n数据链层： 数据单元被称之为帧\n物理层：传输物理信号\n\n进程与线程进程是一个程序的运行实例,启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。 线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。\n\n进程和线程之间的关系有以下特点:\n\n进程中的任意一线程执行出错，都会导致整个进程的崩溃。\n\n线程之间可以对进程的公共数据进行读写操作。\n\n当一个进程关闭之后，操作系统会回收进程所占用的内存。\n虽然有些程序因为代码原因,或安装了额外的插件,可能导致内存泄漏.但只要关闭进程,内存就会被回收.\n\n进程之间的内容相互隔离。\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据.所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。\n\n\n目前浏览器主要包含以下几个进程, 查看 Chrome 的进程类型\n\n1 个浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能\n\n多个渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n\n1 个 GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n1 个网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，后面独立出来，成为一个单独的进程。\n\n多个插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n\n渲染进程的个数如何计算：\n\n如果从一个标签页中打开了另一个新标签页，当新标签页和当前标签页属于同一站点的话，那么新标签页会复用当前标签页的渲染进程。 Chrome 浏览器会将浏览上下文组中属于同一站点的标签分配到同一个渲染进程中,要同时满足 A 和 B 属于同一站点，且 A 和 B 之间有链接关系&lt;a&gt; 元素的 rel 属性为 noopener noreferrer 时会阻止使用同一个渲染进程。\nchrome 浏览器实现了站点隔离，所以 iframe 也会遵循以下的渲染规则，如果和父页面属于同一站点，且有链接关系，也会运行在相同的渲染进程中。\n\n请求的各个阶段\nDNS 域名解析过程域名使用 . 划分, 最后由根域名服务器统一管理，根域名服务器是一个服务器集群，有十几个根域名，但是有一千多台根域名服务器，这就需要通过任播技术找到最近的一台根域名服务器。\n顶级域名服务器会管理 .net .com 这些域名， 权威域名服务器会管理 .qq baidu 这些域名。\n\n发起解析前会检查本地是否有缓存文件。\n\n调用 DNS 客户端发起查询请求，本地的 DNS 服务端一般有互联网服务提供商(ISP)管理，DNS 服务端会查询是否有缓存,如果有则返回带有 Non-authoritative 字段的数据。如果是根域名服务器则返回带有 Authoritative 的字段。缓存需要定期更新。DNS 迭代查询的时候使用的时 UDP 请求，数据量比较小，可以用一个 UDP 包返回，比较注重效率。更新缓存时使用的时 TCP 查询。\n\n获取最近的根域名服务器的地址，查询 .com 域名的服务器地址。\n\n获取最近的 .com 服务器的地址，查询 baidu.com 的服务器地址。\n\n获取最近的 baidu.com 权威域名服务器的地址，查询 mail.baidu.com 对应的 IP。\n\n可能会返回 mail.baidu.com 对应的 CDN(内容分发服务器) 地址,这就是最终的地址。\n\n\nDNS 预解析dns-prefetch(DNS 预获取)是前端网络性能优化的一种措施。它根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短 DNS 解析时间，进而提高网站的访问速度。\n每当在首次 DNS 解析后会对其 IP 进行缓存。至于缓存时长，每种浏览器都不一样，比如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS。\n每当 Chrome 浏览器启动的时候，就会自动的快速解析浏览器最近一次启动时记录的前 10 个域名。所以经常访问的网址就不存在 DNS 解析的延迟，进而打开速度更快。\n\ndns-prefetch 仅对跨域域上的 DNS 查找有效，因此请避免使用它来指向相同域。这是因为，到浏览器看到提示时，您站点域背后的 IP 已经被解析。\n\nhttp 页面下所有的 a 标签的 href 都会自动去启用 DNS Prefetch，也就是说网页的 a 标签 href 带的域名，是不需要在 head 里面加上 link 手动设置的。\n可以通过在服务器端发送 X-DNS-Prefetch-Control 报头，或是在文档中使用值为 http-equiv 的 &lt;meta&gt; 标签：\n&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;\n\n强制查询特定主机名,使用 rel 属性值为 link type 中的 dns-prefetch 的 标签来对特定域名进行预读取：\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://www.baidu.com/&quot; /&gt;\n\nKeep-Alive通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：\nConnection:Keep-Alive\n\n那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。\n如何保证页面文件能被完整地送达浏览器？在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。\n联网，实际上是一套理念和协议组成的体系架构。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。\nIP：把数据包送达目的主机数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准, 访问网站就是向另一台有明确地址的计算机请求信息.\n想通信一定要知道双方 IP 地址, 这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息\n\n将要发送的数据交给网络进程\n创建 IP 头并附加到数据包上，并交给底层传输\n底层通过物理网络，将数据发送到 B\n数据被传输到 B 的网络层，会拆开 IP 头信息，并将数据交给上层处理\n\nUDP：把数据包送达应用程序到达主机后还需要把数据送给应用,，需要基于 IP 之上开发能和应用打交道的协议，最常见的是 用户数据包协议（User Datagram Protocol），简称 UDP。\nUDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。\n虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。\n\n传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层\n网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；\n数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；\n在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序；\n\nTCP：确保数据包的完整性使用 UDP 来传输会存在两个问题：\n\n数据包在传输过程中容易丢失；\n\n大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。\n\n\n基于这两个问题，我们引入 TCP 了。TCP(Transmission Control Protocol，传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:\n\n对于数据包丢失的情况，TCP 提供重传机制；\n\nTCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。\n\n\n既然要实现重传和数据包排序,必然需要一套链接机制,这也就是三次握手,和四次挥手\n\n首先，建立连接阶段。这个阶段是通过三次握手来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作,通过三次握手建立链接.\n\n其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。\n\n最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。\n\n\n流量控制：通过滑动窗口，取值为 min(拥塞窗口，接受窗口)；拥塞控制：慢启动（从 1 开始指数增加），达到阈值之后每次+1（拥塞避免），如果超时阈值修改为当前窗口的一半，重新慢启动开始传输。(TCP Tahoe 版本已废弃)快重传，快恢复，如果接收到三个确认重传的 ack,会直接将阈值修改为当前窗口的一半，并每次传输时窗口大小增加 1（拥塞避免）。(TCP Reno 版本)\nHTTP1.1 HTTP2 HTTP3\nHTTP1.1\n增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持,持久连接在 HTTP&#x2F;1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上 Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。\n提供虚拟主机的支持,HTTP&#x2F;1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名.但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。HTTP&#x2F;1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。\n对动态生成的内容提供了支持,在设计 HTTP&#x2F;1.0 时，需要在响应头中设置完整的数据大小,但是大部分页面内容都是动态的，，因此在传输数据之前并不知道最终的数据大小。HTTP&#x2F;1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。\n安全性，cookies\n存在的问题：\nTCP 慢启动，导致小的核心资源并不能占满带宽立即下载多个 TCP 链接会竞争贷款，可能让核心资源的下载速度变慢队头阻塞的问题，同一时间只能一个 TCP 链接只能处理一个请求，其他的任务需要排队头信息没有压缩,并且被频繁的重复传输\n\nHTTP2解决 HTTP1.1 存在的问题 一个域名只使用一个 TCP 长连接和消除队头阻塞问题 。但是 HTTP2 仍然是基于 TCP 协议的，TCP 传输过程中的丢包，会导致 TCP 队头阻塞，所以随着丢包率的增加，HTTP&#x2F;2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP&#x2F;1.1 的传输效率反而比 HTTP&#x2F;2 表现得更好。\nHTTP2 构建了一个 2 进制分帧层，其中帧和流是两个核心概念。帧是数据传输的最小单位。帧的最外层格式如下。\n\nHTTP2 把请求和响应报文分成头部帧和数据帧。由 type 字段标识。一个流用多个帧组成，同一个流的帧共用一个流 ID 标识,可以将乱序的帧关联起来。\n使用 HPACK 算法，减少头信息的小，减小发送包的体积，从而降低延迟。此算法包含静态表，动态表，Huffman 编码，静态表预定义了 61 个 header 的 key，value。动态表由双方维护自定义的 header 字段，Huffman 编码用于消除重复的字节。\n可以设置请求的权重，高优先级的请求会优先响应。可以服务端推送，如果请求的网页有依赖资源，服务器会主动将资源推送到客户端。\n但是 HTTP2 并没有解决 TCP 层面的队头阻塞，如果传输过程中的包丢失，依然会重传并等待。\n\nHTTP3在 UDP 协议之上，实现了 QUIC 协议，实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。\n集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。\n实现了 HTTP&#x2F;2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。\n实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。\n同时也存在一下问题：\n浏览器的实现和官方定义差距过大，系统内核对 UPD 的优化不佳。中间设备僵化导致丢包率远大于 TCP 链接。\n\n\nTLS 握手过程\n客户端发送给服务端，TLS 版本，加密套件，seq(随机数)1\n服务端响应 TLS 版本，加密套件，seq2\n服务端发送证书\n服务端发送公钥\n服务点通知客户端发送完成\n客户端生成 seq3(预主密钥) 用接收到的公钥加密后在发送给服务端\n服务端用私钥解密，获取预主密钥\n服务端和客户端分别用 seq1+seq2+seq3(预主密钥) 生成会话密钥\n后续的通信使用会话密钥\n\nTLS 只有在握手的过程中使用非对称加密，非对称加密对资源的消耗很大，通信过程使用加密后的会话密钥。\n报文格式\nHTTP\n\n\n\n\n页面性能指标\nFP(First Paint):从开始加载到浏览器首次绘制像素到屏幕上的时间,也就是页面在屏幕上首次发生视觉变化的时间。\n\nFCP（First Contentful Paint）:浏览器首次绘制来自 DOM 的内容的时间。这是用户第一次开始看到页面内容，但仅仅有内容，并不意味着它是有用的内容（例如 Header、导航栏等），也不意味着有用户要消费的内容。\n\nFMP（First Meaningful Paint）:页面的主要内容绘制到屏幕上的时间。主要内容的定义因页面而异，例如对于博客文章，它的主要内容是标题和摘要，对于搜索页面，它的主要内容是搜索结果，对于电商的页面，图片则是主要内容。\n\nFSP（First Screen Paint）:页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。\n\nTTI（Time to Interactive）:表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。\n\n\nHTTP 缓存\n强制缓存HTTP&#x2F;1.1 定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。\n\n每次都提供最新的内容\n此方式下，每次有请求发出时，缓存会将此请求发到服务器（该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回 304），则缓存才使用本地缓存副本。\nCache-Control: no-cache\n\n过期过期机制中，最重要的指令是 “max-age&#x3D;“，表示资源能够被缓存（保持新鲜）的最大时间。max-age 是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js 等静态资源。\nExpires 响应头包含日期&#x2F;时间， 即在此时候之后，响应过期。如果在 Cache-Control 响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。\n\n\n协商缓存强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存\n\nLast-Modified &#x2F; If-Modified-Since\nLast-Modified 是由服务器发送给客户端的 HTTP 响应头标签，时间值是当前资源文件的修改时间\nIf-Modified-Since 是由客户端发送给服务器的 HTTP 请求头标签，客户端再次发起该请求时，会携带上次请求返回的 Last-Modified 的时间值，对比 If-Modified-Since 的时间和该资源在服务器端最后被修改的时间，决定是否更新资源\n\nEtag &#x2F; If-None-Match\nEtag 是由服务器发送给客户端的 HTTP 响应头标签，是服务器端生成的资源文件的一个唯一标识\nIf-None-Match 是由客户端发送给服务器的 HTTP 请求头标签，客户端再次发起该请求时，会携带上次请求返回的 Etag 值，对比服务器端的 Etag 值和 If-None-Match 的值，决定是否更新资源\n\n\n优先级：Etag &#x2F; If-None-Match &gt; Last-Modified &#x2F; If-Modified-Since\n重绘与重排如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。\n\n如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。\n\n如果更改一个既不要布局也不要绘制的属性,把这个过程叫做合成\n使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。\n\n请求时间线\n\nQueuing(排队), 导致排队状态有很多遇到 CSS、HTML、JavaScript 等高优先级资源，图片、视频、音频 这些低优先级资源会让路。浏览器会为每个域名最多维护 6 个 TCP 连接,如果超过这个数量会处于排队状态。网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。\n优化方案： 使用域名分片技术,提高整体的 TCP 链接数量， 把站点升级到 HTTP2。\n\nStalled(停滞), 一些其他的原因导致链接被推\n\nInitial connection（初始化链接）, 建立 TCP 所花费的时间如果是 HTTPS 请求，还会有 SSL 握手时间。\n\nRequest sent(请求发送)，由于只需要把缓冲区中的数据发送出去，所以速度比较快。\n\nTTFB(第一字节时间)，收服务器第一个字节的数据，TTFB 时间越短，就说明服务器响应越快。\n优化方案： 提高运营商的网络带宽,使用 CDN 技术。服务器响应时间过长，问题可能出现在渲染，信息处理等方面,可以考虑提高缓存的使用效率。\n\nContent Download（资源下载时间）\n优化方案： 压缩文件，流式传输。\n\n\n如何验证数字证书\n申请数字证书网站需要准备一套私钥和公钥，私钥留着自己使用；向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。\n\n浏览器验证证书合法性首先，浏览器利用证书的原始信息计算出信息摘要；然后，利用 CA 的公钥来解密数字证书中的数字签名，解密出来的数据也是信息摘要；最后，判断这两个信息摘要是否相等就可以了。浏览器是怎么获取到 CA 公钥的,当部署 HTTP 服务器的时候，除了部署当前的数字证书之外，还需要部署 CA 机构的数字证书，CA 机构的数字证书包括了 CA 的公钥，以及 CA 机构的一些基础信息。服务器会有两个数字证书，域名的数字证书,CA 机构的数字证书。然后在建立 HTTPS 链接时，服务器会将这两个证书一同发送给浏览器，于是浏览器就可以获取到 CA 的公钥了。证明 CA 机构的合法性,操作系统中内置这些 CA 机构的数字证书,，CA 机构众多，因此操作系统不可能将每家 CA 的数字证书都内置进操作系统。于是人们又想出来一个折中的方案，将颁发证书的机构划分为两种类型，根 CA(Root CAs)和中间 CA(Intermediates CAs)，通常申请者都是向中间 CA 去申请证书的，而根 CA 作用就是给中间 CA 做认证，一个根 CA 会认证很多中间的 CA，而这些中间 CA 又可以去认证其他的中间 CA，也就形成了数字证书链。\n\n\nFAQ\n浏览器可以同时打开多个页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？\n端口一样的，网络进程知道每个 tcp 链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。\n\nTCP 传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？\n接收到 http 响应头中的 content-type 类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做 DOM 解析了！基于 http 不用担心数据包丢失的问题，因为丢包和重传都是在 tcp 层解决的。http 能保证数据按照顺序接收的（也就是说，从 tcp 到 http 的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）\n\nhttp 和 websocket 都是属于应用层的协议吗？\n都是应用层协议，而且 websocket 名字取的比较有迷惑性，其实和 socket 完全不一样，可以把 websocket 看出是 http 的改造版本，增加了服务器向客户端主动发送消息的能力。\n\n\n","categories":["浏览器"],"tags":["浏览器","HTTP"]},{"title":"SVG 属性","url":"/posts/66a993551b2e/","content":"stroke-dasharraystroke 作为一个动词，有一画，划的意思。\n在 SVG 中 stroke 作为一个描边属性，通过 stroke-dasharray 可以配置描边中的点和线的范式。换句话说它可以控制，描边中的线段与空白的规则。\n作为一个外观属性，它也可以直接在写在 CSS 中。\n/* 虚线长10，间距10，后面重复，虚线长10，间距10 */stroke-dasharray = &#x27;10&#x27;/* 虚线长10，间距5，后面重复，虚线长10，间距5 */stroke-dasharray = &#x27;10, 5&#x27;/* 虚线长20，间距10，虚线长5 后面是 间距20，虚线10，间距5 一直到下一个重复周期*/stroke-dasharray = &#x27;20, 10, 5&#x27;\n\nstroke-dashoffsetstroke-dashoffset 属性指定了 dash 模式到路径开始的距离, 它是一个偏移量，可以向前或向后偏移描边。\n另外这是一个数值型的属性，因此可以使用 css 动画控制， 来实现路径动画。 这是一个角向渐变环形进度条的例子。\npattern使用预定义的图形对一个对象进行填充或描边，就要用到 pattern 元素。pattern 元素让预定义图形能够以固定间隔在 x 轴和 y 轴上重复（或平铺）从而覆盖要涂色的区域。先使用 pattern 元素定义图案，然后在给定的图形元素上用属性 fill 或属性 stroke 引用用来填充或描边的图案。\n","categories":["CSS","SVG"],"tags":["CSS","SVG"]},{"title":"SVG角向渐变进度条","url":"/posts/f88cc857f1db/","content":"实现基本环形进度条利用 circle 元素， 设置 stroke-width 来实现环形。\n&lt;circle  class=&quot;animate-item&quot;  fill=&quot;none&quot;  stroke=&quot;red&quot;  stroke-width=&quot;20&quot;  cx=&quot;50&quot;  cy=&quot;50&quot;  r=&quot;40&quot;&gt;&lt;/circle&gt;\n\n如果想实现部分环形， 可以使用 stroke-dasharray stroke-dashoffset, 偏移描边,来实现部分圆环\n&lt;circle  class=&quot;animate-item&quot;  fill=&quot;none&quot;  stroke=&quot;red&quot;  stroke-width=&quot;20&quot;  cx=&quot;50&quot;  cy=&quot;50&quot;  r=&quot;40&quot;  stroke-dasharray=&quot;314 1000&quot;  stroke-dashoffset=&quot;200&quot;  stroke-linecap=&quot;round&quot;&gt;&lt;/circle&gt;\n\n因为 circle 的半径是 50，因此描边的路径长度是 Math.PI * 2 * 50 一个大于等于这个数值的描边就会可以覆盖整个圆环， 后面设置一个大一点的空白长度为 1000。\ndashoffset 设置为 200 意味着描边向后偏移了 200, 那个对于第一段描边只剩下 314 - 200 的描边长度。\n圆形绘制的起始点是 0 度角， 因此最终的效果如下。\n\n一般环形位置是从 90 度角开始的， 所以可以给 circle 加上 transform 变换。\n&lt;circle  class=&quot;animate-item&quot;  fill=&quot;none&quot;  stroke=&quot;red&quot;  stroke-width=&quot;20&quot;  cx=&quot;50&quot;  cy=&quot;50&quot;  r=&quot;40&quot;  stroke-dasharray=&quot;314 1000&quot;  stroke-dashoffset=&quot;200&quot;  stroke-linecap=&quot;round&quot;  transform=&quot;rotate(-90 50 50)&quot;&gt;&lt;/circle&gt;\n\n\n使用渐变色SVG 支持线性渐变和镜像渐变， 可以创建一个线性渐变元素。 作为圆环的描边属性值。\n&lt;svg  height=&quot;100&quot;  width=&quot;100&quot;  xmlns=&quot;http://www.w3.org/2000/svg&quot;  xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;  version=&quot;1.1&quot;&gt;  &lt;defs&gt;    &lt;linearGradient      x1=&quot;77.8982925%&quot;      y1=&quot;11.2647007%&quot;      x2=&quot;24.5398068%&quot;      y2=&quot;89.7549679%&quot;      id=&quot;linearGradient&quot;    &gt;      &lt;stop stop-color=&quot;#002974&quot; stop-opacity=&quot;0.21446132&quot; offset=&quot;0%&quot;&gt;&lt;/stop&gt;      &lt;stop stop-color=&quot;#4DD7FF&quot; offset=&quot;99.9125874%&quot;&gt;&lt;/stop&gt;    &lt;/linearGradient&gt;  &lt;/defs&gt;  &lt;circle    class=&quot;animate-item&quot;    fill=&quot;none&quot;    stroke=&quot;url(#linearGradient)&quot;    stroke-width=&quot;20&quot;    cx=&quot;50&quot;    cy=&quot;50&quot;    r=&quot;40&quot;    stroke-dasharray=&quot;314 1000&quot;    stroke-dashoffset=&quot;200&quot;    stroke-linecap=&quot;round&quot;    transform=&quot;rotate(-90 50 50)&quot;  &gt;&lt;/circle&gt;&lt;/svg&gt;\n\n这里使用了一个有倾斜角度的线性渐变模拟， 色环的角向渐变。\n实现角向渐变色虽然 SVG 不支持角向渐变， 但是可以使用 [pattern] 作为描边属性值。\n首先准备一张角向渐变的图片。\n\n在 pattern 中定义并作为描边属性值使用。\n&lt;svg  height=&quot;100&quot;  width=&quot;100&quot;  xmlns=&quot;http://www.w3.org/2000/svg&quot;  xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;  version=&quot;1.1&quot;&gt;  &lt;defs&gt;    &lt;pattern      id=&quot;fill-img&quot;      patternUnits=&quot;userSpaceOnUse&quot;      width=&quot;100&quot;      height=&quot;100&quot;    &gt;      &lt;image xlink:href=&quot;./01.png&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;/image&gt;    &lt;/pattern&gt;  &lt;/defs&gt;  &lt;circle    class=&quot;animate-item&quot;    fill=&quot;none&quot;    stroke=&quot;url(#fill-img)&quot;    stroke-width=&quot;20&quot;    stroke-miterlimit=&quot;1&quot;    cx=&quot;50&quot;    cy=&quot;50&quot;    r=&quot;40&quot;    stroke-dasharray=&quot;314 1000&quot;    stroke-dashoffset=&quot;200&quot;    stroke-linecap=&quot;round&quot;    transform=&quot;rotate(-74 50 50)&quot;  &gt;&lt;/circle&gt;&lt;/svg&gt;\n\n\n由于 line-cap 占据了一定的 stroke 长度，所以 rotate 中并没有旋转到 90 度， 为 line-cap 占据的位置空出一点空间。\n但是当 dashoffset 为 0 时，效果如下， 因此需要给 pattern 一个 transform 属性，用于抵消 circle 旋转的偏移。\n\n&lt;pattern id=&quot;fill-img&quot; patternUnits=&quot;userSpaceOnUse&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;  &lt;image    xlink:href=&quot;./01.png&quot;    x=&quot;0&quot;    y=&quot;0&quot;    width=&quot;100&quot;    height=&quot;100&quot;    transform=&quot;rotate(74 50 50)&quot;  &gt;  &lt;/image&gt;&lt;/pattern&gt;\n\n最后添加动画属性, 初始时 dashoffset 在 314 的位置， 动画开始后将会回退到 0 的位置， 由此实现环形进度条动画效果。\n&lt;style&gt;  .animate-item &#123;    transition: stroke-dashoffset 1.5s ease;  &#125;&lt;/style&gt;&lt;svg  height=&quot;100&quot;  width=&quot;100&quot;  xmlns=&quot;http://www.w3.org/2000/svg&quot;  xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;  version=&quot;1.1&quot;&gt;  &lt;defs&gt;    &lt;pattern      id=&quot;fill-img&quot;      patternUnits=&quot;userSpaceOnUse&quot;      width=&quot;100&quot;      height=&quot;100&quot;    &gt;      &lt;image        xlink:href=&quot;./01.png&quot;        x=&quot;0&quot;        y=&quot;0&quot;        width=&quot;100&quot;        height=&quot;100&quot;        transform=&quot;rotate(74 50 50)&quot;      &gt;&lt;/image&gt;    &lt;/pattern&gt;  &lt;/defs&gt;  &lt;circle    class=&quot;animate-item&quot;    fill=&quot;none&quot;    stroke=&quot;url(#fill-img)&quot;    stroke-width=&quot;20&quot;    stroke-miterlimit=&quot;1&quot;    cx=&quot;50&quot;    cy=&quot;50&quot;    r=&quot;40&quot;    stroke-dasharray=&quot;314 1000&quot;    stroke-dashoffset=&quot;314&quot;    stroke-linecap=&quot;round&quot;    transform=&quot;rotate(-74 50 50)&quot;  &gt;&lt;/circle&gt;&lt;/svg&gt;&lt;script&gt;  setTimeout(function () &#123;    document      .querySelector(&quot; .animate-item&quot;)      .setAttribute(&quot;stroke-dashoffset&quot;, 0);  &#125;, 1000);&lt;/script&gt;\n\n\n","categories":["CSS","SVG"],"tags":["CSS","SVG"]},{"title":"CSS 常见问题","url":"/posts/c9cbf6d4ef1a/","content":"BFC 及其应用block formatting context (块级格式化上下文)， BFC 元素可以隔离子元素对外部元素的影响。[CSS 世界中相关章节]\n如果一个元素是块级元素，满足以下任一情况会触发 BFC:\n\n&lt;html&gt; 元素\nfloat 的值不为 none\noverflow 的值为 auto、scroll 或 hidden；\ndisplay 的值为 table-cell,table-row,table-caption 和 inline-block 中的任何一个；\nposition 的值不为 relative 和 static。\n\nBFC 可以解决以下问题：\n\n避免 margin 重叠，将元素的外层元素变成 BFC 元素，因为 BFC 的隔离性，可以避免子元素与外层元素 margin 重叠但是如果 BFC 元素有上下 margin, 仍然会与外层元素边距重叠\n\n可以让文字环绕图片时，文字自动填充图片右侧空间，而无需设置固定的宽度。如果想要文字于图片保持距离，可使用 margin 等，但是不能使用 p 标签的 margin-left\n&lt;style&gt;  img &#123;    width: 100px;    height: 100px;    float: left;  &#125;  p &#123;    overflow: hidden;  &#125;&lt;/style&gt;&lt;div class=&quot;a&quot;&gt;  &lt;img src=&quot;./01.png&quot; alt=&quot;&quot; /&gt;  &lt;p&gt;xx&lt;/p&gt;&lt;/div&gt;\n\n\n使用 display:table-cell 实现自适应的两栏布局，由于 table-cell 的特性是宽度不会超过父容器的宽度，所以可以给一个很大的宽度\n\n&lt;style&gt;  .wrapper &#123;    width: 100%;  &#125;  img &#123;    width: 100px;    float: left;  &#125;  .right &#123;    display: table-cell;    word-break: break-all;    width: 9999px;  &#125;&lt;/style&gt;&lt;div class=&quot;wrapper&quot;&gt;  &lt;img src=&quot;./01.png&quot; alt=&quot;&quot; /&gt;  &lt;div class=&quot;right&quot;&gt;xxxx&lt;/div&gt;&lt;/div&gt;\n\noverflow 不同值得区别overflow 属性原本的作用指定了块容器元素的内容溢出时是否需要裁剪。[CSS 世界中相关章节]\n\n注意剪裁得部分是\n除非 overflow-x 和 overflow-y 的属性值都是 visible，否则 visible 会当成 auto 来解析\n&lt;html&gt; &lt;textarea&gt; 默认会有滚动条，因为 auto 作为默认值。\n滚动条的产生会影响表格等样式，方法 1 可以空出右边的滚动条的宽度，方法 2 可以不设最后一列宽度\nbody 设置为 absolute, 宽度 100vw,可以解决滚动条晃动的问题。\n\n三栏布局\nfloat 实现，主要元素的排列顺序\n&lt;style&gt;  .container &#123;    width: 100%;    overflow: hidden;  &#125;  .left &#123;    float: left;    width: 20%;  &#125;  .right &#123;    float: right;    width: 20%;  &#125;  .center &#123;    margin-left: 20%;    margin-right: 20%;    background: lightgray;  &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;  &lt;div class=&quot;center&quot;&gt;Center&lt;/div&gt;&lt;/div&gt;\n\nflex 实现\n&lt;style&gt;  .container &#123;    display: flex;  &#125;  .left &#123;    flex: 0 0 20%;  &#125;  .center &#123;    flex: 1;  &#125;  .right &#123;    flex: 0 0 20%;  &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;  &lt;div class=&quot;center&quot;&gt;Center&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;&lt;/div&gt;\n\ngrid 布局\n&lt;style&gt;  .container &#123;    display: grid;    grid-template-columns: 20% 1fr 20%;  &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;  &lt;div class=&quot;center&quot;&gt;Center&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;&lt;/div&gt;\n\n使用 absolute 绝对定位布局\n\n使用 table 布局\ntable 中未设置宽度的单元格会自动占据剩余的空间\n&lt;style&gt;  .container &#123;    display: table;    width: 100%;  &#125;  .left,  .right &#123;    min-width: 100px;  &#125;&lt;/style&gt;&lt;table class=&quot;container&quot;&gt;  &lt;thead&gt;    &lt;tr&gt;      &lt;td width=&quot;100px&quot;&gt;&lt;/td&gt;      &lt;td&gt;&lt;/td&gt;      &lt;td width=&quot;100px&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;table class=&quot;container&quot;&gt;    &lt;tbody&gt;      &lt;tr&gt;        &lt;td class=&quot;cell left&quot;&gt;Left&lt;/td&gt;        &lt;td class=&quot;cell center&quot;&gt;Center&lt;/td&gt;        &lt;td class=&quot;cell right&quot;&gt;Right&lt;/td&gt;      &lt;/tr&gt;    &lt;/tbody&gt;  &lt;/table&gt;&lt;/table&gt;\n\n使用 div 也可以由同样的效果\n&lt;style&gt;  .container &#123;    display: table;    width: 100%;  &#125;  .left,  .right &#123;    min-width: 100px;  &#125;  .cell &#123;    display: table-cell;  &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;cell left&quot;&gt;Left&lt;/div&gt;  &lt;div class=&quot;cell center&quot;&gt;Center&lt;/div&gt;  &lt;div class=&quot;cell right&quot;&gt;Right&lt;/div&gt;&lt;/div&gt;\n\nfloat + bfc\n&lt;style&gt;  .wrapper &#123;    clear: both;  &#125;  .middle &#123;    width: 100%;    float: left;  &#125;  .main &#123;    margin-left: 100px;    margin-right: 100px;  &#125;  .left &#123;    float: left;    width: 100px;    margin-left: -100%;  &#125;  .right &#123;    float: right;    width: 100px;    margin-left: -100%;  &#125;&lt;/style&gt;&lt;div class=&quot;wrapper&quot;&gt;  &lt;div class=&quot;middle&quot;&gt;    &lt;div class=&quot;main&quot;&gt;中间&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;left&quot;&gt;左栏&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;右栏&lt;/div&gt;&lt;/div&gt;\n\ncalc 函数通常配合变量使用，实现动态计算效果。[CSS 新世界 4.5] [兼容性]\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS Flex 布局","url":"/posts/0f6a07f1939f/","content":"flex 弹性布局可以设置元素 display 属性为 flex 或 inline-flex, inline-flex 可以让 flex 元素保持内联的特性。[CSS 新世界中相关章节]\n弹性设置\nflex-grow：当有剩余空间时，元素延伸占据剩余空间的规则\n\nflex-shrink：剩余空间不足时，元素收缩的规则\n\nflex-basis: 元素基础宽度，类似于 width 但如果设置了 auto 以外的值,优先级别 width 高.\nflex-basis 属性下的最小尺寸是由内容决定的，而 width 属性下的最小尺寸是 width 属性的计算值决定的。也就是内容过长的时候，设置了 width 可能溢出，而设置了 flex-basis 宽度是最小内容宽度。\n\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS Grid 布局","url":"/posts/0c9c51f03b67/","content":"grid 网格布局可以设置元素 display 属性为 grid ,inline-grid,inline-grid 可以让 grid 元素保持内联的特性。[CSS 新世界中相关章节]\n应用于容器的属性网格数量与尺寸grid-template-columns 和 grid-template-rows属性主要用来指定网格的数量和尺寸等信息。[CSS 新世界 6.3.1]\ngrid-template: [grid-template-rows] / [grid-template-columns] 是缩写。\n尺寸可用的 9 种数据类型,其中 fr 是单词 fraction 的缩写表示分数，按比例划分可自动分配的尺寸。\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS 尺寸/位置/布局/元素","url":"/posts/3c545ad624c6/","content":"复选框与文本对齐&lt;p&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;span&gt;文本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;input type=&quot;radio&quot; /&gt; &lt;span&gt;文本&lt;/span&gt;&lt;/p&gt;\n\n当字号大于 input 尺寸时， input 会与文字中间对其\n但是字号过小的时候，input 与文字底部并不能对其\n/* 方案1 */input &#123;  vertical-align: -3px;&#125;/* 方案2 */input &#123;  vertical-align: top;  margin-top: 4px;&#125;/* 方案3 */input &#123;  vertical-align: middle;  margin-top: -2px;  margin-bottom: 1px;&#125;\n\n多行文字垂直居中&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;child&quot;    &gt;这里显示多行文字。这里显示多行文字。这里显示多行文字。这里显示多行文字。这里显示多行文字。这里显示多行文字。这里显示多行文字。这里显示多行文字。&lt;/span  &gt;&lt;/div&gt;\n\n/* 方案1 */.box &#123;  width: 500px;  height: 500px;  display: flex;  align-items: center;&#125;/* 方案2 */.box &#123;  width: 500px;  height: 500px;  display: flex;&#125;.child &#123;  margin: auto 0;&#125;/* 方案3 */.box &#123;  width: 500px;  height: 500px;  line-height: 500px;&#125;.child &#123;  vertical-align: middle;  line-height: normal;  display: inline-block;&#125;/* 方案4 */.box &#123;  width: 500px;  height: 500px;  display: table;&#125;.child &#123;  display: table-cell;  vertical-align: middle;&#125;\n\n多行文本超出隐藏.box &#123;  display: -webkit-box;  -webkit-line-clamp: 3;  -webkit-box-orient: vertical;&#125;\n\n三列布局\n绝对定位 1\n\n&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n/* 绝对定位1 */.left &#123;  position: absolute;  width: 200px;  left: 0;  top: 0;  height: 100%;  background: goldenrod;&#125;.right &#123;  position: absolute;  width: 200px;  right: 0;  height: 100%;  background: thistle;&#125;.center &#123;  position: absolute;  right: 200px;  left: 200px;  height: 100%;  background: palegreen;&#125;.box &#123;  position: relative;  height: 100%;&#125;/* 绝对定位2 */.left &#123;  position: absolute;  width: 200px;  left: 0;  top: 0;  height: 100%;  background: goldenrod;&#125;.right &#123;  position: absolute;  width: 200px;  right: 0;  top: 0;  height: 100%;  background: thistle;&#125;.center &#123;  margin: 0 200px;  height: 100%;  background: palegreen;&#125;.box &#123;  position: relative;  height: 100%;&#125;\n\n\n浮动 + 负 margin\n\n&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.left &#123;  float: left;  width: 200px;  margin-left: -100%;  height: 100%;  background: goldenrod;&#125;.center &#123;  margin: 0 200px;  height: 100%;  background: palegreen;&#125;.wrapper &#123;  float: left;  height: 100%;  width: 100%;&#125;.right &#123;  float: left;  width: 200px;  height: 100%;  margin-left: -200px;  background: thistle;&#125;.box &#123;  position: relative;  height: 100%;&#125;\n\n&lt;!-- 推荐，元素与视觉保持一致 --&gt;&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.left &#123;  float: left;  width: 200px;  margin-left: -100%;  height: 100%;  background: goldenrod;&#125;.center &#123;  margin: 0 200px;  height: 100%;  background: palegreen;&#125;.wrapper &#123;  float: left;  height: 100%;  width: 100%;&#125;.right &#123;  float: left;  width: 200px;  height: 100%;  margin-left: -200px;  background: thistle;&#125;.box &#123;  position: relative;  height: 100%;&#125;\n\n\nflex\n\n&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.left &#123;  width: 200px;  height: 100%;  background: goldenrod;&#125;.center &#123;  flex: 1;  height: 100%;  background: palegreen;&#125;.wrapper &#123;  float: left;  height: 100%;  width: 100%;&#125;.right &#123;  width: 200px;  height: 100%;  background: thistle;&#125;.box &#123;  display: flex;  height: 100%;&#125;\n\n尺寸百分比\n无定位元素： 相对于外层元素的内容(容纳)区域\n定位元素： 相对于最近的定位元素的 padding 区域\n\n\n\n\n属性\n百分比相对与\n\n\n\nwidth\n参考元素宽度\n\n\nheight\n参考元素高度，需要指定参考元素高度\n\n\npadding\n参考元素宽度\n\n\nborder\n参考元素宽度\n\n\nmargin\n参考元素宽度\n\n\n最大&#x2F;最小 尺寸可用于防止内部元素，超出容器尺寸\n.box &#123;  width: 300px;&#125;img &#123;  max-width: 100%;&#125;\n\n表单\nform 可以原生支持回车键提交表单， 会自动查找 form 中第一个有 type=&#39;submit&#39; 的按钮， 并触发这个按钮的点击事件\n\n放在 label 中的 input 元素，即使没有使用 for 关联在一起，点击 label 中的任意元素，也会选中 input\n&lt;label&gt;  &lt;input type=&quot;radio&quot; /&gt;  &lt;p&gt;name&lt;/p&gt;  &gt;&lt;/label&gt;\n\n精灵图spritesmith 用于合并图片，并生成生成样式\n属性值计算过程每一个元素的每一个属性都必须有值，属性值变为最终计算样式的过程就是属性值计算过程。\n\n确定声明值: 样式表中没有冲突的声明，作为最终样式\n\n层叠冲突: 对有冲突的声明使用层叠规则，确定 css 属性值\n\n比较重要性,作者样式表会覆盖浏览器默认样式\n比较特殊性,比较权重\n比较源次序，权重相同时，后写的样式覆盖先写的样式\n\n\n使用继承，对仍然没有值的属性，若可以继承，则继承父元素的值\n\n使用默认值，对仍然没有值的属性，使用默认值\n\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS艺术 绘制形状","url":"/posts/f50453852f11/","content":"椭圆border-radius 可以指定数值或百分比,当使用百分比的时候,可以让 border 按各自边长计算圆角,实现椭圆\n.box &#123;  width: 200px;  height: 100px;  background: goldenrod;  border-radius: 50%;&#125;\n\n半橢圓\nborder-radius 是一个简写的属性, 它的完整属性可以表述四个角的圆角\nborder-top-left-radiusborder-top-right-radiusborder-bottom-left-radiusborder-bottom-right-radius\n属性的两个长度或百分比值定义了椭圆的四分之一外边框的边缘角落的形状。第一个值是水平半径，第二个是垂直半径。如果省略第二个值，它是从第一个复制。如果任一长度为零，角落里是方的，不圆润。水平半径的百分比是指边界框的宽度，而垂直半径的百分比是指边界框的高度。\n这样我们只需要指定上边两个角或下边两个角的圆角即可\n.box &#123;  width: 200px;  height: 100px;  background: goldenrod;  border-top-left-radius: 50% 100%;  border-top-right-radius:50% 100%;&#125;\n\n可以是使用简写的属性, border-radius 可以用 / 分隔两组值,左边代表四个角的水平半径,右边代表垂直半径\n而且不同的个数代表不同的位置,这与 border 类似\n50%             top-left:50% | top-right:50% | bottom-right:50% | bottom-left:50%50% 40%         top-left:50% | top-right:40% | bottom-right:50% | bottom-left:40%50% 40% 30%     top-left:50% | top-right:40% | bottom-right:30% | bottom-left:40%50% 40% 30% 20% top-left:50% | top-right:40% | bottom-right:30% | bottom-left:20%\n所以分析一下这个半椭圆\n\n\n水平方向上面的两个角是 50%,  暂时可以写为 50% 50% 0 0 / xx xx xx xx\n垂直方向上面两个角是 100%,现在变为 50% 50% 0 0 / 100% 100% 0 0\n因为半椭圆的垂直方向占据了整个元素的高度,所以不能使用简写属性, 必须要指定上面两垂直半径是100%, 这样弧度才会从底部延伸到顶部现在垂直半径后两个为0,意味着对应的水平半径即使给了也不会生效,因为不能只通过一个半轴长度画椭圆,最终能够属性会变为 50% / 100% 100% 0 0\n\n.box &#123;  width: 200px;  height: 100px;  background: goldenrod;  border-radius: 50%/ 100% 100% 0 0;&#125;\n\n同理如果你想画一个垂直方向的半椭圆\n.box &#123;  width: 200px;  height: 100px;  background: goldenrod;  border-radius: 100% 0 0 100%/50%;&#125;\n\n1&#x2F;4 椭圆也是同样的道理,只需指定一个角上的半径 \n.box &#123;  width: 200px;  height: 100px;  background: goldenrod;  border-radius: 100% 0 0 0;&#125;\n\n这个网址里你可以看到各种通过圆角制作的精美按钮\n\n平行四边形&#x2F;菱形你可能很容易想到使用 skew, 但是有一些细节需要注意, 如果 skew 作用在一个有文字的元素上, 那么里面的文字也会被拉伸\n想解决这个问题, 可能会想到使用两个元素嵌套, 让里面的元素使用反向 skew, 让文字重新边正\n有没有一种方式,可以不嵌套元素,还能让文字不受影响, 办法就是使用 伪元素, 因为伪元素和元素本身不属于嵌套关系,所以更容易处理\n.el &#123;  position: relative;  /* 写文字相关的样式 */&#125;/* 写背景形状相关的样式 */.el::after &#123;  content: &quot;&quot;;  position: absolute;  left:0;  top:0;  right:0;  bottom: 0;  /* 放在文字元素下面 */  z-index: -1;&#125;\n\n对于菱形, 是四边相等的平行四边形, 最容易想到的就是旋转一个正方形\nwidth: 100px;height: 100px;transform: rotate(45deg);\n\n但是中心线长度不相等平行四边形会遇到一点麻烦, 最核心的一个问题就是, 拉伸后的高度应该等于宽度, 以下面这个 宽为100,高为40 的长方形为例\n\n想求的是 AGF 的角度, 那么只要求出 FGE 就可以了, sinFGE = AG / FG 所以 FCE = srcsin(40/100) \n再把 FCE 转成角度 FCE = srcsin(40/100) * 360 / (2 * PI) = 23.5781(deg)\n那么 AGF = (90 - 23.57)deg\nwidth: 100px;height: 40px;transform: skew(-66.43deg);\n\n\n菱形剪裁有时候希望一张图片能剪裁成菱形的形状, 我们已经知道菱形如何制作,所以很容易想到用两个元素嵌套\n第一步把外层的元素旋转并处理成菱形, 里面的元素反向旋转修正, 又因为拉伸之后图片的上下可能填不满,所以需要通过缩放填满外层元素\n&lt;div id=&#x27;box&#x27;&gt;  &lt;img /&gt;&lt;/div&gt;\n\n.box &#123;  transform: rotate(-78deg) skew(-66.43deg);  overflow: hidden;&#125;.box img&#123;  transform: skew(66.43deg) scale(3);&#125;\n\n\n除了这种比较传统的方法, 现在我们有了一个新的属性可以完成这个效果 clip-path,  可以指定点的位置并链接成图形, 如果使用百分比会按照自身的尺寸解析\nimg&#123;  width: 320px;  height: 180px;  clip-path: polygon(50% 0,100% 50%,50% 100%,0 50%);  transition: 1s clip-path;&#125;img:hover &#123;  clip-path: polygon(0 0,100% 0,100% 100%,0 100%);&#125;\n\n\n切角效果看过背景与边框一章之后,很容易会想到用渐变的方式是来实现,另外通常情况下会考虑使用scss来处理\n\nbackground: #5a8;background: linear-gradient(-45deg, transparent 20px, #5a8 0) right,  linear-gradient(45deg, transparent 20px, #fd2 0) left;background-size: 50% 100%;background-repeat: no-repeat;\n\n\n\n/* hack */background: #5a8;background: linear-gradient(-135deg, transparent 20px, #5a8 0) top right,  linear-gradient(135deg, transparent 20px, #542 0) top left,  linear-gradient(-45deg, transparent 20px, #fd2 0) bottom right,  linear-gradient(45deg, transparent 20px, #e93 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat;\n\n\nbackground: #5a8;background:   radial-gradient(circle at top right , transparent 20px, #5a8 0) top right,  radial-gradient(circle at top left,transparent 20px, #542 0) top left,  radial-gradient(circle at bottom right, transparent 20px, #fd2 0) bottom right,  radial-gradient(circle at bottom left, transparent 20px, #e93 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat;\n\n\n上面的方法算是比较完美的解决了这个问题,其中有一点不足就是代码量比较多,可能难以维护\n还可以换一个思路,使用 svg + border-image 这种解决方案, svg 当作边框背景, 创造一个可以被九宫格分割的svg图片, 让九宫格的四个角为折角就能实现我们的需求\n有几个细节需要注意一下, fill 属性需要编码, 需要添加 background-clip 属性,否则背景颜色会延伸到边框区域, 添加一个 border 属性用于hack, 在 border-image 不支持的时候可以回退\nborder: 20px solid #58a;height: 140px;background-clip: padding-box;background: #58a;border-image: 1 url(&#x27;data:image/svg+xml,\\&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;3&quot; height=&quot;3&quot; fill=&quot;%2358a&quot;&gt;\\  &lt;polygon points=&quot;0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2&quot;/&gt;\\&lt;/svg&gt;&#x27;);\n\n梯形从上面的平行四边形中可能会受到一点启发,但实际上在二维变化中,没有一种办法可以将矩形或其他图形,转换成梯形.\n也许可以想到利用两个伪类实现梯形两边,但是一旦需要添加边框或圆角, 这种中方案立刻就没有了操作性.\n既然二维不行,可以思考一下三维中的实现办法, 可以利用透视让矩形的一条边远离我们,从而在视觉上实现梯形的效果.\n.box &#123;  position: relative;  width: 200px;  height: 60px;  line-height:60px;  font-size: 20px;  color: #fff;  text-align: center;&#125;.box:after &#123;  content: &quot;&quot;;  position: absolute;  left:0;  top:0;  bottom: 0;  right: 0;  margin: auto;  z-index: -1;  border-radius: 8px;  border: 2px solid darkorchid;  background: #58a;  /* 保持底边固定,整个图形围绕底边旋转 */  transform-origin: bottom;  /* 第一个属性是景深, 用于表现出3D效果,经过空间旋转的矩形在视觉上高度会缩小, 所以通过放大高度来使变换后的图形和之前的图形,高度相同 */  transform:perspective(300px) rotateX(30deg) scaleY(1.25);&#125;\n\n当需要只有一边倾斜的梯形是,只需要修改修改变换中心. 这个中心可以理解为视觉中是一个直角坐标系, 这个中心点永远在你视线的正前方.当变换中心设置为 bottom 的时候,相当于把这个元素的底边放在了视线中心上,但是左右两边会被视线中心平分, 所以元素绕 x 轴转动的时候,左右两边因为透视会向中间收缩.当变换中心设置为 bottom ,left 的时候, 除了底边在视线中心上,左边也在视线中心, 所以旋转的时候,左边只有高度的变化,而不会因为透视,向中间收缩,因为这条边垂直与你的视线.\n.box:after &#123;  transform-origin: bottom left;  transform: perspective(91px) rotateX(18deg) scaleY(1.25);&#125;\n\n\n饼图先思考一下实现一个双色的饼图需要几个元素, 其实两个元素就够了,其中一个是伪元素, 实现思路是把元素的背景色设置成渐变的两半,伪元素大小为元素的一半,这样就可以把底色漏出来,而显示进度的那一半颜色可以用伪元素覆盖住.\n通过旋转伪元素,并切换伪元素的颜色来显示饼图的大小, 说起来简单但是实现起来细节很多\n先来实现一个 20% 的饼图, 这里用到了 turn 这个表示圈的单位, 0.2turn 表示的就是 0.2 * 360deg, 可以让你免于计算角度\n.box&#123;  position: relative;  width: 200px;  height: 200px;  background: yellowgreen;  background-image: linear-gradient(90deg, transparent 50%,#655 0);  border-radius: 50%;  overflow: hidden;&#125;.box::after &#123;  content:&#x27;&#x27;;  position: absolute;  width: 50%;  height: 100%;  border-radius: 0 100% 100% 0 / 50%;  left: 50%;  top:0;  background-color: inherit;  transform-origin: left center;  transform: rotate(0.2turn);&#125;\n\n\n但是当角度超过 50% 就会有一些问题,因为伪类的颜色还是和没有占比区域的颜色相同,所以还没法表现超出 50% 的饼图, 第一步需要修改伪类的颜色\n但是伪类已经旋转了 180deg,仅仅改变颜色会和另一半颜色拼在一起显示出一个 100% 的饼图,所以需要减去半圈 0.5turn, 如果表示 70% 只需要旋转 (0.7turn - 0.5turn) &#x3D; 0.2turn 就够了\n.box&#123;  position: relative;  width: 200px;  height: 200px;  background: yellowgreen;  background-image: linear-gradient(90deg, transparent 50%,#655 0);  border-radius: 50%;  overflow: hidden;&#125;.box::after &#123;  background-color: #665;  transform: rotate(0.2turn);&#125;\n\n到这里似乎已经可以实现饼图的效果了,但如果想修改一个比例,我们能会修改颜色,修改圈数,能不能只通过一个属性就控制为元素的颜色和角度,这里会用到很多 animation 相关的属性\n第一点需要解决如何让超过 50% 之后,颜色自动改变,可能只用 animation 有这个能力,因为没有什么选择器可以判断元素是不是旋转过了一半,而 animation 可以控制动画的执行位置\n.box&#123;  position: relative;  width: 200px;  height: 200px;  background: yellowgreen;  background-image: linear-gradient(90deg, transparent 50%,#655 0);  border-radius: 50%;  overflow: hidden;&#125;.box::after &#123;  content:&#x27;&#x27;;  position: absolute;  width: 50%;  height: 100%;  border-radius: 0 100% 100% 0 / 50%;  left: 50%;  top:0;  background-color: inherit;  transform-origin: left center;  animation: bg 100s step-end infinite,ani 50s linear infinite;  animation-delay: -10s;  animation-play-state: paused;&#125;@keyframes bg &#123;  50% &#123;    background: #655;  &#125;&#125;@keyframes ani &#123;  to &#123;    transform: rotate(0.5turn);  &#125;&#125;\nstep-end 的目的就是在动画指定到一半也就是 50s 的时候,颜色突然改变,而这时也恰好旋转了半圈因为 ani 动画的执行时间是 50s 旋转半圈, 另外需要使用 animation-play-state: paused  把动画暂停住,这样在一个合适的角度就能显示出比例\n这里用到了 animation-delay 很少使用到的属性, 一个负的延时时间,这是有意义的,它的行为与 0s 延时类似,都会立即执行动画,但是一个负值表示动画已经开始播放,并且持续了对应的时间,效果就是显示第一帧的时候,好像动画已经播放了这么长时间.所以指定一个负值来表示已经旋转过的角度. 如果是 70% 那可以设置为 animation-delay: -70s\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS艺术 背景与边框","url":"/posts/b24d034ad9f9/","content":"半透明边框背景颜色会延伸到边框的下面，如果给元素一个虚线边框就能看到\n\n使用 background-clip 让元素的背景被内边框裁掉\nwidth: 100px;height: 100px;border: 20px dashed hsla(0, 0%, 100%, 0.5);background: darkgoldenrod;background-clip: padding-box;\n\n多重边框box-shadow 模拟原理就是让扩张半径增大，偏移量以及模糊值都为 0，需要注意，阴影并不会占据空间大小，需要处理元素的位置。\nwidth: 100px;height: 100px;background: darkgoldenrod;box-shadow: 0 0 0 10px #0000ff, 0 0 0 20px #00ff00, 0 0 0 30px #ff0000;margin: 30px 0 0 30px;\n\n\noutline使用 outline + border 可以实现两侧边框，比 box-shadow 更灵活。\n注意，outline 的边框可能和圆角不贴和。一些老的浏览器版本中可能存在\nwidth: 100px;height: 100px;background: darkgoldenrod;border: 10px solid #0000ff;outline: 10px solid #00ff00;border-radius: 10px;\n\n使用负的 outline-offset 实现缝线的效果\nwidth: 100px;height: 100px;background: darkgoldenrod;outline: 1px dashed #fff;border-radius: 10px;outline-offset: -10px;\n\n\n背景图片background 简写属性如下\nbackground:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;\n\nbackground-position 允许指定每个方向的偏移量,在简写属性中添 right bottom,可以防止background-position不被支持的时候位置误差过大 \nwidth: 100px;height: 100px;background: darkgoldenrod url(./cover1.jpg) right bottom / 20px 20px no-repeat;background-position: right 20px bottom 20px;\n\n如果你想让背景图片出现在右下角,但是又要空出与 padding 相等的距离,可以使用 background-origin 可以修改出现背景出现的区域\nwidth: 100px;height: 100px;padding:20px;background: darkgoldenrod url(./cover1.jpg) right bottom / 20px 20px no-repeat;background-origin: content-box;\n\n\n也可使用 calc() 函数\nwidth: 100px;height: 100px;box-sizing: border-box;background: darkgoldenrod url(./cover1.jpg) right bottom / 20px 20px no-repeat;background-position: calc(100% - 20px) calc(100% - 20px);\n条纹背景首先我们想实现的是一个实色过度的背景,也就是没有渐变的效果\n当下个颜色的起点在,上一个颜色的终点时,这时候没有空间让渐变产生就会是一个实色的背景\nbackground:linear-gradient(#58a 50%,#fba 50%);background-size:100% 30px;\n\n\n还有一个简写的方法,如果某个颜色的位置比整个列表中他前面颜色的位置都要小,这个颜色的起始位置会被设置为前面颜色中的最大位置\nbackground:linear-gradient(#58a 50%,#fba 0);background-size:100% 30px;\n\n如果想要垂直方向的条纹,需要给定一个角度,并修改背景大小\nbackground:linear-gradient(90deg,#58a 50%,#fba 50%);background-size:30px 100% ;\n\n另一种常用的技巧是,把条纹的主色设置为背景色,再用另一种半透明的颜色覆盖,更容易修改\n45度斜向条纹如果理所当然的把角度改为其他角度,就以为能得到条纹背景,那就错了\n因为旋转的只是一个背景单元(贴片)中的背景,而不是整个背景,他们拼在一起的时候会产生锯齿\n\n所以需要在一个单元(贴片)中完整的画出条纹,在使用这个单元(贴片)去铺满背景\n现在需要加几个锚点,在单元中画出相间的四条背景线,把这些单元拼接在一起的时候就会形成45度的斜向条纹\nbackground:linear-gradient(45deg,#58a 25%,#fba 0,#fba 50%,#58a 0,#58a 75%,#fba 0);background-size:30px 30px ;\n\n其他角度的斜向条纹但是其他角度的时候,会法相还是无法实现,比如 60度\n\n所以css还提供了一个加强版的线性渐变,可以将你画出的部分当作单元并重复铺满整个背景\nbackground:repeating-linear-gradient(60deg,#58a,#58a 15px,#fba 0,#fba 30px);\n\n在实现条纹背景的时候,通常两个颜色属于一个色系,可以将主色设置为背景,副色作为条纹背景盖在上面,而且好处是不支持的时候可以显示主色的背景\nbackground: repeating-linear-gradient(    60deg,    hsla(0, 0%, 100%, 0.1),    hsla(0, 0%, 100%, 0.1) 15px,    transparent 0,    transparent 30px  ),  #58a;\n\n\n网格背景利用半透明的叠加,可以创建对比更明显的网格\nbackground: white;background: linear-gradient(90deg,rgba(200, 0, 0, 0.5) 50%,transparent 0),  linear-gradient(rgba(200, 0, 0, 0.5) 50%, transparent 0);background-size: 30px 30px;\n\n\n也可以让渐变的起始宽度为1px.创建更细的网格线\nbackground: white;background: linear-gradient(90deg, #58a 1px, transparent 0),  linear-gradient(#58a 1px, transparent 0);background-size: 30px 30px;\n\n也可以加重一些边框,形成层次更深的网格\nbackground:    linear-gradient(white 2px,transparent 0),  linear-gradient(90deg, white 2px,transparent 0),  linear-gradient(hsla(0,0%,100%,0.3) 1px,transparent 0),  linear-gradient(90deg,hsla(0,0%,100%,0.3) 1px,transparent 0)   #58a;  background-size: 75px 75px,75px 75px,15px 15px,15px 15px;\n\n\n更复杂的背景案例\nbackground: radial-gradient(      circle at 0% 50%,      rgba(96, 16, 48, 0) 9px,      #613 10px,      rgba(96, 16, 48, 0) 11px    )    0px 10px,  radial-gradient(    at 100% 100%,    rgba(96, 16, 48, 0) 9px,    #613 10px,    rgba(96, 16, 48, 0) 11px  ),  #8a3;background-size: 20px 20px;\n\n\n波点背景\n想实现这样的效果,我们从图形中切出一个小方块.用这个方块铺满整个背景\nbackground:    radial-gradient(tan 30%,transparent 0) #58a;  background-size:30px 30px;\n\n但是现在看着还不是很饱满,我们可以生成两层图案,通过背景定位放到稍微错开的位置\nbackground:    radial-gradient(tan 30%,transparent 0),  radial-gradient(tan 30%,transparent 0),  #58a;  background-size:30px 30px;  background-position:0 0 ,15px 15px;\n\n使用一个 mixin 让代码更容易维护\n/*          单元格大小, 点的半径, 回退颜色, 点的颜色*/@mixin polka($size,   $dot,    $base,  $accent)&#123;  background:$base;  background-image:    radial-gradient($accent $dot,transparent 0),    radial-gradient($accent $dot,transparent 0)    background-size:$size $size;    background-position:0 0,$size/2 $size/2;&#125;\n\n\n棋盘\n期盼的效果看起来简单但实际上有一点麻烦,因为没有一种渐变能实现一个正方形中的1&#x2F;4个小正方形的效果.\n所以需要换一种思路,先实现正方形的两个对角,再用这两个对角,和其他正方形中的对角拼成一个小正方形\nbackground: linear-gradient(  45deg,  #ccc 25%,  transparent 0,  transparent 75%,  #ccc 0);background-size: 30px 30px;\n\n但是在一个渐变里面连续实现两个三角型,没有办法控制他们的位置进行拼接,所以需要分成两个渐变,并控制第二个渐变的背景位置\nbackground: linear-gradient(45deg, #ccc 25%, transparent 0),  linear-gradient(45deg, transparent 75%, #ccc 75%),  linear-gradient(-45deg, #ccc 25%, transparent 0),  linear-gradient(-45deg, transparent 75%, #ccc 75%);background-position: 0 0, -15px 15px, 0 -15px, -15px 0;background-size: 30px 30px;\n\n部分浏览器已经支持角向渐变,可以直接画出1&#x2F;4个正方形\nbackground: conic-gradient(red,yellow,lime,aqua,blue,fuchsia,red);background-size: 30px 30px;\n\n伪随机背景如果背景是不透明的,而且是连续的,那就会每隔background-size指定的像素后就会重复一次.\n所以可以考虑将背景大小设为不同的数值,并且渐变不会铺满整个背景,让他们相互覆盖,形成随机\nbackground: linear-gradient(90deg, #fb3, 10px, transparent 0),  linear-gradient(90deg, #ab4, 20px, transparent 0),  linear-gradient(90deg, #655, 30px, transparent 0);background-size: 40px 100%, 60px 100%, 80px 100%;\n\n\n但是使用整数还是容易被察觉,每隔240px也就是各个背景大小的最小公倍数,所以这里可以把背景大小换成质数\nbackground: linear-gradient(90deg, #fb3, 10px, transparent 0),  linear-gradient(90deg, #ab4, 20px, transparent 0),  linear-gradient(90deg, #655, 30px, transparent 0);background-size: 41px 100%, 61px 100%, 71px 100%;\n\n图像边框如何实现把一张照片中间部分当作内容区域,剩下区域当作背景的效果.\n最简单的想法是,通过两个元素下面的元素用上面的元素遮挡.这个方法是可行的.但是如果只用一个元素呢?\n如果你想到的 background-image 那可能会有一点问题, background-image 会将背景图片按九宫格划分,在四个边上的背景会被拉伸或者重复.\n其实还可以用多重背景来做, 用 background-clip 控制背景的显示区域,下面用一个夸张的样式看下现在的效果\nwidth: 320px;height: 180px;border: 100px solid transparent;background: linear-gradient(white, transparent), url(./cover1.jpg);background-size: cover;background-clip: padding-box, border-box;background-origin: padding-box;\n\n在边框上已经有指定的背景,但是背景没有从边框的左上角开始,这是因为 background-origin 默认是 padding-box 会从内边框的左上角开始,所以边框上的图片是重复平铺之后扩展出来的图片,下面稍微修改一下\nwidth: 320px;height: 180px;border: 20px solid transparent;background: linear-gradient(#fff, #fff), url(./cover1.jpg);background-size: cover;background-clip: padding-box, border-box;background-origin: border-box;\n\n\n下面是简化后的属性\nwidth: 320px;height: 180px;border: 20px solid transparent;background:   linear-gradient(#fff, #fff) padding-box,  url(./cover1.jpg) border-box 0 / cover;\n\n信封效果边框可以利用背景的渐变并应用在边框上\nwidth: 320px;height: 180px;border: 10px solid transparent;background: linear-gradient(#fff, #fff) padding-box,  repeating-linear-gradient(      -45deg,      transparent 0,      transparent 12.5%,      red 0,      red 25%,      transparent 0,      transparent 37.5%,      #58a 0,      #58a 50%,      transparent 0    )  0 / 5em 5em;\n\n\n动态虚线边框width: 320px;height: 180px;border: 1px solid transparent;background:  linear-gradient(#fff, #fff) padding-box,  repeating-linear-gradient(    -45deg,    transparent 0,    transparent 25%,    #000 0,    #000 50%  )  0 / 0.5em 0.5em;  animation: ani 10s linear infinite;&#125;@keyframes ani &#123;  0% &#123;      background-position:0  &#125;  100% &#123;    background-position:100%  &#125;&#125;\n\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS艺术 视觉效果","url":"/posts/bcb927b5ace5/","content":"单侧投影先来回忆一下 box-shadow 的几个属性值\n/*          水平偏移  垂直偏移  模糊半径  扩张半径  颜色   内侧阴影*/box-shadow: h-shadow v-shadow blur spread color inset;\n\n模糊半径和扩张半径共同控制一个阴影的大小.\n如果元素原始的尺寸是 100*100, 设置它的模糊半径为 5px,最终的阴影尺寸是 (100+5)*(100+5),所以如果没有进行平移操作, 每个边上都会延伸出 5px 的阴影.\n这时再设置它的扩张半径属性,会在已有的阴影尺寸上再继续计算, 而且这个值可以是一个负值,如果设置扩张半径为-5px,它会压缩原有的阴影尺寸,最终变为 (105-5)*(105-5),这个属性并不会切割掉设置了阴影的部分,实际上可以看作是它压缩了实心部分也就是元素所占据的那部分的大小.因此现在每个边上都看不见阴影了,但阴影还是存在的,它被缩小到和元素面积相同,被元素覆盖住\n知道了这些实现单侧投影可能就有了一些思路,可以设置一个 4px 的模糊半径, 这样元素四边就都有了 4px 的阴影,再垂直或水平方向上偏移这个阴影 4px,现在一个边上就会有 8px 的阴影,它的对边会被遮盖住,两个临边还是 4px 的阴影,最后在使用扩张半径设置为-4px,把多余的阴影遮盖住,为了效果明显一点,偏移量可以比模糊半径多几个像素\nbox-shadow: 0px 6px 4px -4px #000;\n\n\n不规则投影也许你还是想用 box-shadow 来实现,但事实上 box-shadow 也无能为力,有些场景 box-shadow 并不会正确的显示阴影的效果.\n\n半透明的(图片,背景图片,border-image) 阴影不会穿过半透明区域,实际上还是围绕在元素周围\n元素设置了虚线或点或半透明的边框,但没有背景(或者 background-clip 不是 border-box 时)\n伪类元素拼接\n切角或折角的效果\nclip-path 生成的图形\n\n这里需要用到一个从 SVG 中借鉴来的属性 filter,因为模糊算法不一样肯能有细微的差别\nfilter: drop-shadow(4px 4px 2px red);\n\n注意:这个属性会一视同仁的把所有透明区域都打上阴影,所以如果是元素中的文字,如果没有背景颜色也会打上阴影,而且不受 text-shadow 影响,因为他会给 text-shadow 的阴影打上阴影\n色彩滤镜有的时候想给张图片转换为灰度图,但又需要保留原有的对比度,最好是能与鼠标有交互效果.\n虽然通过 canvas 可以通过脚本的方式进行修改,但是成本很高,也有性能问题. css 提供了滤镜系统可以使用,但不是所有的浏览器都兼容.\n具体属性参考 MDN 或 W3C\ntransition: 0.5 filter;filter: sepia(1) saturate(4);\n\n![0002.png]\n这种方式基本满足效果,但是滤镜的叠加有时会显得过度不自然, 另外一种方式就是混合模式,将上下两层效果混合在一起,一个最重要的区别就是混合叫过不能使用动画,所以混合模式中,只能控制外层的样式过度进行混合\nmix-blend-mode MDN W3C\n&lt;div class=&quot;wrap&quot; &gt; &lt;div class=&quot;box&quot; &gt; &lt;/div &gt; &lt;/div &gt; .wrap &#123;  background: hsla(1, 1, 100, 0.8);&#125;.box &#123;  mix-blend-mode: luminosity;&#125;\n\n毛玻璃效果\n首先能想到的就是文字模糊的问题, 如何能保证背景模糊但是不影响文字, 这里需要使用两个元素,但是为了简洁可以使用伪元素\n另一个元素就是外层的背景图片元素,这里以 body 元素为例, 所以 html 结构如下\n&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;玻璃效果中的文字&lt;/div&gt;&lt;/body&gt;\n\n先把一些简单的样式实现,\nbody &#123;  height: 100%;  background: url(./cover1.jpg) 0 / cover;&#125;.box &#123;  position: relative;  /*     当把一个元素移动到父元素下面的时候,一定要注意父元素的上级元素有没有背景    如果父元素上级元素有背景,那个移动的这个元素的背景会出现在父元素上级元素背景的下面    提升box的层级,防止before移动到box下面的时候背景会在body背景的下面  */  z-index: 1;&#125;.box::before &#123;  content: &quot;&quot;;  position: absolute;  left: 0;  top: 0;  right: 0;  bottom: 0;  background: url(./cover1.jpg) 0 / cover;  /* 移动到父元素的下面,防止背景挡住文字 */  z-index: -1;&#125;\n\n下一个重要的问题就是如何让 before 元素中的背景和 body 的背景完全对其,一种可能的办法是获取父元素背景的大小,子元素使用相同的大小,再获取子元素相对于父元素偏移量,为 background-position 设置相同的偏移量\n虽然这种办法可行,但是一旦父元素存在滚动条会变的很复杂, 一个比较好的方法就是使用 background-attachment 属性.\nbackground-attachment 设置背景图像是否固定或者随着页面的其余部分滚动。当属性值为 fixed 的时候表示,布景图相关于视口固定，所以随页面翻滚布景不动，相当于布景被设置在了 body 上。也就是说给任何元素的布景图设置 background-attachment:fixed;效果都是一样的，都是相关于视口，因为一个网页只要一个视口，该布景和元素现已没关系\n所以分别给这两个元素添加这个属性,但要注意的是填充方式需要相同,否则会有错位的现象, background 最后一个属性就是 background-attachment 的简写形式.\n最后通过一个负数的 margin 来解决模糊效果在临近边界的时候会衰弱, 并用外层元素的 overflow:hidden 把多余的部分剪裁掉\nbody &#123;  background: url(./cover1.jpg) 0 / cover fixed;&#125;.box &#123;  overflow: hidden;&#125;.box:after &#123;  margin: -20px;  background: url(./cover1.jpg) 0 / cover fixed;  filter: blur(20px);&#125;\n","categories":["CSS"],"tags":["CSS"]},{"title":"MySQL DQL查询语言","url":"/posts/64b5a8e1f0ec/","content":"DQL (Data Query Language)数据查询语言;\n基本查询1、查询的结果集 是一个虚拟表2、select 查询列表  类似于System.out.println(打印内容);\nselect后面跟的查询列表，可以有多个部分组成，中间用逗号隔开例如：select 字段1,字段2,表达式 from 表;\nSystem.out.println()的打印内容，只能有一个。\n3、执行顺序\n① from子句② select子句\n4、查询列表可以是：字段、表达式、常量、函数等\nUSE myemployees;#一、查询常量SELECT 100 ;#二、查询表达式SELECT 100%3;#三、查询单个字段SELECT `last_name` FROM `employees`;#四、查询多个字段SELECT `last_name`,`email`,`employee_id` FROM employees;#五、查询所有字段SELECT * FROM `employees`;#F12:对齐格式SELECT     `last_name`,    `first_name`,    `last_name`,    `commission_pct`,    `hiredate`,    `salary` FROM    employees ;    #六、查询函数（调用函数，获取返回值）SELECT DATABASE();SELECT VERSION();SELECT USER();#七、起别名#方式一：使用as关键字SELECT USER() AS 用户名;SELECT USER() AS &quot;用户名&quot;;SELECT USER() AS &#x27;用户名&#x27;;SELECT last_name AS &quot;姓 名&quot; FROM employees;#方式二：使用空格SELECT USER()   用户名;SELECT USER()   &quot;用户名&quot;;SELECT USER()   &#x27;用户名&#x27;;SELECT last_name   &quot;姓 名&quot; FROM employees;#八、+的作用-- 需求：查询 first_name 和last_name 拼接成的全名，最终起别名为：姓 名#方案1：使用+    pass×SELECT first_name+last_name AS &quot;姓 名&quot;FROM employees;#方案2：使用concat拼接函数SELECT CONCAT(first_name,last_name) AS &quot;姓 名&quot;FROM employees;/*Java中+的作用：1、加法运算\t100+1.5      &#x27;a&#x27;+2    1.3+&#x27;2&#x27;\t2、拼接符\t至少有一个操作数为字符串\t&quot;hello&quot;+&#x27;a&#x27;\t\tmysql中+的作用：1、加法运算①两个操作数都是数值型100+1.5②其中一个操作数为字符型将字符型数据强制转换成数值型,如果无法转换，则直接当做0处理&#x27;张无忌&#x27;+100===&gt;100③其中一个操作数为nullnull+null====》nullnull+100====》 null*/        #九、distinct的使用 去重#需求：查询员工涉及到的部门编号有哪些SELECT DISTINCT department_id FROM employees;#十、查看表的结构DESC employees;SHOW COLUMNS FROM employees;\n\n练习\n显示出表 employees 的全部列，各个列之间用逗号连接，列头显示成 OUT_PUT\nSELECT CONCAT(employee_id,&#x27;,&#x27;,first_name,&#x27;,&#x27;,last_name,&#x27;,&#x27;,salary,&#x27;,&#x27;,IFNULL(commission_pct,&#x27;&#x27;))  AS &quot;OUT_PUT&quot;FROM employees;#ifnull(表达式1，表达式2)/*表达式1：可能为null的字段或表达式表达式2：如果表达式1为null，则最终结果显示的值功能：如果表达式1为null，则显示表达式2，否则显示表达式1*/SELECT commission_pct,IFNULL(commission_pct,&#x27;空&#x27;) FROM employees;\n\n条件查询select 查询列表from  表名where 筛选条件;\n执行顺序：①from子句②where子句③select子句\n1、按关系表达式筛选\n关系运算符：&gt;   &lt;    &gt;&#x3D;   &lt;&#x3D;     &#x3D;     &lt;&gt;              补充：也可以使用!&#x3D;,但不建议\n2、按逻辑表达式筛选\n逻辑运算符：and    or   not          补充：也可以使用&amp;&amp;  ||   !  ，但不建议\n3、模糊查询\nlikeinbetween andis null\n#一、按关系表达式筛选#案例1：查询部门编号不是100的员工信息SELECT *FROM employeesWHERE department_id &lt;&gt; 100;#案例2：查询工资&lt;15000的姓名、工资SELECT last_name,salaryFROM employeesWHERE salary&lt;15000;#二、按逻辑表达式筛选#案例1：查询部门编号不是 50-100之间员工姓名、部门编号、邮箱#方式1：SELECT last_name,department_id,emailFROM employeesWHERE department_id &lt;50 OR department_id&gt;100;#方式2：SELECT last_name,department_id,emailFROM employeesWHERE NOT(department_id&gt;=50 AND department_id&lt;=100);#案例2：查询奖金率&gt;0.03 或者 员工编号在60-110之间的员工信息SELECT *FROM employeesWHERE commission_pct&gt;0.03 OR (employee_id &gt;=60 AND employee_id&lt;=110);#三、模糊查询#1、like/*功能：一般和通配符搭配使用，对字符型数据进行部分匹配查询常见的通配符：_ 任意单个字符% 任意多个字符,支持0-多个like/not like */#案例1：查询姓名中包含字符a的员工信息SELECT *FROM employeesWHERE last_name LIKE &#x27;%a%&#x27;;#案例2：查询姓名中包含最后一个字符为e的员工信息SELECT *FROM employeesWHERE last_name LIKE &#x27;%e&#x27;;#案例3：查询姓名中包含第一个字符为e的员工信息SELECT *FROM employeesWHERE last_name LIKE &#x27;e%&#x27;;#案例4：查询姓名中包含第三个字符为x的员工信息SELECT *FROM employeesWHERE last_name LIKE &#x27;__x%&#x27;;#案例5：查询姓名中包含第二个字符为_的员工信息SELECT *FROM employeesWHERE last_name LIKE &#x27;_\\_%&#x27;;SELECT *FROM employeesWHERE last_name LIKE &#x27;_$_%&#x27; ESCAPE &#x27;$&#x27;;#2、in/*功能：查询某字段的值是否属于指定的列表之内a  in(常量值1,常量值2,常量值3,...)a not in(常量值1,常量值2,常量值3,...)in/not in*/#案例1：查询部门编号是30/50/90的员工名、部门编号#方式1：SELECT last_name,department_idFROM employeesWHERE department_id IN(30,50,90);#方式2：SELECT last_name,department_idFROM employeesWHERE department_id = 30OR department_id = 50OR department_id = 90;#案例2：查询工种编号不是SH_CLERK或IT_PROG的员工信息#方式1：SELECT *FROM employeesWHERE job_id NOT IN(&#x27;SH_CLERK&#x27;,&#x27;IT_PROG&#x27;);#方式2：SELECT *FROM employeesWHERE NOT(job_id =&#x27;SH_CLERK&#x27;OR job_id = &#x27;IT_PROG&#x27;);#3、between and/*功能：判断某个字段的值是否介于xx之间between and/not between and*/#案例1：查询部门编号是30-90之间的部门编号、员工姓名#方式1：SELECT department_id,last_nameFROM employeesWHERE department_id BETWEEN 30 AND 90;#方式2：SELECT department_id,last_nameFROM employeesWHERE department_id&gt;=30 AND department_id&lt;=90;#案例2：查询年薪不是100000-200000之间的员工姓名、工资、年薪SELECT last_name,salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesWHERE salary*12*(1+IFNULL(commission_pct,0))&lt;100000 OR salary*12*(1+IFNULL(commission_pct,0))&gt;200000;SELECT last_name,salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesWHERE salary*12*(1+IFNULL(commission_pct,0)) NOT BETWEEN 100000 AND 200000;#4、is null/is not null#案例1：查询没有奖金的员工信息SELECT *FROM employeesWHERE commission_pct IS NULL;#案例2：查询有奖金的员工信息SELECT *FROM employeesWHERE commission_pct IS NOT NULL;SELECT *FROM employeesWHERE salary IS 10000;#----------------对比------------------------------------=\t\t只能判断普通的内容IS              只能判断NULL值&lt;=&gt;             安全等于，既能判断普通内容，又能判断NULL值SELECT *FROM employeesWHERE salary &lt;=&gt; 10000;SELECT *FROM employeesWHERE commission_pct &lt;=&gt; NULL;\n\n排序查询select 查询列表from 表名【where 筛选条件】order by 排序列表\n执行顺序：\n①from子句②where子句③select子句④order by 子句\n特点：\n1、排序列表可以是单个字段、多个字段、表达式、函数、列数、以及以上的组合2、升序 ，通过 asc   ，默认行为   降序 ，通过 desc\n#一、按单个字段排序#案例1：将员工编号&gt;120的员工信息进行工资的升序SELECT * FROM employees ORDER BY salary ;#案例1：将员工编号&gt;120的员工信息进行工资的降序SELECT * FROM employees WHERE employee_id&gt;120 ORDER BY salary DESC;#二、按表达式排序#案例1：对有奖金的员工，按年薪降序SELECT *,salary*12*(1+IFNULL(commission_pct,0))  年薪FROM employeesWHERE commission_pct IS NOT NULLORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;#三、按别名排序#案例1：对有奖金的员工，按年薪降序SELECT *,salary*12*(1+IFNULL(commission_pct,0))  年薪FROM employeesORDER BY 年薪 DESC;#四、按函数的结果排序#案例1：按姓名的字数长度进行升序SELECT last_nameFROM employeesORDER BY LENGTH(last_name);#五、按多个字段排序#案例1：查询员工的姓名、工资、部门编号，先按工资升序，再按部门编号降序SELECT last_name,salary,department_idFROM employeesORDER BY salary ASC,department_id DESC;#六、补充选学：按列数排序SELECT * FROM employees ORDER BY 2 DESC;SELECT * FROM employees ORDER BY first_name;\n\n函数函数：类似于java中学过的“方法”，为了解决某个问题，将编写的一系列的命令集合封装在一起，对外仅仅暴露方法名，供外部调用\n1、自定义方法(函数)2、调用方法(函数)★    叫什么  ：函数名    干什么  ：函数功能\n单行函数\n字符函数  concat  substr  length（str）  char_length  upper  lower  trim  left  right  lpad  rpad  instr  strcmp\n\n数学函数  abs  ceil  floor  round  truncate  mod\n\n日期函数  now  curtime  curdate  datediff  date_format  str_to_date\n\n流程控制函数  if  case\n\n\n1、CONCAT 拼接字符SELECT CONCAT(&#x27;hello,&#x27;,first_name,last_name)  备注 FROM employees;2、LENGTH 获取字节长度SELECT LENGTH(&#x27;hello,郭襄&#x27;);3、CHAR_LENGTH 获取字符个数SELECT CHAR_LENGTH(&#x27;hello,郭襄&#x27;);4、SUBSTRING 截取子串/*注意：起始索引从1开始！！！substr(str,起始索引，截取的字符长度)substr(str,起始索引)*/SELECT SUBSTR(&#x27;张三丰爱上了郭襄&#x27;,1,3);SELECT SUBSTR(&#x27;张三丰爱上了郭襄&#x27;,7);5、INSTR获取字符第一次出现的索引SELECT INSTR(&#x27;三打白骨精aaa白骨精bb白骨精&#x27;,&#x27;白骨精&#x27;);6、TRIM去前后指定的字符，默认是去空格SELECT TRIM(&#x27; 虚  竹    &#x27;)  AS a;SELECT TRIM(&#x27;x&#x27; FROM &#x27;xxxxxx虚xxx竹xxxxxxxxxxxxxxxxxx&#x27;)  AS a;7、LPAD/RPAD  左填充/右填充SELECT LPAD(&#x27;木婉清&#x27;,10,&#x27;a&#x27;);SELECT RPAD(&#x27;木婉清&#x27;,10,&#x27;a&#x27;);8、UPPER/LOWER  变大写/变小写#案例：查询员工表的姓名，要求格式：姓首字符大写，其他字符小写，名所有字符大写，且姓和名之间用_分割，最后起别名“OUTPUT”SELECT UPPER(SUBSTR(first_name,1,1)),first_name FROM employees;SELECT LOWER(SUBSTR(first_name,2)),first_name FROM employees;SELECT UPPER(last_name) FROM employees;SELECT CONCAT(UPPER(SUBSTR(first_name,1,1)),LOWER(SUBSTR(first_name,2)),&#x27;_&#x27;,UPPER(last_name)) &quot;OUTPUT&quot;FROM employees;9、STRCMP 比较两个字符大小SELECT STRCMP(&#x27;aec&#x27;,&#x27;aec&#x27;);10、LEFT/RIGHT  截取子串SELECT LEFT(&#x27;鸠摩智&#x27;,1);SELECT RIGHT(&#x27;鸠摩智&#x27;,1);#二、数学函数1、ABS 绝对值SELECT ABS(-2.4);2、CEIL 向上取整  返回&gt;=该参数的最小整数SELECT CEIL(-1.09);SELECT CEIL(0.09);SELECT CEIL(1.00);3、FLOOR 向下取整，返回&lt;=该参数的最大整数SELECT FLOOR(-1.09);SELECT FLOOR(0.09);SELECT FLOOR(1.00);4、ROUND 四舍五入SELECT ROUND(1.8712345);SELECT ROUND(1.8712345,2);5、TRUNCATE 截断SELECT TRUNCATE(1.8712345,1);6、MOD 取余SELECT MOD(-10,3);a%b = a-(INT)a/b*b-10%3 = -10 - (-10)/3*3   = -1SELECT -10%3;SELECT 10%3;SELECT -10%-3;SELECT 10%-3;#三、日期函数1、NOWSELECT NOW();2、CURDATESELECT CURDATE();3、CURTIMESELECT CURTIME();4、DATEDIFFSELECT DATEDIFF(&#x27;1998-7-16&#x27;,&#x27;2019-7-13&#x27;);5、DATE_FORMATSELECT DATE_FORMAT(&#x27;1998-7-16&#x27;,&#x27;%Y年%M月%d日 %H小时%i分钟%s秒&#x27;) 出生日期;SELECT DATE_FORMAT(hiredate,&#x27;%Y年%M月%d日 %H小时%i分钟%s秒&#x27;)入职日期 FROM employees;6、STR_TO_DATE 按指定格式解析字符串为日期类型SELECT * FROM employeesWHERE hiredate&lt;STR_TO_DATE(&#x27;3/15 1998&#x27;,&#x27;%m/%d %Y&#x27;);#四、流程控制函数1、IF函数SELECT IF(100&gt;9,&#x27;好&#x27;,&#x27;坏&#x27;);#需求：如果有奖金，则显示最终奖金，如果没有，则显示0SELECT IF(commission_pct IS NULL,0,salary*12*commission_pct)  奖金,commission_pctFROM employees;2、CASE函数①情况1 ：类似于switch语句，可以实现等值判断CASE 表达式WHEN 值1 THEN 结果1WHEN 值2 THEN 结果2...ELSE 结果nEND案例：部门编号是30，工资显示为2倍部门编号是50，工资显示为3倍部门编号是60，工资显示为4倍否则不变显示 部门编号，新工资，旧工资SELECT department_id,salary,CASE department_idWHEN 30 THEN salary*2WHEN 50 THEN salary*3WHEN 60 THEN salary*4ELSE salaryEND  newSalaryFROM employees;②情况2：类似于多重IF语句，实现区间判断CASE WHEN 条件1 THEN 结果1WHEN 条件2 THEN 结果2...ELSE 结果nEND案例：如果工资&gt;20000,显示级别A      工资&gt;15000,显示级别B      工资&gt;10000,显示级别C      否则，显示D       SELECT salary, CASE  WHEN salary&gt;20000 THEN &#x27;A&#x27; WHEN salary&gt;15000 THEN &#x27;B&#x27; WHEN salary&gt;10000 THEN &#x27;C&#x27; ELSE &#x27;D&#x27; END AS  a FROM employees;   \n\n分组函数说明：分组函数往往用于实现将一组数据进行统计计算，最终得到一个值，又称为聚合函数或统计函数\n分组函数清单：\nsum(字段名)：求和avg(字段名)：求平均数max(字段名)：求最大值min(字段名)：求最小值count(字段名)：计算非空字段值的个数\n特点：\nsum,avg 一般处理数值类型，max,min,count 可以处理任意类型，以上分组函数都忽略null值。\n可以和 distinct 搭配实现去重的运算\ncount函数一般使用count(*)用作统计行数\n和分组函数一同查询的字段有限制，只能是 group by 后面的函数\n#案例1 ：查询员工信息表中，所有员工的工资和、工资平均值、最低工资、最高工资、有工资的个数SELECT SUM(salary),AVG(salary),MIN(salary),MAX(salary),COUNT(salary) FROM employees;#案例2：添加筛选条件\t#①查询emp表中记录数：\tSELECT COUNT(employee_id) FROM employees;\t#②查询emp表中有佣金的人数：\t\tSELECT COUNT(salary) FROM employees;\t\t\t#③查询emp表中月薪大于2500的人数：\tSELECT COUNT(salary) FROM employees WHERE salary&gt;2500;\t\t#④查询有领导的人数：\tSELECT COUNT(manager_id) FROM employees;\t\t#count的补充介绍★#1、统计结果集的行数，推荐使用count(*)\tSELECT COUNT(*) FROM employees;SELECT COUNT(*) FROM employees WHERE department_id = 30;SELECT COUNT(1) FROM employees;SELECT COUNT(1) FROM employees WHERE department_id = 30;#2、搭配distinct实现去重的统计#需求：查询有员工的部门个数SELECT COUNT(DISTINCT department_id) FROM employees;#思考：每个部门的总工资、平均工资？SELECT SUM(salary)  FROM employees WHERE department_id = 30;SELECT SUM(salary)  FROM employees WHERE department_id = 50;SELECT SUM(salary) ,department_idFROM employeesGROUP BY department_id;\n\n分组查询select 查询列表from 表名where 筛选条件group by 分组列表having 分组后筛选order by 排序列表;\n执行顺序：①from子句②where子句③group by 子句④having子句⑤select子句⑥order by子句\n特点：①查询列表往往是  分组函数和被分组的字段 ★②分组查询中的筛选分为两类            筛选的基表\t使用的关键词\t\t位置分组前筛选\t\t原始表\t\twhere\t\t\tgroup by 的前面\n分组后筛选\t\t分组后的结果集  having\t\t\tgroup by的后面\nwhere——group by ——having\n问题：分组函数做条件只可能放在having后面！！！\n#1）简单的分组#案例1：查询每个工种的员工平均工资SELECT AVG(salary),job_idFROM employeesGROUP BY job_id;#案例2：查询每个领导的手下人数SELECT COUNT(*),manager_idFROM employeesWHERE manager_id IS NOT NULLGROUP BY manager_id;#2）可以实现分组前的筛选#案例1：查询邮箱中包含a字符的 每个部门的最高工资SELECT MAX(salary) 最高工资,department_idFROM employeesWHERE email LIKE &#x27;%a%&#x27;GROUP BY department_id;#案例2：查询每个领导手下有奖金的员工的平均工资SELECT AVG(salary) 平均工资,manager_idFROM employeesWHERE commission_pct IS NOT NULLGROUP BY manager_id;#3）可以实现分组后的筛选#案例1：查询哪个部门的员工个数&gt;5#分析1：查询每个部门的员工个数SELECT COUNT(*) 员工个数,department_idFROM employeesGROUP BY department_id#分析2：在刚才的结果基础上，筛选哪个部门的员工个数&gt;5SELECT COUNT(*) 员工个数,department_idFROM employeesGROUP BY department_idHAVING  COUNT(*)&gt;5;#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资SELECT job_id,MAX(salary)FROM employeesWHERE commission_pct  IS NOT NULLGROUP BY job_idHAVING MAX(salary)&gt;12000;#案例3：领导编号&gt;102的    每个领导手下的最低工资大于5000的最低工资#分析1：查询每个领导手下员工的最低工资SELECT MIN(salary) 最低工资,manager_idFROM employeesGROUP BY manager_id;#分析2：筛选刚才1的结果SELECT MIN(salary) 最低工资,manager_idFROM employeesWHERE manager_id&gt;102GROUP BY manager_idHAVING MIN(salary)&gt;5000 ;#4）可以实现排序#案例：查询没有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序#分析1：按工种分组，查询每个工种有奖金的员工的最高工资SELECT MAX(salary) 最高工资,job_idFROM employeesWHERE commission_pct IS  NULLGROUP BY job_id#分析2：筛选刚才的结果，看哪个最高工资&gt;6000SELECT MAX(salary) 最高工资,job_idFROM employeesWHERE commission_pct IS  NULLGROUP BY job_idHAVING MAX(salary)&gt;6000#分析3：按最高工资升序SELECT MAX(salary) 最高工资,job_idFROM employeesWHERE commission_pct IS  NULLGROUP BY job_idHAVING MAX(salary)&gt;6000ORDER BY MAX(salary) ASC;#5）按多个字段分组#案例：查询每个工种每个部门的最低工资,并按最低工资降序#提示：工种和部门都一样，才是一组工种\t部门  工资1\t10\t100001       20      20002\t203       201       102       302       20SELECT MIN(salary) 最低工资,job_id,department_idFROM employeesGROUP BY job_id,department_id;\n\n\n链接查询说明：又称多表查询，当查询语句涉及到的字段来自于多个表时，就会用到连接查询\n笛卡尔乘积现象：表1 有m行，表2有n行，结果&#x3D;m*n行\n发生原因：没有有效的连接条件如何避免：添加有效的连接条件\n\n分类：\n\n按年代分类：\nsql92标准:仅仅支持内连接\n内连接：\n等值连接\n非等值连接\n自连接\n\n\n\n\nsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\n\n按功能分类：\n内连接：\n等值连接\n非等值连接\n自连接\n\n\n外连接：\n左外连接\n右外连接\n全外连接\n\n\n交叉连接\n\n\n\n\n\n内链接语法:select 查询列表from 表1 别名,表2 别名where 连接条件and 筛选条件group by 分组列表having 分组后筛选order by 排序列表\n执行顺序：\n1、from子句2、where子句3、and子句4、group by子句5、having子句6、select子句7、order by子句\nSQL92和SQL99的区别：    SQL99，使用JOIN关键字代替了之前的逗号，并且将连接条件和筛选条件进行了分离，提高阅读性！！！\n语法：SELECT 查询列表FROM 表名1 别名【INNER】 JOIN  表名2 别名ON 连接条件WHERE 筛选条件GROUP BY 分组列表HAVING 分组后筛选ORDER BY 排序列表;#一）等值连接#①简单连接#案例：查询员工名和部门名SELECT last_name,department_nameFROM departments d  JOIN  employees e ON e.department_id =d.department_id;#②添加筛选条件#案例1：查询部门编号&gt;100的部门名和所在的城市名SELECT department_name,cityFROM departments dJOIN locations lON d.`location_id` = l.`location_id`WHERE d.`department_id`&gt;100;#③添加分组+筛选#案例1：查询每个城市的部门个数SELECT COUNT(*) 部门个数,l.`city`FROM departments dJOIN locations lON d.`location_id`=l.`location_id`GROUP BY l.`city`;#④添加分组+筛选+排序#案例1：查询部门中员工个数&gt;10的部门名，并按员工个数降序SELECT COUNT(*) 员工个数,d.department_nameFROM employees eJOIN departments dON e.`department_id`=d.`department_id`GROUP BY d.`department_id`HAVING 员工个数&gt;10ORDER BY 员工个数 DESC;#二）非等值连接#案例：查询部门编号在10-90之间的员工的工资级别，并按级别进行分组SELECT * FROM sal_grade;SELECT COUNT(*) 个数,gradeFROM employees eJOIN sal_grade gON e.`salary` BETWEEN g.`min_salary` AND g.`max_salary`WHERE e.`department_id` BETWEEN 10 AND 90GROUP BY g.grade;#三）自连接#案例：查询员工名和对应的领导名SELECT e.`last_name`,m.`last_name`FROM employees eJOIN employees mON e.`manager_id`=m.`employee_id`;\n\n\n外连接说明：查询结果为主表中所有的记录，如果从表有匹配项，则显示匹配项；如果从表没有匹配项，则显示 null\n应用场景：一般用于查询主表中有但从表没有的记录\n特点：\n1、外连接分主从表，两表的顺序不能任意调换2、左连接的话，left join 左边为主表右连接的话，right join 右边为主表\n语法：\nselect 查询列表from 表 1 别名left|right|full 【outer】 join 表 2 别名on 连接条件where 筛选条件;\n#案例1：查询所有女神记录，以及对应的男神名，如果没有对应的男神，则显示为null#左连接SELECT b.*,bo.*FROM beauty bLEFT JOIN boys bo ON b.`boyfriend_id` = bo.`id`;#右连接SELECT b.*,bo.*FROM boys boRIGHT JOIN  beauty b ON b.`boyfriend_id` = bo.`id`;#案例2：查哪个女生没有男朋友#左连接SELECT b.`name`FROM beauty bLEFT JOIN boys bo ON b.`boyfriend_id` = bo.`id`WHERE bo.`id`  IS NULL;#右连接SELECT b.*,bo.*FROM boys boRIGHT JOIN  beauty b ON b.`boyfriend_id` = bo.`id`WHERE bo.`id`  IS NULL;#案例3：查询哪个部门没有员工，并显示其部门编号和部门名SELECT COUNT(*) 部门个数FROM departments dLEFT JOIN employees e ON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL;\n\n子查询说明：当一个查询语句中又嵌套了另一个完整的 select 语句，则被嵌套的 select 语句称为子查询或内查询外面的 select 语句称为主查询或外查询。\n分类：\n按子查询出现的位置进行分类：\n1、select 后面要求：子查询的结果为单行单列（标量子查询）2、from 后面要求：子查询的结果可以为多行多列3、where 或 having 后面 ★要求：子查询的结果必须为单列单行子查询多行子查询4、exists 后面要求：子查询结果必须为单列（相关子查询）特点：1、子查询放在条件中，要求必须放在条件的右侧2、子查询一般放在小括号中3、子查询的执行优先于主查询4、单行子查询对应了 单行操作符：&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;多行子查询对应了 多行操作符：any&#x2F;some all in\n单行子查询#一）单行子查询#案例1：谁的工资比 Abel 高?#①查询Abel的工资SELECT salaryFROM employeesWHERE last_name  = &#x27;Abel&#x27;#②查询salary&gt;①的员工信息SELECT last_name,salaryFROM employeesWHERE salary&gt;(\tSELECT salary\tFROM employees\tWHERE last_name  &lt;&gt; &#x27;Abel&#x27;);#案例2：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id 和工资#①查询141号员工的job_idSELECT job_idFROM employeesWHERE employee_id = 141#②查询143号员工的salarySELECT salaryFROM employeesWHERE employee_id = 143#③查询job_id=① and salary&gt;②的信息SELECT last_name,job_id,salaryFROM employeesWHERE job_id = (\tSELECT job_id\tFROM employees\tWHERE employee_id = 141) AND salary&gt;(\tSELECT salary\tFROM employees\tWHERE employee_id = 143);\n\n多行子查询/*in:判断某字段是否在指定列表内x in(10,30,50)any/some:判断某字段的值是否满足其中任意一个x&gt;any(10,30,50)x&gt;min()x=any(10,30,50)x in(10,30,50)all:判断某字段的值是否满足里面所有的x &gt;all(10,30,50)x &gt;max()*/#案例1：返回location_id是1400或1700的部门中的所有员工姓名#①查询location_id是1400或1700的部门SELECT department_idFROM departmentsWHERE location_id IN(1400,1700)#②查询department_id = ①的姓名SELECT last_nameFROM employeesWHERE department_id IN(\tSELECT DISTINCT department_id\tFROM departments\tWHERE location_id IN(1400,1700));#题目：返回其它部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary#①查询job_id为‘IT_PROG’部门的工资SELECT DISTINCT salaryFROM employeesWHERE job_id = &#x27;IT_PROG&#x27;#②查询其他部门的工资&lt;任意一个①的结果SELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary&lt;ANY(\tSELECT DISTINCT salary\tFROM employees\tWHERE job_id = &#x27;IT_PROG&#x27;);等价于SELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary&lt;(\tSELECT MAX(salary)\tFROM employees\tWHERE job_id = &#x27;IT_PROG&#x27;);#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工 的员工号、姓名、job_id 以及salary#①查询job_id为‘IT_PROG’部门的工资SELECT DISTINCT salaryFROM employeesWHERE job_id = &#x27;IT_PROG&#x27;#②查询其他部门的工资&lt;所有①的结果SELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary&lt;ALL(\tSELECT DISTINCT salary\tFROM employees\tWHERE job_id = &#x27;IT_PROG&#x27;);等价于SELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary&lt;(\tSELECT MIN(salary)\tFROM employees\tWHERE job_id = &#x27;IT_PROG&#x27;);#二、放在select后面#案例；查询部门编号是50的员工个数SELECT(\tSELECT COUNT(*)\tFROM employees\tWHERE department_id = 50)  个数;#三、放在from后面#案例：查询每个部门的平均工资的工资级别#①查询每个部门的平均工资SELECT AVG(salary),department_idFROM employeesGROUP BY department_id#②将①和sal_grade两表连接查询SELECT dep_ag.department_id,dep_ag.ag,g.gradeFROM sal_grade gJOIN (\tSELECT AVG(salary) ag,department_id\tFROM employees\tGROUP BY department_id) dep_ag ON dep_ag.ag BETWEEN g.min_salary AND g.max_salary;#四、放在exists后面#案例1 ：查询有无名字叫“张三丰”的员工信息SELECT EXISTS(\tSELECT *\tFROM employees\tWHERE last_name = &#x27;Abel&#x27;) 有无Abel;#案例2：查询没有女朋友的男神信息USE girls;SELECT bo.*FROM boys boWHERE bo.`id` NOT IN(\tSELECT boyfriend_id\tFROM beauty b)SELECT bo.*FROM boys boWHERE NOT EXISTS(\tSELECT boyfriend_id\tFROM beauty b\tWHERE bo.id = b.boyfriend_id);","categories":["数据库"],"tags":["数据库","MySQL"]},{"title":"MySQl 服务基础","url":"/posts/5f3a914ba868/","content":"MySQL 服务启动和停止查看系统内是否有 mysql 服务\nps aux | grep mysql\n\n停止 mysql 服务\nsudo service mysql stop\n\n启动 mysql 服务\nsudo service mysql start\n\n重启 mysql 服务\nsudo service mysql restart\n\n登录与退出登录命令，属性和属性值之间可以省略空格\nmysql -h主机名 -P端口号 -u有户名 -p密码\n\n退出 exit\n常见命令查看当前所有数据库\nshow databases;\n\n打开指定的库\nuse 库名;\n\n查看当前所在库\nselect database();\n\n查看所有表\nshow tables;\n\n查看其他库的所有表\nshow tables from 库名;\n\n创建表\ncreate table 表名 &#123;  列名 列类型，  ...&#125;\n\n查看表结构\ndesc 表名;\n\n查看表结构\n// 进入mysql服务器中select version();// 在命令行中mysql --versionmysql -V\n\n语法规范\n不区分大小写，建议关键字大写，表名，列名小写\n每条命令;结尾\n命令可以换行\n注释单行注释: #注释文字单行注释: -- 注释文字多行注释: /* 注释文字 */\n\n","categories":["数据库"],"tags":["数据库","MySQL"]},{"title":"MySQl 分析函数","url":"/posts/baf7f14e48f8/","content":"ROW_NUMBER表示根据 col1 分组，在分组内部根据 col2 排序，而这个值就表示每组内部排序后的顺序编码\nrow_number() over( partition by col1 order by col2);\n\nROW_NUMBER 返回行信息没有排名\nRANK DENSE_RANKselect *,row_number () over(partition by s.SId order by s.score) as row_number1,rank () over(partition by s.SId order by s.score) as rank1,dense_rank () over(partition by s.SId order by s.score) as dense_rank1from SC s ;\n\nROW_NUMBER 连续排名RANK 值相同排名相同,排名跳跃DENSE_RANK 值相同排名相同,排名连续\n\n查询所有同学最高分对应的科目名称\n","categories":["数据库"],"tags":["数据库","MySQL"]},{"title":"MySQL 局部变量","url":"/posts/53b58b276684/","content":"Transact-SQL 局部变量是可以保存特定类型的单个数据值的对象。在脚本或批处理中通常会使用变量\n\n作为计数器来计算循环执行的次数或控制循环执行的次数。\n保存流程控制中的测试值\n保存要由存储过程返回码或函数返回值返回的数据值。\n\nSELECT @local_variableSELECT &#123; @local_variable &#123; = | += | -= | *= | /= | %= | &amp;= | ^= | |= &#125; expression &#125;    [ ,...n ] [ ; ]\n\n将右边的值赋给左边的变量。\n\n\n\n操作员\n行动\n\n\n\n&#x3D;\n将后面的表达式分配给变量。\n\n\n+&#x3D;\n添加和分配\n\n\n-&#x3D;\n减法和赋值\n\n\n*&#x3D;\n相乘并赋值\n\n\n&#x2F;&#x3D;\n划分和分配\n\n\n%&#x3D;\n取模和赋值\n\n\n&amp;&#x3D;\n按位与并赋值\n\n\n^&#x3D;\n按位异或并赋值\n\n\n| &#x3D;\n按位或并赋值\n\n\nSELECT @local_variable 通常用于将单个值返回到变量中。但是，当表达式是列名时，它可以返回多个值。如果 SELECT 语句返回多个值，则为变量分配最后一个返回的值。\n如果 SELECT 语句没有返回任何行，则变量保留其当前值。如果表达式是不返回值的标量子查询，则变量设置为 NULL。\n一个 SELECT 语句可以初始化多个局部变量。\n\n查询最近 12 个月的数据量, 没有的用 0 补全\n\n因为把表中的所有月份 group by 之后,已有的月份不足 12 个月, 需要补齐,所以先生成一张 12 个月的空表\n注意子查询中的日期不能使用 date_format 因为会失去时间格式,导致上面的变量在 addDate 中不可使用\nselect DATE_FORMAT( @u := ADDDATE(@u,INTERVAL 1 Month),&#x27;%Y-%m&#x27;) as date from (\tselect  @u := ADDDATE(now(),INTERVAL -6 Month) from Student s limit 12) as t;\n\n在拼接已存在的数据\nselect DATE_FORMAT( @u := ADDDATE(@u,INTERVAL 1 Month),&#x27;%Y-%m&#x27;) as date from (\tselect  @u := ADDDATE(now(),INTERVAL -6 Month) from Student s limit 12) as tleft join (\tselect count(*) as sum,DATE_FORMAT(s.date,&#x27;%Y-%m&#x27;) as date  from Student s\tgroup by DATE_FORMAT(s.date,&#x27;%Y-%m&#x27;)) as t2 on t2.date  = t.date\n\n最后把空值处理为 0\nselect date, if(ISNULL(d.sum),0,d.sum) as sum from (\tselect DATE_FORMAT( @u := ADDDATE(@u,INTERVAL 1 Month),&#x27;%Y-%m&#x27;) as date from (\t\tselect  @u := ADDDATE(now(),INTERVAL -6 Month) from Student s limit 12\t) as t\tleft join (\t\tselect count(*) as sum,DATE_FORMAT(s.date,&#x27;%Y-%m&#x27;) as date  from Student s\t\tgroup by DATE_FORMAT(s.date,&#x27;%Y-%m&#x27;)\t) as t2 on t2.date  = t.date) as d\n","categories":["数据库"],"tags":["数据库","MySQL"]},{"title":"MySQL 日期时间函数","url":"/posts/f608af7ca97b/","content":"ADDDATE()-- date时间字段名  expr时间间隔-- unit单位 指的时间单位 天day 小时hour表示等DATE_ADD(date,INTERVAL expr unit)-- 采用这种写法的时候,使用方法与DATE_ADD一致\n\n\n日期+天数\n\nSELECT ADDDATE(&#x27;2020-01-02 00:00:00&#x27;, INTERVAL 1 day) from orders--打印字段为：2020-01-03 00:00:00-- 下面同理， 在写增加天为单位时 可以缩写成SELECT ADDDATE(&#x27;2020-01-02 00:00:00&#x27;, 1) from orders--默认为day--打印字段为：2020-01-03 00:00:00--如果减一天 则为 -1   这里也可写成字符串SELECT ADDDATE(&#x27;2020-01-01 00:00:00&#x27;, &#x27;-1&#x27;) from orders--打印字段为：2020-01-01 00:00:00\n\n\n日期+小时\n\nSELECT ADDDATE(&#x27;2020-01-02 00:00:00&#x27;, INTERVAL 1 HOUR) from orders-- 打印字段为：2020-01-01 01:00:00\n\n\n日期+分钟\n\nSELECT ADDDATE(&#x27;2020-01-02 00:00:00&#x27;, INTERVAL 1 MINUTE) from orders-- 打印字段为：2020-01-01 00:01:00\n\n\n日期+秒\n\nSELECT ADDDATE(&#x27;2020-01-02 00:00:00&#x27;, INTERVAL 1 SECOND) from orders-- 打印字段为：2020-01-01 00:00:01\n\nDATE_FORMAT()date 参数是合法的日期。format 规定日期&#x2F;时间的输出格式。\nDATE_FORMAT(date,format)\n\n\n\n\n格式\n描述\n\n\n\n%a\n缩写星期名\n\n\n%b\n缩写月名\n\n\n%c\n月，数值\n\n\n%D\n带有英文前缀的月中的天\n\n\n%d\n月的天，数值(00-31)\n\n\n%e\n月的天，数值(0-31)\n\n\n%f\n微秒\n\n\n%H\n小时 (00-23)\n\n\n%h\n小时 (01-12)\n\n\n%I\n小时 (01-12)\n\n\n%i\n分钟，数值(00-59)\n\n\n%j\n年的天 (001-366)\n\n\n%k\n小时 (0-23)\n\n\n%l\n小时 (1-12)\n\n\n%M\n月名\n\n\n%m\n月，数值(00-12)\n\n\n%p\nAM 或 PM\n\n\n%r\n时间，12-小时（hh:mm:ss AM 或 PM）\n\n\n%S\n秒(00-59)\n\n\n%s\n秒(00-59)\n\n\n%T\n时间, 24-小时 (hh:mm:ss)\n\n\n%U\n周 (00-53) 星期日是一周的第一天\n\n\n%u\n周 (00-53) 星期一是一周的第一天\n\n\n%V\n周 (01-53) 星期日是一周的第一天，与 %X 使用\n\n\n%v\n周 (01-53) 星期一是一周的第一天，与 %x 使用\n\n\n%W\n星期名\n\n\n%w\n周的天 （0&#x3D;星期日, 6&#x3D;星期六）\n\n\n%X\n年，其中的星期日是周的第一天，4 位，与 %V 使用\n\n\n%x\n年，其中的星期一是周的第一天，4 位，与 %v 使用\n\n\n%Y\n年，4 位\n\n\n%y\n年，2 位\n\n\nNOW() CURDATE() CURTIME()函数返回当前的日期和时间。\n\n\n\nNOW()\nCURDATE()\nCURTIME()\n\n\n\n2008-12-29 16:25:46\n2008-12-29\n16:25:46\n\n\n","categories":["数据库"],"tags":["数据库","MySQL"]},{"title":"MySQL 练习题","url":"/posts/7169c91ebbc1/","content":"创建表结构\n学生表 Student\n\ncreate table Student(Sid varchar(6), Sname varchar(10), Sage datetime, Ssex varchar(10));insert into Student values(&#x27;01&#x27; , &#x27;赵雷&#x27; , &#x27;1990-01-01&#x27; , &#x27;男&#x27;);insert into Student values(&#x27;02&#x27; , &#x27;钱电&#x27; , &#x27;1990-12-21&#x27; , &#x27;男&#x27;);insert into Student values(&#x27;03&#x27; , &#x27;孙风&#x27; , &#x27;1990-05-20&#x27; , &#x27;男&#x27;);insert into Student values(&#x27;04&#x27; , &#x27;李云&#x27; , &#x27;1990-08-06&#x27; , &#x27;男&#x27;);insert into Student values(&#x27;05&#x27; , &#x27;周梅&#x27; , &#x27;1991-12-01&#x27; , &#x27;女&#x27;);insert into Student values(&#x27;06&#x27; , &#x27;吴兰&#x27; , &#x27;1992-03-01&#x27; , &#x27;女&#x27;);insert into Student values(&#x27;07&#x27; , &#x27;郑竹&#x27; , &#x27;1989-07-01&#x27; , &#x27;女&#x27;);insert into Student values(&#x27;08&#x27; , &#x27;王菊&#x27; , &#x27;1990-01-20&#x27; , &#x27;女&#x27;)\n\n\n成绩表 SC\n\ncreate table SC(Sid varchar(10), Cid varchar(10), score decimal(18,1));insert into SC values(&#x27;01&#x27; , &#x27;01&#x27; , 80);insert into SC values(&#x27;01&#x27; , &#x27;02&#x27; , 90);insert into SC values(&#x27;01&#x27; , &#x27;03&#x27; , 99);insert into SC values(&#x27;02&#x27; , &#x27;01&#x27; , 70);insert into SC values(&#x27;02&#x27; , &#x27;02&#x27; , 60);insert into SC values(&#x27;02&#x27; , &#x27;03&#x27; , 80);insert into SC values(&#x27;03&#x27; , &#x27;01&#x27; , 80);insert into SC values(&#x27;03&#x27; , &#x27;02&#x27; , 80);insert into SC values(&#x27;03&#x27; , &#x27;03&#x27; , 80);insert into SC values(&#x27;04&#x27; , &#x27;01&#x27; , 50);insert into SC values(&#x27;04&#x27; , &#x27;02&#x27; , 30);insert into SC values(&#x27;04&#x27; , &#x27;03&#x27; , 20);insert into SC values(&#x27;05&#x27; , &#x27;01&#x27; , 76);insert into SC values(&#x27;05&#x27; , &#x27;02&#x27; , 87);insert into SC values(&#x27;06&#x27; , &#x27;01&#x27; , 31);insert into SC values(&#x27;06&#x27; , &#x27;03&#x27; , 34);insert into SC values(&#x27;07&#x27; , &#x27;02&#x27; , 89);insert into SC values(&#x27;07&#x27; , &#x27;03&#x27; , 98)\n\n\n课程表 Course\n\ncreate table Course(Cid varchar(10),Cname varchar(10),Tid varchar(10));insert into Course values(&#x27;01&#x27; , &#x27;语文&#x27; , &#x27;02&#x27;);insert into Course values(&#x27;02&#x27; , &#x27;数学&#x27; , &#x27;01&#x27;);insert into Course values(&#x27;03&#x27; , &#x27;英语&#x27; , &#x27;03&#x27;)\n\n\n教师表 Teacher\n\ncreate table Teacher(Tid varchar(10),Tname varchar(10));insert into Teacher values(&#x27;01&#x27; , &#x27;张三&#x27;);insert into Teacher values(&#x27;02&#x27; , &#x27;李四&#x27;);insert into Teacher values(&#x27;03&#x27; , &#x27;王五&#x27;)\n\n练习题① 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数② 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩③ 查询在 SC 表存在成绩的学生信息④ 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )⑤ 查询姓李的老师数量⑥ 学过”张三”老师授课的同学的信息⑦ 没有学过”张三”老师授课的同学的信息⑧ 查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息⑨ 查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息⑩ 查询没有学全所有课程的同学的信息⑪ 查询至少有一门课与学号为 01 同学所学相同的同学的信息⑫ 查询和 01 号的同学学习的课程,完全相同的其他同学的信息⑬ 查询所有同学最高分对应的学科名称\n查询”01“课程比”02”课程成绩高的学生的信息及课程分数select Sname as 姓名,t1.score as &quot;语文&quot; , t2.score as &#x27;数学&#x27;from  (select SId ,score from SC as sc1 where sc1.CId=&#x27;01&#x27;) as t1,  (select SId ,score from SC as sc2 where sc2.CId=&#x27;02&#x27;) as t2,  (Select * from Student) as t3where t1.SId=t2.SId and  t2.SId =t3.SId and t1.score&gt;t2.score;select st.*, sc1.score as &#x27;语文&#x27;,sc2.score as &#x27;数学&#x27;from Student as stleft join SC as sc1 on st.SId  = sc1.SId and sc1.CId =&#x27;01&#x27;left join SC as sc2 on st.SId  = sc2.SId and sc2.CId =&#x27;02&#x27;where sc1.score &gt; sc2.score;\n\n查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩select s.SId ,s.Sname,AVG(s2.score) avg_scorefrom Student sleft join SC s2 on s2.SId  = s.SIdgroup by s.SIdhaving avg_score &gt;= 60;\n\n需要注意 where 和 having 的区别, where 是分组前筛选,所以一定写在 group by 的前面, having 是分组后筛选,这道题是想查找求完平均分数之后的结果\n查询在 SC 表存在成绩的学生信息第一种方法:将学生表和成绩表关联,过滤出没有成绩的条目,再用学生 id 分组\nselect s.*from Student sleft join SC s2 on s2.SId = s.SIdwhere s2.score is not NULLgroup by s.SId ;\n\n第二种方法: 先将成绩表按学生 id 分组,再查询学生 id 在分组后的临时表中的学生信息\nselect s.*from Student swhere s.SId in (\tSELECT s.SId\tfrom SC s\tgroup by s.SId);\n\n查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )select s.SId ,s.Sname, COUNT(s2.CId),sum(s2.score)from Student sleft join SC s2 on s2.SId  = s.SIdgroup by s.SId ;\n\n查询姓李的老师数量select COUNT(*) as 数量from Teacher twhere t.Tname LIKE &quot;李%&quot;;\n\n学过”张三”老师授课的同学的信息select s.*,t.Tname  from Student sinner join SC s2 on s.SId = s2.SIdinner join Course c on s2.CId  = c.CIdinner join Teacher t on t.TId  = c.TIdwhere t.Tname = &quot;张三&quot;;\n\n没有学过”张三”老师授课的同学的信息-- 排除学过张三课的同学,剩下的就是没学过张三课的同学select s.* from Student sWHERE  s.SId not in (\tselect s.SId  from Student s\tinner join SC s2 on s.SId = s2.SId\tinner join Course c on s2.CId  = c.CId\tinner join Teacher t on t.TId  = c.TId\twhere t.Tname = &quot;张三&quot;);-- 查找每条成绩对应的课程信息,查找这些信息中是张三老师课的信息-- 在查找这些信息对应的学生信息,并排除SELECT s.* FROM Student sWHERE s.SId NOT IN (\tSELECT s2.SId  from SC s2\tinner JOIN Course c2 on c2.CId = s2.CId\tWHERE c2.TId  = (\t\tSELECT t.TId  from  Teacher t\t\tWHERE t.Tname = &quot;张三&quot;\t));\n\n查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息-- 利用inner join 过滤没有匹配结果的条目SELECT  * from Student sinner join  SC s2 on s2.SId =s.SId and s2.CId = &quot;01&quot;inner join  SC s3 on s3.SId =s.SId and s3.CId = &quot;02&quot;;-- 先分组在查询个数select s.* from Student sinner join SC s2 on s2.SId = s.SIdGROUP BY s.SIdHAVING sum(IF(s2.CId=&quot;01&quot; or s2.CId=&quot;02&quot;,1,0)) &gt;1;\n\n查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息SELECT  * from Student sinner join  SC s2 on s2.SId =s.SId and s2.CId = &quot;01&quot;WHERE s.SId not in (\tSELECT  s.SId  from Student s\tinner join  SC s2 on s2.SId =s.SId and s2.CId = &quot;02&quot;);\n\n查询没有学全所有课程的同学的信息select s.* from Student sleft join SC s2 on s2.SId  = s.SIdGROUP by s.SIdHAVING COUNT(*) &lt; (\tSELECT  COUNT(*) from Course c);\n\n查询至少有一门课与学号为 01 同学所学相同的同学的信息\n查找学号 01 同学学过的科目\n查找每个同学学过的科目,排除 01 同学自己\n查找每个同学学过的科目在 01 同学学过的科目中的同学\n去除重复的同学信息\n\nselect s.* from Student sleft join SC s2 on s2.SId  = s.SIdwhere s2.CId in (\tselect s2.CId  from Student s\tinner  join SC s2 on s2.SId  = s.SId and s2.SId =&#x27;01&#x27;)  and s.SId &lt;&gt; &#x27;01&#x27;group by s.SId;-- 优化查询01同学学过的科目,直接从成绩表中查-- 使用distinct去重Select distinct sc.SId,\t st.* from SC as scJoin Student   stOn sc.SId  = st.SId and st.SId &lt;&gt; &#x27;01&#x27;Where sc.CId  in (Select CId  from SC where SId  = &#x27;01&#x27;)\n\n查询和 01 号的同学学习的课程,完全相同的其他同学的信息\n查找所有同学学过的科目是在 01 同学学过的科目中的同学\n学过和 01 同学相同课程的科目数时候和 01 同学的科目数相同\n\nselect s.* from Student sjoin SC s2 on s2.SId  = s.SId and s.SId &lt;&gt; &#x27;01&#x27; and s2.CId in (select s3.CId  from SC s3 where s3.SId = &#x27;01&#x27;)group by s.SIdHAVING count(s.SId) = (\tselect count(*) from SC s3 where s3.SId = &#x27;01&#x27;)-- 也可以使用group concat 对比课程id-- join的时候无需确认是否课程是01学过的课程select s.* from Student sjoin SC s2 on s2.SId  = s.SId and s.SId &lt;&gt; &#x27;01&#x27;group by s.SIdHAVING GROUP_CONCAT(s2.CId order by s2.CId desc) = (\tselect GROUP_CONCAT(s3.CId order by s3.CId desc) from SC s3 where s3.SId =&#x27;01&#x27;)\n\n查询所有同学最高分对应的学科名称select * from (\tselect s.SId ,s.Sname ,t.CId,t.score,t.row from Student s\tleft join (\t   select s2.*,\t\trow_number () over (partition by s2.SId order by s2.score desc) as row\t\tfrom SC s2\t) as t  on s.SId = t.SId\tleft join Course c on c.CId  = t.CId) as t where t.row = &#x27;1&#x27;\n","categories":["数据库"],"tags":["数据库","MySQL"]},{"title":"BFF 实践","url":"/posts/87af43227417/","content":"BFFBFF，即 Backend For Frontend（服务于前端的后端），也就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理，又称为用户体验适配器。BFF 只是一种逻辑分层，而非一种技术，虽然 BFF 是一个新名词，但它的理念由来已久。\n\n通常一个页面的请求包含了多个不同的请求，用于页面组件的渲染\n同时为了保障 Android，iOS，以及 Web 端的不同需求，需要为不同的平台写不同的 API 接口，而每当值发生一些变化时，需要 Android，iOS，Web 做出修改。\n\n有了 BFF 这一层时，我们就不需要考虑系统后端的迁移。后端发生的变化都可以在 BFF 层做一些响应的修改\n\nBFF 场景多端应用\n我们在设计 API 时会考虑到不同设备的需求，也就是为不同的设备提供不同的 API，虽然它们可能是实现相同的功能，但因为不同设备的特殊性，它们对服务端的 API 访问也各有其特点，需要区别处理。\n服务聚合\n随着微服务的兴起，原本在同一个进程内运行的业务流程被拆分到了不同的服务中。这在增加业务灵活性的同时，也让前端的调用变得更复杂。BFF 的出现为前端应用提供了一个对业务服务调用的聚合点，它屏蔽了复杂的服务调用链，让前端可以聚焦在所需要的数据上，而不用关注底层提供这些数据的服务。\n实战中的玩法访问控制\n例如，服务中的权限控制，将所有服务中的权限控制集中在 BFF 层，使下层服务更加纯粹和独立。\n应用缓存\n项目中时常存在一些需要缓存的临时数据，此时 BFF 作为业务的汇聚点，距离用户请求最近，遂将该缓存操作放在 BFF 层。\n第三方入口\n在业务中需要与第三交互时，将该交互放在 BFF 层，这样可以只暴露必要信息给第三方，从而便于控制第三方的访问。\n初始化项目项目目录结构划分\npackage.json 生命周期 并行执行安装webpack\nyarn add -D webpack-cli webpack\n\npackage.json 文件添加\n&quot;scripts&quot;: &#123;  &quot;test&quot;: &quot;echo test&quot;,  &quot;pretest&quot;: &quot;echo pretest&quot;&#125;,\n\n执行 yarn test\nyarn run v1.22.10$ echo pretestpretest$ echo testtestDone in 0.05s.\n\n并行执行，不能保证顺序\n&quot;scripts&quot;: &#123;  &quot;test1&quot;: &quot;echo test1&quot;,  &quot;test2&quot;: &quot;echo test2&quot;,  &quot;test&quot;: &quot;yarn test1 &amp; yarn test2&quot;&#125;\n\nyarn testyarn run v1.22.10$ yarn test1 &amp; yarn test2$ echo test2$ echo test1test2test1Done in 0.25s.\n\n\nscripy使用scripty拆分复杂命令\nyarn add -D scripty\n\npackage.json\n&quot;scripts&quot;: &#123;  &quot;test:one&quot;: &quot;scripty&quot;,  &quot;test:two&quot;: &quot;scripty&quot;,  &quot;test&quot;: &quot;scripty&quot;&#125;\n\n按照命令建立文件夹\n\n执行 yarn test test文件夹下面的所有命令\npackage.json 定义公共参数package.json\n&quot;config&quot;:&#123;  &quot;port&quot;:9999&#125;\n\n通过变量在命令配置中使用  \nscript&#x2F;test&#x2F;one.sh\necho $npm_package_config_port\n\n执行 yarn test 打印端口\nyarn run v1.22.10$ scriptyscripty &gt; Executing &quot;/home/supreme/Workspace/mvc/scripts/test/one.sh&quot;:9999scripty &gt; Executing &quot;/home/supreme/Workspace/mvc/scripts/test/two.sh&quot;:2Done in 0.13s.\n\njscpd 代码重复率检查yarn add -D jscpd\n\n添加配置文件.jscpd.json\n&#123;  &quot;threshold&quot;: 0,  &quot;reporters&quot;: [&quot;html&quot;, &quot;console&quot;]&#125;\n\nscripts\njscpd --min-lines 1 --output ./doc/jscpd --pattern &quot;src/**/*.js&quot;\n\nwebpack配置建立配置文件夹 config,通过内置方法拿到配置参数\nprocess.env.NODE_ENV\n\n安装 yargs,以对象的形式更方便的获取命令参数\n安装 webpack-merge 合并公共配置和定制配置\nart-template使用art-template作为后端模板，用于服务端渲染html配置和swig 模板类似\nyarn add art-template koa-art-template\n\n打包思路通过webpack打包前端代码\nhtml-webpack-plugin 处理前端模板,放到指定位置\n因为模板中插入js代码所以需要通过编写插件处理\n后端模板通过 gulp 处理\n处理模块化规范,删除无用的代码\nwebpack.js\nconst glob = require(&#x27;glob&#x27;)const &#123; argv &#125; = require(&#x27;yargs&#x27;)const path = require(&#x27;path&#x27;)const files = glob.sync(&quot;./src/web/views/**/*.js&quot;)const htmls = glob.sync(&quot;./src/web/views/**/*.art&quot;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;);const CustomInjectPlugin = require(&#x27;./src/service/config/CustomInjectPlugin&#x27;);const mode = argv.mode;if (!files.length) return;const entry = files.reduce((entry, path) =&gt; &#123;  const match = path.match(/(\\w+)\\/(\\w+)\\.js$/);  entry[match[1]] = match.input;  return entry;&#125;, &#123;&#125;);const htmlPlugin = htmls.map(path =&gt; &#123;  const match = path.match(/(\\w+)\\/(\\w+)\\.art$/);  return new HtmlWebpackPlugin(&#123;    filename: `$&#123;match[1]&#125;.art`,    template: match.input,    hash: true,    chunks: [&#x27;runtime&#x27;, match[1]],    inject: false  &#125;)&#125;)module.exports = &#123;  entry,  mode,  output: &#123;    filename: &#x27;[name]_[contentHash].js&#x27;,    path: __dirname + &#x27;/dist&#x27;  &#125;  plugins: [    new CleanWebpackPlugin(),    ...htmlPlugin,    new CustomInjectPlugin()  ],  optimization: &#123;    runtimeChunk: &#123;      name: &#x27;runtime&#x27;    &#125;  &#125;,  module: &#123;    rules: [      &#123;        test: /\\.js$/,        exclude: /(node_modules|bower_components)/,        use: &#123;          loader: &#x27;babel-loader&#x27;,        &#125;      &#125;    ]  &#125;,  resolve: &#123;    alias: &#123;      &quot;@&quot;: path.resolve(__dirname, &#x27;src/web&#x27;)    &#125;  &#125;&#125;\n\nCustomInjectPlugin.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const pluginName = &#x27;CustomInjectPlugin&#x27;;class CustomInjectPlugin &#123;  js = &#x27;&#x27;  apply(compiler) &#123;    compiler.hooks.compilation.tap(&#x27;pluginName&#x27;, (compilation) =&gt; &#123;      HtmlWebpackPlugin.getHooks(compilation).beforeAssetTagGeneration.tapAsync(        pluginName,        (data, cb) =&gt; &#123;          const &#123; assets: &#123; js &#125; &#125; = data;          this.js = js.map(src =&gt; src.replace(&#x27;@&#x27;, &#x27;./&#x27;)).join(&#x27;&#x27;);          cb(null, data)        &#125;      )      // Static Plugin interface |compilation |HOOK NAME | register listener       HtmlWebpackPlugin.getHooks(compilation).beforeEmit.tapAsync(        pluginName, // &lt;-- Set a meaningful name here for stacktraces        (data, cb) =&gt; &#123;          const &#123; html &#125; = data;          data.html = html.replace(/!script!/, this.js);          this.js = &#x27;&#x27;          cb(null, data)        &#125;      )    &#125;)  &#125;&#125;module.exports = CustomInjectPlugin;\n\ngulpfile.js\nconst &#123; series, src, dest &#125; = require(&#x27;gulp&#x27;);var plugins = require(&#x27;gulp-load-plugins&#x27;)();const replace = require(&#x27;@rollup/plugin-replace&#x27;);const jspath = &#x27;./src/service/**/*.js&#x27;;// 开发环境 监听文件变化, 处理模块化规范function es6(cb) &#123;  plugins.watch(jspath, &#123; ignoreInitial: false &#125;,    function () &#123;      return src(jspath)        .pipe(plugins.babel(&#123;          plugins: [            &quot;@babel/plugin-transform-modules-commonjs&quot;,            &quot;@babel/plugin-transform-runtime&quot;          ]        &#125;))        .pipe(dest(&#x27;dist&#x27;))    &#125;  )    .pipe(dest(&#x27;build&#x27;));  return cb()&#125;function es6dev() &#123;  return src(jspath)    .pipe(plugins.babel(&#123;      ignore: [&#x27;./src/service/config/index.js&#x27;],      plugins: [        //处理模块化规范        &quot;@babel/plugin-transform-modules-commonjs&quot;,        &quot;@babel/plugin-transform-runtime&quot;      ]    &#125;))    .pipe(dest(&#x27;dist&#x27;))&#125;function codeClean(cb) &#123;  return src(jspath)    // transform the files here.    .pipe(plugins.rollup(&#123;      // any option supported by Rollup can be set here.      input: &#x27;./src/service/config/index.js&#x27;,      output: &#123;        format: &#x27;cjs&#x27;      &#125;,      plugins: [        replace(&#123;          &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(&#x27;production&#x27;)        &#125;)      ]    &#125;))    .pipe(dest(&#x27;dist&#x27;))&#125;exports.dev = series(es6);exports.default = series(es6dev, codeClean);\n\n","categories":["DevOps"],"tags":["BFF","工程化","DevOps"]},{"title":"CI CD","url":"/posts/a660168bab48/","content":"\n代码 -&gt; 构建 -&gt; 集成 -&gt; 测试 -&gt; 发布 -&gt; 部署\n|———持续集成——| CI\n|———–持续发布————| CD\n|—————持续部署—————| CD\nCI CD\n\n持续集成(CI)\n\n持续交付和持续部署(CD)\n\n现代软件开发的需求加上部署到不同基础设施的复杂性使得创建应用程序成为一个繁琐的过程。当应用程序出现规模性增长,开发团队人员变得更分散时,快速且不断地生产和发布软件的流程将会变得更加困难。\n\n为了解决这些问题,开发团队开始探索新的策略来使他们的构建、测试和发布流程自动化,以帮助其更快地部署新的生产。这就是持续交付和持续集成发展的由来。\n\n\n流程\n\n自动构建在软件开发过程中,构建流程会将开发人员生成的代码转换为可执行的可用软件。\n对于Go或者C语言等编译语言,此阶段需要通过编译器运行源代码以生成独立的二进制文件。\n对于JavaScript或PHP等解释性语言,没有编译的步骤,但是代码依旧需要在特定的时间内冻结、绑定依赖项、打包以便于分发。这些过程通常称为“构建”或“发布”的工件。\n虽然开发人员可以手动构建,但这样操作有诸多不利。首先,从主动开发到创建构建的转变中引入了上下文转换,使得开发人员不得不停止生产效率更高的工作来专注于构建过程。其次,每个开发人员都在制作自己的工件,这可能导致构建过程不一致。\n为了解决这些顾虑,许多开发团队配置了自动构建流水线。这些系统监视源代码存储库,并在检测到更改时自动启动预配置的构建过程。这一配置无需牵涉过多的人力在其中并且确保了每个构建过程一致。\n","categories":["DevOps"],"tags":["工程化","DevOps"]},{"title":"CLI","url":"/posts/3f200f51f059/","content":"命令行工具基于文本查看，处理，操作计算机上面文件的程序\n开发环境webpack 打包 编译 图片压缩 \n命令vue  [options]\n主命令 + 子命令 + 参数\ninit           generate a new project from a templatelist           list available official templatesbuild          prototype a new projectcreate         (for v3 warning only)help [cmd]     display help for [cmd]\n通过用户的配置拉取远程的模板，来生成模板\nvue list 查看模板的种类\nAvailable official templates:  ★  browserify - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing.  ★  browserify-simple - A simple Browserify + vueify setup for quick prototyping.  ★  pwa - PWA template for vue-cli based on the webpack template  ★  simple - The simplest possible Vue setup in a single HTML file  ★  webpack - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction.  ★  webpack-simple - A simple Webpack + vue-loader setup for quick prototyping.\nborwserify 是有另一种打包规范，用于处理使用CMD打包规范，引用的模块\n初始化vue help init 查看初始化命令\nUsage: vue-init  [project-name]\nOptions:  -c, –clone  use git clone  –offline    use cached template  -h, –help   output usage information  Examples:\n# create a new project with an official template\n$ vue init webpack my-project\n\n# create a new project straight from a github template\n$ vue init username/repo my-project\n\n流程：\n\nvue 输入命令 命令内部初始化\n\n获取用户配置：交互\n\n解析配置 基础配置+用户配置&#x3D;配置\n\n生成项目文件 通过配置来拉取远程官方模板 + 自己写的模板自己写的模板必须包含 ：meta.js &#x2F; jsonprompts&#x3D;&gt;收集弹框信息helpers&#x3D;&gt;模板引擎的扩展complete&#x3D;&gt;钩子函数metalsmith&#x3D;&gt;站点生成器 通过配置和模板生成文件\n还必须包含模板文件：template\n\n完善工作\n\n\n包\ncommander 完整的 node.js 命令行解决方案\n\nInquirer 弹窗交互\n\nchalk 命令行美化工具\n\nora 命令行加载动画\n\nexeca 持续集成 提交到主分支\n\nlerna 处理多包相互依赖\n\n\n目录\ndocs 文档\n\nscripts 脚本\n\npackages &#x3D;&gt; lerna\n\nlib 核心逻辑\n\npackage.json  bin 放置用户自定义命令\n  为什么没有全局安装的命令可以使用 npm run 来执行，但是不能直接调用？\n  如果一个命令想要全局执行，需要添加到全局的环境变量 PATH 中\n  在执 npm run 或者 yarn 的时候，会自动在node_modules中查找需要执行的文件，通过npm link 软连接，添加到全局的环境变量PATH中，在执行完成后再删除\n  全局安装的命令，会安装在 /usr/local/node12.18.4/lib/node_modules/,执行的时候会自动link,和scripts中写的命令同理\n  bin 文件夹下面的命令需要手动link,在入口文件改变时需要重新link\n  所以写一个命令的步骤： 1）创建bin文件夹，添加文件 2） 文件头部添加 #!/usr/bin/env node  表示可执行文件 3） link 到全局\n\n\nvue-clivue-list 请求模板\n#!/usr/bin/env nodeconst logger = require(&#x27;../lib/logger&#x27;)const request = require(&#x27;request&#x27;)const chalk = require(&#x27;chalk&#x27;)// 监听ctrl + c退出事件process.on(&#x27;exit&#x27;, () =&gt; &#123;  console.log()&#125;)//请求模板使用到的包// 如果没有报错，拼接包的名字 返回上面的列表request(&#123;  url: &#x27;https://api.github.com/users/vuejs-templates/repos&#x27;,  headers: &#123;    &#x27;User-Agent&#x27;: &#x27;vue-cli&#x27;  &#125;&#125;, (err, res, body) =&gt; &#123;  if (err) logger.fatal(err)  const requestBody = JSON.parse(body)  if (Array.isArray(requestBody)) &#123;    console.log(&#x27;  Available official templates:&#x27;)    console.log()    requestBody.forEach(repo =&gt; &#123;      console.log(        &#x27;  &#x27; + chalk.yellow(&#x27;★&#x27;) +        &#x27;  &#x27; + chalk.blue(repo.name) +        &#x27; - &#x27; + repo.description)    &#125;)  &#125; else &#123;    console.error(requestBody.message)  &#125;&#125;)\n\nvue-init\n#!/usr/bin/env nodeconst download = require(&#x27;download-git-repo&#x27;)const program = require(&#x27;commander&#x27;)const exists = require(&#x27;fs&#x27;).existsSyncconst path = require(&#x27;path&#x27;)const ora = require(&#x27;ora&#x27;)const home = require(&#x27;user-home&#x27;)const tildify = require(&#x27;tildify&#x27;)const chalk = require(&#x27;chalk&#x27;)const inquirer = require(&#x27;inquirer&#x27;)const rm = require(&#x27;rimraf&#x27;).syncconst logger = require(&#x27;../lib/logger&#x27;)const generate = require(&#x27;../lib/generate&#x27;)const checkVersion = require(&#x27;../lib/check-version&#x27;)const warnings = require(&#x27;../lib/warnings&#x27;)const localPath = require(&#x27;../lib/local-path&#x27;)const isLocalPath = localPath.isLocalPathconst getTemplatePath = localPath.getTemplatePathprogram  .usage(&#x27;&lt;template-name&gt; [project-name]&#x27;)  .option(&#x27;-c, --clone&#x27;, &#x27;use git clone&#x27;)  .option(&#x27;--offline&#x27;, &#x27;use cached template&#x27;)/** * Help. */program.on(&#x27;--help&#x27;, () =&gt; &#123;  console.log(&#x27;  Examples:&#x27;)  console.log()  console.log(chalk.gray(&#x27;    # create a new project with an official template&#x27;))  console.log(&#x27;    $ vue init webpack my-project&#x27;)  console.log()  console.log(chalk.gray(&#x27;    # create a new project straight from a github template&#x27;))  console.log(&#x27;    $ vue init username/repo my-project&#x27;)  console.log()&#125;)/** * Help. */function help () &#123;  program.parse(process.argv)  if (program.args.length &lt; 1) return program.help()&#125;help()/** * Settings. */let template = program.args[0]const hasSlash = template.indexOf(&#x27;/&#x27;) &gt; -1const rawName = program.args[1]const inPlace = !rawName || rawName === &#x27;.&#x27;const name = inPlace ? path.relative(&#x27;../&#x27;, process.cwd()) : rawNameconst to = path.resolve(rawName || &#x27;.&#x27;)const clone = program.clone || falseconst tmp = path.join(home, &#x27;.vue-templates&#x27;, template.replace(/[\\/:]/g, &#x27;-&#x27;))if (program.offline) &#123;  console.log(`&gt; Use cached template at $&#123;chalk.yellow(tildify(tmp))&#125;`)  template = tmp&#125;/** * Padding. */console.log()process.on(&#x27;exit&#x27;, () =&gt; &#123;  console.log()&#125;)if (inPlace || exists(to)) &#123;  inquirer.prompt([&#123;    type: &#x27;confirm&#x27;,    message: inPlace      ? &#x27;Generate project in current directory?&#x27;      : &#x27;Target directory exists. Continue?&#x27;,    name: &#x27;ok&#x27;  &#125;]).then(answers =&gt; &#123;    if (answers.ok) &#123;      run()    &#125;  &#125;).catch(logger.fatal)&#125; else &#123;  run()&#125;/** * Check, download and generate the project. */function run () &#123;  // check if template is local  if (isLocalPath(template)) &#123;    const templatePath = getTemplatePath(template)    if (exists(templatePath)) &#123;      generate(name, templatePath, to, err =&gt; &#123;        if (err) logger.fatal(err)        console.log()        logger.success(&#x27;Generated &quot;%s&quot;.&#x27;, name)      &#125;)    &#125; else &#123;      logger.fatal(&#x27;Local template &quot;%s&quot; not found.&#x27;, template)    &#125;  &#125; else &#123;    checkVersion(() =&gt; &#123;      if (!hasSlash) &#123;        // use official templates        const officialTemplate = &#x27;vuejs-templates/&#x27; + template        if (template.indexOf(&#x27;#&#x27;) !== -1) &#123;          downloadAndGenerate(officialTemplate)        &#125; else &#123;          if (template.indexOf(&#x27;-2.0&#x27;) !== -1) &#123;            warnings.v2SuffixTemplatesDeprecated(template, inPlace ? &#x27;&#x27; : name)            return          &#125;          // warnings.v2BranchIsNowDefault(template, inPlace ? &#x27;&#x27; : name)          downloadAndGenerate(officialTemplate)        &#125;      &#125; else &#123;        downloadAndGenerate(template)      &#125;    &#125;)  &#125;&#125;/** * Download a generate from a template repo. * * @param &#123;String&#125; template */function downloadAndGenerate (template) &#123;  const spinner = ora(&#x27;downloading template&#x27;)  spinner.start()  // Remove if local template exists  if (exists(tmp)) rm(tmp)  download(template, tmp, &#123; clone &#125;, err =&gt; &#123;    spinner.stop()    if (err) logger.fatal(&#x27;Failed to download repo &#x27; + template + &#x27;: &#x27; + err.message.trim())    generate(name, tmp, to, err =&gt; &#123;      if (err) logger.fatal(err)      console.log()      logger.success(&#x27;Generated &quot;%s&quot;.&#x27;, name)    &#125;)  &#125;)&#125;","categories":["DevOps"],"tags":["DevOps"]},{"title":"ESLint 和 Prettier 区别","url":"/posts/02f0336782db/","content":"ESLint 是什么呢？是一个开源的 JavaScript 的 linting 工具，使用 espree 将 JavaScript 代码解析成抽象语法树 (AST)，然后通过AST 来分析我们代码，从而给予我们两种提示：\n\n代码质量问题：使用方式有可能有问题(problematic patterns)\n代码风格问题：风格不符合一定规则 (doesn’t adhere to certain style guidelines)(这里的两种问题的分类很重要，下面会主要讲）\n\n你可能开始为了缩进问题配置了一个规则\n// .eslintrc    &#123;            &quot;indent&quot;: [&quot;error&quot;, 2]    &#125;\n\n\n还安装了 ESLint 的 VSCode 插件，没有通过 ESLint 校验的代码 VSCode 会给予下滑波浪线提示。\n\n为了万无一失，你还添加一个 pre-commit 钩子 eslint --ext .js src，确保没有通过 lint 的代码不会被提交。\n\n更让人开心的是，之前不统一的代码也能通过 eslint –fix 来修改成新的格式。\n\n\nAirbnb Style Guide配置完了缩进之后你可能又会发现有人写大括号的时候不会换行。最终你找到了一个和你有一样困惑的公司Airbnb,并且他们自行讨论出一套完整的校验规则。你 install 了 eslint-config-airbnb ，并且将 .eslintrc 文件改成了下面这样，终于大功告成。\n// .eslintrc&#123;  &quot;extends&quot;: [&quot;airbnb&quot;]&#125;\n\nPrettier上面我们说到，ESLint 主要解决了两类问题，但其实 ESLint 主要解决的是代码质量问题。另外一类代码风格问题其实 Airbnb JavaScript Style Guide 并没有完完全全做完，因为这些问题”没那么重要”，代码质量出问题意味着程序有潜在 Bug，而风格问题充其量也只是看着不爽。\n\n代码质量规则 (code-quality rules)\n\nno-unused-vars\n\nno-extra-bind\n\nno-implicit-globals\n\nprefer-promise-reject-errors…\n\n代码风格规则 (code-formatting rules)\n\nmax-len\n\nno-mixed-spaces-and-tabs\n\nkeyword-spacing\n\ncomma-style…\n\n\n这时候就出现了 Prettier，Prettier 声称自己是一个有主见 (偏见) 的代码格式化工具 (opinionated code formatter)，Prettier 认为格式很重要，但是格式好麻烦，我来帮你们定好吧。简单来说，不需要我们再思考究竟是用 single quote，还是 double quote 这些乱起八糟的格式问题，Prettier 帮你处理。最后的结果，可能不是你完全满意，但是，绝对不会丑，况且，Prettier 还给予了一部分配置项，可以通过 .prettierrc 文件修改。\n所以相当于 Prettier 接管了两个问题其中的代码格式的问题，而使用 Prettier + ESLint 就完完全全解决了两个问题。但实际上使用起来配置有些小麻烦，但也不是什么大问题。因为 Prettier 和 ESLint 一起使用的时候会有冲突，所以\n首先我们需要使用 eslint-config-prettier 来关掉 (disable) 所有和 Prettier 冲突的 ESLint 的配置（这部分配置就是上面说的，格式问题的配置，所以关掉不会有问题），方法就是在 .eslintrc 里面将 prettier 设为最后一个 extends\n// .eslintrc&#123;    &quot;extends&quot;: [&quot;prettier&quot;] // prettier 一定要是最后一个，才能确保覆盖&#125;\n\n 然后再启用 eslint-plugin-prettier ，将 prettier 的 rules 以插件的形式加入到 ESLint 里面。这里插一句，为什么”可选” ？当你使用 Prettier + ESLint 的时候，其实格式问题两个都有参与，disable ESLint 之后，其实格式的问题已经全部由 prettier 接手了。那我们为什么还要这个 plugin？其实是因为我们期望报错的来源依旧是 ESLint ，使用这个，相当于把 Prettier 推荐的格式问题的配置以 ESLint rules 的方式写入，这样相当于可以统一代码问题的来源。\n// .eslintrc    &#123;    &quot;plugins&quot;: [&quot;prettier&quot;],    &quot;rules&quot;: &#123;                &quot;prettier/prettier&quot;: &quot;error&quot;    &#125;&#125;\n\n将上面两个步骤和在一起就是下面的配置，也是官方的推荐配置\n// .eslintrc&#123;  &quot;extends&quot;: [&quot;plugin:prettier/recommended&quot;]&#125;","categories":["DevOps"],"tags":["DevOps"]},{"title":"ESLint配置指南","url":"/posts/87a060953f56/","content":"基础包ESLint: lint 代码的主要工具，所以的一切都是基于此包\n解析器(parser)babel-eslint 已经变更为 @babel&#x2F;eslint-parser: 该依赖包允许你使用一些实验特性的时候，依然能够用上 ESlint 语法检查。\n@typescript-eslint&#x2F;parser: 与@babel/eslint-parser类似，如果你使用 typescript,需要使用 typescript 专有的解析器\n扩展的配置eslint-config-airbnb: 提供了 Airbnb 的 eslintrc 作为可扩展的共享配置。默认导出包含我们所有的 ESLint 规则，包括 ECMAScript 6+ 和 React。引入了 eslint，eslint-plugin-import，eslint-plugin-react，eslint-plugin-react-hooks，和 eslint-plugin-jsx-a11y。如果您不需要 React，请使用eslint-config-airbnb-base。\neslint-config-jest-enzyme: 只用当你使用jest-environment-enzyme 这个库的时候，这个扩展才会有效，使用 jest-environment-enzyme 时有一些全局变量，这个规则可以让 eslint 不报警告。\n插件eslint-plugin-babel 已经变更为 @babel&#x2F;eslint-plugin: 和 babel-eslint 一起用的一款插件.babel-eslint 在将 eslint 应用于 Babel 方面做得很好，但是它不能更改内置规则来支持实验性特性。eslint-plugin-babel 重新实现了有问题的规则，因此就不会误报一些错误信息\neslint-plugin-import 该插目的是要支持对 ES2015+ (ES6+) import&#x2F;export 语法的校验, 并防止一些文件路径拼错或者是导入名称错误的情况\neslint-plugin-jsx-a11y 在 JSX 元素上，对可访问性规则进行静态 AST 检查。\neslint-import-resolver-webpack 在 webpack 项目之中， 我们会借助 alias 别名提升代码效率和打包效率。但是在使用了自定义的路径指向后，eslint 就会对应产生找不到模块的报错。这时候就需要eslint-import-resolver-webpack\neslint-import-resolver-typescript 和 eslint-import-resolver-webpack 类似，主要是为了解决 alias 的问题\neslint-plugin-react React 专用的校验规则插件.\neslint-plugin-jest Jest 专用的 Eslint 规则校验插件.\neslint-plugin-prettier 该插件辅助 Eslint 可以平滑地与 Prettier 一起协作，并将 Prettier 的解析作为 Eslint 的一部分，在最后的输出可以给出修改意见。这样当 Prettier 格式化代码的时候，依然能够遵循我们的 Eslint 规则。如果你禁用掉了所有和代码格式化相关的 Eslint 规则的话，该插件可以更好得工作。所以你可以使用 eslint-config-prettier 禁用掉所有的格式化相关的规则(如果其他有效的 Eslint 规则与 prettier 在代码如何格式化的问题上不一致的时候，报错是在所难免的了)\n@typescript-eslint&#x2F;eslint-plugin Typescript 辅助 Eslint 的插件。\neslint-plugin-promise promise 规范写法检查插件，附带了一些校验规则。\n其他工具husky git 命令 hook 专用配置.\nlint-staged 可以定制在特定的 git 阶段执行特定的命令。\nESLint 配置文件ESLint 配置\nmodule.exports =  &#123;  // 表示eslint检查只在当前目录生效  root:true,  // 默认ESlint使用Espree作为解析器，但是一旦我们使用babel的话，我们需要用@babel/eslint-parser。  // 如果使用TS，则使用 @typescript-eslint/parser  // Specifies the ESLint parser  parser:  &#x27;@babel/eslint-parser&#x27;,  parserOptions: &#123;    // ecmaVersion: 默认值是5，可以设置为3、5、6、7、8、9、10，用来指定使用哪一个ECMAScript版本的 // 语法。也可以设置基于年份的JS标准，比如2015(ECMA 6),也可以设置 latest 使用最近支持的版本    // specify the version of ECMAScript syntax you want to use: 2015 =&gt; (ES6)    ecmaVersion: &#x27;latest&#x27;,    // 如果你的代码是ECMAScript 模块写的，该字段配置为module，否则为script(默认值)    sourceType:  &#x27;module&#x27;,  // Allows for the use of imports    // 额外的语言特性    ecmaFeatures: &#123;      jsx: true, // enable JSX      impliedStrict: true // enable global strict mode    &#125;，      // babel 文件路径    babelOptions: &#123;      configFile: &#x27;./.babelrc&#x27;,    &#125;,  &#125;,  // 指定扩展的配置，配置支持递归扩展，支持规则的覆盖和聚合。  extends:  [    // // Uses airbnb, it including the react rule(eslint-plugin-react/eslint-plugin-jsx-a11y)    &#x27;airbnb&#x27;,    // prettier规则额放在最后需要覆盖默认规则    &#x27;plugin:prettier/recommended&#x27;,  ],  // 字段定义的数据可以在所有的插件中共享。这样每条规则执行的时候都可以访问这里面定义的数据  settings: &#123;    &#x27;import/resolver&#x27;: &#123; // This config is used by eslint-import-resolver-webpack      webpack: &#123;        config: &#x27;./webpack/webpack-common-config.js&#x27;      &#125;    &#125;,  &#125;,  // 环境可以提供的全局变量  env: &#123;    // enable all browser global variables    browser: true  &#125;,  // 配置那些我们想要Linting规则的插件。  // plugins: [&#x27;react-hooks&#x27;, &#x27;promise&#x27;],  // 自定义规则，可以覆盖掉extends的配置。  rules:  &#123;    &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;  &#125;,&#125;;\n\nVSCode 使用 eslint 自动修复\n下载插件 eslint\n\n在setting.json开启 eslint 自动修复配置\n\n\n&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true&#125;\n","categories":["DevOps"],"tags":["DevOps"]},{"title":"Jenkins agent/pipeline","url":"/posts/014626a92ba1/","content":"Agent官方建议使用无论何时都使用 Agent 执行任务，而不是使用内置的节点\n停用内置 Agent\n在 Manage Jenkins -&gt; Nodes -&gt; Build-In Node 的配置中，配置 Number of executors 为 0。\n\nlabel 填写 don’t use Built-In node\n\nUsage 选择 Only build jobs with label expressions matching this node。\n\n点击保存，这样就不会使用内置节点执行任务了。\n\n\n创建新的 AgentAgent 节点可以是物理机，也可以是虚拟机。必须装有和 Jenkins controller 相同的 Java 环境， 不需要安装 jenkins, 只用于执行任务。\n\n点击新建节点，选择 Permanent agent\n\nNumber of executors 填写数量不能大于物理核心数，或是虚拟核心数。\n\nRemote root directory 会从 Jenkins controller 中同步 jenkins 相关文件，确保放在登录用户有权限执行的目录下，例如 /home/user/jenkins, user 是 Agent 节点的登录用户名。\n\nLabels 可以描述当前 Agent 的用途内置的环境\n\nUsage 选择 Use this node as much as possible\n\nLaunch method 选择 Launch agents via SSH，填写 Host，并创建登录凭证， 凭证的类型一定要选择 username with password\n在使用凭证登录的时候，需要校验相关权限，会去查找 Jenkins controller 上的 ~/.ssh 目录下的 known_hosts 文件，如果没有则会需要手动创建 .ssh 文件夹（确保权限正确，不是 root 用户），在使用以下命令同步认证信息 ssh-keyscan -H your_agent_host &gt;&gt; /home/your_user_name/.ssh/known_hosts\nHost Key Verification Strategy 选择 Known hosts file Verification Strategy 进行验证\n\n执行 docker 命令时报错 permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.48/containers/node-18:alpine/json&quot;: dial unix /var/run/docker.sock: connect: permission denied\nJenkins 会以 jenkins 用户身份运行， 把该用户加入本机 docker 组（例如：docker），以便它可以读写 /var/run/docker.sock\nsudo usermod -aG docker jenkins# 如果仍然没有权限，尝试重启系统docker run hello-world\n\n点击保存，Jenkins 会自动检查 Agent 链接\n\n\nPipelineworkspace通过在线的方式创建一个简单的 pipeline\npipeline &#123;    agent any    stages &#123;        stage(&#x27;without docker&#x27;) &#123;            steps &#123;               sh &#x27;&#x27;&#x27;                touch without-docker.txt               &#x27;&#x27;&#x27;            &#125;        &#125;         stage(&#x27;with docker&#x27;) &#123;            agent &#123;                docker &#123;                    image &#x27;node:18-alpine&#x27;                &#125;            &#125;            steps &#123;               sh &#x27;&#x27;&#x27;                npm -v                touch with-docker.txt               &#x27;&#x27;&#x27;            &#125;        &#125;    &#125;&#125;\n\n执行结束后在任务的 workspaces 目录下可以看到生成的多个文件夹，每个文件夹对应一个执行阶段\n/home/jenkins/jenkins-agent/workspace/simple-pipeline on Agent1/home/jenkins/jenkins-agent/workspace/simple-pipeline@2 on Agent1\n\n如果想要合并这些文件夹,共用上一阶段的产物,添加如下的配置\nagent &#123;  docker &#123;      image &#x27;node:18-alpine&#x27;      reuseNode true  &#125;&#125;\n\nGitlab Plugin Pipeline\n测试 Gitlab 对 Jenkins 的认证\nJenkins 中点击右上角的头像，选择 security, 创建一个 API Token.\n点击任意一个任务，查看浏览器地址栏 https://jenkins.iftrue.club/job/simple-freesyle/,simple-freesyle 即为项目的名称（特殊字符需要转义，所以按地址栏中显示的准）, 记下这个项目名称\n在 Gitlab 中进入到一个项目中， setting -&gt; webhooks -&gt; add webhook, 填写 Jenkins 的地址，规则为 https://[Jenkins用户ID]:[Jenkins_Api_Token]@jenkins.iftrue.club/project/[项目名称]\n点击测试通过，在内网环境中可能需要关闭 webhook 的 ssl 验证，才不会报错。（内网环境使用 nginx 作为统一入口，会提示 unable to get local issuer certificate）\n\n配置 Jenkins 对 Gitlab 的认证\n此认证配置仅用于访问 GitLab API，以便向 GitLab 发送构建状态。它不用于克隆 git 仓库。用于克隆的凭证（通常是 SSH 凭证）应该在 git 插件中单独配置。\n创建 Gitlab access tokens, setting -&gt; Access Tokens, 选择 api 权限，复制生成的 token\n在 Jenkins 中创建一个凭证，选择 GitLab API Token, 填写生成的 Gitlab Access Token\njenkins -&gt; System Manage , 找到 GitLab 部分，填写 GitLab host URL 和创建的 GitLab API Token 凭证。（内网环境可能有证书报错的问题，在 高级选项中勾选 Ignore SSL Certificate Errors）\n保存后测试链接是否成功。\n\n任务触发配置\n在一个 pipeline 项目中配置触发器，在 Build Triggers 配置中\n选择 Build when a change is pushed to GitLab，复制 GitLab webhook URL 地址，将项目部分的地址替换到 Gitlab 的 webhook 中，Jenkins 用户名和 Api token 仍然需要保留，点击测试通过。\n继续选择 Push Events，表示在 Gitlab 推送代码时触发 Jenkins 的构建。\npipeline 中选择 pipeline script from SCM, 选择 GitLab 作为 SCM，填写仓库地址。\n保证在 Jenkins controller 中有 Git 环境，否则校验命令会执行失败。\n如果提示 Host key verification failed., Jenkins 凭证中创建一个 SSH Username with private key 类型的凭证，填写 Gitlab 服务器的用户名，Jenkins controller 中的私钥 （如果私钥有密码也需要填写密码）。\n在 Gitlab SSH Key 管理中添加 Jenkins controller 的公钥，这样可以完成 git 的认证。\n如果任务在 Jenkins agent 中执行，Jenkins 默认使用 known_hosts 文件进行认证，gitlab 的认证信息必须添加到 Jenkins agent 的 known_hosts 文件中。\nssh-keyscan -H gitlab_host &gt;&gt; /home/jenkins/.ssh/known_hosts\n\n也可以直接在 System -&gt; Security -&gt; Git Host Key Verification Configuration 中修改为 Accept first connection 会在首次链接后自动保存这个主机指纹。\n这样就可以在拉取代码后，执行项目中的 jenkinsfile 文件\n\n\n拉取项目没有编译的过程，当任务被触发时，agent 节点会直接连接上目标服务器，拉取项目并更新并重新执行项目\n安装 Publish Over SSH 插件， 进入系统管理 -&gt; Publish over SSH\n填写 Jenkins controller 的 SSH Key 密码，添加一个服务器配置，填写服务器的 IP 地址和用户名, 点击测试通过\n配置 jenkinsfile\npipeline &#123;    agent any    stages &#123;        stage(&#x27;Deploy&#x27;) &#123;            steps &#123;                sshPublisher(publishers:                    [sshPublisherDesc(                        // Publish over SSH 插件配置的服务器名称                        configName: &#x27;crawler server&#x27;,                        transfers: [                            sshTransfer(                                // 远程目录，从 /home/your_username 目录下创建                                remoteDirectory: &#x27;crawler&#x27;,                                // 不能使用数组，多类文件可以使用多个 sshTransfer                                sourceFiles:&#x27;*/**&#x27;                            ),                            sshTransfer(                                // 由于ssh链接不是使用的交互式命令行所以.bashrc文件不会被执行                                // 需要手动执行 source ~/.nvm/nvm.sh 以便于找到npm命令                                execCommand: &#x27;cd crawler &amp;&amp; source ~/.nvm/nvm.sh &amp;&amp; npm ci &amp;&amp; npm run build &amp;&amp; npm run start&#x27;                            )                          ],                        //  开启查看详细的报错信息                        verbose: true                        ),                    ]                )            &#125;        &#125;    &#125;&#125;\n","categories":["DevOps"],"tags":["工程化","DevOps"]},{"title":"简单Node部署","url":"/posts/6661e67bf767/","content":"创建非 root 账户有些云服务器会禁止 root 用户登录， 但是如果分发的服务器使用 root 登录，可以创建一个非 root 账号， 防止权限过高导致误操作。\n# root 用户下执行，添加一个 user1 用户adduser user1Adding user `user1&#x27; ...Adding new group `user1&#x27; (1002) ...Adding new user `user1&#x27; (1002) with group `user1&#x27; ...Creating home directory `/home/user1&#x27; ...Copying files from `/etc/skel&#x27; ...New password:Retype new password:passwd: password updated successfullyChanging the user information for user1Enter the new value, or press ENTER for the default        Full Name []: sunzhiqi        Room Number []:        Work Phone []:        Home Phone []:        Other []:Is the information correct? [Y/n]\n\n将指定的用户（user）添加到 sudo 组中，从而授予该用户使用 sudo 命令的权限\ngpasswd -a user1 sudo\n\n之前 root 用户登录的窗口不要关闭，如果新用户无法登录，可以使用 root 用户窗口重启 ssh 服务，再次尝试\nservice ssh restart\n\n免密登录如果使用 ssh 工具可以记住登录密码，如果使用命令行需要配置 免密登录\n修改默认端口修改完成后需要同步修改本地的 config 免密登录配置文件，同时配置服务器防火墙放行端口\nvi /etc/ssh/sshd_config#修改端口字段# Port 22222\n\n禁用 root 登录vi /etc/ssh/sshd_config# 表示禁止密码登录，但是可以通过SSH登录# 通常需要设置为no#PermitRootLogin prohibit-password# 使用密码登录，通常设置为no# PasswordAuthentication yes\n\niptables 配置sudo touch /etc/network/if-up.d/iptables.up\n\n写入规则\n*filter# -A INPUT：向 INPUT 链添加规则，用于处理进入系统的数据包。# -m state：指定使用 state 模块，state 模块允许基于连接状态来过滤数据包。# --state ESTABLISHED,RELATED：允许已建立连接（ESTABLISHED）和相关连接（RELATED）的数据包通过。简单来说，允许已经建立的连接的数据包通过，例如响应来自客户端的请求。# -j ACCEPT：匹配此规则的数据包将被接受（允许通过）。-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# -A OUTPUT：向 OUTPUT 链添加规则，用于处理从系统发送的数据包。# -j ACCEPT：所有匹配此规则的数据包将被接受，即允许所有出站流量。-A OUTPUT -j ACCEPT# -A INPUT：向 INPUT 链添加规则，处理进入系统的数据包。# -p tcp：指定使用 TCP 协议。# --dport 443：指定目标端口为 443，这通常用于 HTTPS 流量。# -j ACCEPT：匹配此规则的 TCP 数据包将被接受，允许 HTTPS 流量进入系统。-A INPUT -p tcp --dport 443 -j ACCEPT# -A INPUT：向 INPUT 链添加规则，处理进入系统的数据包。# -p tcp：指定使用 TCP 协议。# --dport 80：指定目标端口为 80，通常用于 HTTP 流量。# -j ACCEPT：允许所有 HTTP 流量（目标端口 80）进入系统。-A INPUT -p tcp --dport 80 -j ACCEPT# -A INPUT：向 INPUT 链添加规则，处理进入系统的数据包。# -p tcp：指定使用 TCP 协议。# -m state：使用 state 模块来匹配连接状态。# --state NEW：只允许新的连接通过，即连接尚未建立的流量。# --dport 39999：指定目标端口为 39999。# -j ACCEPT：允许目标端口为 39999 的新连接通过。-A INPUT -p tcp -m state --state NEW --dport 22222 -j ACCEPT# -A INPUT：向 INPUT 链添加规则，处理进入系统的数据包。# -p icmp：指定使用 ICMP 协议，通常用于网络诊断，如 ping 命令。# -m icmp：使用 ICMP 模块进行匹配。# --icmp-type 8：指定 ICMP 类型为 8，这表示“回显请求”类型，通常是 ping 请求。# -j ACCEPT：允许 ping 请求（ICMP 类型 8）进入系统。-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# -A INPUT：将规则添加到 INPUT 链，表示处理进入系统的流量。# -m limit 5/min：使用 limit 模块来限制日志记录的频率。这里表示每分钟最多记录 5 次 拒绝的连接请求。这样可以避免日志记录过多导致磁盘空间不足。# -j LOG：指示 iptables 执行日志记录操作。# --log-prefix &quot;iptables denied: &quot;：为每个被记录的日志条目添加前缀。日志条目将以 iptables denied: 开头，便于区分其他日志。# --log-level 7：设置日志级别为 7。日志级别越高，记录的详细信息越多。级别 7 是最高级别，通常用于调试。# 这条规则的作用是：记录所有被拒绝的连接请求，并且每分钟最多记录 5 次，并将日志保存到系统的日志文件中（通常是 /var/log/syslog 或 /var/log/messages）。-A INPUT -m limit 5/min -j LOG --log-prefix &quot;iptables denied: &quot; --log-level 7# 拒绝所有未被允许的入站流量，即如果流量没有匹配任何允许规则，则会被拒绝并发送一个拒绝消息。-A INPUT -j REJECT# 拒绝所有经过路由的流量。通常这种配置用于禁止路由器或网关机器转发流量。-A FORWARD -j REJECT# -A INPUT：将这条规则添加到 INPUT 链，表示处理进入系统的流量。# -p tcp：指定协议为 TCP。# --dport 80：指定目标端口为 80，即 HTTP 流量。# -i eth0：表示该规则仅适用于 eth0 网络接口。也就是说，只有通过该接口的流量才会应用此规则。# -m state：使用 state 模块来匹配数据包的连接状态。# --state NEW：匹配所有 新的连接，即第一次尝试建立连接的流量。# -m recent --set：使用 recent 模块，标记（--set）每个新连接的源 IP 地址。这会将源 IP 地址添加到一个最近连接的列表中。这个模块通常用于追踪和限制访问频率。# 这条规则的作用是：对所有新的、来自 eth0 接口的 HTTP 请求进行标记，记录这些请求的源 IP 地址。-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --set# -A INPUT：将规则添加到 INPUT 链，处理进入的流量。# -p tcp：使用 TCP 协议。# --dport 80：指定目标端口为 80，即 HTTP 流量。# -i eth0：指定网络接口为 eth0。# -m state：使用 state 模块来匹配数据包的连接状态。# --state NEW：匹配所有新的连接。# -m recent --update：使用 recent 模块来更新连接源 IP 的记录。# --seconds 60：指定检查时间窗口为 60 秒。即在过去 60 秒内的请求将被视为重复的请求。# --hitcount 150：如果源 IP 在 60 秒内的请求次数超过 150 次，则触发 DROP 动作。# -j DROP：如果源 IP 地址的请求次数超过 150 次，就会被 丢弃，即拒绝这个源 IP 地址的流量。# 这条规则的作用是：如果一个源 IP 地址在 60 秒内对端口 80 发起超过 150 次新连接，则丢弃该 IP 的请求。这通常用于 防止 DoS（拒绝服务）攻击 或者 流量过载，限制某个 IP 在短时间内过多的连接请求。-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60 --hitcount 150 -j DROPCOMMIT\n\n使用 iptables-restore 从 &#x2F;etc&#x2F;network&#x2F;if-up.d&#x2F;iptables.up 文件中加载并恢复防火墙规则\nsudo iptables-restore &lt; /etc/network/if-up.d/iptables.up\n\n启动防火墙\nsudo ufw enablesudo ufw status\n\n配置开机自动写入\n# 创建文件touch /etc/network/if-up.d/iptables# 写入配置#!/bin/shiptables-restore /etc/iptables.up\n\nfail2banFail2ban 是一个开源的入侵防护工具，主要用于防止基于暴力破解的攻击（如 SSH、HTTP、FTP 等服务的暴力登录尝试）。它通过监控日志文件，检测可疑行为（如多次失败的登录尝试），然后根据配置的规则采取措施，例如暂时或永久禁止攻击者的 IP 地址。\nsudo apt install fail2ban\n\n修改配置\nvi /etc# 换成自己的邮箱destemail = root@localhost\n\n启动服务\nservice fail2ban start\n\n配置 node 环境安装必要依赖\nsudo apt install vim openssl build-essential libssl-dev wget curl git\n\n安装 nvm,指定默认版本\nnvm alias default v20.xx\n\n设置系统文件参数修改了 fs.inotify.max_user_watches 参数，增加每个用户可以监控的文件数（即文件监控器的数量）。\n将此设置永久性地添加到 &#x2F;etc&#x2F;sysctl.conf 配置文件中，并应用该更改，使得新的文件监控数值生效。\necho fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.confsudo sysctl -p\n\n强制同步 cnpm如果使用了 cnpm 源，导致有些包不是最新的，使用以下命令强制同步\ncnpm sync [package]\n\nnginx如果服务器预装了 apache2 需要先删除\n# 删除 Apache2 服务的自动启动配置,它会删除 /etc/rc.d 目录下的相关启动链接。update-rc.d -f apache2 remove# 卸载 Apache2 软件包sudo apt remove apache2\n\n添加 nginx 配置文件\nupstream node_learn &#123;    server 127.0.0.1:3000;  # 定义后端服务器&#125;server &#123;    listen 80;    server_name site.iftrue.club;  # 配置服务器监听端口和域名    # 优化代理设置    location / &#123;        proxy_set_header X-Real-IP $remote_addr;  # 设置请求头，传递真实的客户端 IP 地址        proxy_set_header X-Forwarded-For $proxy_add_X_forwarded_for;  # 设置请求头，传递 X-Forwarded-For 头信息        proxy_set_header Host $http_host;  # 保留原始请求的 Host 头        proxy_set_header X-Nginx-Proxy true;  # 添加 X-Nginx-Proxy 头，标识请求是经过 Nginx 代理的        proxy_pass http://node_learn;  # 转发请求到后端应用        proxy_redirect off;  # 关闭代理重定向        proxy_cache my_cache;  # 启用缓存        proxy_cache_valid 200 1h;  # 缓存 200 状态的响应 1 小时        proxy_cache_use_stale error timeout updating;  # 使用过期的缓存响应来应对错误或超时    &#125;    # 静态资源代理和缓存    location /assets/ &#123;        # 将静态资源代理到 Node.js 应用或提供本地静态文件        proxy_pass http://node_learn/assets/;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_X_forwarded_for;        proxy_set_header Host $http_host;        proxy_set_header X-Nginx-Proxy true;        proxy_cache my_cache;        proxy_cache_valid 200 1d;  # 缓存静态资源 1 天    &#125;    # 如果静态文件已经存储在磁盘中，可以使用 root 或 alias 来提供静态文件    location /static/ &#123;        root /var/www/site.iftrue.club;  # 假设静态资源位于这个目录        try_files $uri $uri/ =404;  # 如果找不到文件返回 404    &#125;    # 你也可以为其他静态资源（如 CSS、JS）设置缓存    location ~* \\.(css|js|jpg|jpeg|png|gif|ico|woff|woff2|ttf|svg)$ &#123;        root /var/www/site.iftrue.club;        try_files $uri $uri/ =404;        expires 30d;  # 设置静态资源缓存 30 天        add_header Cache-Control &quot;public, no-transform&quot;;  # 设置缓存控制头    &#125;    # 其他错误页面、重定向等配置    error_page 404 /404.html;    location = /404.html &#123;        root /usr/share/nginx/html;        internal;    &#125;&#125;\n\n如果需要隐藏响应头中的 nginx 版本信息配置 nginx.conf\n# /etc/nginx/nginx.conf# 取消此行注释server_tokens off;\n\nmysql# 安装服务sudo apt install -y mysql-server# 检查服务是否启动systemctl status mysql# 执行MySQL安全脚本mysql_secure_installation，提高MySQL的安全性# 该脚本允许设置或更改root密码策略、移除匿名用户、禁止root远程登录、删除测试数据库等。sudo mysql_secure_installation# 首次登录没有密码sudo mysql -u root -p#给root用户设置密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;your_password&#x27;; FLUSH PRIVILEGES;EXIT;# 创建对应的数据库CREATE DATABASE my_databaseCHARACTER SET utf8mb4COLLATE utf8mb4_general_ci;# 查看所有数据库SHOW DATABASES;# 删除数据库DROP DATABASE database_name;# 修改字符集和排序ALTER DATABASE database_nameCHARACTER SET utf8mb4COLLATE utf8mb4_general_ci;# 创建新用户# &#x27;localhost&#x27;：表示该用户只能从本地机器连接到数据库。如果希望该用户可以从任何主机连接，可以使用 &#x27;%&#x27;，如 &#x27;new_user&#x27;@&#x27;%&#x27;。CREATE USER &#x27;new_user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;your_password&#x27;;# 查看所有用户SELECT User, Host FROM mysql.user;#ALL PRIVILEGES：赋予所有权限。# my_database.*：指示该用户可以对 my_database 数据库中的所有表进行操作。# &#x27;localhost&#x27;：表示该用户只能从本地连接。GRANT ALL PRIVILEGES ON my_database.* TO &#x27;new_user&#x27;@&#x27;localhost&#x27;;# 如果希望用户只具备某些操作的权限（例如只读权限），可以单独授予特定权限GRANT SELECT ON my_database.* TO &#x27;new_user&#x27;@&#x27;localhost&#x27;;GRANT SELECT, INSERT ON my_database.* TO &#x27;new_user&#x27;@&#x27;localhost&#x27;;# 可以访问所有数据库# GRANT ALL PRIVILEGES ON *.* TO &#x27;new_user&#x27;@&#x27;localhost&#x27;;# 刷新权限FLUSH PRIVILEGES;# 查看端口SHOW VARIABLES LIKE &#x27;port&#x27;;cat /etc/mysql/mysql.conf.d/mysqld.cnf\n\npm2npm install -g pm2# 启动服务pm2 start server.js# 应用列表pm2 list# 应用详细信息pm2 show [appName]\n\n配置 pm2 ecosystem.json&#123;  &quot;apps&quot;: [    &#123;      &quot;name&quot;: &quot;node-learn&quot;,      &quot;script&quot;: &quot;bin/www&quot;,      &quot;env&quot;: &#123;        &quot;NODE_ENV&quot;: &quot;development&quot;      &#125;,      &quot;env_production&quot;: &#123;        &quot;NODE_ENV&quot;: &quot;production&quot;      &#125;    &#125;  ],  &quot;deploy&quot;: &#123;    &quot;production&quot;: &#123;      // 远程服务器上用于执行部署的用户。这个用户将有权限操作目标服务器进行部署工作。      &quot;user&quot;: &quot;ubuntu&quot;,      // 部署目标服务器的 IP 地址。这里设置了一个服务器的 IP 地址      // 表示要将代码部署到这个服务器。      &quot;host&quot;: [&quot;192.168.48.171&quot;],      // 通过 SSH 连接远程服务器时使用的端口号      &quot;port&quot;: &quot;22&quot;,      // 这是你要部署的 Git 分支。origin/master 表示远程仓库的 master 分支      &quot;ref&quot;: &quot;origin/main&quot;,      // 这是 Git 仓库的 URL，表示从哪里拉取代码。      &quot;repo&quot;: &quot;git@git.oschina.net:wolf18387/backend-website.git&quot;,      // 这是部署目标路径，代码将被拉取到这个路径下。      // 所有应用文件将被放置在服务器的 /www/website/production 目录下。      &quot;path&quot;: &quot;/www/node-learn&quot;,      // 这个选项用于 SSH 连接时禁用 SSH 主机密钥检查。      // 这通常用于自动化部署，避免因首次连接服务器时需要确认主机密钥而中断部署。      &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;,      // 部署前的准备脚本      &quot;pre-setup&quot;: &quot;rm -rf /www/node-learn/*&quot;,      // 部署前的准备脚本，在拉取代码后执行      // 在服务器上执行的脚本      // 如果使用的是nvm安装的node需要加上 source ~/.nvm/nvm.sh      // 需要指定环境变量 export NODE_ENV=production deploy.env 只会在 deploy 阶段加载      &quot;post-setup&quot;: &quot;source ~/.nvm/nvm.sh &amp;&amp; npm install &amp;&amp; export NODE_ENV=production &amp;&amp; npx sequelize-cli db:migrate &amp;&amp; npx sequelize-cli db:seed:all&quot;,      &quot;post-deploy&quot;: &quot;source ~/.nvm/nvm.sh &amp;&amp; npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;,      &quot;env&quot;: &#123;        &quot;NODE_ENV&quot;: &quot;production&quot;      &#125;    &#125;  &#125;&#125;\n\n执行部署部署前确认各个服务器之间可以互相免密访问，本地&#x3D;&gt;生产服务器&#x3D;&gt;git 服务器, 将主机加入目标主机的 known hosts 中\n确认服务器的目录是否有写入权限\nwindows 环境会执行失败，需要在 linux 虚拟机中执行\n#  设置远程环境,创建应用目录,初始化 Git 仓库,执行 pre-setup 钩子#  current 当前服务运行的文件夹会软连接到source文件夹上#  source clone下来的源代码#  shared 配置文件等#  只应该在初始化的时候执行一次npx pm2 deploy production setup\n\n部署成功后可以登录服务器检查部署情况\npm2 listpm2 logs\n","categories":["DevOps"],"tags":["DevOps"]},{"title":"Prettire配置指南","url":"/posts/cbc0dbaf8f33/","content":"基础库prettier 定义并实现了基本规则\neslint-config-prettier 关闭所有可能和 prettier 有冲突的规则\neslint-plugin-prettier 屏蔽了冲突规则之后，仍然想让eslint统一报错信息\nprettier-eslint 可以通过 eslint --fix 来使用 prettier 格式化代码\nprettier-eslint-cli 以 cli 方式执行prettier-eslint\nPrettier 影响的规则规则\nPrettier 配置文件一共有三种方式支持对 Prettier 进行配置：\n\n根目录创建.prettierrc 文件，能够写入 YML、JSON 的配置格式，并且支持.yaml&#x2F;.yml&#x2F;.json&#x2F;.js 后缀；\n根目录创建.prettier.config.js 文件，并对外 export 一个对象；\n在 package.json 中新建 prettier 属性。\n\n更多配置\n&#123;  &quot;singleQuote&quot;: true,  &quot;semi&quot;: true,  &quot;printWidth&quot;: 80,  &quot;useTabs&quot;: false&#125;\n\n与 ESLint 结合安装 prettier 插件\nESLint 配置指南\n","categories":["DevOps"],"tags":["DevOps"]},{"title":"StyleLint配置指南","url":"/posts/d81239d4645c/","content":"基础包stylelint 有力的，现代的 lint 工具，帮助你在 style 中避免错误， 按照约定转换会规则。\nstylelint-config-standard stylelint 配置共享库，可以通过 rules 覆盖规则\nstylelint-order 一个为 stylelint 规则排序的插件包\nstylelint-config-sass-guidelines 如果你写 SCSS 可以用这个包\nstylelint-scss 一个SCSS的规则集合\n配置文件&#123;  &quot;extends&quot;: &quot;stylelint-config-sass-guidelines&quot;,  &quot;plugins&quot;: [    &quot;stylelint-scss&quot;,    &quot;stylelint-order&quot;  ],  &quot;rules&quot;: &#123;    &quot;order/properties-order&quot;: [      &quot;position&quot;,      &quot;top&quot;,      &quot;right&quot;,      &quot;bottom&quot;,      &quot;left&quot;,      &quot;z-index&quot;,      &quot;display&quot;,      &quot;justify-content&quot;,      &quot;align-items&quot;,      &quot;float&quot;,      &quot;clear&quot;,      &quot;overflow&quot;,      &quot;overflow-x&quot;,      &quot;overflow-y&quot;,      &quot;margin&quot;,      &quot;margin&quot;,      &quot;margin-top&quot;,      &quot;margin-right&quot;,      &quot;margin-bottom&quot;,      &quot;margin-left&quot;,      &quot;border&quot;,      &quot;border-style&quot;,      &quot;border-width&quot;,      &quot;border-color&quot;,      &quot;border-top&quot;,      &quot;border-top-style&quot;,      &quot;border-top-width&quot;,      &quot;border-top-color&quot;,      &quot;border-right&quot;,      &quot;border-right-style&quot;,      &quot;border-right-width&quot;,      &quot;border-right-color&quot;,      &quot;border-bottom&quot;,      &quot;border-bottom-style&quot;,      &quot;border-bottom-width&quot;,      &quot;border-bottom-color&quot;,      &quot;border-left&quot;,      &quot;border-left-style&quot;,      &quot;border-left-width&quot;,      &quot;border-left-color&quot;,      &quot;border-radius&quot;,      &quot;padding&quot;,      &quot;padding-top&quot;,      &quot;padding-right&quot;,      &quot;padding-bottom&quot;,      &quot;padding-left&quot;,      &quot;width&quot;,      &quot;min-width&quot;,      &quot;max-width&quot;,      &quot;height&quot;,      &quot;min-height&quot;,      &quot;max-height&quot;,      &quot;font-size&quot;,      &quot;font-family&quot;,      &quot;font-weight&quot;,      &quot;text-align&quot;,      &quot;text-justify&quot;,      &quot;text-indent&quot;,      &quot;text-overflow&quot;,      &quot;text-decoration&quot;,      &quot;white-space&quot;,      &quot;color&quot;,      &quot;background&quot;,      &quot;background-position&quot;,      &quot;background-repeat&quot;,      &quot;background-size&quot;,      &quot;background-color&quot;,      &quot;background-clip&quot;,      &quot;opacity&quot;,      &quot;filter&quot;,      &quot;list-style&quot;,      &quot;outline&quot;,      &quot;visibility&quot;,      &quot;box-shadow&quot;,      &quot;text-shadow&quot;,      &quot;resize&quot;,      &quot;transition&quot;    ]  &#125;&#125;\n\n忽略配置\n忽略整个文件，在首行加入 /* stylelint-disable */\n\n/* stylelint-disable */html &#123;&#125;\n\n\n忽略多行\n\n/* stylelint-disable */html &#123;&#125;.div &#123;    color: red;&#125;/* stylelint-enable */\n\n\n忽略一行， 在样式前加入 /* stylelint-disable-next-line */ 以忽略该行\n\n#id &#123;  /* stylelint-disable-next-line */  color: pink !important;&#125;\n\n\n.stylelintrc.json 配置文件\n\n自动格式化\n安裝 StyleLint\n\n在 settings.json 文件设置\n\n\n&#123;  &quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.stylelint&quot;: true  &#125;&#125;\n\n与 Prettier 结合stylelint-prettier 让 Prettier 作为 StyleLint 的规则，并让 StyleLint 统一报错\nstylelint-config-prettier 关闭所有可能冲突的配置\n配置文件\n&#123;  &quot;extends&quot;: [    &quot;stylelint-config-sass-guidelines&quot;,    &quot;stylelint-prettier/recommended&quot;  ],  &quot;plugins&quot;: [    &quot;stylelint-scss&quot;  ]&#125;","categories":["DevOps"],"tags":["DevOps"]},{"title":"Git 命令/配置","url":"/posts/38d05d58ca17/","content":"查看 git 详细命令描述# 会在浏览器打开本地离线文档git help [option]\n\n查看仓库配置文件查看本地仓库配置\ncd [项目路径]cat ./git/config\n\n查看全局仓库配置\ngit config --global -l\n\n设置用户名&#x2F;邮箱用户信息会体现在 commit 提交信息中\n设置本地用户\ngit config user.name &quot;xxx&quot;git config user.email &quot;xxx@.com&quot;\n\n设置全局用户\ngit config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@.com&quot;\n\n如果本地用户没有设置会优先使用全局的用户设置, 如果存在多个用户可以设置本地用户信息\ngit add 做了什么执行 git add . 会将工作区的文件加入到暂存区，体现在 git objects 中会增加一个 .git/objects/[文件sh1前2位]/[文件sh1第3位到40位]] 的文件。[sha1] 的计算逻辑是：\nh = sha1()h.update(&quot;blob [文件长度]\\0&quot;)h.update(&#x27;[文件内容]&#x27;)\n\n可以使用 cat-file 命令查看文件的 类型和内容，可以看见用户文件的类型的 blob,这是第一种 object 类型\ngit cat-file -t [sha1]  #查看类型git cat-file -p [sha1]  #查看内容git cat-file -s [sha1]  #查看文件长度#查看当前目录有所文件的信息git ls-files -s# 100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       a/aa.js# 文件权限         对象名称                                文件名称\n\n解析 objects 文件的原始内容\nconst fs = require(&quot;fs&quot;);const zlib = require(&quot;zlib&quot;);// 创建解压流const inflate = zlib.createInflate();const readStream = fs.createReadStream(  &quot;./c6dd0164fe0eb4fde767f9e731a6c8ade0b69f&quot;);const writeStream = fs.createWriteStream(&quot;bbb.txt&quot;);// 处理数据流readStream.pipe(inflate).pipe(writeStream);\n\ngit commit 做了什么查看执行 commit 之后新增文件的类型为 commit，commit 信息通过 object 文件保存，这是第二种 object 类型\ngit cat-file -t [sha1] #commit\n\n查看 commit 后生成文件的内容\ngit cat-file -p [sha1]#tree de9ca8d60d61e2dbff58571e243256f0d084e030            tree对象文件名字（sha1）#parent ef911d46ddddb69cfb0149bbc7217f582c668f21          上一次提交的文件名字(sha1)#author sunzhiqi &lt;sunzhiqi@live.com&gt; 1724649175 +0800     作者 邮箱  时间戳 时区#committer sunzhiqi &lt;sunzhiqi@live.com&gt; 1724649175 +0800#2                                                        提交的文件内容\n\n继续查看 tree 文件的内容, tree 类型描述提交的文件结构，这是第三个 object 类型\ngit cat-file -p [sha1]#100644 blob b44836b41abbfc0640d4dd88fe587a9a145e5203    LICENSE#100644 blob b9c2b056b82135218b26420e8479c56554b54afb    README.md#100644 blob 4b9a8a29f6956ea1742e42354c5ba36fe717a2ed    a.txt#100644 blob 9f478040b9109d4b1d25ad7f11528ed9a682f063    b.txt# 如果提交内容中有文件夹，那么会有一个单独的 tree 描述文件夹的信息#100644 tree xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx   folder\n\n另外 commit 操作会影响 HEAD 指针的指向\n# 查看HEAD指向的分支cat .git/HEAD         #ref: refs/heads/master# 查看分支对应的文件cat .git/refs/heads/master         #ref: f45e2d0b45ca63806d263ae31276a3fbe4a7229d\n\nGit 通过 3 种类型的 object files 组织文件\n\ncommit 类型，记录了提交的快照信息提供 parent 指向了上一个提交 hash提供 tree 指向了本次提交的快照\n\ntree 类型，记录了目录结构每次提交都会生成一个新的 tree 文件tree 文件记录了目录下的文件信息，可能是 blob 文件，也可能是另一个 tree\n\nblob 类型，记录了文件内容blob 文件可以在不同的 tree 之间被复用\n\n\n文件状态流转\nUntracked 未跟踪, 未被提交到暂存区使用 git add . 将文件加入到暂存区\n\nModified 已修改，提交暂存区的文件在工作区被修改了用 git add . 将文件提交修改到暂存区\n\nStaged 已暂存，提交到暂存区的文件git commit 将暂存区的文件提交到仓库区\n\nUnmodified 代码仓库中的状态\n\n\ndiff 查看文件差异# 对比工作区和暂存区git diff# 对比暂存区和仓库区git diff --cached\n\nbranch operations分支的本质是指向 commit 的指针, 使用自定义名称代指 commit hash\ngit checkout 可以用于切换分支，也可以用于切换到某个 commit， 当使用这个命令后会提示正在处于一个分离头指针的状态。\ngit checkout [hash]\n\n如果相对当前 commit 修改需要依附于一个分支,可以使用 git switch -c [branchName], 在旧的版本中可以使用 git checkout -b [branchName]\nfast-forward从 master 切换到 feature 分支，如果 master commit 没有变化, 那么可以直接将 master 的指针指向 feature\n如果分支已经合并，可以使用 git reset ORIG_HEAD 回到 merge 之前的 commit\ncommit 回滚后修改的文件会在本地显示为 untracked 或 modified 也就是在 feature 分支中修改或新增的文件。\n如果需要丢弃这些修改可是使用 git restore [filename] 或 git restore . 丢弃所有修改。\n如果有添加在暂存区的文件，可以使用 git restore --staged . 丢弃暂存区的修改\n3 way merge如果 feature 分支落后于 master 分支，也就是在 feature 分支上提交了 commit 的同时， master 分支也提交了 commit， 那么在合并的时候会产生一个新的 commit 记录这两个分支的合并。查看这次新分支的提交内容\ngit cat-file -p 4ba28b350b0a8f0btree 444ca23d83cc70878ddb01e5288a4322ded5ac0cparent 57086086b9bd92402227d58e7c6b87e285376910parent 720f3a44023361a4bad5586fe769ccc50f1bc1abauthor sunzhiqi &lt;sunzhiqi@live.com&gt; 1744018132 +0800committer sunzhiqi &lt;sunzhiqi@live.com&gt; 1744018132 +0800\n\n可以看到有两个 parent 指向，分别是 feature 最新的 commit hash 和 master 分支的合并之前的 commit hash。\nconflict 3 way merge如果两个分支都修改了同一个文件，那么在合并的时候会产生冲突。\n&lt;&lt;&lt;&lt;&lt;&lt; HEADmaster 的内容=======feature 的内容&gt;&gt;&gt;&gt;&gt;&gt; feature\n\n手动解决冲突后使用 git add . 提交暂存区, 然后执行 git commit 完成合并操作\nrebaserebase 会将当前分支落后的于 master 分支的 commit 整合到当前分支，这样当前分支包含了 master 分支的最新 commit， 所以再次在 master 分支上执行 merge 操作就可以实现 fast-forward 合并。\nrebase 操作通常避免在 master 分支上执行，并且会修改已经提交的 commit hash,这可能会导致于已经提交到远程的 commit 冲突，多人协作中应该禁止。\ngit checkout featuregit rebase mastergit checkout mastergit merge feature\n\nremote branchgit branch -r  # 查看远程分支git branch -a  # 查看本地和远程分支git remote add origin [url] # 关联远程仓库git remote -vv  # 查看远程仓库git remote show origin # 查看远程仓库详情\n\nfetchfetch 操作会将远程分支的最新 commit 信息下载到本地，但是不会自动合并到当前分支，也就是不会移动 HEAD 指针。\n如果远程分支删除，需要本地同步可以使用以下命令：\ngit fetch --prune# 或者git remote prune\n\nfetch 操作会使用一个非常重要的文件，**.git&#x2F;FETCH_HEAD**, 它记录所有远程分支的最新 commit 信息。并且当 git fetch 执行的时候会将当前分支信息置于文件顶部，其余的分支信息排在后面，这样 git pull 命令会利用最前面的分支信息合并分支\npullgit pull 操作会修改&#x2F;创建 ORIG_HEAD 指针，并且移动 HEAD 指向 merge 之前的 commit 可以用于回滚操作。\npushgit push origin master# 删除远程分支git push origin --delete featuregit push origin -d feature# 推送本地标签到远程git push origin --tags# 关联远程分支git branch --set-upstream-to=origin/feature featuregit branch --set-upstream origin featuregit branch -u origin feature\n\ncherry-pick当分支无法合并,需要把某个分支的 commit 合并到另一个分支，可以使用 cherry-pick。\n# 切换到目标分支git cherry-pick [commitID]# 合并多个 commitgit cherry-pick [commitID1] [commitID2]\n\ntaggit tag v1.0# 创建带注释的标签 -a 表示创建带注释的标签git tag -a v1.0 -m &#x27;tag message&#x27;# 指定任意commit打标签git tag -a v1.0 [commitID]# 查看标签git tag# 查看标签详情git show v1.0# 删除标签git tag -d v1.0\n\ngit tag v1.0 创建轻量标签存放在 .git/refs/tags 目录下\ngit tag -a v1.0 -m &#39;tag message 除了保存在 .git/refs/tags 目录下，还会创建一个对象文件保存在 .git/objects 下，类型是 tag, 这是第四种类型的 object，同时保存信息还包括注释，时间，作者\nsubmodule# 添加子模块git submodule add [url]git submodule add ./path/to/submodule# 首次 clone 项目不会包含子模块的内容# 进入到子模块目录 执行git submodule update --init --recursive# 再次更新子模块git submodule update --remote# 删除子模块git rm submodulerm -rf .git/modules/submodule# 从 .gitmodules 中移除该 submodulevim .gitmodules# 从 .git/config 中移除该 submodulevim .git/config\n\n我提交了什么git showgit log -n1 -p\n\n想修改最近的提交信息提交信息后(commit),发现信息写错了，想修改最近一条提交信息(如果想修改当前提交以前的信息)。\ngit commit --amend --only [filename] -m &#x27;update&#x27;# 会弹出交互式命令行手动提交git commit --amend --only [filename]\n\n--only 参数非常重要,只对当前正在修改的文件进行提交，而不包括暂存区中的其他文件。\n怎么看是否落后与主分支git fetch origingit status\n\n# oneline  提交显示为一行# graph    左侧显示一个 ASCII 图形，用于展示分支和合并的关系# decorate 提交信息中附加上相关的分支、标签等引用名称# 查看远程分支所有提交历史git log --oneline --graph --decorate origin/master# 查看所有分支的提价历史git log --graph --all# 指定分支git log --graph origin/master master\n\n从分支上可以看出，主分支并没有 fff 的提交，最终合并在本地的 master 分支\n\n取消上次提交中的某个文件一次提交中包括， a.txt, b.txt 现在想取消 a.txt 的提交，也就是恢复为上一次的状态\n# 查看上一次提交文件的内容git show [commitID]:a.txt# 将工作区中的文件恢复为上一次提交的内容git checkout HEAD^ a.txt# 也可以使用 commitIdgit checkout [commitId] a.txt# 将恢复的文件加入暂存区   -A 参数可以将删除文件也从暂存区删除git add .# 提交修改到暂存区，沿用上一次的ID，并且不修改提交描述git commit --amend --no-edit\n\n如果当前的的历史已经提交到远程，由于并没有改变提交历史，所以可以安全的 git push -f\n删除 上一次&#x2F;多个 Commit极不建议使用，虽然可以用 reset 重置为上一级的状态，但是会丢失当前的修改，而且会破坏提交历史。\n# HEAD^ 上一个提交状态# hard 改变暂存区和工作目录到指定的提交git reset HEAD^ --hard\n\n使用 soft 参数可以避免工作区被回滚，但提交历史已经被改变，如果你的分支还会被其他人使用，多人写作中会有安全问题。避免在公共分支中使用 git reset,\ngit reset HEAD^ --soft\n\n对于公共分支唯一安全的做法是使用 revert\ngit revert [commitId]# 如果有冲突，解决冲突后执行git add .git revert --continue\n\n修改 commit 之后不能 push\n可能你已经将历史 push 到远程，但是又修改了本地的最近的 commit, 导致 git 理解为你的 commit 和 远程的不同需要先合并分支。尽可能避免修改一个已经推送到远程的历史，如果必须要这样做，只能使用 git push -f\n\nreset 之后想找回# 使用reflog查看头指针的移动历史git refloggit reset --hard [commitId]\n\n提交文件的一部分&#x2F;分别提交到两个 commit# 使用交互式命令行操作git add -p [filename]#y - 将该 hunk 添加到暂存区#n - 不将该 hunk 添加到暂存区#s - 拆分当前 hunk 成更小的块#e - 手动编辑当前 hunk#q - 退出暂存模式#a - 将当前文件的所有剩余 hunk 添加到暂存区#d - 不将当前文件的任何剩余 hunk 添加到暂存区\n\n使用 e 手动编辑的模式时：\n\n如果想要取消删除行的修改，需要将行前的 - 替换为   空字符\n如果想要取消新增行的修改， 需要将 + 行整体删除\n\n添加到暂存区中后执行 commit 操作，接着再次执行一次 git add . 提交剩余的修改。\n有临时工作又不想提交当前的修改# 使用 stash 命令暂存当前修改git stashgit stash push -m &quot;描述&quot; #为stash添加描述# 切换到需要工作的分支进行开发git checkout [branch]# 在当前分支中想要合并最新的主分支，也可以使用暂存功能git pull# 工作结束后切换回原来的分支，并从暂存中取出内容git checkout [main branch]git stash pop\n\n仅 stash 未暂存的更改，而保留暂存区的内容# 已经git add 的内容不想放到stash中# 只把刚在工作区修改的内容放到stash中git stash --keep-index# 如果有文件还没有git add添加过，想要stash这些文件git stash -u\n","categories":["DevOps"],"tags":["DevOps"]},{"title":"npm-lock的作用","url":"/posts/02cd2292635b/","content":"版本被修改了？很久很久以前，你创建了一个项目叫做 ProjectA, 并且引入了 jquery\n用 npm view jquery versions 查看了jquery版本 ,考虑许久之后，决定安装最新版，当时的最新版本是 2.1.0,执行了 npm install -S jquery 之后，在两个文件中生成了版本信息 \npackage.json\n&#123;  &quot;dependencies&quot;: &#123;    &quot;jquery&quot;: &quot;^2.1.0&quot;  &#125;&#125;\n\npackage-lock.json\n&#123;  &quot;dependencies&quot;: &#123;    &quot;jquery&quot;: &#123;      &quot;version&quot;: &quot;2.1.0&quot;,      &quot;resolved&quot;: &quot;https://registry.npmjs.org/jquery/-/jquery-2.1.0.tgz&quot;,      &quot;integrity&quot;: &quot;sha1-HJqMlx0rU9rhDXLhbLtaHfFqSs4=&quot;    &#125;  &#125;&#125;\n\n时光飞逝，虽然看不懂这两个文件的意思，项目圆满的结束了。\n多年以后，一个新项目的经理想到了你曾经做过的项目，让你把项目拿过来参考一下。\n于是你拉取了项目，发现项目里只用到了一个依赖就是 jquery, 于是你在命令行输入了 npm install jquery\n安装成功之后，你惊讶的发现安装的版本为什么和拉取代码的版本不是同一个，而是拉取的代码版本号中，大版本中的最后一个版本呢\n\n~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0* 这意味着安装最新版本的依赖包\n\n这时的 package.json 文件变成：\n&#123;  &quot;dependencies&quot;: &#123;    &quot;jquery&quot;: &quot;^2.2.4&quot;  &#125;&#125;\n\npackage-lock.json\n&#123;  &quot;dependencies&quot;: &#123;    &quot;jquery&quot;: &#123;      &quot;version&quot;: &quot;2.2.4&quot;,      &quot;resolved&quot;: &quot;https://registry.npmjs.org/jquery/-/jquery-2.2.4.tgz&quot;,      &quot;integrity&quot;: &quot;sha1-HJqMlx0rU9rhDXLhbLtaHfFqSs4=&quot;    &#125;  &#125;&#125;\n\n你查阅了资料之后发现这是 npm 有意为之，因为 package.json 中 jquery 的版本是 ^2.1.0, 当使用 npm install 安装时会安装大版本相同的最新版本， 也就解释了为什么版本号会变成 2.2.4\nlock文件解决的问题那这个lock文件的版本又表示什么呢？简单说就是锁住你曾经安装过的包的版本\n当通过 npm install xxx@xx.xx.xx 安装某个包时(如果没有指定版本则安装最新版本呢)， 会在 package.json 中生成安装的包的版本信息，也会在 package-lock.json 中生成相同的版本信息\n但是 package.json 中的版本前面会带着一个符号，它表示的是一个版本范围，以上面的^2.1.0 为例，表示的大版本为2的,高于或等于2.1.0的其他版本\n当你想通过 npm install 初始化项目依赖的时候，他会去找 package-lock.json中锁住的版本，如果锁住的版本恰好在 package.json 指定的范围内，就会安装锁住的版本，否则安装版本范围内的最新版本，并且覆盖原有的版本信息\npackage.json\n&#123;  &quot;dependencies&quot;: &#123;    &quot;jquery&quot;: &quot;^2.1.0&quot;  &#125;&#125;\n\npackage-lock.json\n&#123;  &quot;dependencies&quot;: &#123;    &quot;jquery&quot;: &#123;      &quot;version&quot;: &quot;2.2.1&quot;,      &quot;resolved&quot;: &quot;https://registry.npmjs.org/jquery/-/jquery-3.6.0.tgz&quot;,      &quot;integrity&quot;: &quot;sha512-JVzAR/AjBvVt2BmYhxRCSYysDsPcssdmTFnzyLEts9qNwmjmu4JTAMYubEfwVOSwpQ1I1sKKFcxhZCI2buerfw==&quot;    &#125;  &#125;&#125;\n\n因为 package-lock.json 的版本在 package.json 指定范围内，所以会安装 2.2.1 版本\npackage.json\n&#123;  &quot;dependencies&quot;: &#123;    &quot;jquery&quot;: &quot;^3.0.0&quot;  &#125;&#125;\n\npackage-lock.json\n&#123;  &quot;dependencies&quot;: &#123;    &quot;jquery&quot;: &#123;      &quot;version&quot;: &quot;2.2.1&quot;,      // 被重写为      &quot;version&quot;: &quot;3.6.0&quot;,      &quot;resolved&quot;: &quot;https://registry.npmjs.org/jquery/-/jquery-3.6.0.tgz&quot;,      &quot;integrity&quot;: &quot;sha512-JVzAR/AjBvVt2BmYhxRCSYysDsPcssdmTFnzyLEts9qNwmjmu4JTAMYubEfwVOSwpQ1I1sKKFcxhZCI2buerfw==&quot;    &#125;  &#125;&#125;\n\n因为不在版本范围内，所以安装了版本范围中的最新版本 3.6.0\n不想改变版本那有没有一种办法可以只安装当时的版本呢？ 让我们更好的固定版本\nnpm 提供了 npm ci 的命令， 当通过npm ci xxx 安装包时，如果锁住的版本在版本范围内，就会安装锁住的版本，否则就会抛出错误停止安装\nnpm ci 命令必须依赖于 package-lock.json 如果没有这个文件就会报错，可以使用 npm install 代替\n注意在没有  package-lock.json 文件的时候，通过npm install 初始化项目依赖，会安装版本范围内的最新版本， 在生成的 package-lock.json 会记录版本信息，而且会覆盖package.json 中的版本\n","categories":["DevOps"],"tags":["DevOps"]},{"title":"单元测试理论","url":"/posts/cd5de5e2a6a2/","content":"TDD 测试驱动开发\n首先，开发者在码业务前写一些测试用例\n运行这些测试用例。结果肯定是运行失败，因为测试用例中的业务逻辑还没实现嘛\n开发者实现测试用例中的业务逻辑\n再运行测试用例， 如果开发者代码能力不错，这些测试用例应该可以跑通了(pass)\n对业务代码及时重构，包括增加注释，清理重复等。因为没人比开发者自己更了解哪些代码会对哪些部分造成影响从而导致测试失败(fail)\n\n\n我们通过举例来了解一下如何实践TDD。例子中的代码可以从github上获取tdd-vs-bdd。将代码clone下来，执行命令npm install &amp;&amp; grunt\n假设我们想写一个计算阶乘的函数(这是一个很刻意的例子，但是这个例子对我们指出TDD和BDD的区别很有帮助)。TDD的常用方式是运行某函数，然后断言结果满足某个值。\n在阶乘的例子中，我们使用的javascript测试框架是Mocha。废话不说，上代码：\nvar assert = require(&#x27;assert&#x27;),    factorial = require(&#x27;../index&#x27;); suite(&#x27;Test&#x27;, function ()&#123;    setup(function ()&#123;        // Create any objects that we might need    &#125;);     suite(&#x27;#factorial()&#x27;, function ()&#123;        test(&#x27;equals 1 for sets of zero length&#x27;, function ()&#123;            assert.equal(1, factorial(0));        &#125;);         test(&#x27;equals 1 for sets of length one&#x27;, function ()&#123;            assert.equal(1, factorial(1));        &#125;);         test(&#x27;equals 2 for sets of length two&#x27;, function ()&#123;            assert.equal(2, factorial(2));        &#125;);         test(&#x27;equals 6 for sets of length three&#x27;, function ()&#123;            assert.equal(6, factorial(3));        &#125;);    &#125;);&#125;);\n\n显然上述测试会失败，因为我们尚未实现函数功能。所以接下来我们需要实现满足上述测试用例的阶乘函数。代码如下\nmodule.exports = function (n) &#123;    if (n &lt; 0) return NaN;    if (n === 0) return 1;     return n * factorial(n - 1);\n\n现在我们再次运行测试用例，所有的case都跑通了! 这就是TDD的使用方式。\nBDD 行为驱动开发BDD旨在消除TDD过程中可能造成的问题。\n与TDD相比，BDD是通过编写行为和规范来驱动软件开发。 行为和规范可能看起来与测试非常相似，但是它们之间却有着微妙但重要的区别。\nvar assert = require(&#x27;assert&#x27;),    factorial = require(&#x27;../index&#x27;); describe(&#x27;Test&#x27;, function ()&#123;    before(function()&#123;        // Stuff to do before the tests, like imports, what not    &#125;);     describe(&#x27;#factorial()&#x27;, function ()&#123;        it(&#x27;should return 1 when given 0&#x27;, function ()&#123;            factorial(0).should.equal(1);        &#125;);         it(&#x27;should return 1 when given 1&#x27;, function ()&#123;            factorial(1).should.equal(1);        &#125;);         it(&#x27;should return 2 when given 2&#x27;, function ()&#123;            factorial(2).should.equal(2);        &#125;);         it(&#x27;should return 6 when given 3&#x27;, function ()&#123;            factorial(3).should.equal(6);        &#125;);    &#125;);     after(function () &#123;        // Anything after the tests have finished    &#125;);&#125;);\n\n敏捷开发敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。\n","categories":["DevOps"],"tags":["工程化","DevOps","单元测试"]},{"title":"实现一个CLI工具","url":"/posts/a73e3518930a/","content":"CLI与GUICLI（Command Line Interface） 命令行接口, 在服务器端通常是没有可视化界面的，所有的操作都是在黑窗口的命令行中操作。\nGUI（Graphical User Interface）图形用户界面接口， 通过可视化的界面， 可以避免CLI中的命令操作， 某些场景可以增加效率，减少学习成本， 例如 mysql-workbanch 提供的可视化数据库管理工具，或者是 GitHub for Desktop 一个基于 git 命令的 GUI 工具。\n而 node 中的 CLI 工具就是通过命令行的方式，可以让我们快速根据交互中输入的配置初始化项目。或实现其他工具。\n必备npm包\ncommander 完整的 node.js 命令行解决方案。\n\noption 用于定义选项， 默认提供-h选项，可以查看命令行当前的命令提示\nprogram    // 通过 node xxx-cli.js -v 可以查看指定版本\t.version(require(&#x27;../package&#x27;).version, &quot;-v, --version&quot;)    // 可以修改首行的信息    // 默认 Usage: sun-cra-cli [options] [command]    // 修改为： sun-cra-cli [options-my] [command-my]    .usage(&#x27;&lt;options-my&gt; [command-my]&#x27;)    // 如果指定了-h 选项，默认-h 选项会被覆盖    // .option(&#x27;-h, --help&#x27;, &#x27;help information&#x27;)    .option(&#x27;-s, --small&#x27;, &#x27;small pizza size&#x27;)    .option(&#x27;-p, --pizza-type &lt;type&gt;&#x27;, &#x27;flavour of pizza&#x27;)    // 一定要放在参数处理的逻辑之前,否则不能执行    program.parse(process.argv);    // 获取选项执行其他的逻辑    const options = program.opts();    if (options.small) console.log(&#x27;- small pizza size&#x27;);    if (options.pizzaType) console.log(`- $&#123;options.pizzaType&#125;`);\n\n如果参数不全可以手动打印提示信息\nfunction help () &#123;  program.parse(process.argv)  if (program.args.length &lt; 1) return program.help()&#125;help()\n\ncommand 定义命令\n当执行 node xxx-cli.js 会打印所有的提示信息\n当执行 node xxx-cli.js init 会自动执行全局注册的 xxx-cli-init.js\nprogram    .command(&#x27;init&#x27;, &#x27;generate a new project from a template&#x27;)\n\n打印：\nUsage: sun-cra-cli [options] [command]Options:  -h, --help      display help for commandCommands:  init            generate a new project from a template  help [command]  display help for command\n\n也可以让命令有可选参数\nprogram  // 如果想让命令带上参数，就不能把命令描述写在第二个参数上，要用description方法  .command(&#x27;init&#x27;)  .description(&#x27;clone a repository into a newly created directory&#x27;)  // 两个都是必选参数  .argument(&#x27;&lt;username&gt;&#x27;, &#x27;user to login&#x27;)  .argument(&#x27;&lt;password&gt;&#x27;, &#x27;password for user, if required&#x27;)  // 这时执行 `node xxx-cli.js init` 并不会自动执行init命令所对应的文件  // 需要在action中处理执行逻辑  .action((username, password) =&gt; &#123;    console.log(&#x27;username:&#x27;, username);    console.log(&#x27;password:&#x27;, password);  &#125;);program.parse(process.argv);\n\n\nchalk 一个可以让命令行带上颜色工具\n\nInquirer 交互式命令行用户界面。可以收集用户的输入\n\nora 一个终端加载过度效果\n\n\n连续调用可以输出多行信息\nspinner.start(&#x27;waiting&#x27;)spinner.succeed(&#x27;successfully&#x27;)spinner.start(&#x27;waiting&#x27;)spinner.succeed(&#x27;successfully&#x27;)/**✔ Initialization successful.✔ Initialization successful.*/\n\n\nboxen 可以在终端展示矩形框\n\n收集信息#!/usr/bin/env nodeconst &#123; program &#125; = require(&quot;commander&quot;);/** * Usage: create-bigdata-frontend [options] &lt;name&gt; * name 项目名称 --ts 是否使用ts模板 */program\t.version(require(&#x27;../package&#x27;).version, &quot;-v, --version&quot;) // 定义版本选项\t// .command(&#x27;create [name]&#x27;, &#x27;create a project&#x27;) // 定义命令+描述\t.arguments(&quot;&lt;name&gt;&quot;) // 定义命令参数\t.option(&quot;--ts&quot;, &quot;using the typescript template&quot;) // 定义可提供的选项+描述: 是否使用ts\t.description(&quot;Create a project&quot;, &#123; name: &quot;Project name&quot; &#125;) // 描述+参数，描述\t.action((name, options, command) =&gt; &#123; // 处理函数：(命令声明的所有参数, 选项, 命令对象自身)\t\trequire(&quot;../lib/create.js&quot;)(name, options &amp;&amp; options.ts);\t&#125;)\t.program.parse();\n\n\n初始化逻辑const CLIManager = require(&quot;./CLIManager&quot;);module.exports = async (appName, ts) =&gt; &#123;  const cliM = new CLIManager(&#123; appName &#125;);  await cliM.downloadTemplate(&#x27;https//:xxx.xxx.xxx/xx.git&#x27;); // 获取远程模板  await cliM.writePackageJson(); // 修改package.json  await cliM.rmGit(); // 移除原有.git信息  await cliM.install(); // 安装依赖&#125;;\n\nCLIManager类const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const &#123; exec &#125; = require(&quot;child_process&quot;);module.exports = class CLIManager &#123;  constructor(&#123; appName &#125;) &#123;    this.appName = appName;    // 获取当前命令执行是的目录    this.cwd = process.cwd();    this.targetDir = path.join(process.cwd(), appName);  &#125;  // 执行命令  run(command, options, cb) &#123;    exec(command, options, (error, stdout, stderr) =&gt; &#123;      if (error !== null) &#123;        console.log(chalk.red(&quot;X&quot;), &quot;exec error: &quot; + error);        return;      &#125;      cb(stdout);    &#125;);  &#125;  // 拉取远程模板  downloadTemplate(repositiry) &#123;    return new Promise((resolve, reject) =&gt; &#123;      exec(        `git clone https://github.com/jquery/jquery.git $&#123;this.appName&#125;`,        (error, stdout, stderr) =&gt; &#123;          if (error !== null) &#123;            spinner.fail(`Failed fetching remote git repo`);            reject(error);            return;          &#125;          resolve(stdout);        &#125;      );    &#125;);  &#125;  // 删除.git  rmGit() &#123;    return new Promise((resolve) =&gt; &#123;      this.run(&quot;rm -rf .git&quot;, &#123; cwd: this.targetDir &#125;, (stdout) =&gt; &#123;        resolve(stdout);      &#125;);    &#125;);  &#125;  // 安装依赖  install() &#123;    return new Promise((resolve) =&gt; &#123;      this.run(&quot;npm ci&quot;, &#123; cwd: this.targetDir &#125;, (stdout) =&gt; &#123;        resolve(stdout);      &#125;);    &#125;);  &#125;&#125;;","categories":["DevOps"],"tags":["DevOps"]},{"title":"工程化常用命令","url":"/posts/de11f04658e7/","content":"ps查看进程\nps aux\n\nkill pkillkill -9 pid\n\npkill 后面可以直接写进程的名字\n如果是一个服务使用 systemctl stop\nw who看谁正在连接系统\nlsof 查看端口占用#列出所有打开的文件:lsof备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位# 查看谁正在使用某个文件lsof   /filepath/file#递归查看某个目录的文件信息lsof +D /filepath/filepath2/备注: 使用了+D，对应目录下的所有子目录和文件都会被列出# 比使用+D选项，遍历查看某个目录的所有文件信息 的方法lsof | grep ‘/filepath/filepath2/’# 列出某个用户打开的文件信息lsof  -u username备注: -u 选项，u其实是user的缩写# 列出某个程序所打开的文件信息lsof -c mysql备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成lsof | grep mysql,但是第一种方法明显比第二种方法要少打几个字符了# 列出多个程序多打开的文件信息lsof -c mysql -c apache# 列出某个用户以及某个程序所打开的文件信息lsof -u test -c mysql# 列出除了某个用户外的被打开的文件信息lsof   -u ^root备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示# 通过某个进程号显示该进行打开的文件lsof -p 1# 列出多个进程号对应的文件信息lsof -p 123,456,789# 列出除了某个进程号，其他进程号所打开的文件信息lsof -p ^1# 列出所有的网络连接lsof -i# 列出所有tcp 网络连接信息lsof  -i tcp# 列出所有udp网络连接信息lsof  -i udp# 列出谁在使用某个端口lsof -i :3306# 列出谁在使用某个特定的udp端口lsof -i udp:55# 特定的tcp端口lsof -i tcp:80# 列出某个用户的所有活跃的网络端口lsof  -a -u test -i# 列出所有网络文件系统lsof -N#域名socket文件lsof -u#某个用户组所打开的文件信息lsof -g 5555# 根据文件描述列出对应的文件信息lsof -d description(like 2)# 根据文件描述范围列出文件信息lsof -d 2-3\n\n免密登陆\n生成密钥对\n-t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。\n如果想免密登录，密钥不要填写密码，否则必须验证密钥密码才能登录\nssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;# 或者创建使用 ed25519 加密算法的密钥ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;\n\n上传共钥到服务器对应账号的 home 目录下.ssh 文件夹下面，公钥的权限为 600\nlinux 执行以下命令\nssh-copy-id -i mykey_rsa.pub you_user_name@xxx.xxx.xxx.xxx\n\nwindow 需要手动在服务器上创建文件,\ntouch  ~/.ssh/authorized_keys# 或直接写入文件echo &quot;your_public_key_here&quot; &gt;&gt; ~/.ssh/authorized_keys# 修改权限chmod 600 authorized_keys\n\n指定私钥登陆，私钥的权限为 600\nssh -i 私钥 user@xxx.xxx.xxx.xxx\n\n通过配置文件免密登陆，在本地服务器把私钥复制到 home 下的.ssh 文件夹下面\n创建名称为 config 的文件，配置单一服务器免密登陆\nHost tencent  HostName 124.222.139.87  User ubuntu  IdentityFile ./.ssh/id_ed25519  IdentitiesOnly yes# Host 别名# 　HostName IP# 　Port 端口# 　User 用户名# 　IdentitiesOnly yes#   IdentityFile ~/.ssh/user_rsa  (私钥路径)#   Protocal 2 (协议版本号)#   Compression yes#   ServerAliveInterval 60 （防止被踢配置，长时间没有操作会被踢掉，每隔60秒发一个信号）#   ServerAliveCountMax 20 (最大连接数)#   LogLevel INFO\n\n通配符配置\nHost app-produce  HostName 192.168.1.10  Port 22  User appuser  IdentityFile ~/.ssh/id_ed25519Host \\*\\_produce  User commonuser  IdentityFile ~/.ssh/id_ed25519  Port 22\n\nwgetwget 是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP&#x2F;IP 协议 下载，并可以使用 HTTP 代理。”wget” 这个名称来源于 “World Wide Web” 与 “get” 的结合。\nwget 可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个 wget 下载任务，然后退出系统，wget 将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与.\nwget (选项) (参数)\n\n其中选项如下：\n-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；\n-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；\n-b：进行后台的方式运行 wget；\n-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；\n-c：继续执行上次终端的任务；\n-C&lt;标志&gt;：设置服务器数据块功能标志 on 为激活，off 为关闭，默认值为 on；\n-d：调试模式运行指令；\n-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；\n-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；\n-h：显示指令帮助信息；\n-i&lt;文件&gt;：从指定文件获取要下载的 URL 地址；\n-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；\n-L：仅顺着关联的连接；\n-r：递归下载方式；\n-nc：文件存在时，下载文件不覆盖原有文件；\n-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；\n-q：不显示指令执行过程；\n-nh：不查询主机名称；\n-v：显示详细执行过程；\n-V：显示版本信息；\n–passive-ftp：使用被动模式 PASV 连接 FTP 服务器；\n–follow-ftp：从 HTML 文件中下载 FTP 连接文件。\nwget http://test.com/testfile.zip -&gt;下载指定文件到当前文件夹wget -O wordpress.zip http://test.com/download -&gt;指定保存名字wget --limit-rate=300k http://www.linuxde.net/testfile.zip -&gt;限制下载速度wget -c http://www.linuxde.net/testfile.zip -&gt;断点续传wget -b http://www.linuxde.net/testfile.zip -&gt;后台下载# 设置使用指定浏览器下载（伪装下载）wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.linuxde.net/testfile.zipwget --spider url -&gt;测试下载wget --tries=40 URL -&gt;设置重试次数为40wget -i filelist.txt -&gt;从filelist.txt获取下载地址# 镜像网站# --miror开户镜像下载。# -p下载所有为了html页面显示正常的文件。# --convert-links下载后，转换成本地的链接。# -P ./LOCAL保存所有文件和目录到本地指定目录wget --mirror -p --convert-links -P ./LOCAL URLwget --reject=gif ur -&gt;下载一个网站，但你不希望下载图片，可以使用这条命令wget -o download.log URL -&gt;把下载信息存入日志文件wget -Q5m -i filelist.txt -&gt;限制总下载文件大小wget -r -A.pdf url -&gt;下载指定格式文件# FTP下载wget ftp-urlwget --ftp-user=USERNAME --ftp-password=PASSWORD url\n","categories":["DevOps"],"tags":["工程化","DevOps"]},{"title":"文件自动同步服务器","url":"/posts/db8fc5f7ed73/","content":"index.js#!/usr/bin/env nodeconst shell = require(&#x27;shelljs&#x27;)const chokidar = require(&#x27;chokidar&#x27;)const home = require(&#x27;user-home&#x27;)const path = require(&#x27;path&#x27;)const WORKSPACE_PATH = path.resolve(home, &#x27;Workspace&#x27;);const expectPath = path.join(__dirname, &#x27;./expect.exp&#x27;)const to = &#x27;root@144.xxx.xxx.92:/home/backup&#x27;chokidar  .watch(&#x27;./index.js&#x27;, &#123;    ignored: (path) =&gt; path.includes(&#x27;node_modules&#x27;) || path.includes(&#x27;.git&#x27;)  &#125;)  .on(&#x27;all&#x27;, (event, path) =&gt; &#123;    console.log(event, path);    shell.exec(`expect $&#123;expectPath&#125; $&#123;path&#125; $&#123;to&#125;`)  &#125;); \n\nexpect.exp#expect 不能写错#!/usr/bin/expectset from [lindex $argv 0]set to [lindex $argv 1]set timeout 30spawn bash -c &quot;scp $from $to&quot;# 特殊符号需要转移 回车符号不需要# \\ 需转义为 \\\\\\# &#125; 需转义为 \\&#125;# [ 需转义为 \\[# $ 需转义为 \\\\\\$# ` 需转义为 \\`# &quot; 需转义为 \\\\\\&quot;# ( 需转义为 \\(expect &#123;  &quot;*password:&quot; &#123; send -- &quot;j\\(S7?xx#ky6\\[0n=R\\r&quot; &#125;&#125;# 必须要加这一句，在执行完毕后把持交互状态，把控制台，这时候就可以进行你想要进行的操作了。如果没有这一句，在登陆完成之后就会退出，而不是留在远程终端上。interact","categories":["DevOps"],"tags":["工程化","DevOps"]},{"title":"测试环境karma","url":"/posts/dd661b79ea9b/","content":"初始化yarn init -y\n\n实现第一个测试用例index.js\nvar add = function(a)&#123;  return 1 + a&#125;\n\nindex.spec.js\ndescribe(&#x27;测试基本api&#x27;,function()&#123;  it(&#x27;add&#x27;,function()&#123;    except(add(1)).toBe(2)  &#125;)&#125;)\n\n如何让上面的代码运行安装karma测试框架\nyarn add -D karma\n\n配置package.json可以执行karma命令，如果不想配置可以安装 karma-cli\n&quot;scripts&quot;:&#123;  &quot;karma-init&quot;:&quot;karma init&quot;&#125;\n\n执行命令初始化\nyarn karma-init\n\n\nWhich testing framework do you want to use?\n\n想要使用的单元测试框架 jasmine\n\nDo you want to use Require.js\n\n是否想要用Requirejs， 不需要\n\nDo you want to capture any browsers automatically？\n\n想要自动调用的浏览器 PhantomJS\nPhantomJS是一个可编程的无头浏览器:一个完整的浏览器内核,包括js解析引擎,渲染引擎,请求处理等,但是不包括显示和用户交互页面的浏览器。\nhantomJS的适用范围就是无头浏览器的适用范围。通常无头浏览器可以用于页面自动化，网页监控，网络爬虫等：\n页面自动化测试：希望自动的登陆网站并做一些操作然后检查结果是否正常。网页监控：希望定期打开页面，检查网站是否能正常加载，加载结果是否符合预期。加载速度如何等。网络爬虫：获取页面中使用js来下载和渲染信息，或者是获取链接处使用js来跳转后的真实地址\n\nWhat is the location of your source and test files\n\n想要测试的文件位置，暂时留空\n\nShould any of the files included by the previous patterns be excluded？\n\n想要排除哪些文件暂时留空\n\nDo you want Karma to watch all the files and run the tests on change？\n\n是否需要监听文件改变， 暂时选no,不监听\n下一步\n打开生成的karma.conf.js文件\n&#123;  // 测试框架名称  frameworks: [&#x27;jasmine&#x27;],  //测试文件目录  files: [    &quot;./test/unit/**/*.js&quot;,    &quot;./test/unit/**/*.spec.js&quot;  ],  singleRun:true&#125;\n\n在package.json中添加运行命令\n &quot;scripts&quot;: &#123;  &quot;karma-init&quot;: &quot;karma init&quot;,  &quot;karma-start&quot;: &quot;karma start&quot;&#125;\n\n安装无头浏览器和jasmine适配器\nyarn add -D karma-jasmine karma-phantomjs-launcher phantomjs\n\n编写测试用例\nindex.js\nfunction add(a) &#123;  if (a == 1) &#123;    return a + 1;  &#125; else &#123;    return a + 2;  &#125;&#125;\n\nindex.spec.js\ndescribe(&#x27;单元测试&#x27;,function()&#123;  it(&quot;contains spec with an expectation&quot;, function() &#123;    expect(add(1)).toBe(2);  &#125;)&#125;)\n\n执行 karma-start 进行单元测试\n\n覆盖率测试安装 karma-coverage\nyarn add -D karma-coverage\n\n修改配置项\n&#123;  preprocessors: &#123;    &quot;./test/unit/**/*.js&quot;:&quot;coverage&quot;  &#125;,  reporters: [&#x27;progress&#x27;,&#x27;coverage&#x27;],  coverageReporter: &#123;    dir: &#x27;doc/coverage&#x27;,    reporters: [      // reporters not supporting the `file` property      &#123; type: &#x27;html&#x27;, subdir: &#x27;report-html&#x27; &#125;,    ]  &#125;&#125;\n\n执行再次执行 karma-start\nUI测试安装 backstop\nyarn add -D backstop\n\n添加 package.json 命令行\n&#123;  &quot;scripts&quot;: &#123;    &quot;backstop-init&quot;: &quot;backstop init&quot;,    &quot;backstop-start&quot;: &quot;backstop test&quot;  &#125;&#125;\n\n执行 backstop-init 生成文件目录\n修改文件目录配置\n&#123;  &quot;id&quot;: &quot;baidu&quot;,  // 设计图分辨率设置  &quot;viewports&quot;: [    &#123;      &quot;label&quot;: &quot;phone&quot;,      &quot;width&quot;: 375,      &quot;height&quot;: 667    &#125;,    &#123;      &quot;label&quot;: &quot;tablet&quot;,      &quot;width&quot;: 1024,      &quot;height&quot;: 768    &#125;  ],  //调用 puppeteer 库的脚本  &quot;onBeforeScript&quot;: &quot;puppet/onBefore.js&quot;,  &quot;onReadyScript&quot;: &quot;puppet/onReady.js&quot;,  &quot;scenarios&quot;: [    &#123;      &quot;label&quot;: &quot;baidu home&quot;,      &quot;cookiePath&quot;: &quot;backstop_data/engine_scripts/cookies.json&quot;,      &quot;url&quot;: &quot;https://garris.github.io/BackstopJS/&quot;,      &quot;referenceUrl&quot;: &quot;&quot;,      &quot;readyEvent&quot;: &quot;&quot;,      &quot;readySelector&quot;: &quot;&quot;,      &quot;delay&quot;: 0,      &quot;hideSelectors&quot;: [],      &quot;removeSelectors&quot;: [],      &quot;hoverSelector&quot;: &quot;&quot;,      &quot;clickSelector&quot;: &quot;&quot;,      &quot;postInteractionWait&quot;: 0,      &quot;selectors&quot;: [],      &quot;selectorExpansion&quot;: true,      &quot;expect&quot;: 0,      &quot;misMatchThreshold&quot; : 0.1,      &quot;requireSameDimensions&quot;: true    &#125;  ],  &quot;paths&quot;: &#123;    &quot;bitmaps_reference&quot;: &quot;backstop_data/bitmaps_reference&quot;,    &quot;bitmaps_test&quot;: &quot;backstop_data/bitmaps_test&quot;,    &quot;engine_scripts&quot;: &quot;backstop_data/engine_scripts&quot;,    &quot;html_report&quot;: &quot;doc/backstop_data/html_report&quot;,    &quot;ci_report&quot;: &quot;backstop_data/ci_report&quot;  &#125;,  &quot;report&quot;: [&quot;browser&quot;],  &quot;engine&quot;: &quot;puppeteer&quot;,  &quot;engineOptions&quot;: &#123;    &quot;args&quot;: [&quot;--no-sandbox&quot;]  &#125;,  &quot;asyncCaptureLimit&quot;: 5,  &quot;asyncCompareLimit&quot;: 50,  &quot;debug&quot;: false,  &quot;debugWindow&quot;: false&#125;","categories":["DevOps"],"tags":["工程化","DevOps"]},{"title":"热部署代码","url":"/posts/d192bdaa6516/","content":"const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const vm = require(&quot;vm&quot;);const handlerMap = &#123;&#125;;const hotsPath = path.join(__dirname, &quot;hots&quot;);// 加载文件代码 并 监听指定文件夹目录文件内容变动const loadHandlers = async () =&gt; &#123;  // 遍历出指定文件夹下的所有文件  const files = await new Promise((resolve, reject) =&gt; &#123;    //https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_fs_readdir_path_options_callback    //异步读取指定目录下的文件和文件夹，返回一个数组    fs.readdir(hotsPath, (err, files) =&gt; &#123;      if (err) &#123;        reject(err);      &#125; else &#123;        resolve(files);      &#125;    &#125;);  &#125;);  // 初始化加载所有文件 把每个文件结果缓存到handlerMap变量当中  for (let f in files) &#123;    handlerMap[files[f]] = await loadHandler(path.join(hotsPath, files[f]));  &#125;  // 监听指定文件夹的文件内容变动  await watchHandlers();&#125;;// 监视指定文件夹下的文件变动const watchHandlers = async () =&gt; &#123;  // 这里建议用chokidar的npm包代替文件夹监听   // 监听所有子文件夹  fs.watch(hotsPath, &#123; recursive: true &#125;, async (eventType, filename) =&gt; &#123;    // 获取到每个文件的绝对路径     // 包一层require.resolve的原因，拼接好路径以后，它会主动去帮你判断这个路径下的文件是否存在    //使用require.resolve函数查询模块文件名时并不会加载该模块。    const targetFile = require.resolve(path.join(hotsPath, filename));    // 使用require加载一个模块后，模块的数据就会缓存到require.cache中，下次再加载相同模块，就会直接走require.cache    // 所以我们热加载部署，首要做的就是清除require.cache中对应文件的缓存    const cacheModule = require.cache[targetFile];    // 去除掉在require.cache缓存中parent对当前模块的引用，否则会引起内存泄露，具体解释可以看下面的文章\t// 《记录一次由一行代码引发的“血案”》https://cnodejs.org/topic/5aaba2dc19b2e3db18959e63\t// 《一行 delete require.cache 引发的内存泄漏血案》https://zhuanlan.zhihu.com/p/34702356    if (cacheModule.parent) &#123;            cacheModule.parent.children.splice(cacheModule.parent.children.indexOf(cacheModule), 1);    &#125;    // 清除指定路径对应模块的require.cache缓存    require.cache[targetFile] = null;    // 重新加载发生变动后的模块文件，实现热加载部署效果，并将重新加载后的结果，更新到handlerMap变量当中    const code = await loadHandler(targetFile)    handlerMap[filename] = code;    console.log(&quot;热部署文件：&quot;, filename, &quot;，执行结果：&quot;, handlerMap);  &#125;);&#125;;// 加载指定文件的代码const loadHandler = filename =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    //https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_fs_readfile_path_options_callback    //读取文件中的内容 默认返回buffer    //当目录为文件夹时抛出错误    fs.readFile(filename, (err, data) =&gt; &#123;      if (err) &#123;        resolve(null);      &#125; else &#123;        try &#123;          // 使用vm模块的Script方法来预编译发生变化后的文件代码，检查语法错误，提前发现是否存在语法错误等报错          new vm.Script(data);        &#125; catch (e) &#123;          // 语法错误,编译失败          reject(e);          return;        &#125;        // 编译通过后，重新require加载最新的代码        resolve(require(filename));      &#125;    &#125;);  &#125;);&#125;;loadHandlers()","categories":["DevOps"],"tags":["工程化","DevOps"]},{"title":"sonarQube","url":"/posts/a69bdf0ff1e4/","content":"最后更新2024-12-11\n安装数据库安装 postgresql，[文档]\napt install postgresql\n\n创建 schema\n# 登录数据库sudo -u postgres psql# 创建数据库,必须使用 UTF-8 编码CREATE DATABASE sonarqube_db ENCODING &#x27;UTF8&#x27;;# 链接到新的数据库\\c sonarqube_db # 进入数据库\n\n创建用户 sonarqube\nCREATE USER sonarqube WITH PASSWORD &#x27;YourSecurePassword&#x27;;\n\n创建 scheme，并赋予 sonarqube 用户所有权限\nCREATE SCHEMA sonarqube_schema AUTHORIZATION sonarqube;\n\n由于没有使用默认的 schema，必须要设置 search_path\nALTER USER sonarqube SET search_path to sonarqube_schema;\n\n配置 java 环境安装 java 环境，[文档]\n安装依赖包\napt install -y wget apt-transport-https gpg\n\n下载 Eclipse Adoptium GPG 密钥\nwget -qO - https://packages.adoptium.net/artifactory/api/gpg/key/public | gpg --dearmor | tee /etc/apt/trusted.gpg.d/adoptium.gpg &gt; /dev/null\n\n配置库信息\necho &quot;deb https://packages.adoptium.net/artifactory/deb $(awk -F= &#x27;/^VERSION_CODENAME/&#123;print$2&#125;&#x27; /etc/os-release) main&quot; | tee /etc/apt/sources.list.d/adoptium.list\n\n安装\napt updateapt-get install temurin-21-jdk\n\n安装前环境准备确认信息\n一个进程可能拥有的最大内存映射区域数（vm.max_map_count）大于等于 524288。打开的文件描述符的最大数目（fs.file-max）大于或等于 131072。运行 SonarQube Server 的用户至少可以打开 131072 个文件描述符运行 SonarQube Server 的用户至少可以打开 8192 个线程\n使用以下命令查看信息\nsysctl vm.max_map_countsysctl fs.file-maxulimit -nulimit -u\n\n修改配置\n# 创建一个新的配置文件/etc/sysctl.d/99-sonarqube.conf# 添加vm.max_map_count=524288fs.file-max=131072\n\n# 创建一个新的配置文件/etc/security/limits.d/99-sonarqube.conf# 添加sonarqube   -   nofile   262144sonarqube   -   nproc    16384\n\n在 Linux 内核上启用 seccomp\ngrep SECCOMP /boot/config-$(uname -r)# 如果您的内核有seccomp，将看到以下内容# CONFIG_HAVE_ARCH_SECCOMP_FILTER=y# CONFIG_SECCOMP_FILTER=y# CONFIG_SECCOMP=y\n\n安装 sonar下载,并解压，路径中不能有 .开头的文件夹\nunzip sonarqube-25.3.0.104237.zip\n\n编辑数据库链接信息\nvi &lt;sonarqubeHome&gt;/conf/sonar.propertiessonar.jdbc.username=sonarqubesonar.jdbc.password=mypasswordsonar.jdbc.url=jdbc:postgresql://localhost:5432/sonarqube_db?currentSchema=sonarqube_schema\n\n配置 Elasticsearch 存储路径\nvi &lt;sonarqubeHome&gt;/conf/sonar.propertiessonar.path.data=/var/sonarqube/datasonar.path.temp=/var/sonarqube/temp\n\n启动服务\n&lt;sonarqubeHome&gt;/bin/linux-x86-64/sonar.sh start# http://localhost:9000# admin/admin\n\nFAQ检查日志cat &lt;sonarqubeHome&gt;/logs/sonar.log\n\nStartup error: ‘can not run elasticsearch as root’修改 sonar 安装目录权限\nsudo chown -R sonar:sonar /opt/sonarqube-25.3.0.104237/sudo chown -R sonar:sonar /var/sonarqube\n\nProcess exited with exit value [ElasticSearch]: 143143 错误 99% 与前端启动相关，检查 web.log\n","categories":["DevOps"],"tags":["DevOps"]},{"title":"编码思路-工程化","url":"/posts/d0e9421ea5a1/","content":"which&#x2F;whereis\nwhich\n搜索范围：仅在当前用户的 PATH 环境变量指定的目录中搜索。\n输出内容：仅返回第一个匹配的可执行文件路径。\n\nwhereis\n搜索范围：在预定义的标准系统目录（如 &#x2F;bin, &#x2F;usr&#x2F;include, &#x2F;usr&#x2F;share&#x2F;man 等）中搜索，不依赖 PATH。\n输出内容：返回所有相关文件路径（二进制、手册页、源代码等）。\n\n\nnpm&#x2F;yarn&#x2F;pnpm\nnpm\n嵌套依赖结构：早期版本采用嵌套的 node_modules 结构，导致依赖重复和路径过长问题。\n确定性依赖：在 npm@5 后引入 package-lock.json，锁定依赖版本（解决早期版本依赖不确定性）。\n早期有重复依赖的问题，扁平化处理后可能导致幽灵依赖。\n\nyarn\n确定性依赖：引入 yarn.lock 文件（早于 npm 的 package-lock.json），锁定依赖树。\n并行下载：利用并行请求提升安装速度。\n离线缓存：全局缓存已下载的依赖包，减少重复下载。\n扁平化结构：将嵌套依赖提升到 node_modules 顶层，减少重复安装（但可能引发依赖冲突）\nPnP 模式: 劫持 Node.js 的模块解析逻辑，使其不再依赖物理的 node_modules 目录，而是通过映射表（.pnp.cjs）直接定位到 .zip 文件中的代码。\n\npnpm\n硬链接 + 符号链接：所有依赖包存储在全局存储目录（类似缓存）。通过硬链接共享相同版本的依赖，减少磁盘占用。使用符号链接在项目中按需链接依赖。\n严格依赖隔离：每个包的依赖在独立的 node_modules 中，避免幽灵依赖。\n\n\n本地依赖通常使用 lerna, nx 等工具，原生实现可以使用 file 协议。\n&#123;  &quot;dependencies&quot;: &#123;    &quot;@my/cli-util&quot;: &quot;file:/mnt/d/Workspace/my-cli/packages/util&quot;  &#125;&#125;\n\n使用 pnpm\n// pnpm-workspace.yamlpackages:  - &quot;packages/*&quot;\n\n&#123;  &quot;dependencies&quot;: &#123;    &quot;@my/cli-util&quot;: &quot;workspace:*&quot;  &#125;&#125;\n\n路径处理\nimport-local 优先使用自己的本地安装版本\n\npkg-dir 查找项目的根目录\n\nresolve-cwd 从 CWD 目录解析模块的绝对路径。\n\nwhich 在 path 环境变量中查找第一个匹配\n\nnode 默认处理 .js .json .node 文件, 其他文件格式当作 js 文件处理\n//a.txtconsole.log(1);// index.jsconst a = require(&quot;./a.txt&quot;); // 不会报错，可以加载\n\nroot 检查root-check, 如果使用 root 用户启动，尝试降级\n参数处理minimist 解析命令行参数\nyargs commander 提供交互式的命令行\n检查包是否安装let dir = __dirname;do &#123;  if (fs.statSync(path.join(dir, &quot;node_modules&quot;, packageName)).isDirectory()) &#123;    return true;  &#125;&#125; while (dir !== (dir = path.dirname(dir)));//require(&quot;module&quot;) 用于管理模块的接口for (const internalPath of require(&quot;module&quot;).globalPaths) &#123;  if (fs.statSync(path.join(internalPath, packageName)).isDirectory()) &#123;    return true;  &#125;&#125;return false;\n\n区分使用的是那种包管理器if (fs.existsSync(path.resolve(process.cwd(), &quot;yarn.lock&quot;))) &#123;  packageManager = &quot;yarn&quot;;&#125; else if (fs.existsSync(path.resolve(process.cwd(), &quot;pnpm-lock.yaml&quot;))) &#123;  packageManager = &quot;pnpm&quot;;&#125; else &#123;  packageManager = &quot;npm&quot;;&#125;\n\n原生的命令行交互 readLineconst readLine = require(&quot;readline&quot;);const questionInterface = readLine.createInterface(&#123;  input: process.stdin,  output: process.stderr,&#125;);questionInterface.question(&quot;question one (yes/no):&quot;, (answer) =&gt; &#123;  if (answer.startsWith(&quot;y&quot;)) &#123;  &#125;&#125;);\n\n子进程的 spawn 和 exec 函数之间的区别Node.js 的子进程模块（child_process）有两个函数 spawn 和 exec，使用这两个函数，我们可以启动一个子进程来执行系统中的其他程序。刚接触 child_process 的人可能会问，为什么做同一件事会有两个函数，以及应该使用哪个函数。我将解释 spawn 和 exec 之间的区别，以帮助你决定何时使用哪个函数。\nchild_process.spawn 和 child_process.exec 的最大区别在于它们的返回值–spawn 返回一个流，而 exec 返回一个缓冲区。\nchild_process.spawn 返回一个包含 stdout 和 stderr 流的对象。您可以点击 stdout 流来读取子进程发回 Node 的数据。作为一个流，stdout 具有流所具有的 “data”（数据）、”end”（结束）和其他事件。当您希望子进程向 Node 返回大量数据（如图像处理、读取二进制数据等）时，最好使用 spawn。\nchild_process.spawn 是 “异步 asynchronous”（异步不同步）的，这意味着一旦子进程开始执行，它就会以流的形式从子进程发回数据。\n这里有一个例子，我用 spawn 读取了 Node 的 curl 请求结果。\nchild_process.exec 返回子进程输出的整个缓冲区。默认情况下，缓冲区大小为 200k。如果子进程返回的数据超过该值，程序就会崩溃，并显示错误信息 “Error: maxBuffer exceeded”（错误：超过最大缓冲区）。你可以在执行选项中设置更大的缓冲区大小来解决这个问题。但你不应该这样做，因为 exec 并不适合向 Node 返回巨大缓冲区的进程。你应该使用 spawn 来解决这个问题。那么，exec 用来做什么呢？用它来运行返回结果状态而不是数据的程序。\nchild_process.exec 是 “同步异步 “的，也就是说，虽然 exec 是异步的，但它会等待子进程结束，并尝试一次性返回所有缓冲数据。如果 exec 的缓冲区大小设置得不够大，就会出现 “maxBuffer exceeded”（超过最大缓冲区）错误，导致执行失败。\n请看这里的一个示例，我使用 exec 执行 wget 下载文件，并向 Node 更新执行状态。\n这就是 Node 的子进程 span 和 exec 之间的区别。当你希望子进程向 Node 返回大量二进制数据时，请使用 spawn；当你希望子进程返回简单的状态信息时，请使用 exec。\nconst cp = require(&quot;child_process&quot;);new Promise((resolve, reject) =&gt; &#123;  const executedCommand = cp.spawn(&quot;echo 1&quot;, [], &#123;    stdio: &quot;inherit&quot;,    shell: true,  &#125;);  executedCommand.on(&quot;error&quot;, reject);  executedCommand.on(&quot;exit&quot;, (code) =&gt; &#123;    if (code === 0) resolve();  &#125;);&#125;).then(() =&gt; &#123;&#125;);\n\n区分包的模块化方案const pkgPath = require.resolve(`$&#123;packageName&#125;/package.json`);const pkg = require(pkgPath);if (pkg.type === &quot;module&quot; || /\\.mjs/i.test(pkg.bin[name])) &#123;  import(path.resolve(path.dirname(pkgPath), pkg.bin[name])).catch();&#125; else &#123;  require(path.resolve(path.dirname(pkgPath), pkg.bin[name]));&#125;\n\n检查两个命令是否相似(莱文斯坦距离)[https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2] (fastest-levenshtein)[https://github.com/ka-weihe/fastest-levenshtein]\n获取某个包的最新版本推荐使用 cross-spawn\nconst cp = require(&quot;child_process&quot;);const &#123; output &#125; = cp.spawnSync(  &quot;npm.cmd&quot;,  [&quot;view&quot;, &quot;react@latest&quot;, &quot;version&quot;],  &#123;    stdio: &quot;pipe&quot;,  &#125;);console.log(output.toString());\n\n或者通过 api 拉取 https://registry.npmjs.com/lodash\n是否是浏览器环境// 使用 typeof, 对于不存在的变量会返回 undefinedconst hasDocument = typeof document !== &quot;undefined&quot;;\n\n检查 IE 浏览器var isIE11 =  typeof navigator !== &quot;undefined&quot; &amp;&amp;  navigator.userAgent.indexOf(&quot;Trident&quot;) !== -1;\n\n版本号对比const semver = require(&quot;semver&quot;);const version1 = &quot;1.2.3&quot;;const version2 = &quot;2.0.0&quot;;if (semver.gt(version1, version2)) &#123;  console.log(`$&#123;version1&#125; is greater than $&#123;version2&#125;`);&#125;\n\ncommander 基本结构import &#123; Command &#125; from &quot;commander&quot;;const program = new Command();program  .name(&quot;sun-cli&quot;)  .description(&quot;这是一个描述&quot;)  .option(&quot;--targetCommand&quot;, &quot;参数的描述&quot;, &quot;team1/command&quot;)  .action((options) =&gt; &#123;    console.log(options);  &#125;);program  .command(&quot;clone &lt;source&gt; [destination]&quot;)  .description(&quot;子命令的描述&quot;)  .action((source, destination) =&gt; &#123;    console.log(&quot;clone command called&quot;);  &#125;);program.parse();\n","categories":["DevOps"],"tags":["DevOps"]},{"title":"调试npm包","url":"/posts/61c0760886e4/","content":"npm&#x2F;yarn link通过软链接使用第三方包\n进入本地npm包文件夹，或通过 git clone拉去的第三方包文件夹 \n执行 yarn link 或 npm link 连接到全局（yarn 不会污染全局）\n在项目中使用 yarn link [第三方包]  或 npm link [第三方包]\n在项目中通过 yarn unlink [第三方包] 或 npm unlink [第三方包] 解除链接\n通过一下命令去掉全局安装的包 \nnpm rm --global foo npm ls --global foo // 检查包是否被安装\n","categories":["DevOps"],"tags":["工程化","DevOps","npm"]},{"title":"1.函数式","url":"/posts/cc82b2f7fcfa/","content":"面向对象编程（OO）通过封装变化使得代码更易理解。\n函数式编程（FP）通过最小化变化使得代码更易理解。\n函数式思想JavaScript是一种拥有很多共享状态的动态语言，用不了多久，代码就会积累足够的复杂性。面向对象的编程思想可以解决一部分问。\n我们需要的是一个可以对数据处理，并能处理交互，IO的编程范式，函数式编程在处理数据流转很有帮助，下一步我们希望深入函数式编程的理念，能让其处理异步交互，并且解决代码的复杂性\n在应用设计时应该考虑一下几点：\n\n可扩展性——我是否需要不断地重构代码来支持额外的功能？\n易模块化——如果我更改了一个文件，另一个文件会不会受到影响？\n可重用性——是否有很多重复的代码？\n可测性——给这些函数添加单元测试是否让我纠结？\n易推理性——我写的代码是否非结构化严重并难以推理？\n\n使用Javascript语言的其中一个问题是，缺乏一些能够妥当管理状态的原生解构，需要开发人员自身把控。随着复杂度的增高，变得难以控制。\n声明式编程命令式编程是很具体的告诉计算机如何执行某个任务，而声明式编程是将程序的描述和求值分离。\n副作用和纯函数纯函数 \n\n仅取决于提供的输入，而不依赖于任何在函数求值期间或调用间隔时可能变化的隐藏状态和外部状态。\n\n不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数。\n\n\n副作用的发生情况\n\n改变一个全局的变量、属性或数据结构。this的使用容易发生问题。\n\n改变一个函数参数的原始值。\n\n处理用户输入。\n\n抛出一个异常，除非它又被当前函数捕获了。\n\n屏幕打印或记录日志。\n\n查询 HTML 文档、浏览器的 cookie或访问数据库。\n\n\n引用透明和可置换性引用透明使得开发者可以用这种系统的甚至是数理的方法来推导程序\nincrement();increment();print(counter);//引用不透明,调用期间如果被修改，会影响结果\n\nconst plus = run(increment,increment);print(run(0))//总是为初始值加2\n\n存储不可变数据JavaScript 开发人员面临的问题都是由大量使用严重依赖外部共享变量的、存在太多分支的以及没有清晰的结构大函数所造成的。\n即便是一些由很多文件组成并执行得很成功的应用，也会形成一种共享的可变全局数据网，难以跟踪和调试。\n函数式编程的优点\n促使将任务分解成简单的函数。\n\n使用流式的调用链来处理数据。\n\n通过响应式范式降低事件驱动代码的复杂性。\n\n\n复杂异步应用中的响应总结\n使用纯函数的代码绝不会更改或破坏全局状态，有助于提高代码的可测试性和可维护性。\n\n函数式编程采用声明式的风格，易于推理。这提高了应用程序的整体可读性，通过使用组合和lambda表达式使代码更加精简。\n\n集合中的数据元素处理可以通过链接如map和reduce这样的函数来实现。\n\n函数式编程将函数视为积木，通过一等高阶函数来提高代码的模块化和可重用性。\n\n可以利用响应式编程组合各个函数来降低事件驱动程序的复杂性。\n\n\n","categories":["JavaScript"],"tags":["函数式编程"]},{"title":"2.进阶","url":"/posts/0c62b4573380/","content":"为什么说JavaScript是适合函数式的编程语言JavaScript语言的多范型开发不可变性和变化的对策理解高阶函数和一等函数闭包和作用域的概念探讨闭包的实际使用\n函数式与面向对象面向对象的关键是创建继承层次结构（如继承Person的Student对象）并将方法与数据紧密的绑定在一起。函数式编程则更倾向于通过广义的多态函数交叉应用于不同的数据类型，同时避免使用this\n属性保护\n试用递归来冻结数属性\nvar isObject = (val) =&gt; val &amp;&amp; typeof val === &#x27;object&#x27;;function deepFreeze(obj) &#123;  if(isObject(obj) //遍历所有属性并递归调用Object.freeze()（使用第3章介绍的map）    &amp;&amp; !Object.isFrozen(obj)) &#123; //跳过已经冻结过的对象，冻结没有被冻结过的对象    Object.keys(obj). //跳过所有的函数，即使从技术上说，函数也可以被修改，但是我们更希望注意在数据的属性上  forEach(name =&gt; deepFreeze(obj[name])); //递归地自调用（第3章会介绍递归）    Object.freeze(obj); //冻结根对象  &#125;return obj;&#125;\n\nR.lensProp 保证对象属性的不可变性\n函数需要区分表达式（如返回一个值的函数）和语句（如不返回值的函数）。命令式编程和过程式程序大多是由一系列有序的语句组成的，而函数式编程完全依赖于表达式，因此无值函数在该范式下并没有意义。\n\n一等函数\n\n高阶函数\n\n\n闭包作用域","categories":["JavaScript"],"tags":["函数式编程"]},{"title":"3.轻数据结构,重操作","url":"/posts/8fa41b2ec73f/","content":"理解程序的控制流更易理解的代码与数据命令抽象函数map、reduce 以及filterLodash.js 及函数链递归的思考\n理解程序的控制流程序为实现业务目标所要行进的路径被称为控制流。命令式程序需要通过暴露所有的必要步骤才能极其详细地描述其控制流。\n链接方法&#x27;Functional Programming&#x27;.substring(0, 10).toLowerCase() + &#x27; is fun&#x27;;//函数式concat(toLowerCase(substring(&#x27;Functional Programming&#x27;, 1, 10))),&#x27; is fun&#x27;);\n\n函数链\nlambda表达式\n\nlambda表达式适用于函数式的函数定义，因为它总是需要返回一个值。\n\nR.map()\n\nexport default function _map(fn, functor) &#123;  var idx = 0;  var len = functor.length;  var result = Array(len);  while (idx &lt; len) &#123;    result[idx] = fn(functor[idx]);    idx += 1;  &#125;  return result;&#125;\n\n","categories":["JavaScript"],"tags":["函数式编程"]},{"title":"4.模块化且可重用的代码","url":"/posts/90b882fa913b/","content":"函数链与函数管道的比较Ramda.js 函数库柯里化、部分应用（partial application）和函数绑定通过函数式组合构建模块化程序利用函数组合子增强程序的控制流\n先将问题分解成较小的部分，再重建这些部分以形成整体的解决方案。\n方法链与函数管道的比较Haskell中定义函数的符号。该符号先给出了函数的名称，随后用一个操作符来设置函数的输入和输出类型\n\n方法链接（紧耦合，有限的表现力）它与方法所属的对象紧紧地耦合在一起，限制链中可以使用的方法数量，也就限制了代码的表现力。这样就只能够使用由Lodash提供的操作，而无法轻松地将不同函数库的（或自定义的）函数连接在一起。\n_.chain(names).filter(isValid) //每一个“点”后只能调用 Lodash 提供的方法.map(s =&gt; s.replace(/_/, &#x27; &#x27;)).uniq().map(_.startCase).sort().value();\n\n\n函数的管道化（松耦合，灵活）\n\n方法链接通过对象的方法紧密连接；而管道以函数作为组件，将函数的输入和输出松散地连接在一起。但是，为了实现管道，被连接的函数必须在元数（arity）和类型上相互兼容。\n函数式编程将管道视为构建程序的唯一方法.\n对于不同的任务，问题的定义与解决方案间总是存在很大的差异。因此，特定的计算必须在特定的阶段进行。这些阶段由不同的函数表征，而所选函数的输入和输出需要满足以下两个兼容条件。\n类型&#x3D;&gt;函数的返回类型必须与接收函数的参数类型相匹配。\n元数&#x3D;&gt;接收函数必须声明至少一个参数才能处理上一个函数的返回值。\n元组\n对传入的参数进行参数类型，和个数的校验，可以用TS替代\n\n不可变的——一旦创建，就无法改变一个元组的内部内容。\n避免创建临时类型——元组可以将可能毫不相关的数据相关联。而定义和实例化一些仅用于数据分组的新类型使得模型复杂并令人费解。\n避免创建异构数组——包含不同类型元素的数组使用起来颇为困难，因为会导致代码中充满大量的防御性类型检查。传统上，数组意在存储相同类型的对象。\n\n柯里化要求所有参数都被明确地定义，因此当使用部分参数调用时，它会返回一个新的函数，在真正运行之前等待外部提供其余的参数。\nR._curry1\nfunction curry1(fn) &#123;    return function f1(a) &#123;        // 判断a是否为占位符        if (arguments.length === 0 || _isPlaceholder(a)) &#123;            return f1        &#125; else &#123;            // 多余的参数也可以传入            return fn.apply(this, arguments);        &#125;    &#125;&#125;\n\n部分应用和函数绑定\n柯里化在每次分步调用时都会生成嵌套的一元函数。在底层，函数的最终结果是由这些一元函数的逐步组合产生的。同时，curry的变体允许同时传递一部分参数。因此，可以完全控制函数求值的时间与方式。\n\n部分应用将函数的参数与一些预设值绑定（赋值），从而产生一个拥有更少参数的新函数。该函数的闭包中包含了这些已赋值的参数，在之后的调用中被完全求值。\n\n\n延迟函数绑定当期望目标函数使用某个所属对象来执行时，使用函数绑定来设置上下文对象就变得尤为重要。例如，浏览器中的setTimeout和setInterval等函数，如果不将this的引用设为全局上下文，即window对象，是不能正常工作的。传递undefined在运行时正确设置它们的上下文。\nconst Scheduler = (function () &#123;  const delayedFn = _.bind(setTimeout, undefined, _, _);  return &#123;    delay5: _.partial(delayedFn, _, 5000),    delay10: _.partial(delayedFn, _, 10000),    delay: _.partial(delayedFn, _, _)    &#125;;  &#125;)();Scheduler.delay5(function () &#123;  consoleLog(&#x27;Executing After 5 seconds!&#x27;)&#125;);\n\n函数组合Function.prototype.compose = R.compose;const cleanInput = checkLengthSsn.compose(normalize).compose(trim);\n\n对副作用的处理是，拆分副作用的函数，并且固定副作用函数的参数\npoint-free编程使用compose（或者pipe）就意味着永远不必再声明参数了（称为函数的points），这无疑会使代码更加声明式、更加简洁，或更加point-free。\nR.compose(first, getName, reverse, sortByGrade, combine);\n\npoint-free编程使JavaScript的函数式代码更接近于Haskell和UNIX的理念。它可以用来提高抽象度，促使开发者关注高级组件的组合，而不是低级的函数求值的细节。柯里化在这里也起着很重要的作用，因为它能够灵活地部分定义一个只差最后一个参数的内联函数。这种编码风格也被称为Tacit编程。\n在将组合改为这种编码风格时，要记住，过度的使用会使得程序晦涩且令人费解。\n组合子组合器是一些可以组合其他函数（或其他组合子），并作为控制逻辑运行的高阶函数。组合子通常不声明任何变量，也不包含任何业务逻辑，它们旨在管理函数式程序的流程。除了compose和pipe，还有无数的组合子，一些最常见的组合子如下。\n\nidentity（I-combinator）\n\n为以函数为参数的更高阶函数提供数据，如之前清单4.12中的point-free代码。在单元测试的函数组合器控制流中作为简单的函数结果来进行断言。例如，可以使用identity函数来编写compose的单元测试。函数式地从封装类型中提取数据\n//identity :: (a) -&gt; a\n\n\ntap（K-组合子）\n\n该函数接收一个输入对象a和一个对a执行指定操作的函数。它使用提供的对象调用给定的函数，然后再返回该对象\nfunction tap(fn, x) &#123;  fn(x);  return x;&#125;\n\n\nalt （OR-组合子） alternation\n\nalt组合子能够在提供函数响应的默认行为时执行简单的条件逻辑。该组合器以两个函数为参数，如果第一个函数返回值已定义（即，不是false、null或undefined)\n用于处理if else 逻辑\nconst alt = function (func1, func2) &#123;  return function (val) &#123;    return func1(val) || func2(val);&#125;&#125;;\n\n\nseq（S-组合子） sequence\n\nseq组合子用于遍历函数序列。它以两个或更多的函数作为参数并返回一个新的函数，会用相同的值顺序调用所有这些函数\nseq组合子不会返回任何值，只会一个一个地执行一系列操作。如果要将其嵌入函数组合之间，可以使用R.tap将它与其余部分进行桥接。\nconst seq = function(/*funcs*/) &#123;  const funcs = Array.prototype.slice.call(arguments);    return function (val) &#123;      funcs.forEach(function (fn) &#123;      fn(val);    &#125;);  &#125;;&#125;;\n\n\nfork（join）组合子\n\n\nconst fork = function(join, func1, func2)&#123;  return function(val) &#123;    return join(func1(val), func2(val));  &#125;;&#125;;\n\nconst eqMedianAverage = fork(R.equals, R.median, R.mean);eqMedianAverage([80, 90, 100])); //-&gt; TrueeqMedianAverage([81, 90, 100])); //-&gt; False\n\n总结\n用于连接可重用的、模块化的、组件化程序的函数链与管道。\nRamda.js是一个功能强大的函数库，适用于函数的柯里化与组合。\n可以通过部分求值和柯里化来减少函数元数，利用对参数子集的部分求值将函数转化为一元函数。\n可以将任务分解为多个简单的函数，再通过组合来获得整个解决方案。\n以point-free的风格编写，并用函数组合子来组织的程序控制流，可解决现实问题。\n\n","categories":["JavaScript"],"tags":["函数式编程"]},{"title":"5.针对复杂应用的设计模式","url":"/posts/ba396347e37d/","content":"命令式处理异常方式的问题使用容器，以防访问无效数据用Functor的实现来做数据转换利于组合的Monad数据类型使用Monadic类型来巩固错误处理策略Monadic类型的组合与交错\n命令式错误处理的不足函数式编程其实可以把错误处理得比任何其他开发风格更为优雅，软件中的许多问题都是由于数据不经意地变成了null或undefined、出现了异常、失去网络连接等情况造成的。所以需要大量得错误捕获代码，在每一个使用引用得地方判断null或undefined,是的代码得逻辑越来月复杂\ntry catch我们尝试使用try,catch来捕获错误\ntry &#123;  var student = findStudent(&#x27;444-44-4444&#x27;);&#125; catch (e) &#123;  console.log(&#x27;ERROR&#x27; + e.message);&#125;\n\n但这样会与函数式的设计有兼容性问题。\n\n难以与其他函数组合或链接。\n违反了引用透明性，因为抛出异常会导致函数调用出现另一出口，所以不能确保单一的可预测的返回值。\n会引起副作用，因为异常会在函数调用之外对堆栈引发不可预料的影响。\n违反非局域性的原则，因为用于恢复异常的代码与原始的函数调用渐行渐远。当发生错误时，函数离开局部栈与环境。即 try 中的逻辑会在遇到错误时停止执行，转移到catch处理错误逻辑\n不能只关注函数的返回值，调用者需要负责声明catch块中的异常匹配类型来管理特定的异常。\n当有多个异常条件时会出现嵌套的异常处理块\n\n其中一个常见的场景是JavaScript中因在null对象上调用函数所产生的TypeError。\n空值（null）检查问题本来可以简单地创建一个lens来获取该属性，若是null即返回undefined，但它并不会打印任何错误信息。\n这使代码需要大量的判空检查代码。不管是使用try-catch还是null检查，都是被动的解决方式。\nFunctor 一种更好得解决方案思想说起来也非常简单，创建一个安全的容器，来存放危险代码\n包裹不安全的值map可以是一个更广义的map的概念，而不仅仅是数组。在函数式JavaScript中，map只不过是一个函数，由于引用透明性，只要输入相同，map永远会返回相同的结果。当然，还可以认为map是可以使用lambda表达式变换容器内的值的途径。比如，对于数组，就可以通过map转换值，返回包含新值的新数组。\nclass Wrapper &#123;  constructor(value) &#123;//存储任意类型值的简单类型    this._value = value;  &#125;  // map :: (A -&gt; B) -&gt; A -&gt; B  map(f) &#123; //用一个函数来 map 该类型（就像数组一样）    return f(this.val);  &#125;;  toString() &#123;    return &#x27;Wrapper (&#x27; + this.value + &#x27;)&#x27;;  &#125;&#125;const wrap = (val) =&gt; new Wrapper(val); //能够根据值快速创建Wrapper 的帮助函数\n\n\nWrapper类型使用map安全地访问和操作值。在这种情况下，通过映射 identity 函数就能在容器中提取值\n取值得方法\nconst wrappedValue = wrap(&#x27;Get Functional&#x27;);wrappedValue.map(R.identity); //-&gt; &#x27;Get Functional&#x27; &lt;--- 值的提取\n\n映射任何函数到该容器，比如记录日志或是变换该值：\nwrappedValue.map(log);wrappedValue.map(R.toUpper); //-&gt; &#x27;GET FUNCTIONAL&#x27; &lt;--- 对内部值应用函数\n\n现在所有得对值操作都与要通过map方法先伸入到容器中取值，可以说得到了一定得保护，但现在还没有对null,和undefined得处理\n当初始化一个空值得时候\nconst wrappedNull = wrap(null);wrappedNull.map(doWork); // doWork 被赋予了空值检查的责任\n\n不应该通过dowork来检查，完全可以交给Wrapper类型来做错误处理。换句话说，可以在调用函数之前，检查null、空字符串或者负数，等等。因此，Wrapper.map的语义就由具体的Wrapper类型来确定。\nmap的变种——fmap\n// fmap :: (A -&gt; B) -&gt; Wrapper[A] -&gt; Wrapper[B]Wrapper.prototype.fmap = function (f) &#123;  return wrap(f(this.val)); // 先将返回值包裹到容器中，再返回给调用者&#125;;\n\nfmap知道如何在上下文中应用函数值。它会先打开该容器，应用函数到值，最后把返回的值包裹到一个新的同类型容器中。拥有这种函数的类型称为Functor。\nFunctor定义Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。下面是fmap的一般定义：\nfmap :: (A -&gt; B) -&gt; Wrapper(A) -&gt; Wrapper(B) // Wrapper 可以是任何容器类型\n\nfmap函数接受一个从A-&gt;B的函数，以及一个Wrapper(A) Functor，然后返回包裹着结果的新FunctorWrapper(B)。下图显示了用increment函数作为A-&gt;B的映射函数，只是这里的A和B为同一类型。\n\n一个简单得例子\n通过柯里化初始化一个求和函数\nconst plus = R.curry((a, b) =&gt; a + b);const plus3 = plus(3);\n\n把数字2放到wrap中\nconst two = wrap(2);\n\n再调用fmap把plus3映射到容器上\nconst five = two.fmap(plus3); //-&gt; Wrapper(5) &lt;--- 返回一个具有上下文包裹的值five.map(R.identity); //-&gt; 5\n\nfmap返回同样类型的结果，可以通过映射R.identity来提取它的值。不过需要注意的是，值会一直在容器中，因此可以 fmap 任意次函数来转换值。\ntwo.fmap(plus3).fmap(plus10); //-&gt; Wrapper(15)\n\n\nFunctor有如下一些重要的属性约束。\n\n必须是无副作用的。若映射R.identity函数可以获得上下文中相同的值，即可证明Functor是无副作用的：\n\nwrap(&#x27;Get Functional&#x27;).fmap(R.identity); //-&gt; Wrapper(&#x27;Get Functional&#x27;)\n\n\n必须是可组合的。这个属性的意思是fmap 函数的组合，与分别fmap函数是一样的\n\ntwo.fmap(R.compose(plus3, R.tap(infoLogger))).map(R.identity); //-&gt; 5\n\n\nFunctor的这些属性并不奇怪。遵守这些规则，可以免于抛出异常、篡改元素或者改变函数的行为。其实际目的只是创建一个上下文或一个抽象，以便可以安全地应用操作到值，而又不改变原始值。这也是map可以将一个数组转换到另一个数组，而不改变原数组的原因。而Functor就是这个概念的推广。\n使用Monad函数式地处理错误Functor本身并不需要知道如何处理null。例如Ramda中的R.compose，在收到为null的函数引用时就会抛出异常。\nconst findStudent = R.curry(function(db, ssn) &#123;return wrap(find(db, ssn)); //包裹对象获取逻辑，以避免找不到对象所造成的问题&#125;);const getAddress = function(student) &#123;return wrap(student.fmap(R.prop(&#x27;address&#x27;))); //用 Ramda 的 R.prop()函数来map 对象以获取其地址， 再将结果包裹起来&#125;const studentAddress = R.compose(  getAddress,  findStudent(DB(&#x27;student&#x27;)));//返回的值是被包裹了两层的address对象studentAddress(&#x27;444-44-4444&#x27;).map(R.identity).map(R.identity)\n\nMonad：从控制流到数据流const R = ramda;const Wrap = function (value) &#123;    this._value = value&#125;Wrap.of = (value) =&gt; new Wrap(value)Wrap.prototype.fmap = function (f) &#123;    return Wrap.of(f(this._value))&#125;Wrap.prototype.map = function (f) &#123;    return f(this._value)&#125;// console.log(wrap)// console.log(wrap.map(R.identity))const Empty = function () &#123;&#125;Empty.of = () =&gt; new Empty();Empty.prototype.fmap = function () &#123;    return this&#125;Empty.prototype.map = function () &#123;    return this&#125;const empty = Empty.of()const add = R.curry((a, b) =&gt; a + b);const plus10 = add(10);const isEven = (num) =&gt; Number.isFinite(num) &amp;&amp; num % 2 === 0;const half = (num) =&gt; isEven(num) ? Wrap.of(num / 2) : empty;console.log(half(10).fmap(plus10).map(R.identity)) //15console.log(half(9).fmap(plus10).map(R.identity)) // Empty\n\nMonad——为Monadic操作提供抽象接口。Monadic类型——该接口的具体实现。\nMonadic类型类似于本章介绍的Wrapper对象。不过每个Monad都有不同的用途，可以定义不同的语义便于确定其行为（例如map或fmap）。使用这些类型可以进行链式或嵌套操作，但都应遵循下列接口定义。\n\n类型构造函数——创建Monadic类型（类似于Wrapper的构造函数）。\nunit函数——可将特定类型的值放入Monadic结构中（类似于wrap和前面看到的empty函数）。对于Monad的实现来说，该函数也被称为of函数。\nbind函数——可以链式操作（这就是Functor的fmap，也被称为flatmap）\njoin函数——将两层Monadic结构合并成一层。这会对嵌套返回Monad的函数特别有用。\n\nclass Wrapper &#123;    //类型构造器    constructor(value) &#123;        this._value = value;    &#125;    static of (a) &#123;        //unit 函数        return new Wrapper(a);    &#125;    map(f) &#123;        //bind 函数（ Functor）        return Wrapper.of(f(this.value));    &#125;    join() &#123;        //压平嵌套的Wrapper        if (!(this.value instanceof Wrapper)) &#123;            return this;        &#125;        return this.value.join();    &#125;    toString() &#123;        //返回一个当前结构的文本描述        return `Wrapper ($&#123;this.value&#125;)`;    &#125;&#125;\njoin函数用于逐层扁平化嵌套结构，就像剥洋葱一样。这可以用来消除之前用functor时发现的问题\n// findObject :: DB -&gt; String -&gt; Wrapperconst findObject = R.curry(function(db, id) &#123;return Wrapper.of(find(db, id));&#125;);// getAddress :: Student -&gt; Wrapperconst getAddress = function(student) &#123;return Wrapper.of(student.map(R.prop(&#x27;address&#x27;)));&#125;const studentAddress = R.compose(getAddress, findObject(DB(&#x27;student&#x27;)));studentAddress(&#x27;444-44-4444&#x27;).join().get(); // Address\n\nMonad通常有更多的操作，这里提及的最小接口只是其整个API的子集。一个Monad本身只是抽象，没有任何实际意义。只有实际的实现类型才有丰富的功能。幸运的是，大多数函数式编程的代码只用一些常用的类型就可以消除大量的样板代码，同时还能完成同样的工作。下面来看丰富的Monad实例：Maybe、Either和IO。\n使用Maybe Monad和Either Monad来处理异常除了用来包装有效值，Monadic的结构也可用于建模null或undefined。函数式编程通常使用Maybe和Either来做下列事情。\n\n隔离不纯。\n合并判空逻辑。\n避免异常。\n支持函数组合。\n中心化逻辑，用于提供默认值。\n\n用Maybe合并判空Maybe Monad侧重于有效整合null -判断逻辑。Maybe是一个包含两个具体字类型的空类型（标记类型）。\n\nJust(value)——表示值的容器。\nNothing()——表示要么没有值或者没有失败的附加信息。当然，还可以应用函数到Nothing上。\n\nconst R = ramda;class Maybe &#123; //容器类型（父类）    static just(a) &#123;        return new Just(a);    &#125;    static nothing() &#123;        return new Nothing();    &#125;    static fromNullable(a) &#123;        return a != null ? Maybe.just(a) :            Maybe.nothing(); //由一个可为空的类型创建 Maybe（即构造函数）。如果值为空，则 建一个 Nothing； 否则， 将值存储在 Just 子类型中来表示其存在性    &#125;    static of (a) &#123;        return Maybe.just(a);    &#125;    get isNothing() &#123;        return false;    &#125;    get isJust() &#123;        return false;    &#125;&#125;class Just extends Maybe &#123; //Just 子类型用于处理存在的值    constructor(value) &#123;        super();        this._value = value;    &#125;    get value() &#123;        return this._value;    &#125;    map(f) &#123;        return Just.of(f(this.value)); //将映射函数应用于 Just，变换其中的值，并存储回容器中    &#125;    getOrElse() &#123;        return this.value; //Monad 提供默认的一元操    &#125;    filter(f) &#123;        Maybe.fromNullable(f(this.value) ? this.value : null);    &#125;    get isJust() &#123;        return true;    &#125;    toString() &#123; //返回该结构的文本描述        return `Maybe.Just($&#123;this.value&#125;)`;    &#125;&#125;class Nothing extends Maybe &#123; //Nothing子类型用于为无值的情况提供保护    map(f) &#123;        return this;    &#125;    get value() &#123;        throw new TypeError(            &#x27;Can&quot;t extract the valueof a Nothing.&#x27;); //任何试图从 Nothing 类型中取值的操作会引发表征错误使用 Monad的异常（后文会予以介绍）    &#125;    getOrElse(other) &#123;        return other; //忽略值，返回 other    &#125;    filter() &#123;        return this.value; //如果存在的值满足所给的断言，则返回包含值的 Just，否则，返回 Nothing    &#125;    get isNothing() &#123;        return true;    &#125;    toString() &#123;        return &#x27;Maybe.Nothing&#x27;; //返回结构的文本描述    &#125;&#125;\n\nMaybe显式地抽象对“可空”值（null和undefined）的操作，可让开发者关注更重要的事情。如上述代码所示，Maybe是Just和Nothing的抽象，Just和Nothing各自包含自己的Monadic的实现。正如前面提到的，对于Monadic操作的实现最终取决于具体类型给予的语义。例如，map的行为具体取决于该类型是 Nothing 还是Just\nconst find = (db, id) =&gt; (id ? &#123;    name: &#x27;小红&#x27;,    address: &#x27;北京&#x27;&#125; : undefined)const findStudent = R.curry((db, id) =&gt; Maybe.fromNullable(find(db, id)))const findStudentByDB = findStudent(&#x27;DB&#x27;);// 如果有意义得值传入会生成justconsole.log(findStudentByDB(&#x27;id&#x27;).map(R.prop(&#x27;address&#x27;)).value)// 如果没有意义得值会生成nothing,如果使用value取值会报错console.log(findStudentByDB(undefined).map(R.prop(&#x27;address&#x27;)).getOrElse(123))//赋值时需要注意document.querySelector(&#x27;#student-firstname&#x27;).value = username.getOrElse(&#x27;Enter first name&#x27;);\n\n提升函数\n很明显，Maybe擅长于集中管理的无效数据的检查，但它没有（双关Nothing）提供关于什么地方出了错的信息。我们需要一个更积极的，可以知道失败原因的解决方案。解决这个问题，要最好的工具是Either monad。\n使用EitherEither跟Maybe略有不同。Either代表的是两个逻辑分离的值a和b，它们永远不会同时出现。这种类型包括以下两种情况。\nLeft(a)——包含一个可能的错误消息或抛出的异常对象。Right(b)——包含一个成功的值。\nEither通常操作右值，这意味着在容器上映射函数总是在Right(b)子类型上执行。它类似于Maybe的Just分支。\nEither的常见用法是为失败的结果提供更多的信息。在不可恢复的情况下，左侧可以包含一个合适的异常对象\n与MayBe 类似，合法值也是主右的\nIO Monad","categories":["JavaScript"],"tags":["函数式编程"]},{"title":"Ramda List 方法源码分析","url":"/posts/f7e795e13d0b/","content":"adjust判断索引的合法性\n定义开始节点，其实就是抽象了计算真实索引的计算\nvar adjust = _curry3(function adjust(idx, fn, list) &#123;  if (idx &gt;= list.length || idx &lt; -list.length) &#123;    return list;  &#125;  var start = idx &lt; 0 ? list.length : 0;  var _idx = start + idx;  var _list = _concat(list);  _list[_idx] = fn(list[_idx]);  return _list;&#125;);\n\n\nall_dispatchable\nvar all = _curry2(_dispatchable([&#x27;all&#x27;], _xall, function all(fn, list) &#123;  var idx = 0;  while (idx &lt; list.length) &#123;    if (!fn(list[idx])) &#123;      return false;    &#125;    idx += 1;  &#125;  return true;&#125;));export default all;","categories":["JavaScript"],"tags":["函数式编程","Ramda"]},{"title":"Ramda Math 方法源码分析","url":"/posts/fe66a7d19245/","content":"","categories":["JavaScript"],"tags":["函数式编程","Ramda"]},{"title":"Ramda Object方法源码分析","url":"/posts/f021f8110e5a/","content":"keysSafari 可能存在 argument.length 可枚举的bug\nvar hasArgsEnumBug = (function() &#123;  &#x27;use strict&#x27;;  return arguments.propertyIsEnumerable(&#x27;length&#x27;);&#125;());\n\nIE9一下toString方法存在可以枚举的bug\n// cover IE &lt; 9 keys issuesvar hasEnumBug = !(&#123;toString: null&#125;).propertyIsEnumerable(&#x27;toString&#x27;);var nonEnumerableProps = [  &#x27;constructor&#x27;, &#x27;valueOf&#x27;, &#x27;isPrototypeOf&#x27;, &#x27;toString&#x27;,  &#x27;propertyIsEnumerable&#x27;, &#x27;hasOwnProperty&#x27;, &#x27;toLocaleString&#x27;];\n\n// 如果有原生 Object.keys 实现且Safari不存在bugvar keys = typeof Object.keys === &#x27;function&#x27; &amp;&amp; !hasArgsEnumBug ?  _curry1(function keys(obj) &#123;    // 参数错误处理    return Object(obj) !== obj ? [] : Object.keys(obj);  &#125;) :  _curry1(function keys(obj) &#123;    if (Object(obj) !== obj) &#123;      return [];    &#125;    var prop, nIdx;    var ks = [];    // 如果传入的对象时argument，而且有bug    var checkArgsLength = hasArgsEnumBug &amp;&amp; _isArguments(obj);    // 循环对象每一项检查    for (prop in obj) &#123;      if (_has(prop, obj) &amp;&amp; (!checkArgsLength || prop !== &#x27;length&#x27;)) &#123;        ks[ks.length] = prop;      &#125;    &#125;    // 如果有toString可枚举的bug    if (hasEnumBug) &#123;      nIdx = nonEnumerableProps.length - 1;      // 排除不可枚举的属性      while (nIdx &gt;= 0) &#123;        prop = nonEnumerableProps[nIdx];        if (_has(prop, obj) &amp;&amp; !contains(ks, prop)) &#123;          ks[ks.length] = prop;        &#125;        nIdx -= 1;      &#125;    &#125;    return ks;  &#125;);","categories":["JavaScript"],"tags":["函数式编程","Ramda"]},{"title":"Ramda Relation 方法源码分析","url":"/posts/4b3e617e083b/","content":"","categories":["JavaScript"],"tags":["函数式编程","Ramda"]},{"title":"Ramda Type 方法源码解析","url":"/posts/4f5e1b8629c3/","content":"typetoString 方法是Object内部实现的原型方法，实现方式中规定了某种类型的返回值\nvar type = _curry1(function type(val) &#123;  return val === null    ? &#x27;Null&#x27;    : val === undefined      ? &#x27;Undefined&#x27;      : Object.prototype.toString.call(val).slice(8, -1);&#125;);export default type;","categories":["JavaScript"],"tags":["函数式编程","Ramda"]},{"title":"Ramda 私有方法源码分析","url":"/posts/589c737a0260/","content":"_objectIsObject.is 用于判断两值是否项等\nfunction _objectIs(a, b) &#123;  // MDN polyfill  if (a === b) &#123;    // Steps 6.b-6.e: +0 != -0    return a !== 0 || 1 / a === 1 / b;  &#125; else &#123;    // Step 6.a: NaN == NaN    return a !== a &amp;&amp; b !== b;  &#125;&#125;export default typeof Object.is === &#x27;function&#x27; ? Object.is : _objectIs;\n\n_arrayFromIteratorexport default function _arrayFromIterator(iter) &#123;  var list = [];  var next;  while (!(next = iter.next()).done) &#123;    list.push(next.value);  &#125;  return list;&#125;\n\n_functionNamefunction.name 可能被压缩工具修改，不能依赖函数名来判断函数\n作者通过正则方式判断\nexport default function _functionName(f) &#123;  // String(x =&gt; x) evaluates to &quot;x =&gt; x&quot;, so the pattern may not match.  var match = String(f).match(/^function (\\w*)/);  return match == null ? &#x27;&#x27; : match[1];&#125;\n\n_has判断属性在对象的实例上，而不是在原型上\nexport default function _has(prop, obj) &#123;  return Object.prototype.hasOwnProperty.call(obj, prop);&#125;\n\n等价于\nReflect.has(obj, prop)\n\n\n_isArguments实现了 callee 方法数组也可以当作是形式参数\nvar toString = Object.prototype.toString;var _isArguments = (function() &#123;  return toString.call(arguments) === &#x27;[object Arguments]&#x27; ?    function _isArguments(x) &#123; return toString.call(x) === &#x27;[object Arguments]&#x27;; &#125; :    function _isArguments(x) &#123; return _has(&#x27;callee&#x27;, x); &#125;;&#125;());\n\n_concat通过双循环，涵盖了array-like类型，\n/** * Private `concat` function to merge two array-like objects. * * @private * @param &#123;Array|Arguments&#125; [set1=[]] An array-like object. * @param &#123;Array|Arguments&#125; [set2=[]] An array-like object. * @return &#123;Array&#125; A new, merged array. * @example * *      _concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3] */export default function _concat(set1, set2) &#123;  set1 = set1 || [];  set2 = set2 || [];  var idx;  var len1 = set1.length;  var len2 = set2.length;  var result = [];  idx = 0;  while (idx &lt; len1) &#123;    result[result.length] = set1[idx];    idx += 1;  &#125;  idx = 0;  while (idx &lt; len2) &#123;    result[result.length] = set2[idx];    idx += 1;  &#125;  return result;&#125;\n\n\n_dispatchabledispatchable翻译为调度单元，这个方法用在了类似 R.all 遍历每一项的方法上\n如果如参是一个数组会按照常规循环方式处理，如果不是数组但是对象携带了传入的方法s数组([all])其中的一个，将会调用对象携带的方法\nexport default function _dispatchable(methodNames, transducerCreator, fn) &#123;  return function() &#123;    if (arguments.length === 0) &#123;      return fn();    &#125;    var obj = arguments[arguments.length - 1];    if (!_isArray(obj)) &#123;      var idx = 0;      while (idx &lt; methodNames.length) &#123;        if (typeof obj[methodNames[idx]] === &#x27;function&#x27;) &#123;          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));        &#125;        idx += 1;      &#125;      if (_isTransformer(obj)) &#123;        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));        return transducer(obj);      &#125;    &#125;    return fn.apply(this, arguments);  &#125;;&#125;\n\n_arrayFromIteratorexport default function _arrayFromIterator(iter) &#123;  var list = [];  var next;  while (!(next = iter.next()).done) &#123;    list.push(next.value);  &#125;  return list;&#125;\n\n_equals用在了涉及到比较的方法上,例如 R.equals\n_objectIs\ntype\n_arrayFromIterator\n// 处理map set 集合function _uniqContentEquals(aIterator, bIterator, stackA, stackB) &#123;  var a = _arrayFromIterator(aIterator);  var b = _arrayFromIterator(bIterator);  function eq(_a, _b) &#123;    return _equals(_a, _b, stackA.slice(), stackB.slice());  &#125;  // if *a* array contains any element that is not included in *b*  return !_includesWith(function(b, aItem) &#123;    return !_includesWith(eq, aItem, b);  &#125;, b, a);&#125;export default function _equals(a, b, stackA, stackB) &#123;  // 引用相同，基本类型的值相同  if (_objectIs(a, b)) &#123;    return true;  &#125;  // 类型不同  var typeA = type(a);  if (typeA !== type(b)) &#123;    return false;  &#125;  // 引用不同的情况  //  ??????  if (typeof a[&#x27;fantasy-land/equals&#x27;] === &#x27;function&#x27; || typeof b[&#x27;fantasy-land/equals&#x27;] === &#x27;function&#x27;) &#123;    return typeof a[&#x27;fantasy-land/equals&#x27;] === &#x27;function&#x27; &amp;&amp; a[&#x27;fantasy-land/equals&#x27;](b) &amp;&amp;      typeof b[&#x27;fantasy-land/equals&#x27;] === &#x27;function&#x27; &amp;&amp; b[&#x27;fantasy-land/equals&#x27;](a);  &#125;  // 如果自身实现了equals方法  if (typeof a.equals === &#x27;function&#x27; || typeof b.equals === &#x27;function&#x27;) &#123;    return typeof a.equals === &#x27;function&#x27; &amp;&amp; a.equals(b) &amp;&amp;      typeof b.equals === &#x27;function&#x27; &amp;&amp; b.equals(a);  &#125;  // 其他引用类型  switch (typeA) &#123;    case &#x27;Arguments&#x27;:    case &#x27;Array&#x27;:    case &#x27;Object&#x27;:      // 引用类型如果为Promise实例，看作是项等的      if (typeof a.constructor === &#x27;function&#x27; &amp;&amp;        _functionName(a.constructor) === &#x27;Promise&#x27;) &#123;        return a === b;      &#125;      break;    // 基本类型的装箱对象    case &#x27;Boolean&#x27;:    case &#x27;Number&#x27;:    case &#x27;String&#x27;:      if (!(typeof a === typeof b &amp;&amp; _objectIs(a.valueOf(), b.valueOf()))) &#123;        return false;      &#125;      break;    case &#x27;Date&#x27;:    // 时间类型转为事件戳      if (!_objectIs(a.valueOf(), b.valueOf())) &#123;        return false;      &#125;      break;    case &#x27;Error&#x27;:      return a.name === b.name &amp;&amp; a.message === b.message;    case &#x27;RegExp&#x27;:    // 正则类型的所有实例方法的实现相同      if (!(a.source === b.source &amp;&amp;          a.global === b.global &amp;&amp;          a.ignoreCase === b.ignoreCase &amp;&amp;          a.multiline === b.multiline &amp;&amp;          a.sticky === b.sticky &amp;&amp;          a.unicode === b.unicode)) &#123;        return false;      &#125;      break;  &#125;  // 处理map set集合  var idx = stackA.length - 1;  while (idx &gt;= 0) &#123;    if (stackA[idx] === a) &#123;      return stackB[idx] === b;    &#125;    idx -= 1;  &#125;  switch (typeA) &#123;    case &#x27;Map&#x27;:      if (a.size !== b.size) &#123;        return false;      &#125;      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));    case &#x27;Set&#x27;:      if (a.size !== b.size) &#123;        return false;      &#125;      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));    case &#x27;Arguments&#x27;:    case &#x27;Array&#x27;:    case &#x27;Object&#x27;:    case &#x27;Boolean&#x27;:    case &#x27;Number&#x27;:    case &#x27;String&#x27;:    case &#x27;Date&#x27;:    case &#x27;Error&#x27;:    case &#x27;RegExp&#x27;:    case &#x27;Int8Array&#x27;:    case &#x27;Uint8Array&#x27;:    case &#x27;Uint8ClampedArray&#x27;:    case &#x27;Int16Array&#x27;:    case &#x27;Uint16Array&#x27;:    case &#x27;Int32Array&#x27;:    case &#x27;Uint32Array&#x27;:    case &#x27;Float32Array&#x27;:    case &#x27;Float64Array&#x27;:    case &#x27;ArrayBuffer&#x27;:      break;    default:      // Values of other types are only equal if identical.      // 其他类型只有引用相同才算项等      return false;  &#125;  // 处理数组或对象的每一个值是否项等  var keysA = keys(a);  if (keysA.length !== keys(b).length) &#123;    return false;  &#125;  var extendedStackA = stackA.concat([a]);  var extendedStackB = stackB.concat([b]);  idx = keysA.length - 1;  while (idx &gt;= 0) &#123;    var key = keysA[idx];    if (!(_has(key, b) &amp;&amp; _equals(b[key], a[key], extendedStackA, extendedStackB))) &#123;      return false;    &#125;    idx -= 1;  &#125;  return true;&#125;","categories":["JavaScript"],"tags":["函数式编程","Ramda"]},{"title":"Ramda中的柯理化","url":"/posts/6d8100d82f85/","content":"_curry1内置接口，保证了参数的个数，无需判断\n/** * Optimized internal one-arity curry function. * * @private * @category Function * @param &#123;Function&#125; fn The function to curry. * @return &#123;Function&#125; The curried function. */export default function _curry1(fn) &#123;  return function f1(a) &#123;    if (arguments.length === 0 || _isPlaceholder(a)) &#123;      return f1;    &#125; else &#123;      return fn.apply(this, arguments);    &#125;  &#125;;&#125;\n\n\n_curry2如果以值的真假为纬度分支会比较复杂，而且不能正确参数的位置\nconst _curry2 = function (fn) &#123;  return function f2(a, b) &#123;    return a !== undefined &amp;&amp; b !== undefined      ? _isPlaceholder(a) &amp;&amp; _isPlaceholder(b)        ? f2        : isPlaceholder(a)          ? _curry1(function (_a) &#123; return fn(_a, b) &#125;)          : _isPlaceholder(b)            ? _curry1(function (_b) &#123; return fn(a, _b) &#125;)            : fn.apply(this, arguments)      : a !== undefined        ? _curry1(function (_b) &#123; return fn(a, _b) &#125;)        : f2  &#125;&#125;\n\n作者以参数的个数为纬度考虑\n/** * Optimized internal two-arity curry function. * * @private * @category Function * @param &#123;Function&#125; fn The function to curry. * @return &#123;Function&#125; The curried function. */export default function _curry2(fn) &#123;  return function f2(a, b) &#123;    switch (arguments.length) &#123;      case 0:        return f2;      case 1:        // 如果a传入的是undefined也是一个参数        return _isPlaceholder(a)          ? f2          : _curry1(function(_b) &#123; return fn(a, _b); &#125;);      default:        return _isPlaceholder(a) &amp;&amp; _isPlaceholder(b)          ? f2          : _isPlaceholder(a)            ? _curry1(function(_a) &#123; return fn(_a, b); &#125;)            : _isPlaceholder(b)              ? _curry1(function(_b) &#123; return fn(a, _b); &#125;)              : fn(a, b);    &#125;  &#125;;&#125;\n\n\n_curry3同理增加分支判断\n/** * Optimized internal three-arity curry function. * * @private * @category Function * @param &#123;Function&#125; fn The function to curry. * @return &#123;Function&#125; The curried function. */export default function _curry3(fn) &#123;  return function f3(a, b, c) &#123;    switch (arguments.length) &#123;      case 0:        return f3;      case 1:        return _isPlaceholder(a)          ? f3          : _curry2(function(_b, _c) &#123; return fn(a, _b, _c); &#125;);      case 2:        return _isPlaceholder(a) &amp;&amp; _isPlaceholder(b)          ? f3          : _isPlaceholder(a)            ? _curry2(function(_a, _c) &#123; return fn(_a, b, _c); &#125;)            : _isPlaceholder(b)              ? _curry2(function(_b, _c) &#123; return fn(a, _b, _c); &#125;)              : _curry1(function(_c) &#123; return fn(a, b, _c); &#125;);      default:        return _isPlaceholder(a) &amp;&amp; _isPlaceholder(b) &amp;&amp; _isPlaceholder(c)          ? f3          // 其中两个是占位符的情况          : _isPlaceholder(a) &amp;&amp; _isPlaceholder(b)            ? _curry2(function(_a, _b) &#123; return fn(_a, _b, c); &#125;)            : _isPlaceholder(a) &amp;&amp; _isPlaceholder(c)              ? _curry2(function(_a, _c) &#123; return fn(_a, b, _c); &#125;)              : _isPlaceholder(b) &amp;&amp; _isPlaceholder(c)                ? _curry2(function(_b, _c) &#123; return fn(a, _b, _c); &#125;)                // 其中一个是占位符的情况                : _isPlaceholder(a)                  ? _curry1(function(_a) &#123; return fn(_a, b, c); &#125;)                  : _isPlaceholder(b)                    ? _curry1(function(_b) &#123; return fn(a, _b, c); &#125;)                    : _isPlaceholder(c)                      ? _curry1(function(_c) &#123; return fn(a, b, _c); &#125;)                      : fn(a, b, c);    &#125;  &#125;;&#125;\n\ncurry共有方法curry的实现， 对共有方法curryN的封装，在不确定参数个数时候通过 fn.length 获取参数长度\nvar curry = _curry1(function curry(fn) &#123;  return curryN(fn.length, fn);&#125;);\n\ncurryN需要指定参数的个数， 抽象出参数个数的判断，最多个数为10个，防止参数过多造成栈溢出\n_arity 对参数个数的处理\nexport default function _arity(n, fn) &#123;  /* eslint-disable no-unused-vars */  switch (n) &#123;    case 0: return function() &#123; return fn.apply(this, arguments); &#125;;    case 1: return function(a0) &#123; return fn.apply(this, arguments); &#125;;    case 2: return function(a0, a1) &#123; return fn.apply(this, arguments); &#125;;    // ...    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) &#123; return fn.apply(this, arguments); &#125;;    default: throw new Error(&#x27;First argument to _arity must be a non-negative integer no greater than ten&#x27;);  &#125;&#125;\n\nvar curryN = _curry2(function curryN(length, fn) &#123;  if (length === 1) &#123;    return _curry1(fn);  &#125;  return _arity(length, _curryN(length, [], fn));&#125;);\n\n在参数较少时使用其他的内置方法  \nfunction curryN(length, fn) &#123;  return _curry2(function (length, fn) &#123;    return length === 1      ? _curry1(fn)      : length === 2        ? _curry2(fn)        : length === 3          ? _curry3(fn)          : _arity(length, _curryN(length, [], fn))  &#125;)&#125;\n\n\n_curryN 核心方法下面是一段糟糕的代码\nreceive保持了源数组的引用，不符合函数式编成数据不可变的思想\n每次添加新参数，都要查询可添加的位置\n// 1. 真实参数个数和length项等 则执行函数// 2. 实时记录占位符的位置， 新参数优先放到占位符function _curryN(length, receive, fn) &#123;  return function fN() &#123;    var index = 0;    var zw = 0;    function findzw(zw, receive) &#123;      while (zw &lt; receive.length) &#123;        if (_isPlaceholder(receive[zw])) &#123;          //指向占位符的前一位， 方便后面处理          return zw - 1        &#125;        zw++      &#125;      return zw - 1    &#125;    // 找到占位符的位置    zw = findzw(zw, receive);    while (index &lt; arguments.length) &#123;      receive[zw + 1] = arguments[index];      //更新之后重新查找占位符, 条过当前的占位符      zw = findzw(zw + 1, receive);      index++;    &#125;    // 没有占位符 则位置+1为参数长度    if (zw + 1 === length) &#123;      return fn.apply(this, receive)    &#125; else &#123;      // 计算剩余参数      var j = 0;      var len = 0      while (j &lt; receive.length) &#123;        if (!_isPlaceholder(receive[index])) &#123;          len++;        &#125;        j++      &#125;      return _arity(length - len, _curryN(length, receive, fn))    &#125;  &#125;&#125;\n\n源码的实现\nfunction _curryN(length, receive, fn) &#123;  return function () &#123;    // 复制已接受参数的数组    var combined = [];    // 遍历入参的索引    var argsIdx = 0;    // 剩余参数    var left = length;    // 遍历已接受参数索引    var combinedIdx = 0;    // 如果参数没有复制完成，或新如参没有添加完成则继续执行    while (combinedIdx &lt; received.length || argsIdx &lt; arguments.length) &#123;      var result;      // 通过条件语句处理了占位符的问题      // 如果老参数没有复制完成，且复制的值不是占位符，或者入参已经都处理了，直接取出当前的老参数，用于复制到新的数组中      // 通过双指针解决占位符的问题      if (combinedIdx &lt; received.length &amp;&amp;        (!_isPlaceholder(received[combinedIdx]) ||          argsIdx &gt;= arguments.length)) &#123;        result = received[combinedIdx];      &#125; else &#123;        // 如果老参数都复制完，或者时占位符，或者还有新参数没有复制        // 取一个新参数加到数组中        result = arguments[argsIdx];        argsIdx += 1;      &#125;      // 添加到新数组中      combined[combinedIdx] = result;      // 如果不是占位符剩余参数 -1      if (!_isPlaceholder(result)) &#123;        left -= 1;      &#125;      combinedIdx += 1;    &#125;    // 如果没有剩余参数直接执行    return left &lt;= 0      ? fn.apply(this, combined)      // 否则通过_arity固定新函数的参数个数      : _arity(left, _curryN(length, combined, fn));  &#125;;&#125;\n","categories":["JavaScript"],"tags":["函数式编程","Ramda"]},{"title":"Symbol实现","url":"/posts/b7da4eaa8d00/","content":"Symbol类型的行为1.类型检测Symbol 值通过 Symbol 函数生成，使用 typeof，结果为 “symbol”\n2.不能使用newSymbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。\n3.instanceof 的结果为 falsevar s = Symbol(&#x27;foo&#x27;);console.log(s instanceof Symbol); // false\n\n4.参数接受var s1 = Symbol(&#x27;foo&#x27;);console.log(s1); // Symbol(foo)\n\n如果接受的是一个对象调用的则是对象的 toString 方法\n5.不能运算Symbol 值不能与其他类型的值进行运算，会报错。\nvar sym = Symbol(&#x27;My symbol&#x27;); console.log(&quot;your symbol is &quot; + sym); // TypeError: can&#x27;t convert symbol to string\n\n6.可以转换为字符串var sym = Symbol(&#x27;My symbol&#x27;); console.log(String(sym)); // &#x27;Symbol(My symbol)&#x27;console.log(sym.toString()); // &#x27;Symbol(My symbol)&#x27;\n\n7.可以当作属性名Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。\nvar mySymbol = Symbol(); // 第一种写法var a = &#123;&#125;;a[mySymbol] = &#x27;Hello!&#x27;; // 第二种写法var a = &#123;  [mySymbol]: &#x27;Hello!&#x27;&#125;; // 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &#x27;Hello!&#x27; &#125;); // 以上写法都得到同样结果console.log(a[mySymbol]); // &quot;Hello!&quot;\n\n8.不能枚举Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。\nvar obj = &#123;&#125;;var a = Symbol(&#x27;a&#x27;);var b = Symbol(&#x27;b&#x27;); obj[a] = &#x27;Hello&#x27;;obj[b] = &#x27;World&#x27;; var objectSymbols = Object.getOwnPropertySymbols(obj); console.log(objectSymbols);// [Symbol(a), Symbol(b)]\n\n9.Symbol.for如果我们希望使用同一个 Symbol 值，可以使用 Symbol.for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。\nvar s1 = Symbol.for(&#x27;foo&#x27;);var s2 = Symbol.for(&#x27;foo&#x27;); console.log(s1 === s2); // true\n\n10.Symbol.keyForSymbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。\nvar s1 = Symbol.for(&quot;foo&quot;);console.log(Symbol.keyFor(s1)); // &quot;foo&quot; var s2 = Symbol(&quot;foo&quot;);console.log(Symbol.keyFor(s2) ); // undefined\n\npolyfile分析Symbol 返回一个独一无二的值，根据官方文档symbol的创建步骤\n\nSymbol ( [ description ] )\n\n  When Symbol is called with optional argument description, the following steps are taken:\n  If NewTarget is not undefined, throw a TypeError exception.  If description is undefined, var descString be undefined.  Else, var descString be ToString(description).  ReturnIfAbrupt(descString).  Return a new unique Symbol value whose [[Description]] value is descString.\n\n如果使用 new ，就报错\n如果 description 是 undefined，让 descString 为 undefined\n否则 让 descString 为 ToString(description)\n如果报错，就返回\n返回一个新的唯一的 Symbol 值，它的内部属性 [[Description]] 值为 descString\n\n还需要定义一个 [[Description]] 属性，如果直接返回一个基本类型的值，是无法做到这一点的，所以我们最终还是返回一个对象\n第一版var SymbolPolyfill = function Symbol(description) &#123;      // 实现特性第 2 点：Symbol 函数前不能使用 new 命令      if (this instanceof SymbolPolyfill) throw new TypeError(&#x27;Symbol is not a constructor&#x27;);      // 实现特性第 4 点：如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。      var descString = description === undefined ? undefined : String(description)      // 实现第六点：可以转为字符串      var symbol = Object.create(&#123;        toString: function() &#123;          return &#x27;Symbol(&#x27; + this.__Description__ + &#x27;)&#x27;;        &#125;,        // 不能与其他值运算        // 对于原生 Symbol，显式调用 valueOf 方法，会直接返回该 Symbol 值，        // 而我们又无法判断是显式还是隐式的调用，所以这个我们就只能实现一半，要不然实现隐式调用报错，要不然实现显式调用返回该值，        valueOf: function() &#123;          throw new Error(&#x27;Cannot convert a Symbol value&#x27;)        &#125;      &#125;)      Object.defineProperties(symbol, &#123;          &#x27;__Description__&#x27;: &#123;              value: descString,              writable: false,              enumerable: false,              configurable: false          &#125;      &#125;);      // 实现特性第 6 点，因为调用该方法，返回的是一个新对象，两个对象之间，只要引用不同，就不会相同      return symbol;  &#125;\n\n第三版当我们模拟的所谓 Symbol 值其实是一个有着 toString 方法的 对象，当对象作为对象的属性名的时候，就会进行隐式类型转换，还是会调用我们添加的 toString 方法，对于 Symbol(‘foo’) 和 Symbol(‘foo’)两个 Symbol 值，虽然描述一样，但是因为是两个对象，所以并不相等，但是当作为对象的属性名的时候，都会隐式转换为 Symbol(foo) 字符串，这个时候就会造成同名的属性。\nvar a = SymbolPolyfill(&#x27;foo&#x27;);var b = SymbolPolyfill(&#x27;foo&#x27;); console.log(a ===  b); // false var o = &#123;&#125;;o[a] = &#x27;hello&#x27;;o[b] = &#x27;hi&#x27;; console.log(o); // &#123;Symbol(foo): &#x27;hi&#x27;&#125;\n\n为了防止不会出现同名的属性，毕竟这是一个非常重要的特性，迫不得已，我们需要修改 toString 方法，让它返回一个唯一值，所以第 8 点就无法实现了，而且我们还需要再写一个用来生成 唯一值的方法，就命名为 generateName，我们将该唯一值添加到返回对象的 Name 属性中保存下来。\nvar generateName = (function()&#123;        var postfix = 0;        return function(descString)&#123;            postfix++;            return &#x27;@@&#x27; + descString + &#x27;_&#x27; + postfix        &#125;    &#125;)()     var SymbolPolyfill = function Symbol(description) &#123;         if (this instanceof SymbolPolyfill) throw new TypeError(&#x27;Symbol is not a constructor&#x27;);         var descString = description === undefined ? undefined : String(description)         var symbol = Object.create(&#123;            toString: function() &#123;                return this.__Name__;            &#125;        &#125;)         Object.defineProperties(symbol, &#123;            &#x27;__Description__&#x27;: &#123;                value: descString,                writable: false,                enumerable: false,                configurable: false            &#125;,            &#x27;__Name__&#x27;: &#123;                value: generateName(descString),                writable: false,                enumerable: false,                configurable: false            &#125;        &#125;);         return symbol;    &#125;\n\n第四版var generateName = (function()&#123;        var postfix = 0;        return function(descString)&#123;            postfix++;            return &#x27;@@&#x27; + descString + &#x27;_&#x27; + postfix        &#125;    &#125;)()     var SymbolPolyfill = function Symbol(description) &#123;         if (this instanceof SymbolPolyfill) throw new TypeError(&#x27;Symbol is not a constructor&#x27;);         var descString = description === undefined ? undefined : String(description)         var symbol = Object.create(&#123;            toString: function() &#123;                return this.__Name__;            &#125;,            valueOf: function() &#123;                return this;            &#125;        &#125;)         Object.defineProperties(symbol, &#123;            &#x27;__Description__&#x27;: &#123;                value: descString,                writable: false,                enumerable: false,                configurable: false            &#125;,            &#x27;__Name__&#x27;: &#123;                value: generateName(descString),                writable: false,                enumerable: false,                configurable: false            &#125;        &#125;);         return symbol;    &#125;    // 遍历 forMap,查找该值对应的键值即可。    var forMap = &#123;&#125;;     Object.defineProperties(SymbolPolyfill, &#123;        &#x27;for&#x27;: &#123;            value: function(description) &#123;                var descString = description === undefined ? undefined : String(description)                return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);            &#125;,            writable: true,            enumerable: false,            configurable: true        &#125;,        &#x27;keyFor&#x27;: &#123;            value: function(symbol) &#123;                for (var key in forMap) &#123;                    if (forMap[key] === symbol) return key;                &#125;            &#125;,            writable: true,            enumerable: false,            configurable: true        &#125;    &#125;);","categories":["JavaScript"],"tags":["Symbol"]},{"title":"Babel 源码与插件","url":"/posts/c106a03ba7c5/","content":"调式源码git clone https://github.com/&lt;your-github-username&gt;/babelcd babelmake bootstrap# 在想要调试文件的入口处添加断点# -i 指定测试package# -t 指定测试用例 fixturesyarn run  jest -i packages/babel-parser -t &#x27;es2016/simple parameter list/arrow function&#x27;\n\n插件开发最小化环境相关依赖包\n&#123;  &quot;babel-plugin-tester&quot;: &quot;^11.0.4&quot;,  &quot;jest&quot;: &quot;^29.7.0&quot;,  &quot;ts-jest&quot;: &quot;^29.2.6&quot;,  &quot;ts-node&quot;: &quot;^10.9.2&quot;,  &quot;typescript&quot;: &quot;^5.8.2&quot;&#125;\n\n测试文件入口与 fixtures 用例\n//__test__/index.tsimport &#123; pluginTester &#125; from &quot;babel-plugin-tester&quot;;import insertLogPlugin from &quot;../plugins/babel-plugin-insert-log&quot;;import path from &quot;path&quot;;pluginTester(&#123;  plugin: insertLogPlugin,  babelOptions: &#123;    plugins: [&quot;@babel/plugin-syntax-jsx&quot;],  &#125;,  fixtures: path.join(__dirname, &quot;fixtures&quot;),&#125;);\n\n// __tests__/fixtures/in-arrow-function/code.tsconst a = () =&gt; console.log(1);// __tests__/fixtures/in-arrow-function/output.tsconst a = () =&gt; &#123;  console.log(1);&#125;;\n\njest 配置文件, 排除 fixtures 目录下的测试用例，避免多次执行\n/** @type &#123;import(&#x27;ts-jest&#x27;).JestConfigWithTsJest&#125; **/module.exports = &#123;  testEnvironment: &quot;node&quot;,  transform: &#123;    &quot;^.+.tsx?$&quot;: [&quot;ts-jest&quot;, &#123;&#125;],  &#125;,  testMatch: [&quot;**/__tests__/**/*&quot;, &quot;!**/fixtures/**/*&quot;],&#125;;\n\nbabel-parser使用多个类继承，完善 parser 功能\nexport default class Parser extends StatementParser&#123;&#125;abstract class StatementParser extends ExpressionParser&#123;&#125;abstract class ExpressionParser extends LValParser&#123;&#125;abstract class LValParser extends NodeUtils&#123;&#125;abstract class NodeUtils extends UtilParser&#123;&#125;abstract class UtilParser extends Tokenizer&#123;&#125;abstract class Tokenizer extends CommentsParser&#123;&#125;class CommentsParser extends BaseParser&#123;&#125;\n\n解析 le\\\\u0074 x = 5 流程：\n\n实例化 Parser，调用 parse 方法开始解析\n\n初始化 file, grogram 节点\n\n尝试解析 token\n\n跳过空白符，注释等\n\n根据第一个字符判断要如何解析， 比如 l 为一个小写字母， 会被当作 Identifier 解析\n\n尝试读取完成的标识符\nthis.state.pos += str &lt;= 0xffff ? 1 : 2; 如果字符 charCode 大于 0xffff 例如 龘, 则向后移动两个字符\n如果匹配到 \\, 则判断是否是一个 Unicode 转义序列,后面三位必须是 \\\\u 开头，如果不是则标记错误\n如果是一个转移字符，尝试读取这个转义字符并返回, 因此第一个 token 会是 let\n\n解析 Program 节点，let 作为 ExpressionStatement 加入 Program 节点，保存在 body 数组中\n继续尝试解析 x &#x3D; 5 这个表达式作为 AssignmentExpression，x 和 5 作为 Identifier 和 NumericLiteral 加入 AssignmentExpression 分别作为 left 和 right\n\n\n\n\n最终形成的树结构就是 ast.\n","categories":["JavaScript"],"tags":["Babel"]},{"title":"实现自己的 call(),apply(),bind(),new()","url":"/posts/c0b3cf5248bf/","content":"call()第一步，改变 this 的指向, 当函数作为对象属性调用时，this 会指向对象，因此需要将参数包装成一个对象\nFunction.prototype.myCall = function (thisArg) &#123;  let that = thisArg;  if (that === undefined || that === null) that = window;  if (typeof that === &quot;number&quot;) that = new Number(that);  if (typeof that === &quot;string&quot;) that = new String(that);  if (typeof that === &quot;boolean&quot;) that = new Boolean(that);  if (typeof that === &quot;bigint&quot;) that = new BigInt(that);  that.fn = this;  that.fn();&#125;;function a() &#123;  console.log(this);&#125;a.myCall(1);a.myCall(&quot;2&quot;);\n\n第二步，实现参数的传递，如果使用 ES6 可以使用剩余参数和扩展运算符\nFunction.prototype.myCall = function (thisArg, ...args) &#123;  thisArg.fn = this;  thisArg.fn(...args);&#125;;function a(a, b, c) &#123;  console.log(this, a, b, c);&#125;a.myCall(&#123; name: &quot;name&quot; &#125;, 1, 2, 3);\n\n在 ES5 中只用通过 eval() 实现，它可以执行一段字符串的脚本, 可以使用一个数组收集参数。\nFunction.prototype.myCall = function (thisArg) &#123;  var that = thisArg;  if (that === undefined || that === null) that = global;  if (typeof that === &quot;number&quot;) that = new Number(that);  if (typeof that === &quot;string&quot;) that = new String(that);  if (typeof that === &quot;boolean&quot;) that = new Boolean(that);  if (typeof that === &quot;bigint&quot;) that = new BigInt(that);  if (typeof that === &quot;symbol&quot;) that = new Symbol(that);  var args = [];  for (var i = 1; i &lt; arguments.length; i++) &#123;    args.push(&quot;arguments[&quot; + i + &quot;]&quot;);  &#125;  that.fn = this;  // 这里args会进行隐式类型转换，调用toString方法  return eval(&quot;that.fn(&quot; + args + &quot;)&quot;);&#125;;function a(a, b, c) &#123;  console.log(this, a, b, c);  return a + b + c;&#125;console.log(a.myCall(null, 1, 2, 3));\n\n第三步，消除副作用， 由于在执行前在 thisArg 上添加了，fn 方法所以需要清除，也可以使用 Symbol 或自定义的随机数，从创建唯一的标识\n&#123;  var result = eval(&quot;that.fn(&quot; + args + &quot;)&quot;);  delete that.fn;  return result;&#125;\n\napply()apply 与 call 的区别只是参数的形式是数组，因此可以直接遍历参数，而不用使用 arguments\nFunction.prototype.myApply = function (thisArg, args) &#123;  var argsArr = [];  var result = void 0;  thisArg.fn = this;  if (!args) &#123;    result = eval(&quot;that.fn()&quot;);  &#125; else &#123;    for (var i = 1; i &lt; args.length; i++) &#123;      argsArr.push(&quot;arguments[&quot; + i + &quot;]&quot;);    &#125;    result = eval(&quot;that.fn(&quot; + args + &quot;)&quot;);  &#125;  // 这里args会进行隐式类型转换，调用toString方法  delete that.fn;  return result;&#125;;\n\nbind()第一步, 验证 this 必须是一个函数， 这是为了避免 bind 方法 this 被修改 fn.bind.call(null), 把 this 包装成新的函数并返回\nFunction.prototype.myBind = function (thisArg) &#123;  if (typeof this !== &quot;function&quot;)    throw new TypeError(&quot;Bind must be called on a function&quot;);  var boundTargetFunction = this;  var args =  return function boundFunction() &#123;    return boundTargetFunction.apply(newThis);  &#125;;&#125;;\n\n第二步，处理参数，新函数调用时的参数需要和 bind 执行时的参数合并，共同传递给原函数\nFunction.prototype.myBind = function (thisArg) &#123;  if (typeof this !== &quot;function&quot;)    throw new TypeError(&quot;Bind must be called on a function&quot;);  var targetFunction = this;  var args = Array.prototype.slice.call(arguments, 1);  return function boundFunction() &#123;    return targetFunction.apply(      args.concat(Array.prototype.slice.call(arguments, 1))    );  &#125;;&#125;;\n\n第三步，新函数需要保留原函数的原型方法，并区分调用方式\nFunction.prototype.myBind = function (thisArg) &#123;  if (typeof this !== &quot;function&quot;)    throw new TypeError(&quot;Bind must be called on a function&quot;);  var targetFunction = this;  var args = Array.prototype.slice.call(arguments, 1);  function boundFunction() &#123;    return targetFunction.apply(      // 如果bind之后的函数用 new 调用，那么原函数中的 this 指向的应该是对象实例      this instanceof boundFunction        ? this        : // 如果以普通函数调用，原函数this指向bind绑定时传入的值          thisArg,      args.concat(Array.prototype.slice.call(arguments, 1))    );  &#125;  // 拷贝源函数的原型链  boundFunction.prototype = this.prototype;  return boundFunction;&#125;;\n\nnewnew 操作接受一个函数\n\n创建一个新对象这个对象就是 this\n设置对象的原型为构造函数的原型\n将函数的执行上下文添加进 this\n执行函数，如果返回值是一个对象就直接返回\n如果不是对象就返回创建的 this\n\nfunction myNew(Constructor, ...args) &#123;  const newObj = &#123;&#125;;  Object.setPrototypeOf(newObj, Constructor.prototype);  let result = Constructor.apply(newObj, args);  return result instanceof Object ? result : newObj;&#125;","categories":["JavaScript"],"tags":["JavaScript","ES6基础"]},{"title":"canvas 画板","url":"/posts/35b9815417e8/","content":"橡皮擦依赖于 ctx.globalCompositeOperation 配置，有以下可选项\nsource-over（默认值）：新图形绘制在现有图形上方。source-in：新图形仅在与现有图形重叠的区域内绘制。source-out：新图形仅在与现有图形不重叠的区域内绘制。source-atop：新图形绘制在现有图形上方，但只在它们重叠的区域内可见。destination-over：新图形绘制在现有图形下方。destination-in：现有图形仅保留与新图形重叠的部分。destination-out：现有图形中与新图形不重叠的部分保留。destination-atop：现有图形绘制在新图形上方，但只在它们重叠的区域内可见。lighter：重叠区域的颜色通过加法混合。copy：只有新图形可见，现有内容被清除。xor：重叠区域变透明。\nctx.globalCompositeOperation = &quot;destination-out&quot;;// 线宽影响橡皮擦大小ctx.lineWidth = 10;ctx.strokeStyle = &quot;red&quot;;ctx.lineTo(x, y);ctx.stroke();\n\n使用 rfa 逐帧绘制const queue = [];const draw = () =&gt; &#123;  requestAnimationFrame(() =&gt; &#123;    let len = queue.length;    for (var i = 0; i &lt; len; i++) &#123;      const a = queue[i];      ctx.lineTo(a[0], a[1]);    &#125;    if (len) &#123;      ctx.stroke();    &#125;    queue = [];    if (mark) draw();  &#125;);&#125;;canvas?.addEventListener(&quot;pointerdown&quot;, () =&gt; &#123;  mark = true;  // 取整数减少浮点运算  queue.push([    Math.floor(e.clientX * window.devicePixelRatio),    Math.floor(e.clientY * window.devicePixelRatio),  ]);  ctx.beginPath();  draw();&#125;);\n\n平滑曲线使用贝塞尔曲线拟合\n\n取 B C 中点 B1, A 为起点，B 为控制点，B1 为终点\n取 C D 中点 C1, B1 为起点，C 为控制点，C1 为终点\n\n\nlet rfa = 0;const draw = (index = 0) =&gt; &#123;  if (!index &amp;&amp; rfa) return;  rfa = requestAnimationFrame(() =&gt; &#123;    let len = queue.length;    if (len &amp;&amp; !index) &#123;      const a = queue[index];      ctx.lineTo(a[0], a[1]);      index++;    &#125;    while (len &gt;= 3 &amp;&amp; index &lt; len - 1) &#123;      const cur = queue[index];      const next = queue[index + 1];      const cx = (cur[0] + next[0]) &gt;&gt; 1;      const cy = (cur[1] + next[1]) &gt;&gt; 1;      ctx.quadraticCurveTo(cur[0], cur[1], cx, cy);      index += 1;    &#125;    if (len) &#123;      ctx.stroke();    &#125;    if (mark) &#123;      draw(index);    &#125; else &#123;      rfa = 0;    &#125;  &#125;);&#125;;\n\n离屏 canvas 模拟粉笔效果let queue: any[] = [];const offScreen = new OffscreenCanvas(dimension.width, dimension.height);const offCtx = offScreen.getContext(&quot;2d&quot;) as OffscreenCanvasRenderingContext2D;offCtx.scale(width / dimension.width, height / dimension.height);offCtx.strokeStyle = &quot;red&quot;;offCtx.lineWidth = 6;offCtx.lineCap = &quot;round&quot;;const draw = () =&gt; &#123;  requestAnimationFrame(() =&gt; &#123;    let len = queue.length;    offCtx.clearRect(0, 0, dimension.width, dimension.height);    // 在清除画布之后必须使用 beginPath    offCtx.beginPath();    for (var i = 0; i &lt; len; i++) &#123;      const a = queue[i];      offCtx.lineTo(a[0], a[1]);    &#125;    if (len) &#123;      offCtx.stroke();    &#125;    for (let i = 1; i &lt; len; i++) &#123;      const pre = queue[i - 1];      const cur = queue[i];      const length = Math.round(        Math.sqrt(Math.pow(pre[0] - cur[0], 2) + Math.pow(pre[1] - cur[1], 2))      );      const xUnit = (cur[0] - pre[0]) / length;      const yUnit = (cur[1] - pre[1]) / length;      for (let i = 0; i &lt; length; i++) &#123;        const xCurrent = pre[0] + i * xUnit;        const yCurrent = pre[1] + i * yUnit;        const xRandom = xCurrent + (Math.random() - 0.5) * 6 * 1.2;        const yRandom = yCurrent + (Math.random() - 0.5) * 6 * 1.2;        offCtx.clearRect(          xRandom,          yRandom,          Math.random() * 2 + 2,          Math.random() + 1        );      &#125;    &#125;    queue = [];    ctx.globalCompositeOperation = &quot;source-over&quot;;    ctx.drawImage(offScreen, 0, 0, dimension.width, dimension.height);    if (mark) draw();  &#125;);&#125;;\n","categories":["JavaScript"],"tags":["canvas"]},{"title":"Cookie的domain属性","url":"/posts/44b7ce1ba097/","content":"一些概念\ndomain表示的是cookie所在的域，默认为请求的地址，如网址为www.test.com/test/test.aspx，那么domain默认为www.test.com。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。\n\npath表示cookie所在的目录，asp.net默认为&#x2F;，就是根目录。在同一个服务器上有目录如下：&#x2F;test&#x2F;,&#x2F;test&#x2F;cd&#x2F;,&#x2F;test&#x2F;dd&#x2F;，现设一个cookie1的path为&#x2F;test&#x2F;，cookie2的path为&#x2F;test&#x2F;cd&#x2F;，那么test下的所有页面都可以访问到cookie1，而&#x2F;test&#x2F;和&#x2F;test&#x2F;dd&#x2F;的子页面不能访问cookie2。这是因为cookie能让其path路径下的页面访问。\n\n浏览器会将domain和path都相同的cookie保存在一个文件里，cookie间用*隔开。\n\n含值键值对的cookie：含多个子键值对的cookie格式是name&#x3D;key1&#x3D;value1&amp;key2&#x3D;value2。可以理解为单键值对的值保存一个自定义的多键值字符串，其中的键值对分割符为&amp;，当然可以自定义一个分隔符，但用asp.net获取时是以&amp;为分割符。\n\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"co模块","url":"/posts/7e5726aaca4d/","content":"简介基于生成器的nodej和浏览器控制流，使用promises，让您以一种很好的方式编写非阻塞代码。\n可以让Generator函数的自动执行。不用编写Generator函数的执行器。\nAPIco(fn*).then( val &#x3D;&gt; )\n通过解析一个Generator，Generator函数，或任何返回Generator的函数，并返回一个Promise\nco(function* () &#123;  return yield Promise.resolve(true);&#125;).then(function (val) &#123;  console.log(val);&#125;, function (err) &#123;  console.error(err.stack);&#125;);\n\nvar fn &#x3D; co.wrap(fn*)\n把generator转换为一个普通函数并返回Promise\nvar fn = co.wrap(function* (val) &#123;  return yield Promise.resolve(val);&#125;); fn(true).then(function (val) &#123; &#125;);\n\n执行逻辑\nco(fn) 执行传入co模块的 generator 函数 fn \n\n把 fn 执行的结果 res，包装成 promise 对象\n\n\nconst gen = fn(); const res = gen.next()  const rp =  toPromise(res.value)\n\n如果是合法的 promise 这继续调用 fn 的 next 方法\n\nrp.then((value)=&gt; res.next())\nco其实是一个返回promise对象的函数， 内部通过递归的方式调用 generator 的 next 方法\n源码分析工具方法\n// sllice 引用var slice = Array.prototype.slice;// isObjectfunction isObject(val) &#123;  return Object == val.constructor;&#125;//导出方法module.exports = co[&#x27;default&#x27;] = co.co = co;//判断是否是promise对象，只要是实现了thenable的对象都可以视为promise对象function isPromise(obj) &#123;  return &#x27;function&#x27; == typeof obj.then;&#125;function isGenerator(obj) &#123;  return &#x27;function&#x27; == typeof obj.next &amp;&amp; &#x27;function&#x27; == typeof obj.throw;&#125;// 是否是generator函数function isGeneratorFunction(obj) &#123;  // 一定是GeneratorFunction构造函数的实例  // (function()&#123;&#125;).constructor === Function =&gt; true  var constructor = obj.constructor;  if (!constructor) return false;  if (&#x27;GeneratorFunction&#x27; === constructor.name || &#x27;GeneratorF方法function thunkToPromise(fn) &#123;  var ctx = this;  return new Promise(function (resolve, reject) &#123;    fn.call(ctx, function (err, res) &#123;      if (err) return reject(err);      if (arguments.length &gt; 2) res = slice.call(arguments, 1);      resolve(res);    &#125;);  &#125;);&#125;// arrayToPromise yeildable数组转换为promisefunction arrayToPromise(obj) &#123;  // 每一项都转换为promise  // 第二个参数为toPromise执行时的this值  return Promise.all(obj.map(toPromise, this));&#125;// objectToPromise yieldables对象转为promisefunction objectToPromise(obj)&#123;  // 借用 function Object()&#123;&#125;  var results = new obj.constructor();  var keys = Object.keys(obj);  var promises = [];  for (var i = 0; i &lt; keys.length; i++) &#123;    var key = keys[i];    // 每一项转为promise    var promise = toPromise.call(this, obj[key]);    if (promise &amp;&amp; isPromise(promise)) defer(promise, key);    // 其他情况直接返回key值    else results[key] = obj[key];  &#125;  return Promise.all(promises).then(function () &#123;    return results;  &#125;);  function defer(promise, key) &#123;    // 提前在results中定义key    results[key] = undefined;    promises.push(promise.then(function (res) &#123;      // 提前一步拿到结果      // 通常自己的写法为这里直接返回promise      // 在promise.all 中在遍历结果生成result,这样写法更简洁一点      results[key] = res;    &#125;));  &#125;&#125;//把yeild转为Promise对象function toPromise(obj) &#123;  // 如果为假直接返回  if (!obj) return obj;  //如果已经是promise直接返回  if (isPromise(obj)) return obj;  // 如果是generator函数 通过co函数栈为promise  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);  // this通过next方法中toPromise.call(ctx, ret.value)来绑定  if (&#x27;function&#x27; == typeof obj) return thunkToPromise.call(this, obj);  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);  if (isObject(obj)) return objectToPromise.call(this, obj);  return obj;&#125;\n\n\nco 核心方法\nfunction co(gen) &#123;  var ctx = this;  var args = slice.call(arguments, 1)  // 把任何东西包装成promise, 从而避免promise调用链  // 内存泄漏的问题  // https://github.com/tj/co/issues/180  return new Promise(function(resolve, reject) &#123;        // 执行Generator函数，返回Generator    if (typeof gen === &#x27;function&#x27;) gen = gen.apply(ctx, args);    // 如果没有next方法，则直接返回    if (!gen || typeof gen.next !== &#x27;function&#x27;) return resolve(gen);    onFulfilled();    /**     * @param &#123;Mixed&#125; res     * @return &#123;Promise&#125;     * @api private     * 通过 try catch 捕获执行时错误     */    function onFulfilled(res) &#123;      var ret;      try &#123;        ret = gen.next(res);      &#125; catch (e) &#123;        return reject(e);      &#125;      next(ret);    &#125;    /**     * @param &#123;Error&#125; err     * @return &#123;Promise&#125;     * @api private     */    function onRejected(err) &#123;      var ret;      try &#123;        ret = gen.throw(err);      &#125; catch (e) &#123;        return reject(e);      &#125;      next(ret);    &#125;    /**     * Get the next value in the generator,     * return a promise.     *     * @param &#123;Object&#125; ret     * @return &#123;Promise&#125;     * @api private     */        function next(ret) &#123;      if (ret.done) return resolve(ret.value);      var value = toPromise.call(ctx, ret.value);      // 如果可以包装成promise, 通过thenable方法继续调用onFulfilled，执行下一个next, 并把promise的值传入，当作上一个next的结果      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);      // 抛出错误      return onRejected(new TypeError(&#x27;You may only yield a function, promise, generator, array, or object, &#x27;        + &#x27;but the following object was passed: &quot;&#x27; + String(ret.value) + &#x27;&quot;&#x27;));    &#125;  &#125;);&#125;\n\nco.wrap(fn*)\n// 通过柯理化函数，返回一个包含co执行结果的正常函数co.wrap = function (fn) &#123;  createPromise.__generatorFunction__ = fn;  return createPromise;  function createPromise() &#123;    return co.call(this, fn.apply(this, arguments));  &#125;&#125;;","categories":["JavaScript"],"tags":["JavaScript","Node"]},{"title":"d3-dispatch 源码分析","url":"/posts/31cd34c799c3/","content":"d3-dispatch 是一个基于 观察者模式 的事件处理工具.\n使用方法// 注册事件const d = dispatch(&quot;start&quot;, &quot;end&quot;);//帮顶事件方法d.on(&#x27;start.a&#x27;,()=&gt;&#123;&#125;)d.on(&#x27;start.*b.c&#x27;,()=&gt;&#123;&#125;) // *b.c作为方法名d.on(&#x27;start.d start.e&#x27;,()=&gt;&#123;&#125;) // 帮顶d,e两个方法d.on(&#x27;start.d&#x27;,null) // 删除d绑定事件d.on(&#x27;start.e&#x27;) // 获取e绑定事件// 执行方法d.fire(&#x27;start&#x27;) // 按照帮顶顺序执行每一个方法\n\ndispatch用于添加一个或多个事件名称,事件对应着一个队列,可以包含多个子方法\nconst d = dispatch(&quot;start&quot;, &quot;end&quot;);\n\n\n尝试把方法名转换为字符串\n不能转换为字符串 或 已经注册过 或 包含空格或. 则不合法\n\nconst dispatch = (...args: string[]) =&gt; &#123;  const types: Types = &#123;&#125;;  for (let i = 0, l = args.length, t; i &lt; l; i += 1) &#123;    t = `$&#123;args[i]&#125;`;    if (!t || t in types || /[\\s.]/.test(t)) throw new Error();    types[t] = [];  &#125;  return new Dispatch(types);&#125;;export default dispatch;\n\nDispatchinterface TypeItem &#123;  name: string;  value: (...args: unknown[]) =&gt; unknown;&#125;interface Types &#123;  [k: string]: TypeItem[];&#125;// 工具方法空函数const noop = &#123; value: () =&gt; &#123;&#125; &#125; as TypeItem;class Dispatch &#123;  private types: Types;  constructor(types: Types) &#123;    this.types = types;  &#125;  on() &#123;&#125;  copy() &#123;&#125;  fire() &#123;&#125;&#125;\n\n一个取值的工具方法事件对象中取出回调方法的数组\nconst get = (type: TypeItem[], name: string): TypeItem[&quot;value&quot;] | undefined =&gt; &#123;  for (let i = 0, n = type.length, c; i &lt; n; i += 1) &#123;    c = type[i];    if (c.name === name) &#123;      return c.value;    &#125;  &#125;  return undefined;&#125;;\n\n设置值的工具方法如果存在同名方法,从事件队列中删除,并置空同名方法如果传递了回调函数则在队列最后重新添加方法\nconst set = (  _type: TypeItem[],  name: string,  callback: TypeItem[&quot;value&quot;] | null): TypeItem[] =&gt; &#123;  let type = _type;  for (let i = 0, n = type.length; i &lt; n; i += 1) &#123;    if (type[i].name === name) &#123;      type[i] = noop;      type = type.slice(0, i).concat(type.slice(i + 1));      break;    &#125;  &#125;  if (callback != null) type.push(&#123; name, value: callback &#125;);  return type;&#125;;\n\n解析事件方法名方法名尝试转为字符串,并删除头尾空格预处理a.b a.c 会添加两个回调方法, a.b.c 会添加 b.c 作为方法名称用空格来切割,因为可能存在多个绑定事件查找 . 的第一个匹配位置,后面的无论是什么都看作是一个方法\nconst parseTypenames = (  typenames: string,  types: Types): &#123; type: string; name: string &#125;[] =&gt; &#123;  return typenames    .trim()    .split(/^|\\s+/)    .map(function map(_t) &#123;      let t = _t;      let name = &quot;&quot;;      const i = t.indexOf(&quot;.&quot;);      if (i &gt;= 0) &#123;        name = t.slice(i + 1);        t = t.slice(0, i);      &#125;      const has = Object.prototype.hasOwnProperty.call(types, t);      if (t &amp;&amp; !has) throw new Error(`unknown type:  $&#123;t&#125;`);      return &#123; type: t, name &#125;;    &#125;);&#125;;\n\nonpublic on(    _typename: string | &#123; name: string; type: string &#125;,    callback: TypeItem[&#x27;value&#x27;] | null  ): this | TypeItem[&#x27;value&#x27;] | undefined &#123;    const &#123; types &#125; = this;    let typename = _typename;    const T = parseTypenames(`$&#123;typename&#125;`, types);    let t: string | TypeItem[&#x27;value&#x27;] | undefined;    let i = 0;    const n = T.length;    // 如果不存在回调函数,把他作为取值操作,返回最先匹配到的方法    if (callback === undefined) &#123;      while (i &lt; n) &#123;        typename = T[i];        t = typename.type;        if (!t) return undefined;        t = get(types[t], typename.name);        if (t) return t;      &#125;      i += 1;      return undefined;    &#125;    // 如果回调函数不是方法,直接报错    if (callback != null &amp;&amp; typeof callback !== &#x27;function&#x27;)      throw new Error(`invalid callback: $&#123;callback&#125;`);    // 添加到 type 事件对象中    while (i &lt; n) &#123;      // 插入      typename = T[i];      t = typename.type;      const ct = typename;      if (t) types[t] = set(types[t], typename.name, callback);      // 删除      // 所有监听队列中的同名方法都将被删除      else if (callback == null)        Object.entries(types).forEach(([k, v]) =&gt; &#123;          types[k] = set(v, ct.name, null);        &#125;);      i += 1;    &#125;    return this;  &#125;\n\ncopypublic copy() &#123;  const copy: Types = &#123;&#125;;  const &#123; types &#125; = this;  Object.entries(types).forEach(([k, v]) =&gt; &#123;    copy[k] = v.slice();  &#125;);  return new Dispatch(copy);&#125;\n\nfirepublic fire(type: string, that?: unknown, ...args: unknown[]) &#123;  const has = Object.prototype.hasOwnProperty.call(this.types, type);  if (!has) throw new Error(`unknown type: $&#123;type&#125;`);  const t = this.types[type];  let i = 0;  const n = t.length;  for (; i &lt; n; i += 1) t[i].value.apply(that, args);&#125;\n","categories":["JavaScript"],"tags":["d3"]},{"title":"解构赋值","url":"/posts/041ae5ec9907/","content":"数组的解构赋值\n如果解构不成功，变量的值就等于undefined\n\n对于 Set 结构，也可以使用数组的解构赋值。\n\n\nlet [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&#x27;a&#x27;];x // &quot;a&quot;y // undefinedz // []let [x, y, z] = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);\n\n\n如果等号的右边是可遍历的结构（Iterator），会报错\n\n// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;;\n\nfunction* fibs() &#123;  let a = 0;  let b = 1;  while (true) &#123;    yield a;    [a, b] = [b, a + b];  &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5\n\n\n默认值， 只有结构元素严格等于undefined才会使用默认值\n\nlet [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null\n\n如果默认值是表达式，只有赋值时才会执行\nfunction f() &#123;  console.log(&#x27;aaa&#x27;);&#125;//f不会执行let [x = f()] = [1];//等价于let x;if ([1][0] === undefined) &#123;  x = f();&#125; else &#123;  x = [1][0];&#125;\n\n可以使用其他变量但这个变量必须已经声明\nlet [x = 1, y = x] = [];     // x=1; y=1\n\n对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n对象的解构赋值是下面形式的简写,真正被赋值的是后者，而不是前者。\nlet &#123; foo: baz &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined\n\n\n注意模式和变量的区别， 这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。\n\nlet obj = &#123;  p: [    &#x27;Hello&#x27;,    &#123; y: &#x27;World&#x27; &#125;  ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // &quot;Hello&quot;y // &quot;World&quot;p // [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]\n\n\n嵌套赋值\n\nlet obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true]// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &#x27;baz&#x27;&#125;;\n\n\n对象的解构赋值可以取到继承的属性。\n\nconst obj1 = &#123;&#125;;const obj2 = &#123; foo: &#x27;bar&#x27; &#125;;Object.setPrototypeOf(obj1, obj2);const &#123; foo &#125; = obj1;foo // &quot;bar&quot;\n\n\n如果要将一个已经声明的变量用于解构赋值，必须非常小心。\n\n// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;);\n\n\n由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\n\nlet arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3\n\n字符串结构赋值\n字符串被转换成了一个类似数组的对象。\n\n还可以对这个属性解构赋值。\n\n\nconst [a, b, c, d, e] = &#x27;hello&#x27;;let &#123;length : len&#125; = &#x27;hello&#x27;;\n\n数值和布尔值的解构赋值\n解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。\n\nlet &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true\n\n\n由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。\n\nlet &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError\n\n函数参数的解构赋值注意默认值的设置方式\nfunction move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;  return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;  return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0]\n\n圆括号问题变量声明语句，模式不能使用圆括号。\nlet &#123;x: (c)&#125; = &#123;&#125;;//错误\n函数参数不能使用圆括号\n// 报错function f([(z)]) &#123; return z; &#125;\n\n赋值语句的模式报错\n// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];\n\n可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确\n\n\n常见使用方式\n交换变量的值\n\nlet x = 1;let y = 2;[x, y] = [y, x];\n\n\n从函数返回多个值\n\n函数参数的定义\n\n提取 JSON 数据\n\n函数参数的默认值\n\n遍历 Map 结构\n\n\nconst map = new Map();map.set(&#x27;first&#x27;, &#x27;hello&#x27;);map.set(&#x27;second&#x27;, &#x27;world&#x27;);for (let [key, value] of map) &#123;  console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world\n\n\n获取引入模块的方法\n\n","categories":["JavaScript"],"tags":["JavaScript","ES6基础"]},{"title":"编码","url":"/posts/fb3e4fd3fe1c/","content":"计算机自己能理解的“语言”是二进制数，最小的信息标识是二进制位，8个二进制位表示一个字节；而我们人类所能理解的语言文字则是一套由英文字母、汉语汉字、标点符号字符、阿拉伯数字等等很多的字符构成的字符集\n如果要让计算机来按照人类的意愿进行工作，则必须把人类所使用的这些字符集转换为计算机所能理解的二级制码，这个过程就是编码，他的逆过程称为解码。\n最开始计算机在美国发明使用，需要编码的字符集,并不是很大，无外乎英文字母、数字和一些简单的标点符号，因此采用了一种单字节编码系统。在这套编码规则中，人们将所需字符集中的字符一一映射到128个二进制数上，这128个二进制数是最高位为0，利用剩余低7位组成00000000~01111111（0X00~0X7F）。0X00到0X1F共32个二进制数来对控制字符或通信专用字符（如LF换行、DEL删除、BS退格）编码，0X20到0X7F共96个二进制数来对阿拉伯数字、英文字母大小写和下划线、括号等符号进行编码。\n将这套字符集映射到0X00~0X7F二进制码的过程就称为基础ASCII编码\n通过这个编码过程，计算机就将人类的语言转化为自己的语言存储了起来，反之从磁盘中读取二级制数并转化为字母数字等字符以供显示的过程就是解码。\n随着计算机被迅速推广使用，欧洲的非英语国家的人们发现这套由美国人设计的字符集不够用了，比如一些带重音的字符、希腊字母等都不在这个字符集中\n于是扩充了ASCII编码规则，将原本为0的最高位改为1，因此扩展出了10000000~11111111（0X80~0XFF）这128个二进制数。\n这其中，最优秀的扩展方案是ISO 8859-1，通常称之为Latin-1。Latin-1利用128~255这128个二进制数，包括了足够的附加字符集来涵盖基本的西欧语言，同时在0~127的范围内兼容ASCII编码规则。\n随着使用计算机的国家越来越多，自然而然需要编码的字符集就越来越庞大，早先的ASCII编码字符集由于受到单字节的限制，其容量就远远不够了，比方说面对成千上万的汉字，其压力可想而知。\n因此中国国家标准总局发布了一套《信息交换用汉字编码字符集》的国家标准，其标准号就是GB 2312—1980。\n这个字符集共收入汉字6763个和非汉字图形字符682个，采用两个字节对字符集进行编码，并向下兼容ASCII编码方式。简言之，整个字符集分成94个区，每区有94个位，分别用一个字节对应表示相应的区和位。每个区位对应一个字符，因此可用所在的区和位来对汉字进行两字节编码。\n再后来生僻字、繁体字及日韩汉字也被纳入字符集，就又有了后来的GBK字符集及相应的编码规范，GBK编码规范也是向下兼容GBK2312的。\n在中国发展的同时，计算机在全世界各个国家不断普及，不同的国家地区都会开发出自己的一套编码系统，因此编码系统五花八门，这时候问题就开始凸显了，特别是在互联网通信的大环境下，装有不同编码系统的计算机之间通信就会彼此不知道对方在“说”些什么，按照A编码系统的编码方式将所需字符转换成二进制码后，在B编码系统的计算机上解码是无法得到原始字符的，相反会出现一些出人意料的古怪字符，这就是所谓的\n为了实现跨语言、跨平台的文本转换和处理需求，ISO国际标准化组织提出了Unicode的新标准，这套标准中包含了Unicode字符集和一套编码规范。Unicode字符集涵盖了世界上所有的文字和符号字符，Unicode编码方案为字符集中的每一个字符指定了统一且唯一的二进制编码，这就能彻底解决之前不同编码系统的冲突和乱码问题。这套编码方案简单来说是这样的：编码规范中含有17个组（称为平面），每一个组含有65536个码位（例如组0就是0X0000~0XFFFF），每一个码位就唯一对应一个字符，大部分的字符都位于字符集平面0的码位中，少量位于其他平面。\n既然提到了Unicode编码，那么常常与之相伴的UTF-8，UTF-16编码方案又是什么？\n其实到目前为止我们都一致混淆了两个概念，即字符代码和字符编码，字符代码是特定字符在某个字符集中的序号，而字符编码是在传输、存储过程当中用于表示字符的以字节为单位的二进制序列。ASCII编码系统中，字符代码和字符编码是一致的，比如字符A，在ASCII字符集中的序号，也就是所谓的字符代码是65，存储在磁盘中的二进制比特序列是01000001（0X41，十进制也是65），另外的，如在GB2312编码系统中字符代码和字符编码的值也是一致的，所以无形之中我们就忽略了二者的差异性。而在Unicode标准中，我们目前使用的是UCS-4，即字符集中每一个字符的字符代码都是用4个字节来表示，其中字符代码0~127兼容ASCII字符集，一般的通用汉字的字符代码也都集中在65535之前，使用大于65535的字符代码，即需要超过两个字节来表示的字符代码是比较少的。因此，如果仍然依旧采用字符代码和字符编码相一致的编码方式，那么英语字母、数字原本仅需一个字节编码，目前就需要4个字节进行编码，汉字原本仅需两个字节进行编码，目前也需要4个字节进行编码，这对于存储或传输资源而言是很不划算的。\n因此就需要在字符代码和字符编码间进行再编码，这样就引出了UTF-8、UTF-16等编码方式\n基于上述需求，UTF-8就是针对位于不同范围的字符代码转化成不同长度的字符编码，同时这种编码方式是以字节为单位，并且完全兼容ASCII编码，即0X00-0X7F的字符代码和字符编码完全一致，也是用一个字节来编码ASCII字符集，而常用汉字在Unicode中的字符代码是4E00-9FA5，在文末的对应关系中我们看到是用三个字节来进行汉字字符的编码。UTF-16同理，就是以16位二进制数为基本单位对Unicode字符集中的字符代码进行再编码，原理和UTF-8一致。\n文末的对应关系中我们看到是用三个字节来进行汉字字符的编码。UTF-16同理，就是以16位二进制数为基本单位对Unicode字符集中的字符代码进行再编码，原理和UTF-8一致。\n","categories":["JavaScript"],"tags":["JavaScript","ES6基础"]},{"title":"TS extends 使用技巧","url":"/posts/e1e2644f39f7/","content":"extends 关键字在 TS 中的两种用法，即接口继承和条件判断。\n接口继承和 class 中的继承类似,但是类型中可以使用多继承\ninterface T3 extends T1, T2 &#123;  age: number;&#125;\n\n条件语句extends 可以当作类型中的 if 语句使用,当时理念上与 if 略有不同\ntype T = string;type A = T extends string ? true : false;\n\n上面的语句可以简单理解为, T 的类型是否是 string 类型. 但是,更准确的说法是 T 的类型能否分配给 string 类型.\n因为类型系统中不能像 if 一样,通过 == 或 === 来判断, 例如下面的接口或对象类型\ninterface A1 &#123;  name: string;&#125;interface A2 &#123;  name: string;  age: number;&#125;type A = A2 extends A1 ? string : number; //string\n\n这两个类型并不是完全相同,但是 A2 的类型可以分配给 A1 使用,因为 A2 中 完全包括了 A1 中的类型,也就是说可以把 A2 当做 A1 使用.\n反过来 A1 不能当作 A2 使用,应为 A1 中没有 age 类型,可能导致类型错误.\n条件分配类型看一个例子\ntype A2 = &quot;x&quot; | &quot;y&quot; extends &quot;x&quot; ? string : number; // numbertype P&lt;T&gt; = T extends &quot;x&quot; ? string : number;type A3 = P&lt;&quot;x&quot; | &quot;y&quot;&gt;; // string | number\n\nA3 并不会和 A2 相同,造成这个的原因就是 分配条件类型（Distributive Conditional Types）\n\nWhen conditional types act on a generic type, they become distributive when given a union type\n\n当条件类型作用在泛型上时, 当传入一个联合类型这个类型是可分配的.\n换句话说,当在使用泛型做条件判断的时候, 而且这个泛型传入的是一个联合类型,就会像数学中的分配率一样,把联合类型中的没没一项分别进行条件判断,最终返回一个联合类型\n所以上面 A3 类型,等价于\ntype A3 =  | (&quot;x&quot; extends &quot;x&quot; ? string : number)  | (&quot;y&quot; extends &quot;x&quot; ? string : number);\n\n分配条件类型最终会返回一个不同分支返回结果的联合类型,如果返回的结果是一个包装过的类型,那么就是不同分支包装类型的联合类型\ntype Test&lt;T, T2 = T&gt; = T extends T2 ? &#123;t: T&#125; : never;type a = Test&lt;string|number&gt;  // &#123;t:string&#125; | &#123;t:number&#125;type Test2&lt;T, T2 = T&gt; = T extends T2 ? [T] : never;type a = Test&lt;string|number&gt;  // [string] | [number]\n\n注意 never\nnever 在条件语句中的行为可能和想象的不一样,这也是条件类型在对其约束, never 相当于空的联合类型,所以没有判断直接返回\ntype A1 = never extends &quot;x&quot; ? string : number; // stringtype P&lt;T&gt; = T extends &quot;x&quot; ? string : number;type A2 = P&lt;never&gt;; // never\n\n防止条件类型分配\n如果不想让 never 解析成空的联合类型,而是当作一个 never 类型传入,实际上就是阻止类型系统对联合类型自动分配,可以使用一个 []\ntype P&lt;T&gt; = [T] extends [&quot;x&quot;] ? string : number;type A1 = P&lt;&quot;x&quot; | &quot;y&quot;&gt;; // numbertype A2 = P&lt;never&gt;; // string\n\n","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"函数","url":"/posts/9cfefd7f06a1/","content":"与解构赋值默认值结合使用参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。\nfunction throwIfMissing() &#123;  throw new Error(&#x27;Missing parameter&#x27;);&#125;function foo(mustBeProvided = throwIfMissing()) &#123;  return mustBeProvided;&#125;foo()// Error: Missing parameter\n\n函数的 length 属性没有默认值的时候，函数的length属性是形式参数的个数\n指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。\n这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。\n(function(...args) &#123;&#125;).length // 0\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。\n(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1\n\n作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域\nvar x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123;  var x = 3;  y();  console.log(x);&#125;foo() // 3x // 1\n\n上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。\n如果将var x &#x3D; 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。\nvar x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123;  x = 3;  y();  console.log(x);&#125;foo() // 2x // 1\n\nrestrest 参数之后不能再有其他参数\n函数的length属性，不包括 rest 参数\n严格模式ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\nname函数的name属性，返回该函数的函数名。\nFunction构造函数返回的函数实例，name属性的值为anonymous。\n(new Function).name // &quot;anonymous&quot;\n\nfunction foo() &#123;&#125;;foo.bind(&#123;&#125;).name // &quot;bound foo&quot;(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;\n\n箭头函数如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。\nlet foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined\n\n上面代码中，原始意图是返回一个对象&#123; a: 1 &#125;，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。\n如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。\nlet fn = () =&gt; void doesNotReturn();\n\n箭头函数注意点\n函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n\n\n不适用的场景\n\n定义对象的方法，且该方法内部包括this\n\n需要动态this的时候，也不应使用箭头函数\n\n\nvar button = document.getElementById(&#x27;press&#x27;);button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;  this.classList.toggle(&#x27;on&#x27;);&#125;);\n\n尾调用优化尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。\n即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。\n尾递归“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;  if( n &lt;= 1 ) &#123;return ac2&#125;;  return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;\n\n尾递归的两种形式：\n柯里化（currying）\nfunction currying(fn, n) &#123;  return function (m) &#123;    return fn.call(this, m, n);  &#125;;&#125;function tailFactorial(n, total) &#123;  if (n === 1) return total;  return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120\n\nES6 的函数默认值\nfunction factorial(n, total = 1) &#123;  if (n === 1) return total;  return factorial(n - 1, n * total);&#125;factorial(5) // 120\n\n严格模式ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\n\nfunc.arguments：返回调用时函数的参数。\n\nfunc.caller：返回调用当前函数的那个函数。\n\n\n尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。\nfunction restricted() &#123;  &#x27;use strict&#x27;;  restricted.caller;    // 报错  restricted.arguments; // 报错&#125;restricted();\n\n\n尾递归的实现\ntco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。\nfunction tco(f) &#123;    var value; //记录返回值    var args = []; //记录参数    var active = false; //记录执行状态    // 通过返回新函数，形成闭包共享状态    return function accumulator() &#123;        //每次目标函数执行前保存参数        args.push(arguments);        //上一次执行的状态        if (!active) &#123;            active = true;            // 因为每次执行前缓存了参数，所以下一次执行时一定会有参数            // 通过while实现递归的效果            while (args.length) &#123;                value = f.apply(this, args.shift());            &#125;            active = false;        &#125;    &#125;&#125;var sum = tco(function (x, y) &#123;    if (y &gt; 0) &#123;        return sum(x + 1, y - 1)    &#125; else &#123;        console.log(x);        return x    &#125;&#125;);\n\n函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。函数参数与数组和对象的尾逗号规则，保持一致了。\n","categories":["JavaScript","基础"],"tags":["JavaScript","ES6基础"]},{"title":"Generator","url":"/posts/82e2e8174a56/","content":"概念Generator 函数是 ES6 提供的一种异步编程解决方案\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\nyeildyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。\nyield表达式如果用在另一个表达式之中，必须放在圆括号里面。\nfunction* demo() &#123;  console.log(&#x27;Hello&#x27; + yield); // SyntaxError  console.log(&#x27;Hello&#x27; + yield 123); // SyntaxError  console.log(&#x27;Hello&#x27; + (yield)); // OK  console.log(&#x27;Hello&#x27; + (yield 123)); // OK&#125;\n\nyield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。\nfunction* demo() &#123;  foo(yield &#x27;a&#x27;, yield &#x27;b&#x27;); // OK  let input = yield; // OK&#125;\n\n与 Iterator 接口的关系任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\nfunction* gen()&#123;  // some code&#125;var g = gen();g[Symbol.iterator]() === g// true\n\nnext 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\nfor…of 循环for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。\n一旦next方法的返回对象的done属性为true，for...of循环就会中止,return语句返回的不包括在for...of循环之中。\nGenerator.prototype.throw()Generator.prototype.return()共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。\nyield*如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。\nES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。\nthisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。\nGenerator 函数也不能跟new命令一起用，会报错。\n首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。\nfunction* gen() &#123;  this.a = 1;  yield this.b = 2;  yield this.c = 3;&#125;function F() &#123;  return gen.call(gen.prototype);&#125;var f = new F();f.next();  // Object &#123;value: 2, done: false&#125;f.next();  // Object &#123;value: 3, done: false&#125;f.next();  // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3\n\nGenerator 与状态机Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。\nvar clock = function* () &#123;  while (true) &#123;    console.log(&#x27;Tick!&#x27;);    yield;    console.log(&#x27;Tock!&#x27;);    yield;  &#125;&#125;;\n\n应用\n异步操作的同步化表达\n\nfunction* main() &#123;  var result = yield request(&quot;http://some.url&quot;);  var resp = JSON.parse(result);    console.log(resp.value);&#125;function request(url) &#123;  makeAjaxCall(url, function(response)&#123;    it.next(response);  &#125;);&#125;var it = main();it.next();\n\n\n控制流管理\n\n部署 Iterator 接口\n\n作为数据结构\n\n\n","categories":["JavaScript","基础"],"tags":["JavaScript","ES6基础"]},{"title":"Generator 异步","url":"/posts/18bcaf615ff5/","content":"es6 之前实现异步的方法\n\n回调函数\n事件监听\n发布&#x2F;订阅\nPromise 对象\n\n异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\nPromise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。\n错误处理Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。\n使用指针对象的throw方法抛出的错误，可以被函数体内的try…catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离\nfunction* gen(x)&#123;  try &#123;    var y = yield x + 2;  &#125; catch (e)&#123;    console.log(e);  &#125;  return y;&#125;var g = gen(1);g.next();g.throw(&#x27;出错了&#x27;);// 出错了\n\n异步任务的封装虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。\nvar fetch = require(&#x27;node-fetch&#x27;);function* gen()&#123;  var url = &#x27;https://api.github.com/users/github&#x27;;  var result = yield fetch(url);  console.log(result.bio);&#125;var g = gen();var result = g.next();result.value.then(function(data)&#123;  return data.json();&#125;).then(function(data)&#123;  g.next(data);&#125;);\n\nThunk 函数的含义编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。\nJavaScript 语言的 Thunk 函数“传值调用”（call by value），即在进入函数体之前，就计算x + 5的值（等于 6），再将这个值传入函数f。C 语言就采用这种策略。\n“传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。\n// Thunk版本的readFile（单参数版本）var Thunk = function (fileName) &#123;  return function (callback) &#123;    return fs.readFile(fileName, callback);  &#125;;&#125;;var readFileThunk = Thunk(fileName);readFileThunk(callback);\n\n\nThunkify增加了重复执行的判断\nfunction thunkify(fn) &#123;  return function() &#123;    var args = new Array(arguments.length);    var ctx = this;    for (var i = 0; i &lt; args.length; ++i) &#123;      args[i] = arguments[i];    &#125;    return function (done) &#123;      var called;      args.push(function () &#123;        if (called) return;        called = true;        done.apply(null, arguments);      &#125;);      try &#123;        fn.apply(ctx, args);      &#125; catch (err) &#123;        done(err);      &#125;    &#125;  &#125;&#125;;\n\n基于Thunk自动流程管理\n实现自动执行，一定会自动调用Generator函数执行后的next()方法\n\n通过while的判断是否需要执行下一步\nfunction run(fn) &#123;    const g = fn();    let res = g.next();    while (res.value) &#123;        res = g.next();    &#125;&#125;;function* g() &#123;    yield 1;    yield 2;    return 3&#125;run(g);\n\n结合函数式编程的思想，这里不应该通过循环实现，应该递归调用，考虑创建一个子函数 next用于递归调用\nfunction run(fn) &#123;    const g = fn();    function next() &#123;        const res = g.next();        if (!res.done) next()    &#125;    next()&#125;;function* g() &#123;    yield 1;    yield 2;    return 3&#125;run(g);\n\n有返回值的情况\nfunction run(fn) &#123;    const g = fn();    function next(val) &#123;        const res = g.next(val);        if (!res.done) next(res.value)    &#125;    next()&#125;;function* g() &#123;    const a = yield 2;    const b = yield a * 2;    const c = yield b * 2;    return c * 2&#125;run(g);\n\n内部的next函数就是 Thunk 的回调函数。next函数先将指针移到 Generator 函数的下一步（gen.next方法），然后判断 Generator 函数是否结束（result.done属性），如果没结束，就将next函数再传入 Thunk 函数（result.value属性），否则就直接退出。\nconst fs = require(&#x27;fs&#x27;);const Thunk = function (fn) &#123;  return function (...args) &#123;    return function (callback) &#123;      return fn.call(this, ...args, callback);    &#125;  &#125;;&#125;;const readFileThunk1 = Thunk(fs.readFile)(&#x27;./1.txt&#x27;);const readFileThunk2 = Thunk(fs.readFile)(&#x27;./2.txt&#x27;);const readFileThunk3 = Thunk(fs.readFile)(&#x27;./3.txt&#x27;);function run(fn) &#123;  const g = fn();  function next(err, data) &#123;    if (err) throw new Error();    const res = g.next(data)    if (!res.done) res.value(next)  &#125;  next()&#125;;function* g() &#123;  const a = yield readFileThunk1;  const b = yield readFileThunk2;  const c = yield readFileThunk3;&#125;console.log(run(g));\n\n基于Promise的自动执行器const fs = require(&#x27;fs&#x27;);const readFile = function (path) &#123;  return new Promise((resolve, reject) =&gt; &#123;    fs.readFile(path, function (err, data) &#123;      if (err) return reject(err);      resolve(data);    &#125;)  &#125;)&#125;function run(fn) &#123;  const g = fn();  function next(data) &#123;    const res = g.next(data);    if (!res.done) res.value.then(data =&gt; next(data));    return res.value;  &#125;  next()&#125;;function* g() &#123;  const a = yield readFile(&#x27;./1.txt&#x27;);  const b = yield readFile(&#x27;./2.txt&#x27;);  const c = yield readFile(&#x27;./3.txt&#x27;);  return &#x27;end&#x27;&#125;run(g)\n\nco的实现function co(gen) &#123;    var ctx = this;    var args = slice.call(arguments, 1);    // 统一返回Promise对象    return new Promise(function (resolve, reject) &#123;        //co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为resolved。        if (typeof gen === &#x27;function&#x27;) gen = gen.apply(ctx, args);        if (!gen || typeof gen.next !== &#x27;function&#x27;) return resolve(gen);        onFulfilled();        //co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。        function onFulfilled(res) &#123;            var ret;            try &#123;                ret = gen.next(res);            &#125; catch (e) &#123;                return reject(e);            &#125;            next(ret);            return null;        &#125;        function onRejected(err) &#123;            var ret;            try &#123;                ret = gen.throw(err);            &#125; catch (e) &#123;                return reject(e);            &#125;            next(ret);        &#125;        function next(ret) &#123;            if (ret.done) return resolve(ret.value);            //确保每一步的返回值，是 Promise 对象。            var value = toPromise.call(ctx, ret.value);            //使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。            if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);            //在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。            return onRejected(new TypeError(                &#x27;You may only yield a function, promise, generator, array, or object, &#x27; +                &#x27;but the following object was passed: &quot;&#x27; + String(ret.value) + &#x27;&quot;&#x27;));        &#125;    &#125;);&#125;","categories":["JavaScript","基础"],"tags":["JavaScript","ES6基础"]},{"title":"Iterator","url":"/posts/a4bc3a9860ef/","content":"概念ES6在原有Array,Object增加了Map,Set,共有4种用于表示集合的数据解构\n遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作\nIterator 的作用有三个：\n\n一是为各种数据结构，提供一个统一的、简便的访问接\n\n二是使得数据结构的成员能够按某种次序排列\n\n三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。\n\n\nIterator 的遍历过程是这样的。\n\n创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n\n第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n\n不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\n\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n默认 Iterator 接口当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。\nES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性.\n一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。\n原生具备 Iterator 接口的数据结构如下。\n\nArray\nMap\nSet\nString\nTypedArray\n函数的 arguments 对象\nNodeList 对象\n\n对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。\n调用场合\n解构赋值\n\n扩展运算符\n\nyield*\n\n\n数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口\n\nfor…of\nArray.from()\nMap(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）\nPromise.all()\nPromise.race()\n\n结合Generator函数let obj = &#123;  * [Symbol.iterator]() &#123;    yield &#x27;hello&#x27;;    yield &#x27;world&#x27;;  &#125;&#125;;\n\n遍历器对象的 return()，throw()return()方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句），就会调用return()方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return()方法。\nreturn()方法必须返回一个对象，这是 Generator 语法决定的。\nthrow()方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。\n与其他遍历语法forEach无法中途跳出\nfor...in循环有几个缺点。数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。\nfor...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。某些情况下，for...in循环会以任意顺序遍历键名。\nfor...of有着同for…in一样的简洁语法，但是没有for…in那些缺点。不同于forEach方法，它可以与break、continue和return配合使用。提供了遍历所有数据结构的统一操作接口。\n","categories":["JavaScript","基础"],"tags":["JavaScript","ES6基础"]},{"title":"Koa Router","url":"/posts/7855919be700/","content":"中间件中间件容器 负责不同组件和不同服务之间的交互，需要一个中间件负责统一的对服务使用\n一个简单的中间件\nconst koa = require(&#x27;koa&#x27;);const app = new koa();const m1 = async (ctx, next) =&gt; &#123;  console.log(1);  await next();  console.log(2);&#125;const m2 = async (ctx, next) =&gt; &#123;  console.log(3);  await next();  console.log(4);&#125;const m3 = async (ctx, next) =&gt; &#123;  console.log(5);  await next();  console.log(6);&#125;app  .use(m1)  .use(m2)  .use(m3)app.listen(3000)\n\n最终返回的结果为 1 3 5 2 4 6\n也就是洋葱模型，由koa-compose模块来实现\n实现洋葱模型的几个关键：\n\n统一的上下文 ctx\n操作先进后出 通过next控制\n有提前结束的机制\n\n中间件类型\n\n应用级中间件 vue全局导航守卫\n路由级中间件 独享路由守卫\n错误处理中间件  \n第三方中间件\n\nconst koa = require(&#x27;koa&#x27;);const Router = require(&#x27;koa-router&#x27;)const app = new koa();const router = new Router();const m1 = async (ctx, next) =&gt; &#123;  // 应用级中间件最先被访问  console.log(&#x27;应用级中间件&#x27;);  //通过next进入路由级中间件  await next();  if (ctx.status == 404) &#123;    ctx.body = &#x27;404&#x27;  &#125;&#125;// 路由级中间件会按照顺序访问router.get(&#x27;/&#x27;, async (ctx, next) =&gt; &#123;  console.log(&#x27;路由级中间件1&#x27;);  await next()&#125;)router.get(&#x27;/&#x27;, async (ctx, next) =&gt; &#123;  console.log(&#x27;路由级中间件2&#x27;);  ctx.body = &#x27;路由&#x27;&#125;)app.use(router.routes());app  .use(m1)app.listen(3000)\n\nkoa 和 express 比较express 通过connect添加中间件 封装了路由，视图, 异步处理使用callback (深层次的错误不能捕获)\nkoa 依赖于co模块，不包含任何中间件， 处理了回调 (使用了async await) 和错误处理(使用了try catch),\n处理get post 请求参数koa-body\n静态资源中间件koa-static\n","categories":["JavaScript"],"tags":["JavaScript","Koa"]},{"title":"let const","url":"/posts/a3107e8a8e51/","content":"let\n只在let命令所在的代码块内有效\n\n&#123;  let a = 10;  var b = 1;&#125;a // ReferenceError: a is not defined.b // 1\n\n\nfor循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\n\nfor (let i = 0; i &lt; 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not defined\n\n\n不存在变量提升\n声明的变量一定要在声明后使用，否则报错。\n\n\n// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;\n\n\n暂时性死区\n只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n如果要使用let声明的变量无论读取还是赋值，都要在声明之后\n在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n\nvar tmp = 123;if (true) &#123;  tmp = &#x27;abc&#x27;; // ReferenceError  let tmp;&#125;\n\n  对typeof的使用有影响，生命前使用会报错，没有声明的反而不会报错\ntypeof x; // ReferenceErrorlet x;typeof undeclared_variable // &quot;undefined&quot;\n\n暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\n不允许重复声明\n不能在函数内部重新声明参数。\n\n\nfunction func(arg) &#123;    let arg;&#125;func() // 报错function func(arg) &#123;    &#123;        let arg;    &#125;&#125;func() // 不报错\n\n块级作用域没有块级作用域，这带来很多不合理的场景。\n\n内层变量可能会覆盖外层变量。\n\nvar tmp = new Date();function f() &#123;  console.log(tmp);  if (false) &#123;    var tmp = &#x27;hello world&#x27;;  &#125;&#125;f(); // undefined\n\n\n用来计数的循环变量泄露为全局变量。\n\nvar s = &#x27;hello&#x27;;for (var i = 0; i &lt; s.length; i++) &#123;  console.log(s[i]);&#125;console.log(i); // 5\n\nES6 的块级作用域\nlet实际上为 JavaScript 新增了块级作用域。\n\nfunction f1() &#123;  let n = 5;  if (true) &#123;    let n = 10;  &#125;  console.log(n); // 5&#125;\n\n\n块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。\n\n// IIFE 写法(function () &#123;  var tmp = ...;  ...&#125;());// 块级作用域写法&#123;  let tmp = ...;  ...&#125;\n\n\n在块级作用域中声明函数\nES5 的规定都是非法的。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。\n\n\n// 浏览器的 ES6 环境function f() &#123; console.log(&#x27;I am outside!&#x27;); &#125;(function () &#123;  if (false) &#123;    // 重复声明一次函数f    function f() &#123; console.log(&#x27;I am inside!&#x27;); &#125;  &#125;  f();&#125;());// Uncaught TypeError: f is not a function\n\n理论上上面的代码在ES6浏览器会报错，但在真实浏览器环境中还是会执行方法，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。\n1.允许在块级作用域内声明函数。\n2.函数声明类似于var，即会提升到全局作用域或函数作用域的头部。\n3.同时，函数声明还会提升到所在的块级作用域的头部。\n应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。\n// 块级作用域内部的函数声明语句，建议不要使用&#123;  let a = &#x27;secret&#x27;;  function f() &#123;    return a;  &#125;&#125;// 块级作用域内部，优先使用函数表达式&#123;  let a = &#x27;secret&#x27;;  let f = function () &#123;    return a;  &#125;;\n\nES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。\nlet只能出现在当前作用域的顶层\n// 第一种写法，报错if (true) let x = 1;// 第二种写法，不报错if (true) &#123;  let x = 1;&#125;\n\n严格模式下，函数只能声明在当前作用域的顶层。\n// 不报错&#x27;use strict&#x27;;if (true) &#123;  function f() &#123;&#125;&#125;// 报错&#x27;use strict&#x27;;if (true)  function f() &#123;&#125;\n\nconstconst声明一个只读的常量。一旦声明，常量的值就不能改变。\nconst一旦声明变量，就必须立即初始化，不能留到以后赋值。\n其他特性与let相同\nconst实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\nconst a = [];a.push(&#x27;Hello&#x27;); // 可执行a.length = 0;    // 可执行a = [&#x27;Dave&#x27;];    // 报错\n\n如果不想让对象的属性可操作，应该使用Object.freeze方法。\nvar constantize = (obj) =&gt; &#123;  Object.freeze(obj);  Object.keys(obj).forEach( (key, i) =&gt; &#123;    if ( typeof obj[key] === &#x27;object&#x27; ) &#123;      constantize( obj[key] );    &#125;  &#125;);&#125;;\n\nES6 声明变量的六种方法var,function,let,const,import,class\n顶层对象的属性是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）\n为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。\nglobalThis 对象JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。\n\n浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。\n\n浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。\n\nNode 里面，顶层对象是global，但其他环境都不支持。\n\n\n同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。\n\n全局环境中，this会返回顶层对象。但是，Node.js 模块中this返回的是当前模块，ES6 模块中this返回的是undefined。\n\n函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。\n\n不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。\n\n\n// 方法一(typeof window !== &#x27;undefined&#x27;   ? window   : (typeof process === &#x27;object&#x27; &amp;&amp;      typeof require === &#x27;function&#x27; &amp;&amp;      typeof global === &#x27;object&#x27;)     ? global     : this);// 方法二var getGlobal = function () &#123;  if (typeof self !== &#x27;undefined&#x27;) &#123; return self; &#125;  if (typeof window !== &#x27;undefined&#x27;) &#123; return window; &#125;  if (typeof global !== &#x27;undefined&#x27;) &#123; return global; &#125;  throw new Error(&#x27;unable to locate global object&#x27;);&#125;;","categories":["JavaScript"],"tags":["JavaScript","ES6基础"]},{"title":"Object新特性","url":"/posts/b9d1ca6378f6/","content":"属性的简洁表示法const foo = &#x27;bar&#x27;;const baz = &#123;foo&#125;;\n\n属性名表达式性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]\nlet propKey = &#x27;foo&#x27;;let obj = &#123;  [propKey]: true,  [&#x27;a&#x27; + &#x27;bc&#x27;]: 123&#125;;\n\n方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。\n如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。\nconst obj = &#123;  get foo() &#123;&#125;,  set foo(x) &#123;&#125;&#125;;obj.foo.name// TypeError: Cannot read property &#x27;name&#x27; of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;);descriptor.get.name // &quot;get foo&quot;descriptor.set.name // &quot;set foo&quot;\n\n有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。\n(new Function()).name // &quot;anonymous&quot;var doSomething = function() &#123;  // ...&#125;;doSomething.bind().name // &quot;bound doSomething&quot;\n\n如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。\nconst key1 = Symbol(&#x27;description&#x27;);const key2 = Symbol();let obj = &#123;  [key1]() &#123;&#125;,  [key2]() &#123;&#125;,&#125;;obj[key1].name // &quot;[description]&quot;obj[key2].name // &quot;&quot;\n\n属性的可枚举性和遍历可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。\nlet obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;)//  &#123;//    value: 123,//    writable: true,//    enumerable: true,//    configurable: true//  &#125;\n\n\n有四个操作会忽略enumerable为false的属性。\n\nfor...in循环：只遍历对象自身的和继承的可枚举的属性。\n\nObject.keys()：返回对象自身的所有可枚举的属性的键名。\n\nJSON.stringify()：只串行化对象自身的可枚举的属性。\n\nObject.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。\n\n\nClass 的原型的方法都是不可枚举的。\nObject.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, &#x27;foo&#x27;).enumerable// false\n\n操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。\n属性的遍历\nfor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。\n\nObject.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\n\nObject.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。\n\nObject.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。\n\nReflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\n\n\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。\n\n首先遍历所有数值键，按照数值升序排列。\n\n其次遍历所有字符串键，按照加入时间升序排列。\n\n最后遍历所有 Symbol 键，按照加入时间升序排列。\n\n\nsuper 关键字super 指向当前对象的原型对象。\nsuper关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。\n也不可以直接调用super对象，只能调用super下面的方法\n// 报错const obj = &#123;  foo: super.foo&#125;// 报错const obj = &#123;  foo: () =&gt; super.foo&#125;// 报错const obj = &#123;  foo: function () &#123;    return super.foo  &#125;&#125;//报错const obj = &#123;    fn()&#123;        return super === obj.__proto__    &#125;&#125;\n\nlet obj = &#123;    fn() &#123;        return super.a === this.__proto__.a    &#125;&#125;obj.__proto__.a = 1;console.log(obj.fn()) //true\n\n解构赋值扩展运算符的解构赋值，不能复制继承自原型对象的属性。\nconst o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3;let &#123; x, ...newObj &#125; = o;let &#123; y, z &#125; = newObj;x // 1y // undefinedz // 3\n\nES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式\nlet &#123; x, ...&#123; y, z &#125; &#125; = o;// SyntaxError: ... must be followed by an identifier in declaration contexts\n\n对象的扩展运算符如果扩展运算符后面不是对象，则会自动将其转为对象。\n扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。\n// 等同于 &#123;...Object(1)&#125;&#123;...1&#125; // &#123;&#125;\n\n对象的扩展运算符等同于使用Object.assign()方法。\n// 写法一const clone1 = &#123;  __proto__: Object.getPrototypeOf(obj),  ...obj&#125;;// 写法二const clone2 = Object.assign(  Object.create(Object.getPrototypeOf(obj)),  obj);// 写法三const clone3 = Object.create(  Object.getPrototypeOf(obj),  Object.getOwnPropertyDescriptors(obj))\n\n取值函数get在扩展a对象时会自动执行，导致报错。\nlet a = &#123;  get x() &#123;    throw new Error(&#x27;not throw yet&#x27;);  &#125;&#125;let aWithXGetter = &#123; ...a &#125;; // 报错\n\n链判断运算符a?.b// 等同于a == null ? undefined : a.ba?.[x]// 等同于a == null ? undefined : a[x]a?.b()// 等同于a == null ? undefined : a.b()a?.()// 等同于a == null ? undefined : a()\n\nconst firstName = message?.body?.user?.firstName || &#x27;default&#x27;;const fooValue = myForm.querySelector(&#x27;input[name=foo]&#x27;)?.value\n\nNull 判断运算符ES2020 引入了一个新的 Null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。\nconst animationDuration = response.settings?.animationDuration ?? 300;\n\n","categories":["JavaScript"],"tags":["JavaScript","ES6基础"]},{"title":"Object新增方法","url":"/posts/161e4611a149/","content":"Object.is()用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。\n不同之处只有两个：一是+0不等于-0，二是NaN等于自身。\nObject.defineProperty(Object, &#x27;is&#x27;, &#123;  value: function(x, y) &#123;    if (x === y) &#123;      // x===y 是前提，x!==0排除为零的情况，如果xy为0通过转为Infinity判断      return x !== 0 || 1 / x === 1 / y;    &#125;    // 针对NaN的情况， NaN!==NaN    return x !== x &amp;&amp; y !== y;  &#125;,  configurable: true,  enumerable: false,  writable: true&#125;);\n\nObject.assign()将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象。并不会返回新对象\n只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。Symbol属性虽然不能被 Object.keys 等方法枚举，但是可以被拷贝\n由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。\nObject.assign(undefined) // 报错Object.assign(null) // 报错let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true\n\n其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。因为只有字符串的包装对象，会产生可枚举属性。\nObject(true) // &#123;[[PrimitiveValue]]: true&#125;Object(10)  //  &#123;[[PrimitiveValue]]: 10&#125;Object(&#x27;abc&#x27;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;\n\n注意点\n\n浅拷贝\n\n同名属性的替换\n\n数组的处理\nObject.assign() 可以用来处理数组，但是会把数组视为对。Object.assign()把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。\n\n\nObject.assign([1, 2, 3], [4, 5])// [4, 5, 3]\n\n\n取值函数的处理\n\nObject.assign() 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。\nconst source = &#123;  get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125;\n\nObject.create()Object.create() 是一个ES5的方法，经常与 Object.assign 混用\nObject.create() 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\nObject.create(proto[, propertiesObject])// proto 新创建对象的原型对象。// propertiesObject 可选。需要传入一个对象，该对象的属性类型参照Object.defineProperties()的第二个参数。如果该参数被指定且不为 undefined，该传入对象的自有可枚举属性(即其自身定义的属性，而不是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符。\n\npropertiesObject参数是 null 或非原始包装对象，则抛出一个 TypeError 异常。\n常见用途\n为对象添加属性\n\n为对象添加方法\n\n克隆对象\n如果想要保持继承链\n\n\nfunction clone(origin) &#123;  let originProto = Object.getPrototypeOf(origin);  return Object.assign(Object.create(originProto), origin);&#125;\n\n\n合并多个对象\n\nconst merge =  (target, ...sources) =&gt; Object.assign(target, ...sources);\n\n\n属性指定默认值\n\nObject.assign(&#123;&#125;, DEFAULTS, options);\n\nObject.getOwnPropertyDescriptors()返回指定对象所有自身属性（非继承属性）的描述对象。\nfunction getOwnPropertyDescriptors(obj) &#123;  const result = &#123;&#125;;  for (let key of Reflect.ownKeys(obj)) &#123;    result[key] = Object.getOwnPropertyDescriptor(obj, key);  &#125;  return result;&#125;\n\n该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。\nconst merge = (target, source) =&gt; Object.defineProperties(    target,    Object.getOwnPropertyDescriptors(source))\n\nObject.getOwnPropertyDescriptors()方法的另一个用处，是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。\nconst shallowClone = (obj) =&gt; Object.create(  Object.getPrototypeOf(obj),  Object.getOwnPropertyDescriptors(obj));\n\nlet mix = (object) =&gt; (&#123;  with: (...mixins) =&gt; mixins.reduce(    (c, mixin) =&gt; Object.create(      c, Object.getOwnPropertyDescriptors(mixin)    ), object)&#125;);\n\n__proto__属性__proto__ 本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6.\n无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。\n实现上，__proto__调用的是Object.prototype.__proto__，具体实现如下。\nObject.defineProperty(Object.prototype, &#x27;__proto__&#x27;, &#123;  get() &#123;    let _thisObj = Object(this);    return Object.getPrototypeOf(_thisObj);  &#125;,  set(proto) &#123;    if (this === undefined || this === null) &#123;      throw new TypeError();    &#125;    if (!isObject(this)) &#123;      return undefined;    &#125;    if (!isObject(proto)) &#123;      return undefined;    &#125;    let status = Reflect.setPrototypeOf(this, proto);    if (!status) &#123;      throw new TypeError();    &#125;  &#125;,&#125;);function isObject(value) &#123;  return Object(value) === value;&#125;\n\n如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。\nObject.getPrototypeOf(&#123; __proto__: null &#125;)\n\nObject.setPrototypeOf()function setPrototypeOf(obj, proto) &#123;  obj.__proto__ = proto;  return obj;&#125;\n\n如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。\nObject.setPrototypeOf(1, &#123;&#125;) === 1 // trueObject.setPrototypeOf(&#x27;foo&#x27;, &#123;&#125;) === &#x27;foo&#x27; // trueObject.setPrototypeOf(true, &#123;&#125;) === true // true\n\n\nObject.getPrototypeOf()如果参数不是对象，会被自动转为对象。\n// 等同于 Object.getPrototypeOf(Number(1))Object.getPrototypeOf(1)// Number &#123;[[PrimitiveValue]]: 0&#125;// 等同于 Object.getPrototypeOf(String(&#x27;foo&#x27;))Object.getPrototypeOf(&#x27;foo&#x27;)// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;// 等同于 Object.getPrototypeOf(Boolean(true))Object.getPrototypeOf(true)// Boolean &#123;[[PrimitiveValue]]: false&#125;Object.getPrototypeOf(1) === Number.prototype // trueObject.getPrototypeOf(&#x27;foo&#x27;) === String.prototype // trueObject.getPrototypeOf(true) === Boolean.prototype // true\n\nObject.keys()，Object.values()，Object.entries()Object.entries实现\n// Generator函数的版本function* entries(obj) &#123;  for (let key of Object.keys(obj)) &#123;    yield [key, obj[key]];  &#125;&#125;// 非Generator函数的版本function entries(obj) &#123;  let arr = [];  for (let key of Object.keys(obj)) &#123;    arr.push([key, obj[key]]);  &#125;  return arr;&#125;Object.from\n\n\nObject.fromEntries()Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。\n// 例一const entries = new Map([  [&#x27;foo&#x27;, &#x27;bar&#x27;],  [&#x27;baz&#x27;, 42]]);Object.fromEntries(entries)// &#123; foo: &quot;bar&quot;, baz: 42 &#125;// 例二const map = new Map().set(&#x27;foo&#x27;, true).set(&#x27;bar&#x27;, false);Object.fromEntries(map)// &#123; foo: true, bar: false &#125;\n","categories":["JavaScript"],"tags":["JavaScript","ES6基础"]},{"title":"Proxy","url":"/posts/f756b03cc566/","content":"简介Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\n可以理解成 Proxy 代理了点运算符，和赋值运算符\n通用用法： ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。\nvar object = &#123; proxy: new Proxy(target, handler) &#125;;\n\nproxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。\nvar proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, propKey) &#123;    return 35;  &#125;&#125;);let obj = Object.create(proxy);obj.time // 35\n\nget()get 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。\nconst target = Object.defineProperties(&#123;&#125;, &#123;  foo: &#123;    value: 123,    writable: false,    configurable: false  &#125;,&#125;);const handler = &#123;  get(target, propKey) &#123;    return &#x27;abc&#x27;;  &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo// TypeError: Invariant check failed\n\nset()set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。\n严格模式下，set代理如果没有返回true，就会报错。\nhas()如果原对象不可配置或者禁止扩展，这时has()拦截会报错。\nhas()拦截只对in运算符生效，对for…in循环不生\nvar obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123;  has: function(target, prop) &#123;    return false;  &#125;&#125;);&#x27;a&#x27; in p // TypeError is thrown\n\nconstruct()construct()方法返回的必须是一个对象，否则会报错。\nconst p = new Proxy(function() &#123;&#125;, &#123;  construct: function(target, argumentsList) &#123;    return 1;  &#125;&#125;);new p() // 报错// Uncaught TypeError: &#x27;construct&#x27; on proxy: trap returned non-object (&#x27;1&#x27;)\n\n由于construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。\nconst p = new Proxy(&#123;&#125;, &#123;  construct: function(target, argumentsList) &#123;    return &#123;&#125;;  &#125;&#125;);new p() // 报错// Uncaught TypeError: p is not a constructor\n\nconstruct()方法中的this指向的是handler，而不是实例对象。\nconst handler = &#123;  construct: function(target, args) &#123;    console.log(this ===  handler);    return new target(...args);  &#125;&#125;let p = new Proxy(function () &#123;&#125;, handler);new p() // true\n\ndeleteProperty()目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。\n","categories":["JavaScript"],"tags":["JavaScript","ES6基础"]},{"title":"react-draggable 源码分析","url":"/posts/1b2dc5f38592/","content":"react-draggable 一个可以让组件实现拖拽的库\n整体结构只有两个核心文件,Draggable 和 DraggableCore\nDraggable 的作用是初始化组件,并且预处理一些参数,最终的核心逻辑由 DraggableCore 完成\nclass Draggable extends React.Component&lt;DraggableProps, DraggableState&gt; &#123;  //可选属性  static propTypes = &#123;    allowAnyClick: PropTypes.bool, //任意鼠标键可以拖动    disabled: PropTypes.bool, // 禁止拖动    enableUserSelectHack: PropTypes.bool, //如果禁止页面元素可以被选择无效,可以使用这个属性    offsetParent: PropTypes.HTMLElement, // 计算初始偏移量的时候会相对于这个元素    grid: PropTypes.arrayOf(PropTypes.number), //以网格的形式移动元素    handle: PropTypes.string, // 指定元素可拖动的区域    cancel: PropTypes.string, //指定元素不能拖动的区域    nodeRef: PropTypes.object, //用于直接指定那个元素可以被拖动    onStart: PropTypes.func, //自定义拖动开始时的回调函数    onDrag: PropTypes.func, //自定义拖动中的回调函数    onStop: PropTypes.func, //自定义拖动结束时候的回调函数    onMouseDown: PropTypes.func,    scale: PropTypes.number, // 拖动时候的偏移比例    axis: PropTypes.oneOf([&quot;both&quot;, &quot;x&quot;, &quot;y&quot;, &quot;none&quot;]), //指明可拖动的方向轴    // 拖动边界    bounds: PropTypes.oneOfType([      PropTypes.shape(&#123;        left: PropTypes.number,        right: PropTypes.number,        top: PropTypes.number,        bottom: PropTypes.number,      &#125;),      PropTypes.string,      PropTypes.oneOf([false]),    ]),    //自定义拖动时候的样式    defaultClassName: PropTypes.string,    defaultClassNameDragging: PropTypes.string,    defaultClassNameDragged: PropTypes.string,    // 默认位置    defaultPosition: PropTypes.shape(&#123;      x: PropTypes.number,      y: PropTypes.number,    &#125;),    // 默认偏移量    positionOffset: PropTypes.shape(&#123;      x: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),      y: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),    &#125;),  &#125;;  // 初始化状态  constructor(props: DraggableProps) &#123;    super(props);    this.state = &#123;      dragging: false,      dragged: false,      x: props.position ? props.position.x : props.defaultPosition.x,      y: props.position ? props.position.y : props.defaultPosition.y,      prevPropsPosition: &#123; ...props.position &#125;,      // 用于计算在边界外的拖动      slackX: 0,      slackY: 0,      isElementSVG: false,    &#125;;  &#125;  // 如果组件是受控的,检查新传入的值时候与上一次更新时候的值不同,避免组件频繁更新  static getDerivedStateFromProps(    &#123; position &#125;: DraggableProps,    &#123; prevPropsPosition &#125;: DraggableState  ): ?$Shape&lt;DraggableState&gt; &#123;    if (      position &amp;&amp;      (!prevPropsPosition ||        position.x !== prevPropsPosition.x ||        position.y !== prevPropsPosition.y)    ) &#123;      return &#123;        x: position.x,        y: position.y,        prevPropsPosition: &#123; ...position &#125;,      &#125;;    &#125;    return null;  &#125;  findDOMNode() &#123;&#125;  // 预处理用户提供的事件绑定方法  // 其他的事件属性与这个类似  onDragStart(e, coreData) &#123;    // 创建一个事件对象,返回给使用者    const shouldStart = this.props.onStart(      e,      createDraggableData(this, coreData)    );    // 如果绑定方法返回 false,那么同样放回false,在实际调用时停止程序执行    if (shouldStart === false) return false;    //标记状态, 表示拖动开始    this.setState(&#123; dragging: true, dragged: true &#125;);  &#125;  onDrag() &#123;    // Draggable 中的状态与 DraggableCore 中的状态是区分开的    if (!this.state.dragging) return false;    // 在这里处理边界问题和偏移量比例的问题    // 相当于把用户的自定义配置影响分离出来,DraggableCore 只处理核心拖拽的问题    function createDraggableData(draggable, coreData) &#123;      const scale = draggable.props.scale;      return &#123;        node: coreData.node,        x: draggable.state.x + coreData.deltaX / scale,        y: draggable.state.y + coreData.deltaY / scale,        deltaX: coreData.deltaX / scale,        deltaY: coreData.deltaY / scale,        lastX: draggable.state.x,        lastY: draggable.state.y,      &#125;;    &#125;    const uiData = createDraggableData(this, coreData);    const newState: $Shape&lt;DraggableState&gt; = &#123;      x: uiData.x,      y: uiData.y,    &#125;;    // Keep within bounds.    if (this.props.bounds) &#123;      // Save original x and y.      const &#123; x, y &#125; = newState;      // Add slack to the values used to calculate bound position. This will ensure that if      // we start removing slack, the element won&#x27;t react to it right away until it&#x27;s been      // completely removed.      newState.x += this.state.slackX;      newState.y += this.state.slackY;      const [newStateX, newStateY] = getBoundPosition(        this,        newState.x,        newState.y      );      newState.x = newStateX;      newState.y = newStateY;      // Recalculate slack by noting how much was shaved by the boundPosition handler.      newState.slackX = this.state.slackX + (x - newState.x);      newState.slackY = this.state.slackY + (y - newState.y);      // Update the event we fire to reflect what really happened after bounds took effect.      uiData.x = newState.x;      uiData.y = newState.y;      uiData.deltaX = newState.x - this.state.x;      uiData.deltaY = newState.y - this.state.y;    &#125;    // Short-circuit if user&#x27;s callback killed it.    const shouldUpdate = this.props.onDrag(e, uiData);    if (shouldUpdate === false) return false;    this.setState(newState);  &#125;  onDragStop() &#123;&#125;  render() &#123;    return (      &lt;DraggableCore        &#123;...draggableCoreProps&#125;        onStart=&#123;this.onDragStart&#125;        onDrag=&#123;this.onDrag&#125;        onStop=&#123;this.onDragStop&#125;      &gt;        &#123;React.cloneElement(React.Children.only(children), &#123;          className: className,          style: &#123; ...children.props.style, ...style &#125;,          transform: svgTransform,        &#125;)&#125;      &lt;/DraggableCore&gt;    );  &#125;&#125;class DraggableCore extends React.Component&lt;  DraggableCoreProps,  DraggableCoreState&gt; &#123;  componentDidMount() &#123;    this.mounted = true;    // 组件挂载时去查找需要挂载的元素,并绑定事件    const thisNode = this.findDOMNode();    // 因为移动短的touch 事件可能会让屏幕发生滚动,所以必须通过原生事件绑定传入 passive 参数    if (thisNode) &#123;      addEvent(thisNode, eventsFor.touch.start, this.onTouchStart, &#123;        passive: false,      &#125;);    &#125;  &#125;  findDOMNode(): ?HTMLElement &#123;    return this.props?.nodeRef      ? this.props?.nodeRef?.current      : ReactDOM.findDOMNode(this);  &#125;  handleDragStart() &#123;&#125;  handleDrag() &#123;&#125;  handleDragStop() &#123;&#125;  // 在组件上绑定下面四个方法,当方法被触发时,可以区分是否是触摸设备  onMouseDown() &#123;    const eventsFor = &#123;      touch: &#123;        start: &quot;touchstart&quot;,        move: &quot;touchmove&quot;,        stop: &quot;touchend&quot;,      &#125;,      mouse: &#123;        start: &quot;mousedown&quot;,        move: &quot;mousemove&quot;,        stop: &quot;mouseup&quot;,      &#125;,    &#125;;    dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse    return this.handleDragStart(e);  &#125;  onMouseUp() &#123;&#125;  onTouchStart() &#123;&#125;  onTouchEnd() &#123;&#125;&#125;\n\ngetBoundPositionfunction getBoundPosition(  draggable: Draggable,  x: number,  y: number): [number, number] &#123;  // If no bounds, short-circuit and move on  if (!draggable.props.bounds) return [x, y];  // Clone new bounds  let &#123; bounds &#125; = draggable.props;  bounds = typeof bounds === &quot;string&quot; ? bounds : cloneBounds(bounds);  const node = findDOMNode(draggable);  if (typeof bounds === &quot;string&quot;) &#123;    const &#123; ownerDocument &#125; = node;    const ownerWindow = ownerDocument.defaultView;    let boundNode;    if (bounds === &quot;parent&quot;) &#123;      boundNode = node.parentNode;    &#125; else &#123;      boundNode = ownerDocument.querySelector(bounds);    &#125;    if (!(boundNode instanceof ownerWindow.HTMLElement)) &#123;      throw new Error(        &#x27;Bounds selector &quot;&#x27; + bounds + &#x27;&quot; could not find an element.&#x27;      );    &#125;    const boundNodeEl: HTMLElement = boundNode; // for Flow, can&#x27;t seem to refine correctly    const nodeStyle = ownerWindow.getComputedStyle(node);    const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.    bounds = &#123;      left:        -node.offsetLeft +        int(boundNodeStyle.paddingLeft) +        int(nodeStyle.marginLeft),      top:        -node.offsetTop +        int(boundNodeStyle.paddingTop) +        int(nodeStyle.marginTop),      right:        innerWidth(boundNodeEl) -        outerWidth(node) -        node.offsetLeft +        int(boundNodeStyle.paddingRight) -        int(nodeStyle.marginRight),      bottom:        innerHeight(boundNodeEl) -        outerHeight(node) -        node.offsetTop +        int(boundNodeStyle.paddingBottom) -        int(nodeStyle.marginBottom),    &#125;;  &#125;  // Keep x and y below right and bottom limits...  if (isNum(bounds.right)) x = Math.min(x, bounds.right);  if (isNum(bounds.bottom)) y = Math.min(y, bounds.bottom);  // But above left and top limits.  if (isNum(bounds.left)) x = Math.max(x, bounds.left);  if (isNum(bounds.top)) y = Math.max(y, bounds.top);  return [x, y];&#125;\n\nhandleDragStartconst handleDragStart: EventHandler&lt;MouseTouchEvent&gt; = (e) =&gt; &#123;  // 用于自定义的 onMouseDown 事件  this.props.onMouseDown(e);  // 任意鼠标按键都一颗拖动,否则只有鼠标左键可以拖动  if (    !this.props.allowAnyClick &amp;&amp;    typeof e.button === &quot;number&quot; &amp;&amp;    e.button !== 0  )    return false;  // 查找到需要拖动的元素  const thisNode = this.findDOMNode();  if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) &#123;    throw new Error(&quot;&lt;DraggableCore&gt; not mounted on DragStart!&quot;);  &#125;  const &#123; ownerDocument &#125; = thisNode;  // 控制可拖动区域和不可拖动区域  // handle cancel 属性传入的是控制区域的元素标签名称  // 用原生的 matches 方法检查这个标签是否在拖动元素的内部,如果有就停止执行  element.matches(&#x27;p&#x27;)  // 这是真正的 onStart 方法还没有执行,不需要重置状态  if (    this.props.disabled ||    !(e.target instanceof ownerDocument.defaultView.Node) ||    (this.props.handle &amp;&amp;      !matchesSelectorAndParentsTo(e.target, this.props.handle, thisNode)) ||    (this.props.cancel &amp;&amp;      matchesSelectorAndParentsTo(e.target, this.props.cancel, thisNode))  ) &#123;    return;  &#125;  // Prevent scrolling on mobile devices, like ipad/iphone.  // Important that this is after handle/cancel.  if (e.type === &quot;touchstart&quot;) e.preventDefault();  // Set touch identifier in component state if this is a touch event. This allows us to  // distinguish between individual touches on multitouch screens by identifying which  // touchpoint was set to this element.  // 记录触摸点的 id  const touchIdentifier = getTouchIdentifier(e);  this.setState(&#123; touchIdentifier &#125;);  // Get the current drag point from the event. This is used as the offset.  // 首先如果存在触摸点,则回去touch 事件,否则获取原生的 event  // 通过 findDOMNode 查找需要拖动的元素, 获取用于计算相对位置的元素 offsetParent 如果没有这个属性就用上级 parentNode || document  // const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;  // const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;  // 获取相对于父元素的鼠标位置  const position = getControlPosition(e, touchIdentifier, this);  if (position == null) return; // not possible but satisfies flow  const &#123; x, y &#125; = position;  // Create an event object with all the data parents need to make a decision here.  const coreEvent = createCoreData(this, x, y);  // 真正执行 onStart 方法  const shouldUpdate = this.props.onStart(e, coreEvent);  // 如果返回值为false 停止执行  if (shouldUpdate === false || this.mounted === false) return;  // Add a style to the body to disable user-select. This prevents text from  // being selected all over the page.  if (this.props.enableUserSelectHack) addUserSelectStyles(ownerDocument);  // Initiate dragging. Set the current x and y as offsets  // so we know how much we&#x27;ve moved during the drag. This allows us  // to drag elements around even if they have been moved, without issue.  this.setState(&#123;    dragging: true,    lastX: x,    lastY: y,  &#125;);  // Add events to the document directly so we catch when the user&#x27;s mouse/touch moves outside of  // this element. We use different events depending on whether or not we have detected that this  // is a touch-capable device.  addEvent(ownerDocument, dragEventFor.move, this.handleDrag);  addEvent(ownerDocument, dragEventFor.stop, this.handleDragStop);&#125;;\n\nhandleDragconst handleDrag: EventHandler&lt;MouseTouchEvent&gt; = (e) =&gt; &#123;  // Get the current drag point from the event. This is used as the offset.  const position = getControlPosition(e, this.state.touchIdentifier, this);  if (position == null) return;  let &#123; x, y &#125; = position;  // 实现按网格拖动  if (Array.isArray(this.props.grid)) &#123;    let deltaX = x - this.state.lastX,      deltaY = y - this.state.lastY;    const deltaX = Math.round(deltaX / this.props.grid[0]) * this.props.grid[0];    const deltaY = Math.round(deltaY / this.props.grid[0]) * this.props.grid[0];    if (!deltaX &amp;&amp; !deltaY) return; // skip useless drag    (x = this.state.lastX + deltaX), (y = this.state.lastY + deltaY);  &#125;  const coreEvent = createCoreData(this, x, y);  // Call event handler. If it returns explicit false, trigger end.  // 指定自定义方法,如果返回 false 手动停止执行  const shouldUpdate = this.props.onDrag(e, coreEvent);  if (shouldUpdate === false || this.mounted === false) &#123;    try &#123;      // $FlowIgnore      this.handleDragStop(new MouseEvent(&quot;mouseup&quot;));    &#125; catch (err) &#123;&#125;    return;  &#125;  this.setState(&#123;    lastX: x,    lastY: y,  &#125;);&#125;;\n\nhandleDragStopconst handleDragStop: EventHandler&lt;MouseTouchEvent&gt; = (e) =&gt; &#123;  if (!this.state.dragging) return;  const position = getControlPosition(e, this.state.touchIdentifier, this);  if (position == null) return;  let &#123; x, y &#125; = position;  // Snap to grid if prop has been provided  if (Array.isArray(this.props.grid)) &#123;    let deltaX = x - this.state.lastX || 0;    let deltaY = y - this.state.lastY || 0;    [deltaX, deltaY] = snapToGrid(this.props.grid, deltaX, deltaY);    (x = this.state.lastX + deltaX), (y = this.state.lastY + deltaY);  &#125;  const coreEvent = createCoreData(this, x, y);  // Call event handler  const shouldContinue = this.props.onStop(e, coreEvent);  if (shouldContinue === false || this.mounted === false) return false;  const thisNode = this.findDOMNode();  if (thisNode) &#123;    // Remove user-select hack    if (this.props.enableUserSelectHack)      removeUserSelectStyles(thisNode.ownerDocument);  &#125;  // 重置状态并移除事件  // Reset the el.  this.setState(&#123;    dragging: false,    lastX: NaN,    lastY: NaN,  &#125;);  if (thisNode) &#123;    // Remove event handlers    removeEvent(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);    removeEvent(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);  &#125;&#125;;\n","categories":["Javascript"],"tags":["React"]},{"title":"Reflect","url":"/posts/9b0ba8e2db08/","content":"概念将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。\n修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。\n// 老写法try &#123;  Object.defineProperty(target, property, attributes);  // success&#125; catch (e) &#123;  // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123;  // success&#125; else &#123;  // failure&#125;\n\n让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\n// 老写法&#x27;assign&#x27; in Object // true// 新写法Reflect.has(Object, &#x27;assign&#x27;) // true\n\nReflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。\n","categories":["JavaScript","基础"],"tags":["JavaScript","ES6基础"]},{"title":"字符串","url":"/posts/5ad83b69523f/","content":"字符的 Unicode 表示法ES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 &quot;\\u0061&quot;===&quot;a&quot;\n这种表示法只限于码点在\\u0000~\\uFFFF之间的字符，对双字节的文字 𠮷 不能解析&quot;\\u20BB7&quot;,因为对于超出范围的文字会解析成\\u20BB 和 7，ES6 对这一点做出了改进,通过使用大括号的方式 &quot;\\u&#123;20BB7&#125;&quot;===&quot;𠮷&quot;\n\n中文转Unicode的方法\n\nfunction toUnicode(str) &#123;    if (typeof str !== &#x27;string&#x27;) &#123;        throw new Error()    &#125;    if (str === &#x27;&#x27;) &#123;        return;    &#125;    var res = &#x27;&#x27;;    for (var i = 0; i &lt; str.length; i++) &#123;        res += &#x27;\\\\u&#x27; + str[i].charCodeAt().toString(16)    &#125;    return res;&#125;\n\nfunction toUnicode(str) &#123;    if (typeof str !== &#x27;string&#x27;) &#123;        throw new Error()    &#125;    if (str === &#x27;&#x27;) &#123;        return;    &#125;    let res = &#x27;&#x27;;    for (let s of str) &#123;        res += `\\\\u&#123;$&#123;s.codePointAt().toString(16)&#125;&#125;`    &#125;    return res;&#125;\n\n\nUnicode转中文\n\nfunction toCh(str) &#123;    if (typeof str !== &#x27;string&#x27;) &#123;        throw new Error()    &#125;    if (str === &#x27;&#x27;) &#123;        return;    &#125;    var reg = /\\\\u&#123;([a-f0-9A-F]+)&#125;/g;    var res = &#x27;&#x27;;    while (reg.exec(str)) &#123;        res += String.fromCodePoint(parseInt(RegExp.$1, 16));    &#125;    return res;&#125;\n\nfromCodePoint codePointAtES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。\nString.fromCharCode(0x20BB7)// &quot;ஷ&quot;\n\n上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。\nString.fromCodePoint(0x20BB7)// &quot;𠮷&quot;String.fromCodePoint(0x78, 0x1f680, 0x79) === &#x27;x\\uD83D\\uDE80y&#x27;// true\n\n注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上\nJavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。\nvar s = &quot;𠮷&quot;;s.length // 2s.charAt(0) // &#x27;&#x27;s.charAt(1) // &#x27;&#x27;s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271\n\ncodePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别 32 位的 UTF-16 字符。\nlet s = &#x27;𠮷a&#x27;;for (let ch of s) &#123;  console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61\n\n另一种方法也可以，使用扩展运算符（…）进行展开运算。\nlet arr = [...&#x27;𠮷a&#x27;]; // arr.length === 2arr.forEach(  ch =&gt; console.log(ch.codePointAt(0).toString(16)));// 20bb7// 61\n\ncodePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。\nfunction is32Bit(c) &#123;  return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit(&quot;𠮷&quot;) // trueis32Bit(&quot;a&quot;) // false\n\n字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。\n除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。\nlet text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123;  console.log(text[i]);&#125;// &quot; &quot;// &quot; &quot;for (let i of text) &#123;  console.log(i);&#125;// &quot;𠮷&quot;\n\n需要转移的字符\n\n\n码点\n字符\n\n\n\nU+005C\n反斜杠（reverse solidus)\n\n\nU+000D\n回车（carriage return）\n\n\nU+2029\n段分隔符（paragraph separator）\n\n\nU+000A\n换行符（line feed）\n\n\nJSON.stringify()具体来说，UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。\nJSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。\n为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。\nJSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;&quot;\\\\uD834&quot;&quot;JSON.stringify(&#x27;\\uDF06\\uD834&#x27;) // &quot;&quot;\\\\udf06\\\\ud834&quot;&quot;\n\n模板字符串\n如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n\n如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。\n\n模板字符串中嵌入变量，需要将变量名写在${}之中。\n\n通过模板字符串编译模板\n\n\nlet template = `    &lt;ul&gt;        &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;            &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;        &lt;% &#125; %&gt;    &lt;/ul&gt;`;function complie(template) &#123;    let evalExpr = /&lt;%=(.+?)%&gt;/g;    let expr = /&lt;%([\\s\\S]+?)%&gt;/g;    template = template        .replace(evalExpr, &#x27;`); \\n  echo( $1 ); \\n  echo(`&#x27;)        .replace(expr, &#x27;`); \\n $1 \\n  echo(`&#x27;);    template = &#x27;echo(`&#x27; + template + &#x27;`);&#x27;;        const excu = `        &#x27;use strict;&#x27;        let html = &#x27;&#x27;;        function echo(exp) &#123;            html += exp        &#125;        $&#123;template&#125;        return html;    `    return function (data) &#123;        return Function(&#x27;data&#x27;,excu)(data);    &#125;&#125;console.log(complie(template)(&#123;    supplies: [1, 2, 3]&#125;))\n\n标签模板它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。\nlet a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag([&#x27;Hello &#x27;, &#x27; world &#x27;, &#x27;&#x27;], 15, 50);\n\nfunction passthru(literals, ...values) &#123;  let output = &quot;&quot;;  let index;  for (index = 0; index &lt; values.length; index++) &#123;    output += literals[index] + values[index];  &#125;  output += literals[index]  return output;&#125;\n\n\n过滤 HTML 字符串，防止用户输入恶意内容。\n\nlet message =  SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123;  let s = templateData[0];  for (let i = 1; i &lt; arguments.length; i++) &#123;    let arg = String(arguments[i]);    // Escape special characters in the substitution.    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)            .replace(/&lt;/g, &quot;&amp;lt;&quot;)            .replace(/&gt;/g, &quot;&amp;gt;&quot;);    // Don&#x27;t escape special characters in the template.    s += templateData[i];  &#125;  return s;&#125;\n\n\n多语言转换（国际化处理）。\n\ni18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;\n\nraw属性\ntag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[“First line\\nSecond line”]，那么strings.raw数组就是[“First line\\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\n视为\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。\ntag`First line\\nSecond line`function tag(strings) &#123;  console.log(strings.raw[0]);  // strings.raw[0] 为 &quot;First line\\\\nSecond line&quot;  // 打印输出 &quot;First line\\nSecond line&quot;&#125;\n\nString.raw()ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\nString.raw`Hi\\\\n`// 返回 &quot;Hi\\\\\\\\n&quot;String.raw`Hi\\\\n` === &quot;Hi\\\\\\\\n&quot; // true\n\n// `foo$&#123;1 + 2&#125;bar`// 等同于String.raw(&#123; raw: [&#x27;foo&#x27;, &#x27;bar&#x27;] &#125;, 1 + 2) // &quot;foo3bar&quot;\n\n实例方法：includes(), startsWith(), endsWith()\nincludes()：返回布尔值，表示是否找到了参数字符串。\n\nstartsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n\nendsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\n\n三个方法都支持第二个参数，表示开始搜索的位置。\nendsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\nlet s = &#x27;Hello world!&#x27;;s.startsWith(&#x27;world&#x27;, 6) // trues.endsWith(&#x27;Hello&#x27;, 5) // trues.includes(&#x27;Hello&#x27;, 6) // false\n\nrepeat()参数如果是小数，会被取整。如果repeat的参数是负数或者Infinity，会报错。参数NaN等同于 0。repeat的参数是字符串，则会先转换成数字。\n&#x27;x&#x27;.repeat(3) // &quot;xxx&quot;\n\n\n实例方法：padStart()，padEnd()padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。\n如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。\n如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。\n如果省略第二个参数，默认使用空格补全长度。\n&#x27;xxx&#x27;.padStart(2, &#x27;ab&#x27;) // &#x27;xxx&#x27;&#x27;abc&#x27;.padStart(10, &#x27;0123456789&#x27;)// &#x27;0123456abc&#x27;&#x27;x&#x27;.padStart(4) // &#x27;   x&#x27;&#x27;x&#x27;.padEnd(4) // &#x27;x   &#x27;\n\n常见用途，补全字符串，提示时间格式\n&#x27;1&#x27;.padStart(10, &#x27;0&#x27;) // &quot;0000000001&quot;&#x27;12&#x27;.padStart(10, &#x27;YYYY-MM-DD&#x27;) // &quot;YYYY-MM-12&quot;\n\ntrimStart()，trimEnd()ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\n","categories":["JavaScript"],"tags":["JavaScript","ES6基础"]},{"title":"Three.js 基础","url":"/posts/38aeea3b300c/","content":"模型类型.fbx\nFBX 是 FilmBoX 这套软件所使用的格式，后改称 Motionbuilder。因为 Motionbuilder 扮演的是动作制作的平台，所以在前端的 modeling 和后端的 rendering 也都有赖于其它软件的配合，所以 Motionbuilder 在档案的转换上自然下了一番功夫。\nFBX 最大的用途是用在诸如在 Max、Maya、Softimage 等软件间进行模型、材质、动作和摄影机信息的互导，这样就可以发挥 Max 和 Maya 等软件的优势。可以说，FBX 方案是非常好的互导方案。\n.glTF\nglTF 是一种可以减少 3D 格式中与渲染无关的冗余数据并且在更加适合 OpenGL 簇加载的一种 3D 文件格式。glTF 的提出是源自于 3D 工业和媒体发展的过程中，对 3D 格式统一化的急迫需求。如果用一句话来描述：glTF 就是三维文件的 JPEG ，三维格式的 MP3。在没有 glTF 的时候，大家都要花很长的的时间来处理模型的载入。\n很多的游戏引擎或者工控渲染引擎，都使用的是插件的方式来载入各种格式的模型。可是，各种格式的模型都包含了很多无关的信息。就 glTF 格式而言，虽然以前有很多 3D 格式，但是各种 3D 模型渲染程序都要处理很多种的格式。对于那些对载入格式不是那么重要的软件，可以显著减少代码量，所以也有人说，最大的受益者是那些对程序大小敏感的 3D Web 渲染引擎，只需要很少的代码就可以顺利地载入各种模型了。\n此外，glTF 是对近二十年来各种 3D 格式的总结，使用最优的数据结构，来保证最大的兼容性以及可伸缩性。这就好比是本世纪初 xml 的提出。glTF 使用 json 格式进行描述，也可以编译成二进制的内容：bglTF。glTF 可以包括场景、摄像机、动画等，也可以包括网格、材质、纹理，甚至包括了渲染技术（technique）、着色器以及着色器程序。同时由于 json 格式的特点，它支持预留一般以及特定供应商的扩展。\n.obj\nOBJ 文件是 Alias|Wavefront 公司为它的一套基于工作站的 3D 建模和动画软件”Advanced Visualizer”开发的一种标准 3D 模型文件格式，很适合用于 3D 软件模型之间的互导。目前几乎所有知名的 3D 软件都支持 OBJ 文件的读写。OBJ 文件是一种文本文件，可以直接用写字板打开进行查看和编辑修改。\n物体 位移&#x2F;缩放&#x2F;旋转cube.position.x = 0;cube.position.set(0, 0, 0);cube.scale.y = 1;cube.scale.set(0, 1, 0);cube.rotate.z = Math.PI / 4;cube.rotate.set(0, 0, Math.PI / 4);\n\n一个物体的 position/scale/rotate 属性描述一个物体的 位置&#x2F;缩放&#x2F;旋转，当这个物体再世界坐标系中，那么他的 位移&#x2F;缩放&#x2F;旋转 相对于世界坐标系。\n如果物体在另一个物体中，那么他的 位移&#x2F;缩放&#x2F;旋转 相对于父元素的位置。\n// 由于物体位置相对于父元素，因此cube在坐标原点parentCube.add(cube);parentCube.position.x = -3;cube.position.x = 3;\n\n画布适应窗口的变化window.addEventListener(&quot;resize&quot;, () =&gt; &#123;  // 更新摄像头宽高比  camera.aspect = window.innerWidth / window.innerHeight;  // 更新摄像机的投影矩阵  camera.updateProjectionMatrix();  // 更新渲染器  renderer.setSize(window.innerWidth, window.innerHeight);&#125;);\n\n通过 GUI 快速调试参数通过安装 dat.gui （不推荐）\nimport * as dat from &quot;dat.gui&quot;;\n\n新方法是使用 threejs 自带的 GUI (推荐)\nimport &#123; GUI &#125; from &quot;three/examples/jsm/libs/lil-gui.module.min&quot;;const gui = new GUI();const handle = &#123;  click: () =&gt; console.log(&quot;click&quot;),  fullscreen: () =&gt; console.log(&quot;fullscreen&quot;),&#125;;// 添加两个按钮，点击和全屏gui.add(handle, &quot;click&quot;).name(&quot;点击&quot;);gui.add(handle, &quot;fullscreen&quot;).name(&quot;全屏&quot;);//修改数值,最小值-10，最大值10，步长1gui.add(cube.position, &quot;x&quot;).name(&quot;x轴位置&quot;).min(-10).max(10).step(1);//使用 folder 分组let folder = gui.addFolder(&quot;按钮组&quot;);folder.add(handle, &quot;click&quot;).name(&quot;点击&quot;);folder.add(handle, &quot;fullscreen&quot;).name(&quot;全屏&quot;);//事件gui.add(handle, &quot;click&quot;).onChange(noop).onFinishChange(noop);//颜色const colors = &#123;  cubeColor: &quot;#ff0000&quot;,&#125;;gui  .addColor(colors, &quot;cubeColor&quot;)  .name(&quot;颜色&quot;)  .onChange(() =&gt; cube.material.color.set(val));\n\nGeometry 几何体顶点&#x2F;索引threejs 中使用 position 中类型化数组描述顶点的位置信息。三个为一组，绘制时会将一组顶点绘制为一个三角形，复杂的几何体也是由多个三角形构成。\n顶点的排列顺序(绕序)影响绘制的效果，逆时针 (Counter Clockwise, CCW) 排列的面视为正面， 顺时针排列视为反面。模型情况下，背面不会渲染以便提高性能。\nThree.js 使用相机的视角和顶点位置之间的关系来判断一个面是正面还是反面。当从相机位置看时，顶点按照逆时针排列的面会被认为是正面；相反，顺时针排列的面会被认为是背面。顶点顺序的判断依赖于面法向量（normal vector）。法向量是垂直于面的一个矢量，它通过面顶点的排列顺序来决定。如果法向量指向相机方向，面被认为是正面，否则是反面。\nconst position = new Float32Array([  1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0,]);const geometry = new THREE.BufferGeometry();const indices = new Uint16Array();geometry.setAttribute(&quot;position&quot;, new THREE.BufferAttribute(position, 3));const mesh = new THREE.Mesh(geometry, material);\n\n但是查看 position 属性会发现有 6 个顶点，这时可以通过建立索引，共用顶点优化顶点数量。\n// 去除掉可以公用的顶点，const position = new Float32Array([1, 1, 0, -1, -1, 0, 1, -1, 0, -1, 1, 0]);// 使用索引来描述const indices = new Uint16Array([0, 1, 2, 0, 3, 1]);geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n\n顶点分组为几何体的顶点分组，可以为每个组设置单独的材质。\ngeometry.addGroup(0, 3, 0); // 开始位置，数量，材质索引geometry.addGroup(3, 3, 1);const mesh = new THREE.Mesh(geometry, [material, material2]);\n\n顶点转换对几何体的顶点操作（position, rotate, translate）通常是不推荐的，这会改变几何体原有的顶点信息（attribute.position）, 通常在物体（Mesh）上修改。\nUVUV 决定了 2D 纹理如何映射到 3D 空间中，U V 分别代表 2D 纹理的横纵坐标（为了与 3D 中的 X Y Z 坐标区分）。在模型建好之后会将纹理展开到 2D 平面中,这一过程叫做 UV 展开。常用的算法有投影展开法（Projection Mapping）,迭代展开法（Iterative Unwrapping）,Least Squares Conformal Mapping (LSCM) 和 Angle-Based Flattening (ABF) 等。\n如果一个物体缺失 UV 信息，那么纹理将无法映射到物体表面。如果 UV 坐标没有覆盖（1，1）区域，剩余位置颜色会自动按 UV 坐标边缘采集。\n法线法线是垂直与平面的向量，决定了光纤如何反射。\n// 法线辅助器import &#123; VertexNormalsHelper &#125; from &quot;three/examples/jsm/helpers/VertexNormalsHelper.js&quot;;const geometry = new THREE.BufferGeometry();// ...// 自动计算法线geometry.computeVertexNormals();// ...// 添加法线辅助器const helper = new VertexNormalsHelper(mesh, 0.2, 0x00ff00);scene.add(helper);\n\n包围盒包围盒用于可视化的检视物体，或用于碰撞检测。\nfbxLoader.load(floorFbx, function (group) &#123;  // 通过名称或ID查找到模型中指定的物体  const mesh = group.getObjectById(40);  // const mesh =  group.getObjectByName(&#x27;a23&#x27;)  // 由于物体的父级可能存在几何变化导致与物体的尺寸不同，因此需要更新物体的世界矩阵  //                    更新父级， 更新子集  mesh.updateWorldMatrix(true, true);  // 需要手动调用几何体包围盒计算函数  const geometry = mesh.geometry;  geometry.computeBoundingBox();  // 获取包围盒计算结果  const box = geometry.boundingBox;  // 使用世界矩阵更新包围盒  box.applyMatrix4(mesh.matrixWorld);  // 创建包围盒辅助器显示包围盒  const boxHelper = new THREE.Box3Helper(box, 0xff0000);  // 添加到场景中  scene.add(boxHelper);&#125;);\n\n多个物体包围盒\nconst mesh = group.getObjectById(40);const mesh1 = group.getObjectById(41);const mesh2 = group.getObjectById(42);const boxUnion = new THREE.Box3();[mesh, mesh1, mesh2].forEach((mesh) =&gt; &#123;  mesh.updateWorldMatrix(true, true);  const geometry = mesh.geometry;  geometry.computeBoundingBox();  const box = geometry.boundingBox;  box.applyMatrix4(mesh.matrixWorld);  const boxHelper = new THREE.Box3Helper(box, 0xff0000);  scene.add(boxHelper);  boxUnion.union(box);&#125;);const boxHelper = new THREE.Box3Helper(boxUnion, 0xff0000);scene.add(boxHelper);\n\n使用 setFromObject，自动计算和世界轴对齐的一个对象 Object3D （含其子对象）的包围盒，计算对象和子对象的世界坐标变换。\nconst boxUnion = new THREE.Box3();[mesh, mesh1, mesh2].forEach((mesh) =&gt; &#123;  const box = new THREE.Box3().setFromObject(mesh);  const boxHelper = new THREE.Box3Helper(box, 0xff0000);  scene.add(boxHelper);  boxUnion.union(box);&#125;);const boxHelper = new THREE.Box3Helper(boxUnion, 0xff0000);scene.add(boxHelper);\n\n几何体居中&#x2F;获取中心// 会将几何体的中心放到世界中心geometry.center();// 但是Mesh对象可能有几何变换，导致物体看上去仍然偏移// 需要重置Mesh的几何信息mesh.position.set(0, 0, 0);// 获取包围盒的中心点const vec3 = box.getCenter(new THREE.Vector3());\n\n边缘几何体&#x2F;线框几何体// 通过名称或ID查找到模型中指定的物体const mesh = group.getObjectById(40);const geometry = mesh.geometry;// 创建边缘几何体const edgeGeometry = new THREE.EdgesGeometry(geometry);// 创建线框几何体// const wireGeometry = new THREE.WireframeGeometry(geometry);// 创建线段材质const lineMaterial = new THREE.LineBasicMaterial(&#123;  color: 0xffffff,&#125;);// 创建线段物体const lineMesh = new THREE.LineSegments(edgeGeometry, lineMaterial);// 由于新创建的物体丢失了源物体的世界矩阵信息，因此位置大小可能表现不同// 需要使用源物体的世界矩阵信息重新赋值// 更新源物体的世界矩阵信息// mesh.updateWorldMatrix();// 应用源物体的世界矩阵lineMesh.matrix.copy(mesh.matrixWorld);//将矩阵信息解构到物体的变换信息上lineMesh.matrix.decompose(  lineMesh.position,  lineMesh.quaternion,  lineMesh.scale);scene.add(lineMesh);\n\n材质与纹理three.js 中的材质就是几何体表面的材料。所有材质均继承自 Material。ThreeJS 的材质分为：基础材质、深度材质、法向量材质、琥珀材质、冯氏材质、标准材质、着色器材质、基础线材质以及虚线材质。材质就像物体的皮肤，让几何体看起来像金属还是木板，是否透明，什么颜色。\n纹理的基类是 Texture，通过给其属性 Image 传入一个图片从而构造出一个纹理。纹理是材质的属性，材质和几何体 Gemotry 构成 Mesh\n材质基类 Material\ntransparent: 定义此材质是否透明,可以配合 opacity 使用，控制透明程度。\n\n纹理基类（Texture）\ncolorSpace\n1.THREE.NoColorSpace: 这意味着没有应用任何特定的颜色空间，纹理的颜色数据会被原样使用。这个选项通常用于已经处于需要的颜色空间中的纹理，或者那些不依赖于颜色空间的特定用途。\n2.THREE.SRGBColorSpace:在此颜色空间中，颜色数据以 SRGB 格式存储。SRGB 是一个 RGB 标准，它试图将色彩的表现和人眼感知到的颜色更好地匹配。相对于线性颜色空间，SRGB 颜色空间在暗区提供了更多的颜色级别。使用此颜色空间时，需要注意图像的颜色可能会被转换为非线性的 SRGB 格式。\n3.THREE.LinearSRGBColorSpace 这也是一个以 SRGB 格式存储颜色数据的颜色空间，但颜色数据被当作线线性性数据处理。在进行计算和处理时，这种颜色空间可以提供更精确的结果。但是由于人眼对光线的感知，50%感觉的亮度只需要 18%的发光强度，这可能导致物体颜色过浅。\n\nneedsUpdate 指定需要重新编译材质。如果动态设置纹理需要将此属性设置为true。\n\n\n基础材质 MeshBasicMaterial\nmap: 颜色贴图。默认会随几何体的大小拉伸。 开启 transparent 属性，会影响有透明通道图片的效果。\n\nMeshMatcapMaterial由一个材质捕捉（MatCap，或光照球（Lit Sphere））纹理定义。mapcap 编码了光照，颜色等信息，因此不对光照做出反应。可以投射阴影，但是不会接受阴影。是一个低成本实现光照效果得材质，缺点是固定了光照信息，不能对光照反应。\nMeshLambertMaterial该材质使用基于非物理的 Lambertian 模型来计算反射率。 这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）\nMeshPhongMaterial该材质使用非物理的 Blinn-Phong 模型来计算反射率。可以模拟高光的或玻璃效果，但是由于不是物理模型，因此玻璃效果不能与场景中其他物体作用，只能通过透明度设置。\n// 实现玻璃效果，只限于与环境光线相互作用// 加载环境贴图是必须的，映射模式需要修改为折射envMap.mapping = THREE.EquirectangularRefractionMapping;// scene.environment = envMap;// scene.background = envMap;const box = new THREE.BoxGeometry(1, 1, 1);const bujianMatertal = new THREE.MeshPhongMaterial(&#123;  refractionRatio: 0.7, // 空气的折射|反射率  // 当设置为 THREE.EquirectangularRefractionMapping 值为折射系数  // 越高越像玻璃  reflectivity: 0.99,  envMap: envMap,&#125;);const boxMesh = new THREE.Mesh(box, bujianMatertal);// 必须要有环境光，与环境光相互作用const light = new THREE.AmbientLight(0xffffff, 1);scene.add(light);\n\nFOG 雾通常会把背景颜色和雾的颜色设置成相同颜色，可以让雾融入到场景中\n镭射光纤，选择物体const raycaster = new THREE.Raycaster();const pointer = new THREE.Vector2();window.addEventListener(&quot;pointermove&quot;, onPointerMove);function onPointerMove(event) &#123;  // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)  pointer.x = (event.clientX / window.innerWidth) * 2 - 1;  pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;&#125;function rayTest() &#123;  raycaster.setFromCamera(pointer, camera);  const intersects = raycaster.intersectObjects(mesharr);  if (intersects.length === mesharr.length) return;  // intersects 是一个按深度排序的数组  for (let i = 0; i &lt; intersects.length; i++) &#123;&#125;&#125;function animate() &#123;  rayTest();  //...&#125;\n\n补间动画THREE.js 集成了 Tween 动画库\nimport &#123; Tween, Easing &#125; from &quot;three/examples/jsm/libs/tween.module.js&quot;;const tween = new Tween(mesh.position);// 移动到某个位置tween.to(&#123; x: 2 &#125;, 1000);// 位置更新时回调tween.onUpdate(() =&gt; &#123;  // console.log(mesh.position.x);&#125;);//重复次数tween.repeat(10);// 是否往返tween.yoyo(true);// 是否延迟tween.delay(1000);// 设置缓动tween.easing(Easing.Bounce.In);tween.start();// 动画链// tween.chain(tween2);// tween2.chain(tween);// 更新动画function animate() &#123;  tween.update();&#125;\n","categories":["Three.js"],"tags":["Three.js","webGL"]},{"title":"underscore框架设计","url":"/posts/a2a41d69ba3d/","content":"立即执行函数使用立即执行函数，创建局部作用域，隔离环境并初始化代码\n(function (global, factory) &#123;&#125;(this, function () &#123;&#125;))\n\n判断采用那种模块化规范导出// commomjs 规范typeof exports === &#x27;object&#x27; &amp;&amp; typeof module !== &#x27;undefined&#x27; ? module.exports = factory() :// amd 规范typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define(&#x27;underscore&#x27;, factory) :// 如果都不是则 直接挂在this上(global = global || self, (function () &#123;  var current = global._;  var exports = global._ = factory();  //防止多次引入冲突  exports.noConflict = function () &#123;    global._ = current;    return exports;  &#125;;&#125;()));\n\n创建根节点// 建立根节点对象，self 在浏览器端， global 在服务端， this 在一些虚拟机中，使用self 代替 window 提供对 Webworker 的支持var root = typeof self == &#x27;object&#x27; &amp;&amp; self.self === self &amp;&amp; self ||          typeof global == &#x27;object&#x27; &amp;&amp; global.global === global &amp;&amp; global ||          Function(&#x27;return this&#x27;)() ||          &#123;&#125;;\n\neach方法each 依赖的函数\n一个内部函数，根据参数返回不同的回调函数的封装，一个复用的方法\nfunction optimizeCb(func, context, argCount) &#123;  // 没有传入执行上下文， 直接返回函数  if (context === void 0) return func;  switch (argCount == null ? 3 : argCount) &#123;    case 1:      return function (value) &#123;        return func.call(context, value);      &#125;;      // The 2-argument case is omitted because we’re not using it.    case 3:      return function (value, index, collection) &#123;        return func.call(context, value, index, collection);      &#125;;    case 4:      return function (accumulator, value, index, collection) &#123;        return func.call(context, accumulator, value, index, collection);      &#125;;  &#125;  return function () &#123;    return func.apply(context, arguments);  &#125;;&#125;\n\nisArrayLike\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;// 简单获取属性值function shallowProperty(key) &#123;  return function (obj) &#123;    return obj == null ? void 0 : obj[key];  &#125;;&#125;var getLength = shallowProperty(&#x27;length&#x27;);// 属性检查 数字格式，且不能超过数组最大值function createSizePropertyCheck(getSizeProperty) &#123;  return function (collection) &#123;    var sizeProperty = getSizeProperty(collection);    return typeof sizeProperty == &#x27;number&#x27; &amp;&amp; sizeProperty &gt;= 0 &amp;&amp; sizeProperty &lt;= MAX_ARRAY_INDEX;  &#125;&#125;var isArrayLike = createSizePropertyCheck(getLength);\n\nfunction each(obj, iteratee, context) &#123;  iteratee = optimizeCb(iteratee, context);  var i, length;  if (isArrayLike(obj)) &#123;    for (i = 0, length = obj.length; i &lt; length; i++) &#123;      iteratee(obj[i], i, obj);    &#125;  &#125; else &#123;    var _keys = keys(obj);    for (i = 0, length = _keys.length; i &lt; length; i++) &#123;      iteratee(obj[_keys[i]], _keys[i], obj);    &#125;  &#125;  return obj;&#125;\n\n挂载方法 混合模式依赖的函数\n//内部方法，创建一个toString 基础测试器  function tagTester(name) &#123;    var tag = &#x27;[object &#x27; + name + &#x27;]&#x27;;    return function (obj) &#123;      return toString.call(obj) === tag;    &#125;;  &#125;  var isFunction = tagTester(&#x27;Function&#x27;);  var isFunction$1 = isFunction;  //返回一个排序的 所有工具函数名的数组  function functions(obj) &#123;    var names = [];    for (var key in obj) &#123;      if (isFunction$1(obj[key])) names.push(key);    &#125;    return names.sort();  &#125;\n\n定义underscore方法\n\n如果是underscore实例直接返回\n如果不是通过new操作符执行函数\n再次进入第二行的判断，这时已经是underscore的实例会继续往下执行\n在实例上挂在一个变量指向传入的对象\n\nfunction _(obj) &#123;  if (obj instanceof _) return obj;  if (!(this instanceof _)) return new _(obj);  this._wrapped = obj;&#125;\n\n核心mixin 方法\nfunction mixin(obj) &#123;  // 循环所有导出方法的名称  each(functions(obj), function (name) &#123;    // 每个名称对应的方法    var func = _[name] = obj[name];    //  在原型上挂载同样的方法    _.prototype[name] = function () &#123;      //拿到上面挂载的 传入的对象      var args = [this._wrapped];      // 拼接为整个数组       Array.prototype.push.apply(args, arguments);      //直接用定义的内置方法执行      return chainResult(this, func.apply(_, args));    &#125;;  &#125;);  return _;&#125;var allExports = &#123;  each:each&#125;var _$1 = mixin(allExports);// Legacy Node.js API._$1._ = _$1;return _$1;\n\n所以可以用下面的方法执行方法\n_([1,2,3]).each(function(item)&#123;console.log(item)&#125;);\n\n","categories":["JavaScript"],"tags":["函数式编程","underscore"]},{"title":"vue/dev-server","url":"/posts/cf5154c5daae/","content":"demo 介绍此 demo 展示在页面中直接引入 esModule 文件，并在文件中引入 vue 组件的渲染流程\n渲染流程\nsequenceDiagram\n    autonumber\n    participant Client\n    participant Server\n    Client->>Server: /main.js\n    Note left of Server: 返回资源的时候处理node_modules中依赖的路径\n    Server->>Client: main.js文件内容\n    Note left of Server: __module/vue 和 test.vue\n    Client->>Server: 浏览器分析分析并请求import资源\n    Server->>Client: 返回依赖资源或是打包后的js文件\n\n\n\n浏览器向服务器请求入口文件 main.js, 请求路径为 import 路径 .main.js\n\n服务端接收到请求，交给 middleware 处理，首先检查缓存，如果缓存存在直接返回缓存结果，如果不存在，通过请求路径读取本地资源文件，处理后加入缓存并返回\n\n如果文件是 js 结尾, 这里表示的是入口文件\n\n将文件内容转为 ast 语法树， 分析依赖模块包括 vue 和 text.vue，将 node_module 中的依赖路径转换为自定义路径用于资源请求时区分资源并可以加入缓存优化，例如__module/vue，将 ast 生成的代码返回给浏览器\n浏览器会自动请求 esMoudle 中 import 的文件 http://localhost:3000/\\_\\_modules/vue http://localhost:3000/test.vue\n\n\n如果文件路径中包含 \\_\\_moudles, 则尝试加载 node_modules 中的文件通过 require.resolve(&quot;vue&quot;) 可以获取某个包在 node_modules 中的绝对路径\n\n如果文件路径是以 .vue 结尾， 需要使用 vue 提供的编译模块将文件编译成单个 js 文件\n\n首先通过 vueComplier compileToDescriptor 将 vue 文件处理 template, styles，scripts 的描述对象\n在使用 vueCompiler.assemble 将描述文件中的各部分组装成代码，返回给浏览器\n\n\n\nmiddleware.jsconst vueCompiler = require(&quot;@vue/component-compiler&quot;);const fs = require(&quot;fs&quot;);const stat = require(&quot;util&quot;).promisify(fs.stat);const root = process.cwd();const path = require(&quot;path&quot;);const parseUrl = require(&quot;parseurl&quot;);const &#123; transformModuleImports &#125; = require(&quot;./transformModuleImports&quot;);const readFile = require(&quot;util&quot;).promisify(fs.readFile);const parseUrl = require(&quot;parseurl&quot;);const defaultOptions = &#123;  cache: true,&#125;;async function loadPkg(pkg) &#123;  if (pkg === &quot;vue&quot;) &#123;    const dir = path.dirname(require.resolve(&quot;vue&quot;));    const filepath = path.join(dir, &quot;vue.esm.browser.js&quot;);    return readFile(filepath);  &#125; else &#123;    // TODO    // check if the package has a browser es module that can be used    // otherwise bundle it with rollup on the fly?    throw new Error(&quot;npm imports support are not ready yet.&quot;);  &#125;&#125;async function readSource(req) &#123;  const &#123; pathname &#125; = parseUrl(req);  const filepath = path.resolve(root, pathname.replace(/^\\//, &quot;&quot;));  return &#123;    filepath,    source: await readFile(filepath, &quot;utf-8&quot;),    updateTime: (await stat(filepath)).mtime.getTime(),  &#125;;&#125;function transformModuleImports(code) &#123;  const ast = recast.parse(code);  recast.types.visit(ast, &#123;    visitImportDeclaration(path) &#123;      const source = path.node.source.value;      if (!/^\\.\\/?/.test(source) &amp;&amp; isPkg(source)) &#123;        path.node.source = recast.types.builders.literal(          `/__modules/$&#123;source&#125;`        );      &#125;      this.traverse(path);    &#125;,  &#125;);  return recast.print(ast).code;&#125;const vueMiddleware = (options = defaultOptions) =&gt; &#123;  let cache;  let time = &#123;&#125;;  if (options.cache) &#123;    const LRU = require(&quot;lru-cache&quot;);    cache = new LRU(&#123;      max: 500,      length: function (n, key) &#123;        return n * 2 + key.length;      &#125;,    &#125;);  &#125;  const compiler = vueCompiler.createDefaultCompiler();  function send(res, source, mime) &#123;    res.setHeader(&quot;Content-Type&quot;, mime);    res.end(source);  &#125;  function injectSourceMapToBlock(block, lang) &#123;    const map = Base64.toBase64(JSON.stringify(block.map));    let mapInject;    switch (lang) &#123;      case &quot;js&quot;:        mapInject = `//# sourceMappingURL=data:application/json;base64,$&#123;map&#125;\\n`;        break;      case &quot;css&quot;:        mapInject = `/*# sourceMappingURL=data:application/json;base64,$&#123;map&#125;*/\\n`;        break;      default:        break;    &#125;    return &#123;      ...block,      code: mapInject + block.code,    &#125;;  &#125;  function injectSourceMapToScript(script) &#123;    return injectSourceMapToBlock(script, &quot;js&quot;);  &#125;  function injectSourceMapsToStyles(styles) &#123;    return styles.map((style) =&gt; injectSourceMapToBlock(style, &quot;css&quot;));  &#125;  async function tryCache(key, checkUpdateTime = true) &#123;    const data = cache.get(key);    if (checkUpdateTime) &#123;      const cacheUpdateTime = time[key];      const fileUpdateTime = (        await stat(path.resolve(root, key.replace(/^\\//, &quot;&quot;)))      ).mtime.getTime();      if (cacheUpdateTime &lt; fileUpdateTime) return null;    &#125;    return data;  &#125;  function cacheData(key, data, updateTime) &#123;    const old = cache.peek(key);    if (old != data) &#123;      cache.set(key, data);      if (updateTime) time[key] = updateTime;      return true;    &#125; else return false;  &#125;  async function bundleSFC(req) &#123;    const &#123; filepath, source, updateTime &#125; = await readSource(req);    const descriptorResult = compiler.compileToDescriptor(filepath, source);    console.log(descriptorResult);    const assembledResult = vueCompiler.assemble(compiler, filepath, &#123;      ...descriptorResult,      script: injectSourceMapToScript(descriptorResult.script),      styles: injectSourceMapsToStyles(descriptorResult.styles),    &#125;);    return &#123; ...assembledResult, updateTime &#125;;  &#125;  return async (req, res, next) =&gt; &#123;    if (req.path.endsWith(&quot;.vue&quot;)) &#123;      const key = parseUrl(req).pathname;      let out = await tryCache(key);      if (!out) &#123;        // Bundle Single-File Component        const result = await bundleSFC(req);        console.log(result);        out = result;        cacheData(key, out, result.updateTime);      &#125;      send(res, out.code, &quot;application/javascript&quot;);    &#125; else if (req.path.endsWith(&quot;.js&quot;)) &#123;      const key = parseUrl(req).pathname;      let out = await tryCache(key);      if (!out) &#123;        // transform import statements        const result = await readSource(req);        out = transformModuleImports(result.source);        console.log(out);        cacheData(key, out, result.updateTime);      &#125;      send(res, out, &quot;application/javascript&quot;);    &#125; else if (req.path.startsWith(&quot;/__modules/&quot;)) &#123;      const key = parseUrl(req).pathname;      const pkg = req.path.replace(/^\\/__modules\\//, &quot;&quot;);      let out = await tryCache(key, false); // Do not outdate modules      if (!out) &#123;        out = (await loadPkg(pkg)).toString();        cacheData(key, out, false); // Do not outdate modules      &#125;      send(res, out, &quot;application/javascript&quot;);    &#125; else &#123;      next();    &#125;  &#125;;&#125;;exports.vueMiddleware = vueMiddleware;\n","categories":["Javascript"],"tags":["vue"]},{"title":"web中的拦截技巧","url":"/posts/042375f2ced5/","content":"代码注入时机\n源码注入\n构建，推送服务注入\n网关注入，nginx 等修改响应文件\n浏览器插件注入\n\n重写 api通过 重写 fetch xhr 原型链，添加额外的功能\nconst _console = window.console;window.console = new Proxy(_console, &#123;  get(target, props) &#123;    const fn = target[props];    return (...args) =&gt; &#123;      fn.apply(null, args);      _console.info(&quot;other info&quot;);    &#125;;  &#125;,&#125;);\n\n拦截事件document.addEventListener(  &quot;click&quot;,  (e) =&gt; &#123;    e.stopPropagation();    e.preventDefault();  &#125;,  &#123;    // 捕获阶段执行    capture: true,    // 一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault()    passive: false,  &#125;);\n\n监听 DOM 变化// 选择需要观察变动的节点const targetNode = document.getElementById(&quot;some-id&quot;);// 当观察到变动时执行的回调函数const callback = function (mutationsList, observer) &#123;  // Use traditional &#x27;for loops&#x27; for IE 11  for (let mutation of mutationsList) &#123;    if (mutation.type === &quot;childList&quot;) &#123;      console.log(&quot;A child node has been added or removed.&quot;);    &#125; else if (mutation.type === &quot;attributes&quot;) &#123;      console.log(&quot;The &quot; + mutation.attributeName + &quot; attribute was modified.&quot;);    &#125;  &#125;&#125;;// 创建一个观察器实例并传入回调函数const observer = new MutationObserver(callback);// 观察器的配置（需要观察什么变动）const config = &#123; attributes: true, childList: true, subtree: true &#125;;// 以上述配置开始观察目标节点observer.observe(targetNode, config);// 之后，可停止观察observer.disconnect();\n\n监听对象属性变化const obj = &#123; a: 1 &#125;;Object.defineProperty(obj, &quot;a&quot;, &#123;  get() &#123;&#125;,  set(v) &#123;&#125;,&#125;);const newObj = new Proxy(obj, &#123;  get(target, props) &#123;&#125;,  set(target, props, value) &#123;&#125;,&#125;);\n\nservice workerservice worker\nthis.addEventListener(&quot;fetch&quot;, function (event) &#123;&#125;);\n\nweb containerwebcontainers\n整合远程调试方案根据以上的拦截技巧可以整个一个远程调试的方案，可以实现以下的功能:\n\n实现共享域名的登录态 cookie\n在远程设备（手机、测试设备）调试本地开发中服务无需配置 Web 服务的 https 直接使用 https 协议访问开发服务，避免 http 协议导致许多 Web API 不可用仅限于安全上下文的特性 (opens new window)\n该服务是一个天然的中间层，可无感注入代码实现效率工具，比如：远程网络抓包、Mock 移动端控制台（eruda）远程代码调试（chii）切换后端接口环境、接口染色\n\n思路：\n\n客户端发起 https 请求,并在请求路径中添加 ip port\n\n\nnginx 拦截指定域名的所有请求如果请求的是 html 文件，则 注入客户端的 sdk.js\nlocation / &#123;sub_filter &#x27;&lt;/body&gt;&#x27; &#x27;&lt;script src=&quot;/sdk.js&quot;/&gt;&lt;/body&gt;&#x27;;root html;index index.html;&#125;\n\n同时把 ip port 写入 cookie\n\n如果是资源请求，直接从 cookie 中读取 ip port\n\nsdk 中拦截所有的 a 标签的默认事件，在跳转路径上添加 ip port\n\nsocket 请求需要重写 socket api，让其携带域名和端口访问\n\n\n","categories":["JavaScript"]},{"title":"wordcloud2 源码分析","url":"/posts/e37c9567c419/","content":"wordcloud2 是一个词云工具,根据文字的不同权重,铺满整个图形.\n与 jquery 类似,通过立即执行函数,根据不同的模块化规范导出 WordCloud 方法\n(() =&gt; &#123;  // ...  // Expose the library as an AMD module  if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;    global.WordCloud = WordCloud;    define(&quot;wordcloud&quot;, [], function () &#123;      return WordCloud;    &#125;);  &#125; else if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) &#123;    module.exports = WordCloud;  &#125; else &#123;    global.WordCloud = WordCloud;  &#125;&#125;)();\n\n事件设计实现 setImmediate , 为了保证每次绘制一个单词,需要在每次绘制之后,重新调用绘制方法, 并传入下一个单词.\n源码中使用 postMessage 事件模拟, 回比 setTimeout(fn,0) 执行时机提前一些,如果不支持则回退到 setTimeout\nwindow.setImmediate = (function setupSetImmediate () &#123;    return window.msSetImmediate ||    window.webkitSetImmediate ||    window.mozSetImmediate ||    window.oSetImmediate ||    (function setupSetZeroTimeout () &#123;        if (!window.postMessage || !window.addEventListener) &#123;        return null        &#125;        var callbacks = [undefined]        var message = &#x27;zero-timeout-message&#x27;        // Like setTimeout, but only takes a function argument.  There&#x27;s        // no time argument (always zero) and no arguments (you have to        // use a closure).        var setZeroTimeout = function setZeroTimeout (callback) &#123;        var id = callbacks.length        callbacks.push(callback)        window.postMessage(message + id.toString(36), &#x27;*&#x27;)        return id        &#125;        window.addEventListener(&#x27;message&#x27;, function setZeroTimeoutMessage (evt) &#123;        // Skipping checking event source, retarded IE confused this window        // object with another in the presence of iframe        if (typeof evt.data !== &#x27;string&#x27; ||            evt.data.substr(0, message.length) !== message/* ||            evt.source !== window */) &#123;            return        &#125;        evt.stopImmediatePropagation()        var id = parseInt(evt.data.substr(message.length), 36)        if (!callbacks[id]) &#123;            return        &#125;        callbacks[id]()        callbacks[id] = undefined        &#125;, true)        /* specify clearImmediate() here since we need the scope */        window.clearImmediate = function clearZeroTimeout (id) &#123;        if (!callbacks[id]) &#123;            return        &#125;        callbacks[id] = undefined        &#125;        return setZeroTimeout    &#125;)()\n\nlist 是需要渲染词条的数组, 事件绑定在 canvas 元素上, 如果还有词条需要渲染就递归执行渲染方法. 超出长度或超时则停止执行.\nfunction start() &#123;  addEventListener(&quot;wordcloudstart&quot;, anotherWordCloudStart);  timer[timerId] = loopingFunction(function loop() &#123;    if (i &gt;= settings.list.length) &#123;      stoppingFunction(timer[timerId]);      removeEventListener(&quot;wordcloudstart&quot;, anotherWordCloudStart);      delete timer[timerId];      return;    &#125;    var drawn = putWord(settings.list[i]);    if (exceedTime() || canceled) &#123;      stoppingFunction(timer[timerId]);      removeEventListener(&quot;wordcloudstart&quot;, anotherWordCloudStart);      delete timer[timerId];      return;    &#125;    i++;    timer[timerId] = loopingFunction(loop, settings.wait);  &#125;, settings.wait);&#125;start();\n\n源码设计\n合并初始化和默认参数,判断元素合法性\n\n定义默认图形的函数表达式,\nswitch (settings.shape) &#123;  case &quot;cardioid&quot;:    settings.shape = function shapeCardioid(theta) &#123;      return 1 - Math.sin(theta);    &#125;;&#125;// 如果不是极坐标表示的方式,需要自行转换 \\// http://timdream.org/wordcloud2.js/shape-generator.html 用于生成图形坐标const shape = () =&gt; &#123;  const max = 1026;  const leng = [    290, 296, 299, 301, 305, 309, 311, 313, 315, 316, 318, 321, 325, 326, 327,    328, 330, 330, 331, 334, 335, 338, 340, 343, 343, 343, 346, 349, 353, 356,    360, 365, 378, 380, 381, 381,  ];  return leng[((theta / (2 * Math.PI)) * leng.length) | 0] / max;&#125;;\n\n随机颜色方法 randomHslColor\nfunction randomHslColor(min, max) &#123;  return (    &quot;hsl(&quot; +    (Math.random() * 360).toFixed() +    &quot;,&quot; +    (Math.random() * 30 + 70).toFixed() +    &quot;%,&quot; +    (Math.random() * (max - min) + min).toFixed() +    &quot;%)&quot;  );&#125;\n\n获取随机角度 getRotateDeg\n有几个变量可以控制这个值:\nrotateRatio 旋转角度的概率maxRotation 最大值 Math.PI / 2minRotation 最小值 -Math.PI / 2rotationRange 旋转角度区间默认在 [-Math.PI / 2 , Math.PI / 2]rotationSteps 固定递进旋转角度, 如果是 3 旋转角度只会是 [-90deg,-30deg,30deg,90deg]\nfunction getRotateDeg() &#123;  // 最大角度和最小角度相同  if (rotationRange === 0) &#123;    return minRotation;  &#125;  // 概率以外不旋转  if (Math.random() &gt; settings.rotateRatio) &#123;    return 0;  &#125;  //固定角度区随机值  if (rotationSteps &gt; 0) &#123;    return (      minRotation +      (Math.floor(Math.random() * rotationSteps) * rotationRange) /        (rotationSteps - 1)    );  &#125; else &#123;    return minRotation + Math.random() * rotationRange;  &#125;&#125;\n\n获取渲染相关数据 getTextInfo\n传入需要渲染的 词条,权重,旋转角度\n采用双缓存的方法,创建另一个不可见的 canvas 画布,将词条绘制在另一个画布上,将画布转成图片,并分析像素点信息,最终返回文字信息\n定义一个网格大小,将画布分成若干个格子,一旦一个有效像素点落在格子中,那么这个格子中的其他像素点无需在判断,从而优化性能\nfunction getTextInfo() &#123;  // 根据权重计算字体大小 weightFactor 指定权重基数  var fontSize = weight * weightFactor;  // 不绘制  if (fontSize &lt;= settings.minSize) &#123;    return false;  &#125;  var mu = 1;  // 网格大小  var g = settings.gridSize;  // 创建新画布  var fcanvas = document.createElement(&quot;canvas&quot;);  // 绘制词条前获取词条的宽高  var fw = fctx.measureText(word).width / mu;  var fh =    Math.max(      fontSize * mu,      fctx.measureText(&quot;m&quot;).width,      fctx.measureText(&quot;\\uFF37&quot;).width    ) / mu;  // 创建一个包围盒, 让他足够容纳文字  var boxWidth = fw + fh * 2;  var boxHeight = fh * 3;  // 计算网格的长宽个数  var fgw = Math.ceil(boxWidth / g);  var fgh = Math.ceil(boxHeight / g);  boxWidth = fgw * g;  boxHeight = fgh * g;  // 绘制文字时候的偏移量  var fillTextOffsetX = -fw / 2;  // 希腊字母在 0.4 高度的位置,视觉效果会在中间位置  var fillTextOffsetY = -fh * 0.4;  // 计算考虑到旋转角度后的盒子大小  var cgh = Math.ceil(    (boxWidth * Math.abs(Math.sin(rotateDeg)) +      boxHeight * Math.abs(Math.cos(rotateDeg))) /      g  );  var cgw = Math.ceil(    (boxWidth * Math.abs(Math.cos(rotateDeg)) +      boxHeight * Math.abs(Math.sin(rotateDeg))) /      g  );  var width = cgw * g;  var height = cgh * g;  // 把文字绘制到临时画布上  fctx.fillStyle = &quot;#000&quot;;  fctx.textBaseline = &quot;middle&quot;;  fctx.fillText(    word,    fillTextOffsetX * mu,    (fillTextOffsetY + fontSize * 0.5) * mu  );  // 将画布转为 像素点  var imageData = fctx.getImageData(0, 0, width, height).data;  // 计算像素占据的网格  var occupied = [];  var gx = cgw;  var gy, x, y;  //  文字占据区域的网格坐标 [x1,x2,y1,y2]  var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];  while (gx--) &#123;    gy = cgh;    while (gy--) &#123;      y = g;      singleGridLoop: while (y--) &#123;        x = g;        while (x--) &#123;          if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) &#123;            // 如果像素点落在格子中则添加到数列中            occupied.push([gx, gy]);            if (gx &lt; bounds[3]) &#123;              bounds[3] = gx;            &#125;            if (gx &gt; bounds[1]) &#123;              bounds[1] = gx;            &#125;            if (gy &lt; bounds[0]) &#123;              bounds[0] = gy;            &#125;            if (gy &gt; bounds[2]) &#123;              bounds[2] = gy;            &#125;            break singleGridLoop;          &#125;        &#125;      &#125;    &#125;  &#125;  return &#123;    mu: mu,    occupied: occupied,    bounds: bounds,    gw: cgw,    gh: cgh,    fillTextOffsetX: fillTextOffsetX,    fillTextOffsetY: fillTextOffsetY,    fillTextWidth: fw,    fillTextHeight: fh,    fontSize: fontSize,  &#125;;&#125;\n\n\n\n绘制策略\n现在有了文字包围盒的尺寸和坐标,需要利用这些信息将图形填充满\n首先拿到一个词条, 以中心点为圆心,这个中心点可能是用户自定义的中心点,所以不一定在图形的中心. 以指定的半径画圆 (也可能是其他图形的极坐标表达式产生的图形),在这个圆上平均取若干个采样点,半径越大采样点越多.\n从圆心开始,初始半径为 0,也就表示词条放在中心点. 下一个词条进来的时候,因为半径为 0 的圆上已经有了一个词条,所以扩大半径画圆,产生采样点,循环这些采样点,并检测词条是否发生碰撞.\n如果不能放下就继续循环采样点,如果所有采样点都不符合条件,则扩大半径重新读取采样点,重新遍历\n如果可以放下,则跳出所有循环,传入下一个词条,重复以上过程\n\n计算绘制点\n最终绘制的过程,是以中心点为原点,指定半径长度画圆, 在圆周上平均取八个点作为绘制点,半径每增加一次,绘制点增加 8 个,其中半径的最大值是包围盒对角线的长度(当中心点在包围盒的一个顶点时)\n// 绘制的中心点center = settings.origin  ? [settings.origin[0] / g, settings.origin[1] / g]  : [ngx / 2, ngy / 2];// 最大绘制半径,当中心点在包围盒的四个顶点时,绘制最大半径就是对角线的长度//maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));var r = maxRadius + 1;while (r--) &#123;  // 获取不同半径圆周上的点的坐标  var points = getPointsAtRadius(maxRadius - r);  // 检查是否可以绘制  var drawn = points.some(tryToPutWordAtPoint);  if (drawn) &#123;    // leave putWord() and return true    return true;  &#125;&#125;var getPointsAtRadius = function getPointsAtRadius(radius) &#123;  // 采样点的个数随半径的增加增大  var T = radius * 8;  // Getting all the points at this radius  var t = T;  var points = [];  // 半径为 0 时,词条放在中心点  if (radius === 0) &#123;    points.push([center[0], center[1], 0]);  &#125;  // 半径不为 0 时获取采样点的坐标,共有t个采样点  while (t--) &#123;    var rx = 1;    // 图形的数学表达式建立在极坐标系中, x 的取值范围 [0, 2*Math.PI] 值域为 [0,1]    // 这个值会和半径相乘,得到半径的实际长度    // 这个过程可以想象乘等比放大一个图形的过程,而在放大的过程中,图形上的采样点也越来越多    if (settings.shape !== &quot;circle&quot;) &#123;      rx = settings.shape((t / T) * 2 * Math.PI); // 0 to 1    &#125;    // Push [x, y, t] t is used solely for getTextColor()    points.push([      center[0] + radius * rx * Math.cos((-t / T) * 2 * Math.PI),      center[1] +        radius * rx * Math.sin((-t / T) * 2 * Math.PI) * settings.ellipticity,      (t / T) * 2 * Math.PI,    ]);  &#125;  pointsAtRadius[radius] = points;  return points;&#125;;\n\n碰撞检测\nvar tryToPutWordAtPoint = function (gxy) &#123;  // gxy [x1,y1] 采样点坐标  // info.gw info.gh 旋转周的包围和宽度和高度  // 将包围盒中心和采样点对其  var gx = Math.floor(gxy[0] - info.gw / 2);  var gy = Math.floor(gxy[1] - info.gh / 2);  var gw = info.gw;  var gh = info.gh;  // occupied 所有包含有效像素的格子的坐标  // ngx ngy 整个画布被分成的格子数  // grid 所有格子的二维数组  var canFitText = function canFitText(gx, gy, gw, gh, occupied) &#123;    var i = occupied.length;    while (i--) &#123;      // 从偏移后的采样点位置,每次加上格子的坐标      var px = gx + occupied[i][0];      var py = gy + occupied[i][1];      // 是否超出画布的情况      if (px &gt;= ngx || py &gt;= ngy || px &lt; 0 || py &lt; 0) &#123;        if (!settings.drawOutOfBound) &#123;          return false;        &#125;        continue;      &#125;      // 只要有一个格子放不下就是重叠的情况直接跳出      if (!grid[px][py]) &#123;        return false;      &#125;    &#125;    return true;  &#125;;  // If we cannot fit the text at this position, return false  // and go to the next position.  if (!canFitText(gx, gy, gw, gh, info.occupied)) &#123;    return false;  &#125;  // Actually put the text on the canvas  drawText(    gx,    gy,    info,    word,    weight,    maxRadius - r,    gxy[2],    rotateDeg,    attributes,    extraDataArray  );  // Mark the spaces on the grid as filled  updateGrid(gx, gy, gw, gh, info, item);  // Return true so some() will stop and also return true.  return true;&#125;;\n\n其他实现思路填充过程可以使用 阿基米德螺线\nconst points = []; // 所有放置点let dxdy,  maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), // 最大半径  t = 1, // 阿基米德弧度  index = 0, // 当前位置序号  dx, // x坐标  dy; // y坐标// 通过每次增加的步长固定为1，实际步长为 step * 1，来获取下一个放置点while ((dxdy = getPosition((t += 1)))) &#123;  dx = dxdy[0];  dy = dxdy[1];  if (Math.min(Math.abs(dx), Math.abs(dy)) &gt;= maxDelta) break; // (dx, dy)距离中心超过maxDelta，跳出螺旋返回false  points.push([dx, dy, index++]);&#125;\n","categories":["Javascript"],"tags":["wordcloud"]},{"title":"你不知道的JavaScript","url":"/posts/8fcbb8daddf5/","content":"变量提升如果在函数声明后有同名的变量被定义，但是没有赋值，则不会被覆盖，如果同名变量被赋值这函数声明被覆盖\nfunction a() &#123;    alert(10)&#125;var a;console.log(a);//function a()&#123;&#125;a = 1;console.log(a)//1\n\nalert(a)a();var a = 3;function a() &#123;    alert(10)&#125;alert(a)a = 6;a();\n\n等价于\nvar afunction a() &#123;    alert(10)&#125;alert(a)//function a()&#123;&#125;a();a = 3;alert(a)//3a = 6;a();//TypeError\n\nalert会把函数转为字符串function a()&#123;...&#125;,对象会调用toString方法转为[object Object]\nvar x = 1,    y = 0,    z = 0;function add(x) &#123;    return (x = x + 1);&#125;y = add(x);console.log(y)function add(x) &#123;    return (x = x + 3);&#125;z = add(x);console.log(z)\n\n等价于\nfunction add(x) &#123;    return (x = x + 1);&#125;// 上面函数被覆盖function add(x) &#123;    return (x = x + 3);&#125;      var x = 1,    y = 0,    z = 0;y = add(x);console.log(y)z = add(x);console.log(z)\n\nthis指向在构造函数中，如果在this指定属性前访问，会返回undefined\nfunction go() &#123;    console.log(this.a);    this.a = 30;&#125;new go()//undefined\n\n如果在原型连上定义，则会去原型链上查找，找不到会返回undefined,但是不会去查找全局作用域，因为通过 new 操作符，this 指向生成的对象实例\nfunction go() &#123;    console.log(this.a);    this.a = 30;&#125;go.prototype.a = 40new go()//40\n\nthis.a = 20;function go() &#123;    console.log(this.a);    this.a = 30;&#125;go.prototype.a = 40;var test = &#123;    a: 50,    init: function (fn) &#123;        fn();        console.log(this.a);        return fn;    &#125;&#125;;//在执行new构造函数时，this.a还没有被赋值，所以去原型链上查找返回40//在读取对象实例的a属性时，this.a 已经被赋值，所以返回30console.log((new go()).a); //40 30//在init方法中fn没有被具体对象调用，所以fn执行时，go方法中this指向全局，返回20//在下一步中对this.a赋值，this指向window对象所以把全局的a修改为30//init中的this指向调用init方法的test对象返回50test.init(go);//20 50//再次执行fn即go方法，这时this.a已经被修改为30//init中的this还是指向test对象返回test.a = 50var p = test.init(go);//30 50//用一个p变量接受最后返回的go方法，在调用时相当于window调用，最终返回被修改后的a属性为30p();//30\n\n一些常见的变量\n可以通过self判断时否时windows环境\nself.self===self\n\n由于self变量经常被修改所以又创建了一个新变量表示全局对象 globalThis,也是为了和 Node 环境靠拢\nself === globalThistop === globalThisparent===globalThis\n\n严格模式函数中的严格模式只对函数作用域生效，如果在函数中调用其他函数，其他函数不受严格模式影响 ES6不建议使用局部严格模式\n参数传递js中基本类型时按值传递的，引用类型是按地址传递的，形参和实参没有关系\nfunction test(m) &#123;    m = &#123;        v: 5    &#125;&#125;var m = &#123;    k: 30&#125;;test(m);alert(m.v);//undefined\n\n块级作用域&#123;    function init()&#123;&#125;    init = 4&#125;console.log(init);// function init()&#123;&#125;\n\n// 在块级作用域中，如果在函数声明前变量已经定义，则函数声明和后面的赋值都不会执行&#123;    init = 6    function init() &#123;&#125;    init = 4    // 如果重新定义会报错Identifier &#x27;init&#x27; has already been declared    // const init = 7    init = 7    console.log(init); //7&#125;console.log(init);//6\n\n类似于函数的声明不能覆盖变量的定义\nvar init = 1;function init() &#123;&#125;console.log(init)\n\n条件语句中的函数声明function init()&#123;    console.log(1);&#125;if(false)&#123;    function init()&#123;        console.log(2);    &#125;&#125;init()\n\n变量被提升，函数不会被提升，等价于：\nfunction init()&#123;    console.log(1);&#125;var init;if(false)&#123;    function init()&#123;        console.log(2);    &#125;&#125;init()\n\n如果在函数体内部，会被提升至作用域顶端\nfunction init()&#123;    console.log(1);&#125;(function()&#123;  if(false)&#123;      function init()&#123;          console.log(2);      &#125;  &#125;  init()&#125;)\n\n等价于\nfunction init()&#123;    console.log(1);&#125;(function()&#123;  var init;  if(false)&#123;      function init()&#123;          console.log(2);      &#125;  &#125;  init() //TypeError&#125;)\n\n继承function extend(sup, sub) &#123;    var F = function () &#123;&#125;    F.prototype = sup.prototype;    F.prototype.constructor = sub;    sub.prototype = new F();    const stck = Object.keys(Super);    for (var i = 0; i &lt; stck.length; i++) &#123;        sub[stck[i]] = sup[stck[i]]    &#125;&#125;function Super() &#123;    this.color = &#x27;red&#x27;&#125;Super.prototype.init = function () &#123;&#125;Super.time = Date.now();function Sub() &#123;    Super.call(this);&#125;extend(Super, Sub);console.log(new Sub())\n\n\n正则的拷贝/** Used to match `RegExp` flags from their coerced string values. */var reFlags = /\\w*$/;/** * @private * @param &#123;Object&#125; regexp The regexp to clone. * @returns &#123;Object&#125; Returns the cloned regexp. */function cloneRegExp(regexp) &#123;    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));    result.lastIndex = regexp.lastIndex;    return result;&#125;const reg = /foo/glet reg2 = cloneRegExp(reg) // /foo/gconsole.log(reg2);\n\n柯理化实现 before after\nfunction test(a, b, c) &#123;  console.log(&#x27;test&#x27;, a, b, c);  return &#x27;test&#x27;;&#125;Function.prototype.after = function (cb) &#123;  const _this = this;  return function _after() &#123;    if (_this.name !== &#x27;_before&#x27;) &#123;      cb();      const res = _this.apply(_this, arguments);      return res;    &#125;    const res = _this.apply(_this, arguments);    cb(res);  &#125;&#125;Function.prototype.before = function (cb) &#123;  const _this = this;  function _before() &#123;    if (_this.name === &#x27;_after&#x27;) &#123;      const res = _this.apply(_this, arguments);      cb(res);      return    &#125;    const res = cb();    _this.apply(_this, arguments);    return res;  &#125;  return _before&#125;test  .before(function () &#123;    console.log(&#x27;before&#x27;);    return 10;  &#125;)  .after(function (res) &#123;    console.log(&#x27;after&#x27;);  &#125;)  (1, 2, 3)\n\n反柯理化从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。或者说让一个对象去借用一个原本不属于他的方法。\n//简单实现var uncurrying = (fn) =&gt; (context,...rest)=&gt;fn.apply(context,rest);//使用call.apply省略context参数//调用fn的call方法，和Funcion的call方法是同理的，省略了一步原型链查找的过程//call方法需要执行call执行时候的上下文即fn函数，并把其他参数分别传入//加上apply方法，重指定call执行时候的上下文，并且call方法的参数可以用数组的形式传入 也就是rest包含[context,...rest]var uncurrying = fn =&gt; (...rest)=&gt; fn.call.apply(fn,rest)var uncurrying = fn =&gt; (...rest)=&gt; Function.prototype.call.apply(fn,rest)//也可以直接挂载在Function上面Function.prototype.uncurrying = function ()&#123;    return this.call.bind(this)&#125;\n\n使用场景\n//借用自己var un = Function.prototype.uncurrying.uncurrying();var a = un(Array.prototype.map)([1,2],function(i)&#123;console.log(i)&#125;);//改变函数的执行上下文function sayHi () &#123;    return &quot;Hello &quot; + this.value +&quot; &quot;+[].slice.call(arguments);&#125;var sayHiuncurrying=sayHi.uncurrying();console.log(sayHiuncurrying(&#123;value:&#x27;world&#x27;&#125;,&quot;hahaha&quot;));//借用方法var obj = &#123;    push:function(v)&#123;          return  Array.prototype.push.uncurrying()(this,v)    &#125; &#125;obj.push(&#x27;first&#x27;);\n\n","categories":["JavaScript"],"tags":["JavaScript","应用案例"]},{"title":"偏函数和函数柯里化","url":"/posts/cf3b0ed7034e/","content":"偏函数 (Partial application)\nIn computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity.\n\n在计算机科学中，局部应用是指固定一个函数的一些参数，然后产生另一个更小元的函数。（什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。）\n没有上下文的偏函数const partial = (fn, ...args) =&gt; &#123;  return (...args2) =&gt;  fn.call(this, ...args, ...args2)&#125;console.log(partial(function (a, b, c, d) &#123;  return a + b + c + d&#125;, 1, 2)(3, 4))\n\nbind 实现\n类型判断，错误处理\n缓存一级参数\n定义返回的新函数\n处理原型链\n绑定新函数的执行上下文，判断是否通过new调用\n\nFunction.prototype.bind = function (ctx) &#123;  if (typeof this !== &#x27;function&#x27;) throw new Error();  var args = Array.prototype.slice.call(arguments, 1);  var toBind = this;  var fn = function _fn() &#123;    args = args.concat(Array.prototype.slice.call(arguments, 0))    toBind.apply(this instanceof _fn ? this : ctx, args)  &#125;  if (toBind.prototype) &#123;    fn.prototype = Object.create(toBind.prototype)  &#125;  return fn;&#125;\n\nFunction.prototype.bind = function (ctx) &#123;  if (typeof this !== &#x27;function&#x27;) throw new Error();  var args = Array.prototype.slice.call(arguments, 1);  var toBind = this;  var noop = function()&#123;&#125;  var fn = function _fn() &#123;    args = args.concat(Array.prototype.slice.call(arguments, 0))    toBind.apply(noop.prototype.isPrototypeOf(this) ? this : ctx, args)  &#125;  if (toBind.prototype) &#123;    noop.prototype = toBind.prototype;  &#125;  fn.prototype = new noop()  return fn;&#125;\n\n柯里化 (Currying)\nIn mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.\n\n在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术\nES6实现const curry = (fn, args = []) =&gt;  fn.length === args.length ? fn(...args) : (...args2) =&gt; curry(fn, [...args, ...args2])\n\n反柯理化使用箭头函数不能绑定函数的this\nconst uncurry = (fn) =&gt; (...args) =&gt; fn.apply(this, args)\n\nFunction.prototype.uncurring = function () &#123;  var self = this;  return function () &#123;    return self.apply(this, arguments);  &#125;;&#125;;\n\n偏函数与柯里化区别柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。\n局部应用则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。\n","categories":["JavaScript"],"tags":["函数式编程"]},{"title":"前后端分离理念","url":"/posts/d1d20bf07f77/","content":"","categories":["JavaScript"],"tags":["JavaScript","应用案例"]},{"title":"基于流式布局的轮播图实现思路","url":"/posts/11613865a688/","content":"\n \n\n布局这是一个流式布局下得轮播图案例，问题还比较多，可以提供一种不错的思路\n通过让父元素禁止换行，每个图片子元素设置inline-block,流式排列\n* &#123;  padding: 0;  margin: 0;&#125;#root &#123;  width: 500px;  height: 280px;  margin:auto;  white-space: nowrap;  overflow: hidden;&#125;#root&gt;div &#123;  width: 500px;  height: 280px;  display: inline-block;  transition: .5s linear;&#125;\n\n&lt;div id=&#x27;root&#x27;&gt;  &lt;div style=&#x27;background: url(./assets/1b809d9a2bdf3ecc481322d7c9223c21)&#x27;&gt;&lt;/div&gt;  &lt;div style=&#x27;background: url(./assets/1b809d9a2bdf3ecc481322d7c9223c21)&#x27;&gt;&lt;/div&gt;  &lt;div style=&#x27;background: url(./assets/1b809d9a2bdf3ecc481322d7c9223c21)&#x27;&gt;&lt;/div&gt;  &lt;div style=&#x27;background: url(./assets/1b809d9a2bdf3ecc481322d7c9223c21)&#x27;&gt;&lt;/div&gt;&lt;/div&gt;\n\n开始拖动通过CSS的transform属性来改变图片的位置，这里我们不让如父元素一起滚动，而是控制每一个元素的滚动，来看一下实现的思路\n在鼠标按下的时候加一个标识，表示正在拖动,并且记录下鼠标点击的位置\nroot.addEventListener(&#x27;mousedown&#x27;, event =&gt; &#123;  mark = true;  startX= event.clientX;&#125;)\n\n在鼠标移动的时候,判断是否，已经开始移动\ndocument.addEventListener(&#x27;mousemove&#x27;, function (event) &#123;  if (!mark) return false&#125;);\n\n由于是使用流式布局，每一个元素都在自己的位置上，而且偏移量为0\n那么当前正在窗口中的图片的索引标记为pos,初始化为0\n再滑动的时候需要知道当前窗口内的图片索引，当滑动距离的绝对值超过500，则pos切换为上一张图片，或下一张图片，\n//错误，不能直接向下取整，因为向左滑动的时候不足500不能算作前一张，向上也同理let current = position - Math.floor(x / 500);// 需要去掉偏移量之后，看是否超过了500let current = position - Math.ceil((x-x % 500) / 500);\n\n下面，我们只关心pos左侧和右侧的图片是哪一张\n如果是右边的一张图片，那索引就会 +1, 按照[1,2,3,0,1,2,3,0,...]的顺序循环，需要让他在到达最后索引的时候归零，这里可以通过取余实现\nconst right = (pos+1)%length\n\n但是左边的一张图片，是按倒叙排列的 [3,2,1,0,3,2,1,0,...] 当pos===0左边一张图片的索引为3，也就是让位置[-1]和 图片索引[3]对应，这里我们还是通过取余操作，但是要先加上子元素的长度length,把它转为整数，对于右边的图片来说，对于多加的长度没有影响，因为加了一倍的长度，最终取余的时候还是可以约调\nconst index = (pos+ offset + lenth) % length\n\n下面是如何把中间位置，和左右两张图片放到对应的位置\n首先减去偏移量，把图片移动到窗口位置，类似绝对定位的效果,500为图片的宽度\nlet dx = - index * 500\n\n在加上左右位置的偏移量，和鼠标滑动的偏移量\n注意：为了学习理解，滑动的事件实在document上面的，所以滑动距离可能会超过500px,这里需要取余计算剩余偏移量\nlet dx  = -index * 500 + offset * 500 + x % 500 \n\n最终滑动事件为\ndocument.addEventListener(&#x27;mousemove&#x27;, function (event) &#123;  if (!mark) return false  let x = event.clientX - startX;  let current = position - Math.ceil((x - x % 500) / 500);  for (let offset of [-1, 0, 1]) &#123;    let pos = current + offset;    pos = (pos + children.length) % children.length    children[pos].style.transition = &#x27;none&#x27;;    children[pos].style.transform = `translateX($&#123;- pos * 500 + offset * 500 + x % 500&#125;px)`  &#125;&#125;);\n\n结束拖动鼠标松开的时候，需要知道偏移量是否超过组件宽度的一半，如果偏移量大于250就是下一张，如果小于-250就是前一张,有四种情况可以画数轴感受一下\nif (x % 500 &gt;= -250 &amp;&amp; x % 500 &lt;= 0) c = 1;if (x % 500 &lt;= 250 &amp;&amp; x % 500 &gt;= 0) c = -1if (x % 500 &lt; -250) c = -1if (x % 500 &gt; 250) c = 1\n\n最终滚动时候开启动画，并且忽略鼠标拖动的偏移量，通过css动画让图片恢复到对应的位置上\ndocument.addEventListener(&#x27;mouseup&#x27;, function (event) &#123;  mark = false;  let x = event.clientX - startX;  position = position - Math.round(x / 500);  for (let offset of [0, c]) &#123;    let pos = position + offset;    pos = (pos + children.length) % children.length    children[pos].style.transition = &#x27;&#x27;;    children[pos].style.transform = `translateX($&#123;- pos * 500 + offset * 500&#125;px)`  &#125;&#125;);\n\n上面判断前后哪一张的条件语句可以用数学的算法优化\ndocument.addEventListener(&#x27;mouseup&#x27;, function (event) &#123;  mark = false;  let x = event.clientX - startX;  position = position - Math.round(x / 500);  for (let offset of [0, Math.sign(x % 500 - Math.sign(x) * 250)]) &#123;    let pos = position + offset;    pos = (pos + children.length) % children.length    children[pos].style.transition = &#x27;&#x27;;    children[pos].style.transform = `translateX($&#123;- pos * 500 + offset * 500&#125;px)`  &#125;&#125;);","categories":["JavaScript"],"tags":["JavaScript","应用案例"]},{"title":"TypeScript 基本类型","url":"/posts/17ef7065c12e/","content":"TS 是什么是JavaScript的超集，添加了类型系统。 拟补JavaScript在开发大型系统时的不足。\n相比 JS 的优势\n类型化的思维方式，开发更加严谨，提前发现错误，减少改bug的时间\n\n类型系统提高了代码的可读性，并使维护和重构更加容易\n\n补充了接口枚举等开发大型应用时JS缺失的功能。\n\n\n注释单行注释 // 快捷键 ctrl + /\n多行注释 /*  */ 快捷键 ctrl + shift + A (ubuntu)\n类型注解为变量添加类型约束的方式\n声明变量必须指定type类型\nlet a:number;\n\n变量命名规则不能以数字开头，且只能包含 $，_， 数字，字母\n数据类型原始类型: Number&#x2F;String&#x2F;Bollean&#x2F;undefined&#x2F;null 对应类型注解为 number&#x2F;string&#x2F;boolean&#x2F;undefined&#x2F;null\nundefined null类型 属于其他类型 never 的子类型\n联合类型\nconst n:number | null | undefined;n = 1;\n\n如果直接赋值不需要声明type类型，类型推论 \nlet a = 1;// 如果重新覆盖不同的类型值会提示错误a = &#x27;22&#x27;// 错误\n\n也可通通过字面量赋值\nlet a:1|true;a = 1;\n\n\n数组类型 Array\n// 指定数组中的类型let arr:number[] = [1,2,3]\n\nlet arr:Array&lt;number&gt; = [1,2,3]\n\nlet arr:any[] = [1,2,3]\n\nobject\n[propName:string]:any 表示任意类型的属性\nlet b:&#123;  name:string,  age?:number,  [propName:string]:any&#125;\n\n元组类型 tuple\n数组类型的一种，可以指定数组中不同元素的类型\nlet arr:[string，number] = [&#x27;123&#x27;,3.4]\n\n类数组\nfunction  fn(...args:any[]) &#123;  const arg:IArguments = arguments;&#125;fn(1,2,3)\n\n枚举类型 enum\n定义枚举类型\nenum StatusEnum &#123;  success = 0,  error = -1&#125;const a: StatusEnum = StatusEnum.success\n\n如果没有声明值，则返回枚举字段的索引， 如果其中一个有值，后面没有赋值的字段会把前面的值 +1 返回\nenum Color &#123; red, gray = 5, black&#125;const c:Color = Color.red //0const c1:Color = Color.gray //5const c2:Color = Color.black //6\n\n常数枚举\nconst enum Color &#123; red, gray&#125;console.log(Color.red,Color.gray);//最终编译为console.log(0/*Color.red*/,1/*Color.red*/)\n\n任意类型 any\n一个变量设置了any,相当于关闭了类型监测\n声明变量如果没有执行类型，会默认设置为any类型\n使用场景：第三方库没有定义的类型，类型转换的时候，数据结构太复杂太灵活，ts为document提供了一整套类型声明\nconst a:any = document.getElementById(&#x27;app&#x27;)a.style.innerHTML = &#x27;&lt;div /&gt;&#x27;\n\nconst ele:HTMLElement|null = document.getElementById(&#x27;app&#x27;)ele!.style.color = &#x27;&lt;div /&gt;&#x27;\n\nvoid 类型\nvoid 表示没有任何类型，一般用于定义方法的时候没有返回值\nfunction fun:void()&#123;  cosnole.log(1)&#125;const fun = (): void =&gt; &#123;  console.log(1)&#125;\n\nnever类型\n包括 null 和 undefined 类型，代表从不会出现的值，这意意味着never类型只能被never类型所赋值\n用于报错，没有值的类型，函数执行不完,比如事件循环，数据库的监听\nconst a: never = (() =&gt; &#123; throw new Error &#125;)()\n\nfunction fn(): never &#123;  throw new Error();&#125;\n\nfunction fn(): never &#123;  while(true)&#123;&#125;  // 需要never类型，永远不会到达的语句  cosnole.log(1)&#125;\n\n\nunknow 类型\nunknow 类型在复制给其他的变量时会检查，不允许把unknow类型复制给其他类型,如果使用的是any类型将不会检查错误\nconst d:any = &#x27;123&#x27;const s:string = d;// 不会报错const d:unknow = &#x27;123&#x27;const s:string = d;// 回报错\n\n通过类型判断允许赋值\nif(typeof d === &#x27;string&#x27;)&#123;  s = d&#125;\n\n类型断言\ns = d as string;\n\n字面量类型 \n描述的是同类型不同值\nlet a: &quot;aaa&quot; | &quot;bbb&quot;;a = &quot;aaa&quot;;\n\n类型别名type MyType = 1|2|3const a:MyType = 1;const a:MyType = 2;const a:MyType = 3;\n\n定义函数函数参数和返回值类型必须被声明\nfunction fn(a: number = 2, b?: number, ...c: Array&lt;any&gt;): void &#123;  if (b) &#123;    console.log(a, b, c);  &#125; else &#123;    console.log(a, b, c);  &#125;&#125;fn(1)\n\n函数重载表示同名的函数如果参数不同函数会重载\n但是JS中没有重载的概念，下面同名的函数会覆盖上面的函数\nTS中模拟函数重载, 通过不同的参数类型校验\nfunction fn(a: number): number;function fn(b: string): string;function fn(c: any): any &#123;  if (typeof c === &#x27;number&#x27;) &#123;    return c + 1;  &#125;&#125;;\n\n定义函数的结构\nconst fn:(a:number,b:number) =&gt; number\n\n\n包装对象自动在基本类型的对象类型之间切换,基本类型上没有方法，在内部迅速的完成一个装箱操作，把基本类型迅速包装成对象类型，然后调用对象类型的方法。\n","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"Javascript 常见问题","url":"/posts/d85305269aaa/","content":"柯里化‌函数柯里化（Currying）是一种将接受多个参数的函数转换为接受单个参数的函数的技术。\n\n\nconst curry = &lt;T extends (...args: any[]) =&gt; any&gt;(fn: T): CurryFunction&lt;T&gt; =&gt; &#123;  let args: any[] = [];  return function curryFunction(this: any, arg: any) &#123;    args.push(arg);    if (args.length &gt;= fn.length) return fn.apply(this, args);    return curryFunction;  &#125; as CurryFunction&lt;T&gt;;&#125;;type CurryFunction&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (  ...args: infer P) =&gt; infer R  ? P extends [infer F, ...infer Rest]    ? (arg: F) =&gt; CurryFunction&lt;(...args: Rest) =&gt; R&gt;    : R  : never;const a = curry((a: string, b: boolean, c: number): void =&gt; &#123;  console.log(a, b, c);&#125;);\n\n反柯里化","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"微前端 ④ qiankun","url":"/posts/cf72544bb831/","content":"什么是 qiankunqiankun 是一个微前端的解决方案，对 single-spa 进行了封装。\n执行流程\n\nCSS 沙箱如何实现strictStyleIsolation 严格模式， 通过 ShadowDOM 实现,将子应用最外层的元素升级为 ShadowDOM\nvar containerElement = document.createElement(&quot;div&quot;);containerElement.innerHTML = appContent;var appElement = containerElement.firstChild;if (strictStyleIsolation) &#123;  if (supportShadowDOM) &#123;    var innerHTML = appElement.innerHTML;    appElement.innerHTML = &quot;&quot;;    var shadow;    if (appElement.attachShadow) &#123;      shadow = appElement.attachShadow(&#123;        mode: &quot;open&quot;,      &#125;);    &#125; else &#123;      shadow = appElement.createShadowRoot();    &#125;    shadow.innerHTML = innerHTML;  &#125;&#125;\n\n另一种是开启了 experimentalStyleIsolation 实验性沙箱配置，原理是尝试通过遍历 sheet 样式表的每一条样式，为每条样式添加一个私有化的选择器\n// 给子应用的最外层元素设置一个私有属性，用于添加选择器// css.QiankunCSSRewriteAttr 默认私有化属性  data-qiankun// appInstanceId 子应用的 name 属性appElement.setAttribute(css.QiankunCSSRewriteAttr, appInstanceId);// 创建私有化的选择器 prefix =&gt;div[data-qiankun=&quot;setting&quot;]var prefix = &quot;&quot;  .concat(tag, &quot;[&quot;)  .concat(QiankunCSSRewriteAttr, &#x27;=&quot;&#x27;)  .concat(appName, &#x27;&quot;]&#x27;);// 获取并便利所有的 style 标签var styleNodes = appElement.querySelectorAll(&quot;style&quot;) || [];_forEach(styleNodes, function (stylesheetElement) &#123;  // 创建新的style标签，并将当前style中的样式复制到新标签中  var styleNode = document.createElement(&quot;style&quot;);  styleNode.appendChild(    document.createTextNode(stylesheetElement.textContent || &quot;&quot;)  );  // 获取 CSSStyleSheet 对象，并将 cssRules 转为数组, 遍历并重写规则  var sheet = styleNode.sheet;  var rules = arrayify(sheet.cssRules);  var css = &quot;&quot;;  rules.forEach(function (rule) &#123;    switch (rule.type) &#123;      case RuleType.STYLE:        /**          1 对于 html body :root 几个根元素            会直接用 prefix 替换掉，防止对基座应用样式污染          2 html + body 格式的演示qiankun认为是非标准的样式不做处理          3 html &gt; body html body 性质的选择器会将 html 替换为空字符串          4 检查 a,html or *:not(:root) 根元素前插入了其他字符的选择器            同样需要替换为 a,[prefix] *:not([prefix]) 的形式                    5 其他选择器会在选择器前添加前缀             [prefix] .text &#123;&#125;                    最后拼接字符串         */        css += ruleStyle(rule, prefix);        break;      case RuleType.MEDIA:      case RuleType.SUPPORTS:        /**           媒体查询 @media screen and (max-width: 300px) &#123;&#125;           能力检测 @supports (display: grid) &#123;&#125;           会递归调用重写方法，将中间的选择器重写                  */        css += ruleStyle(rule, prefix);        break;    &#125;  &#125;);&#125;);\n\njs 沙箱快照沙箱如果平台不支持 Proxy ,则使用快照沙箱。 通过记录 window 对象上的属性变化，会复或保存状态。\n这种方式的沙箱只关注应用激活和卸载时的差异，并不能控制属性的来源，因为是在全局 window 对象上进行操作，所以全部应用的对全局属性的操作，都会反映在 window 对象上。\nfunction iter(win, cb) &#123;  for (const k in win) &#123;    if (win.hasOwnProperty(k) || k === &quot;clearInterval&quot;) &#123;      cb(k);    &#125;  &#125;&#125;class SnapshotSandBox &#123;  deleteProps = new Set();  modifyPropsMap = &#123;&#125;;  proxy = window;  snapshot = &#123;&#125;;  active() &#123;    this.snapshot = &#123;&#125;;    // 激活时记录当前的window快照，不关心 window 上是否有其他应用的属性。    // 只关心本次激活和卸载时属性的变化， 就是子应用的属性变化。    iter(window, (k) =&gt; &#123;      this.snapshot[k] = window[k];    &#125;);    // 之前卸载时检测出修改或添加的属性，本次激活时要添加回来    // 虽然添加和修改的属性都是在 window 上，但是应用卸载后可能被其他应用删除或重写    // 这里使用记录值恢复之前的状态    Object.keys(this.modifyPropsMap).forEach((k) =&gt; &#123;      window[k] = this.modifyPropsMap[k];    &#125;);    // 删除卸载时记录的删除值    // 同样因为其他同框架的子应用可能会添加相同属性    this.deleteProps.forEach((k) =&gt; &#123;      delete window[k];    &#125;);    this.sandboxRunning = true;  &#125;  inactive() &#123;    this.deleteProps.clear();    this.modifyPropsMap = &#123;&#125;;    // 和刚激活应用时的快照对比，检查新增或修改的属性    iter(window, (k) =&gt; &#123;      if (window[k] !== this.snapshot[k]) &#123;        this.modifyPropsMap[k] = window[k];      &#125;    &#125;);    // 快照中有，但是当前 window 上没有，那么属性被删除    iter(this.snapshot, (k) =&gt; &#123;      if (!window.hasOwnProperty(k)) &#123;        this.deleteProps.add(k);        // 恢复环境， 应用中删除的属性，退出应用是需要还原        window[k] = this.snapshot[k];      &#125;    &#125;);    this.sandboxRunning = false;  &#125;&#125;\n\n由于快照沙箱，对属性的操作都是在 window 上，因此多子应用的时候无法隔离子应用的状态，会导致冲突。只能适用于单实例。\nproxy 沙箱const createFakeWindow = (globalContext, speed) =&gt; &#123;  const fakeWindow = &#123;&#125;;  const propertiesWithGetter = new Map();  // 获取 window 静态属性  Object.getOwnPropertyNames(globalContext)    .filter((p) =&gt; &#123;      // 属性描述符      // configurable 为假表示不能 修改，不能删除      const dec = Object.getOwnPropertyDescriptor(globalContext, p);      return dec?.configurable;    &#125;)    .forEach((p) =&gt; &#123;      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);      if (descriptor) &#123;        const hasGetter = Object.prototype.hasOwnProperty.call(          descriptor,          &quot;get&quot;        );        // FAQ window 引用属性，为什么需要要修改属性描述符        if (          p === &quot;self&quot; ||          p === &quot;window&quot; ||          p === &quot;parent&quot; ||          p === &quot;top&quot; ||          (speed &amp;&amp; p === &quot;document&quot;)        ) &#123;          descriptor.configurable = true;          // 属性访问器和， writable 属性描述符不能同时指定          if (!hasGetter) &#123;            descriptor.writable = true;          &#125;        &#125;        // 记录所有所有访问器得属性        if (hasGetter) propertiesWithGetter.set(p, true);        // FAQ 所有 configurable 为假得属性，就一定是环境级别属性属性么        Object.defineProperties(fakeWindow, p, Object.freeze(descriptor));      &#125;    &#125;);  // Object.keys(window).forEach(k=&gt;&#123;  //     if( has)  //     const propDescriptor =   Object.getOwnPropertyDescriptor(window,k);  //     c  // &#125;)&#125;;let activeSandboxCount = 0;class ProxySandBox &#123;  sandboxRunning = true;  activeSandboxCount = 0;  document = document;  constructor(name, globalContext = window, opts) &#123;    this.name = name;    this.globalContext = globalContext;    this.type = &quot;proxy&quot;;    const &#123; updatedValueSet &#125; = this;    const &#123; speedy &#125; = opts || &#123;&#125;;    const &#123; fakeWindow, propertiesWithGetter &#125; = createFakeWindow(      globalContext,      !!speedy    );    const proxy = new Proxy(fakeWindow, &#123;      get(target, p) &#123;        // this.registerRunningApp()        // 处理对一些特殊属性值得处理        //Symbol.unscopables 提供了一种机制，允许对象指定哪些属性在 with 语句中不应该被暴露为局部变量。如果一个属性在对象的 Symbol.unscopables 列表中，它将不会出现在 with 语句的作用域中。        //   const obj = &#123;        //     a: 1,        //     b: 2,        //     [Symbol.unscopables]: &#123;        //         b: true // 使 &#x27;b&#x27; 在 with 语句中不可见        //     &#125;        // &#125;;        if (p === Symbol.unscopables) return unscopables;        if (p === &quot;window&quot; || p === &quot;self&quot; || p === &quot;globalThis&quot;) &#123;          return proxy;        &#125;        // 如果获取得上级 window, 允许逃逸        if (p === &quot;top&quot; || p === &quot;parent&quot;) &#123;          if (globalContext === globalContext.parent) &#123;            return proxy;          &#125;          return globalContext[p];        &#125;        if (p === &quot;hasOwnProperty&quot;) &#123;          // proxy.hasOwnProperty.call(&#123;a&#125;,&#x27;a&#x27;)          return function hasOwnProperty(key) &#123;            if (this !== proxy &amp;&amp; this !== null &amp;&amp; typeof this === &quot;object&quot;) &#123;              return Object.prototype.hasOwnProperty.call(this, key);            &#125;            // proxy.hasOwnProperty(&quot;a&quot;)            return (              fakeWindow.hasOwnProperty(key) ||              globalContext.hasOwnProperty(key)            );          &#125;;        &#125;        if (p === &quot;document&quot;) &#123;          return this.document;        &#125;        if (p === &quot;eval&quot;) &#123;          return eval;        &#125;        // customProp &#123;configurable:false&#125; =&gt; &#123;configurable:true&#125;        const actualTarget = propertiesWithGetter.has(p)          ? globalContext          : p in target          ? target          : globalContext;        const value = actualTarget[p];        // 校验了是不是frozen的属性， 如果是需要直接返回        // propertyDescriptor.configurable === false        // &amp;&amp; (propertyDescriptor.writable === false || (propertyDescriptor.get &amp;&amp; !propertyDescriptor.set)),        if (isPropertyFrozen(actualTarget, p)) &#123;          return value;        &#125;        // 非原生全局属性直接返回 addEventListener        // isNativeGlobalProp 枚举了 所有的全局属性        // useNativeWindowForBindingsProps 记录所有执行时需要绑定原生window方法 [fetch,true]        if (!isNativeGlobalProp(p) &amp;&amp; !useNativeWindowForBindingsProps.has(p)) &#123;          return value;        &#125;        // 如果不处理 fetch.bind(this) 实际时绑定的proxyWindow 导致报错        const boundTarget = useNativeWindowForBindingsProps.get(p)          ? nativeGlobal          : globalContext;        // 仅绑定 isCallable &amp;&amp; !isBoundedFunction &amp;&amp; !isConstructable 的函数对象，如 window.console、window.atob 这类，不然微应用中调用时会抛出 Illegal invocation 异常        // 目前没有完美的检测方式，这里通过 prototype 中是否还有可枚举的拓展方法的方式来判断        // @warning 这里不要随意替换成别的判断方式，因为可能触发一些 edge case（比如在 lodash.isFunction 在 iframe 上下文中可能由于调用了 top window 对象触发的安全异常）        const rebindTarget2Fn = (target, fn) =&gt; &#123;          const isCallable = (fn) =&gt;            typeof fn === &quot;function&quot; &amp;&amp; fn instanceof Function;          // bind 函数的名称会以 bound开头  &quot;bound fn&quot;          const isBoundedFunction = (fn) =&gt;            fn.name.indexOf(&quot;bound &quot;) === 0 &amp;&amp; !fn.hasOwnProperty(&quot;prototype&quot;);          const isConstructable = () =&gt; &#123;            const hasPrototypeMethods =              fn.prototype &amp;&amp;              // class有constructor属性              fn.prototype.constructor === fn &amp;&amp;              // 构造器需要有原型链              Object.getOwnPropertyNames(fn.prototype).length &gt; 1;            if (hasPrototypeMethods) return true;            // 假设以下视为构造函数            // 1. 有 prototype 并且 prototype 上有定义一系列非 constructor 属性            // 2. 函数名大写开头            // 3. class 函数            let constructable = hasPrototypeMethods;            if (!constructable) &#123;              const fnString = fn.toString();              const constructableFunctionRegex = /^function\\b\\s[A-Z].*/;              const classRegex = /^class\\b/;              constructable =                constructableFunctionRegex.test(fnString) ||                classRegex.test(fnString);            &#125;            return constructable;          &#125;;          if (            isCallable(fn) &amp;&amp;            !isBoundedFunction(fn) &amp;&amp;            !isConstructable(fn)          ) &#123;            const boundValue = Function.prototype.bind.call(fn, target);            // 拷贝原有方法的静态属性            Object.getOwnPropertyNames(fn).forEach((key) =&gt; &#123;              // boundValue might be a proxy, we need to check the key whether exist in it              if (!boundValue.hasOwnProperty(key)) &#123;                Object.defineProperty(                  boundValue,                  key,                  Object.getOwnPropertyDescriptor(fn, key)                );              &#125;            &#125;);            // 如果原方法 prototype 属性设置了不可枚举，会导致原型链丢失            // 赋值的时候不能使用 = 或 Object.assign, 因为赋值操作会向上查询原型链            // 如果描述符被设 writable =false 或没有 set 属性访问器，会抛出错误            // Cannot assign to read only property &#x27;prototype&#x27; of function            if (              fn.hasOwnProperty(&quot;prototype&quot;) &amp;&amp;              !boundValue.hasOwnProperty(&quot;prototype&quot;)            ) &#123;              Object.defineProperty(boundValue, &quot;prototype&quot;, &#123;                value: fn.prototype,                enumerable: false,                writable: true,              &#125;);            &#125;            // 有一些库会使用 /native code/.test(fn.toString()) 检测是不是原生的方法            // 如果不特殊处理，所有toString 返回的都是 [object fakeWindow] 或 [object Window]]            if (typeof fn.toString === &quot;function&quot;) &#123;              const valueHasInstanceToString =                fn.hasOwnProperty(&quot;toString&quot;) &amp;&amp;                !boundValue.hasOwnProperty(&quot;toString&quot;);              const boundValueHasPrototypeToString =                boundValue.toString === Function.prototype.toString;              if (valueHasInstanceToString || boundValueHasPrototypeToString) &#123;                // valueHasInstanceToString? 有自定义的 toString 使用原方法                //                         : 使用原生的 toString                const originToStringDescriptor =                  Object.getOwnPropertyDescriptor(                    valueHasInstanceToString ? fn : Function.prototype,                    &quot;toString&quot;                  );                Object.defineProperty(                  boundValue,                  &quot;toString&quot;,                  Object.assign(                    &#123;&#125;,                    originToStringDescriptor,                    originToStringDescriptor?.get                      ? null                      : &#123; value: () =&gt; fn.toString() &#125;                  )                );              &#125;            &#125;          &#125;        &#125;;        return rebindTarget2Fn(boundTarget, value);      &#125;,    &#125;);  &#125;  active() &#123;    if (!this.activeSandboxCount) activeSandboxCount += 1;    this.sandboxRunning = true;  &#125;  inActive() &#123;    this.sandboxRunning = false;  &#125;  patchDocument(doc) &#123;    this.document = doc;  &#125;&#125;\n","categories":["JavaScript"],"tags":["微前端","qiankun"]},{"title":"微前端 ② single-spa","url":"/posts/54288ac5bfdb/","content":"single-spa 是一个将多个 JavaScript 微前端整合到一个前端应用程序中的框架。下面是一些优点:\n\n在同一个页面上使用多个框架而不刷新页面\n独立部署微前端\n使用新框架编写代码，而无需重写现有的应用程序\n\nsingle-spa 比较好的解决了以下问题：\n\n应用加载顺序和依赖管理\n路由管理\n版本管理和升级\n调试和监控\n\n依赖管理single-spa 通过 systemjs 实现了应用资源的依赖管理\nwebpack 配置微前端应用需要适当改造，将输出的模式更改为 systemjs， 并且实现 single-spa 指定的接口。single-spa 官方提供了配置工具，用来降低配置的成本。\nwebpack-config-single-spa 用于输出 webpack 打包文件\n&#123;  output: &#123;    // 输出格式改为 systemjs    libraryTarget: &quot;system&quot;,  &#125;,   devServer: &#123;      // 任意路径下都返回 spa 应用入口文件      historyApiFallback: true，      // 允许对子应用的跨域调用      headers: &#123;        &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,      &#125;,    &#125;,    // 会增加一个入口文件，动态指定 __webpack_public_path__    // 避免子应用中异步加载的资源请求了主应用的路径    new SystemJSPublicPathPlugin(        //...    ),    // 处理开发模式下独立启动子应用显示页面    !isProduction &amp;&amp;    new StandaloneSingleSpaPlugin(&#123;        //...    &#125;),&#125;;\n\n前端项目配置项目的入口需要使用 single-spa-react 改造， 帮助实现 single-spa 要求的生命周期函数。\nconst lifecycles = singleSpaReact(&#123;  React,  ReactDOM,  rootComponent: Root,  domElementGetter: () =&gt; document.querySelector(&quot;#aa&quot;),  errorBoundary(err, info, props) &#123;    // Customize the root error boundary for your microfrontend here.    return null;  &#125;,&#125;);\n\n下面是 singleSpaReact 的实现\nconst opts = &#123;  /** 接收到的参数*/&#125;;const SingleSpaContext = opts.React.createContext();opts.SingleSpaRoot = createSingleSpaRoot(opts);// 将传入的新组件包装成新的 Root 组件function createSingleSpaRoot() &#123;  // 为了支持 React 15 所以 single-spa 并没有使用 useEffect  // 并且使用 函数 模拟 ES6 class 实现  function SingleSpaRoot() &#123;&#125;  SingleSpaRoot.prototype = Object.create(opts.React.Component.prototype);  // 绑定自定义钩子函数  SingleSpaRoot.prototype.componentDidMount = function () &#123;    setTimeout(this.props.mountFinished);  &#125;;  // 绑定自定义钩子函数  SingleSpaRoot.prototype.render = function () &#123;    return this.props.children;  &#125;;  opts.SingleSpaRoot = createSingleSpaRoot(opts);  const lifecycles = &#123;    bootstrap: bootstrap.bind(null, opts),    mount: mount.bind(null, opts),    unmount: unmount.bind(null, opts),  &#125;;  // 暴露接口方法  return lifecycles;&#125;\n\n实现 bootstrap 接口方法\nfunction mount(opts, props) &#123;  const whenMounted = function () &#123;    resolve(this);  &#125;;  const elementToRender = getElementToRender(opts, props, whenMounted);  // 包装 rootComponent  传入额外的 props  function getElementToRender(opts, props, mountFinished) &#123;    const elementToRender = opts.React.createElement(opts.rootComponent, props);    // 绑定 context    // ...    // 绑定 errorBoundary    // ...    elementToRender = opts.React.createElement(      opts.SingleSpaRoot,      &#123;        ...props,        mountFinished,        updateFinished() &#123;          //...        &#125;,        unmountFinished() &#123;          //...        &#125;,      &#125;,      elementToRender    );    return elementToRender;  &#125;  const domElement = opts.domElementGetter();  if (opts.ReactDOMClient?.createRoot) &#123;    opts.renderType = &quot;createRoot&quot;;  &#125; else &#123;    opts.renderType = &quot;render&quot;;  &#125;  const renderResult = reactDomRender(&#123;    elementToRender,    domElement: opts.domElementGetter(),    reactDom: opts.ReactDOMClient || opts.ReactDOM,    renderType: opts.renderType,  &#125;);  // 挂载组件  function reactDomRender(&#123;    reactDom,    renderType,    elementToRender,    domElement,  &#125;) &#123;    const renderFn = reactDom[renderType];    switch (renderType) &#123;      case &quot;createRoot&quot;:      case &quot;unstable_createRoot&quot;:      case &quot;createBlockingRoot&quot;:      case &quot;unstable_createBlockingRoot&quot;: &#123;        const root = renderFn(domElement);        root.render(elementToRender);        return root;      &#125;      case &quot;hydrateRoot&quot;: &#123;        const root = renderFn(domElement, elementToRender);        return root;      &#125;      case &quot;hydrate&quot;:      default: &#123;        renderFn(elementToRender, domElement);        // The renderRoot function should return a react root, but ReactDOM.hydrate() and ReactDOM.render()        // do not return a react root. So instead, we return null which indicates that there is no react root        // that can be used for updates or unmounting        return null;      &#125;    &#125;  &#125;  opts.domElements[props.name] = domElement;  opts.renderResults[props.name] = renderResult;&#125;\n\n实现 unmount 接口方法\nfunction unmount(opts, props) &#123;  return new Promise((resolve) =&gt; &#123;    opts.unmountResolves[props.name] = resolve;    const root = opts.renderResults[props.name];    if (root &amp;&amp; root.unmount) &#123;      // React &gt;= 18      const unmountResult = root.unmount();    &#125; else &#123;      // React &lt; 18      (opts.ReactDOMClient || opts.ReactDOM).unmountComponentAtNode(        opts.domElements[props.name]      );    &#125;    delete opts.domElements[props.name];    delete opts.renderResults[props.name];  &#125;);&#125;\n\n实现 update 接口方法\nfunction update(opts, props) &#123;  return new Promise((resolve) =&gt; &#123;    if (!opts.updateResolves[props.name]) &#123;      opts.updateResolves[props.name] = [];    &#125;    opts.updateResolves[props.name].push(resolve);    const elementToRender = getElementToRender(opts, props, null);    const renderRoot = opts.renderResults[props.name];    if (renderRoot &amp;&amp; renderRoot.render) &#123;      // React 18 with ReactDOM.createRoot()      renderRoot.render(elementToRender);    &#125; else &#123;      // React 16 / 17 with ReactDOM.render()      const domElement = chooseDomElementGetter(opts, props)();      // This is the old way to update a react application - just call render() again      getReactDom(opts).render(elementToRender, domElement);    &#125;  &#125;);&#125;\n\nsingleSpa 源码\n首先定义子应用加载数组，以及各个阶段的状态\n\nconst apps = [];const NOT_LOADED = &quot;NOT_LOADED&quot;;const LOADING_SOURCE_CODE = &quot;LOADING_SOURCE_CODE&quot;;const NOT_BOOTSTRAPPED = &quot;NOT_BOOTSTRAPPED&quot;;const BOOTSTRAPPING = &quot;BOOTSTRAPPING&quot;;const NOT_MOUNTED = &quot;NOT_MOUNTED&quot;;const MOUNTING = &quot;MOUNTING&quot;;const MOUNTED = &quot;MOUNTED&quot;;const LOAD_ERROR = &quot;LOAD_ERROR&quot;;const SKIP_BECAUSE_BROKEN = &quot;SKIP_BECAUSE_BROKEN&quot;;// 主应用启动状态let isStart = false;\n\n\nsingleSpa 提供 registerApplication 方法用于注册子应用，记录子应用必要信息， 同时会执行 reroute 方法，如何路径匹配，会加载子应用， 但是不会渲染子应用，子应用渲染需要等待 start 方法执行 isStart 标记为 true 后才会挂载子应用。\n\nfunction registerApplication(appNameOrConfig) &#123;  // app 必须是返回 promise 的函数  // customProps 必须是对象  appNameOrConfig.customProps = appNameOrConfig.customProps || &#123;&#125;;  // activeWhen 是一个路径匹配函数的数组  appNameOrConfig.activeWhen = Array.isArray(appNameOrConfig.activeWhen)    ? appNameOrConfig.activeWhen    : [appNameOrConfig.activeWhen];  appNameOrConfig.activeWhen = appNameOrConfig.activeWhen.map((path) =&gt;    typeof path === &quot;function&quot; ? path : pathToActiveWhen(path)  );  apps.push(&#123;    loadErrorTime: null,    status: NOT_LOADED,    ...appNameOrConfig,  &#125;);  reroute();&#125;\n\n\nsingleSpa 提供 start 方法用于在注册后启动主应用, 在 start 方法中重写路由监听事件，可以让 singleSpa 响应路由的变化。\n\nfunction start() &#123;  isStart = true;  patchHistoryApi(opts);  reroute();&#125;let urlRerouteOnly;let originalReplaceState;function createPopStateEvent(state, originalMethodName) &#123;  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49  // We need a popstate event even though the browser doesn&#x27;t do one by default when you call replaceState, so that  // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and  // singleSpaTrigger=&lt;pushState|replaceState&gt; on the event instance.  let evt;  try &#123;    evt = new PopStateEvent(&quot;popstate&quot;, &#123; state &#125;);  &#125; catch (err) &#123;    // IE 11 compatibility https://github.com/single-spa/single-spa/issues/299    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd    evt = document.createEvent(&quot;PopStateEvent&quot;);    evt.initPopStateEvent(&quot;popstate&quot;, false, false, state);  &#125;  evt.singleSpa = true;  evt.singleSpaTrigger = originalMethodName;  return evt;&#125;function patchedUpdateState(updateState, methodName) &#123;  return function () &#123;    const urlBefore = window.location.href;    const result = updateState.apply(this, arguments);    const urlAfter = window.location.href;    if (urlBefore !== urlAfter) &#123;      // 手动触发 popstate 事件，让不同的子应用可以响应路由的变化。      window.dispatchEvent(        createPopStateEvent(window.history.state, methodName)      );    &#125;    return result;  &#125;;&#125;function patchHistoryApi() &#123;  urlRerouteOnly = true;  originalReplaceState = window.history.replaceState;  function urlReroute() &#123;    reroute([], arguments);  &#125;  window.addEventListener(&quot;hashchange&quot;, urlReroute);  //调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件。popstate 事件只会在浏览器某些行为下触发  //比如点击后退按钮（或者在 JavaScript 中调用 history.back()  go()方法）。即，在同一文档的两个历史记录条目之间导航会触发该事件。  window.addEventListener(&quot;popstate&quot;, urlReroute);  const originalAddEventListener = window.addEventListener;  const originalRemoveEventListener = window.removeEventListener;  // history 改变的时候需要主动触发事件  window.history.pushState = patchedUpdateState(    window.history.pushState,    &quot;pushState&quot;  );  window.history.replaceState = patchedUpdateState(    originalReplaceState,    &quot;replaceState&quot;  );&#125;\n\n\nreroute 方法控制了子应用生命周期的执行。\n\nfunction reroute(  pendingPromises = [],  eventArguments,  silentNavigation = false) &#123;  const &#123; appsToUnload, appsToUnmount, appsToLoad, appsToMount &#125; =    getAppChanges();  let appsThatChanged,    cancelPromises = [];  if (start) &#123;    appsThatChanged = appsToUnload.concat(      appsToLoad,      appsToUnmount,      appsToMount    );    return performAppChanges();  &#125;  if (!start) &#123;    appsThatChanged = appsToLoad;    return loadApps();  &#125;  function loadApps() &#123;    return Promise.resolve().then(() =&gt; &#123;      const loadPromises = appsToLoad.map((app) =&gt; &#123;        if (app.loadPromise) return app.loadPromise;        if (app.status !== NOT_LOADED &amp;&amp; app.status !== LOAD_ERROR) &#123;          return app;        &#125;        app.status = LOADING_SOURCE_CODE;        return (app.loadPromise = Promise.resolve()          .then((val) =&gt; &#123;            // val 获取到子项目暴露的接口            return (loadPromise = app.app(app));          &#125;)          .then((val) =&gt; &#123;            app.status = NOT_BOOTSTRAPPED;            app.bootstrap = val.bootstrap;            app.mount = val.mount;            app.unmount = val.unmount;            app.unload = val.unload;            delete app.loadPromise;          &#125;));      &#125;);      let succeeded;      return Promise.all(loadPromises);    &#125;);  &#125;  function performAppChanges() &#123;    return Promise.resolve().then(() =&gt; &#123;      return Promise.all(cancelPromises).then(() =&gt; &#123;        appsToUnmount.map((app) =&gt;          app.unmount(&#123; name: app.name &#125;).then(() =&gt; (app.status = NOT_MOUNTED))        );        loadApps().then((res) =&gt; &#123;          const loadThenMountPromises = appsToLoad.map((app) =&gt; &#123;            console.log(app);            app.status = BOOTSTRAPPING;            return Promise.resolve(app.loadPromise)              .then((res) =&gt; &#123;                return app.bootstrap();              &#125;)              .then(() =&gt; &#123;                return Promise.resolve().then(() =&gt; &#123;                  app.status = MOUNTING;                  return app                    .mount(&#123;                      name: app.name,                    &#125;)                    .then(() =&gt; &#123;                      app.status = MOUNTED;                    &#125;);                &#125;);              &#125;);          &#125;);        &#125;);        appsToMount.map((app) =&gt; &#123;          app.mount(&#123; name: app.name &#125;).then(() =&gt; (app.status = MOUNTED));        &#125;);      &#125;);    &#125;);  &#125;&#125;function getAppChanges() &#123;  const appsToUnload = [],    appsToUnmount = [],    appsToLoad = [],    appsToMount = [];  let appsThatChanged,    cancelPromises = [];  // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds  const currentTime = new Date().getTime();  console.log(apps);  apps.forEach((app) =&gt; &#123;    const appShouldBeActive =      app.status !== SKIP_BECAUSE_BROKEN &amp;&amp; app.activeWhen[0](window.location);    switch (app.status) &#123;      case LOAD_ERROR:        if (appShouldBeActive &amp;&amp; currentTime - app.loadErrorTime &gt;= 200) &#123;          appsToLoad.push(app);        &#125;        break;      case NOT_LOADED:      case LOADING_SOURCE_CODE:        if (appShouldBeActive) &#123;          appsToLoad.push(app);        &#125;        break;      case NOT_BOOTSTRAPPED:      case NOT_MOUNTED:        if (!appShouldBeActive) &#123;          appsToUnload.push(app);        &#125; else if (appShouldBeActive) &#123;          appsToMount.push(app);        &#125;        break;      case MOUNTED:        if (!appShouldBeActive) &#123;          appsToUnmount.push(app);        &#125;        break;      // all other statuses are ignored    &#125;  &#125;);  return &#123; appsToUnload, appsToUnmount, appsToLoad, appsToMount &#125;;&#125;\n","categories":["JavaScript"],"tags":["微前端","single-spa"]},{"title":"微前端 ③ systemJs","url":"/posts/ae7d32dcd157/","content":"什么是 systemJs它可以加载不同模块格式的代码，包括 ES 模块、CommonJS 和 AMD 模块，提供了一致的模块加载体验。\nSystemJS 支持将现代 ES 模块代码转译为 System.register 格式（通常需要配合 webpack 等编译工具），以便在不支持 ES 模块的旧版浏览器中运行。这意味着开发者可以编写现代的、基于标准的模块代码，并确保它在旧版浏览器（如 IE11）中也能正常运行。\n通过使用接近原生模块加载速度的 System.register 格式，SystemJS 在旧版浏览器中提供了高性能的模块加载能力。\n另外还有一下的高级特性：\n\nSystemJS 支持顶级 await、动态导入（dynamic import）、循环引用和实时绑定（live bindings），这些都是现代 JavaScript 模块的重要特性。\n它还支持 import.meta.url，这是 ES 模块的一部分，允许模块访问其自身的 URL。\n支持模块类型（module types）和导入映射（import maps），使得开发者可以更灵活地管理模块依赖关系。\n提供对内容安全策略（Content Security Policy, CSP）和完整性检查（integrity）的支持，增强了模块加载的安全性。\n\n它也是 import 提案的解决方案， 在浏览器中原生的 esModule 不允许通过 import React from &#39;react&#39; 的方式引入依赖，必须使用相对或绝对路径 import React from &#39;https://xxx/cdn/react.js&#39; 或 import React from &#39;./react&#39; ，但配合 webpack, 可以将代码编译成 systemJs 模块化方案的代码，用于加载外部依赖。\nsystemJs 加载 react 应用创建 index.html 模板, systemJS 会接管有 type=&#39;systemjs-importmap&#39; script 标签中资源的加载。\n&lt;head&gt;  &lt;script type=&quot;systemjs-importmap&quot;&gt;    &#123;      &quot;imports&quot;: &#123;        &quot;react&quot;: &quot;https://cdn.jsdelivr.net/npm/react/umd/react.development.js&quot;,        &quot;react-dom&quot;: &quot;https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js&quot;      &#125;    &#125;  &lt;/script&gt;  &lt;script src=&quot;https://cdn.staticfile.net/systemjs/6.14.3/system.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;\n\n配合 webpack 将 scripts 处理成 systemJs 能识别的格式, libraryTarget 配置为 system, 设置 HtmlWebpackPlugin 插件的 scriptLoading: &quot;systemjs-module&quot; 可以为 script 标签自动添加 type 类型。externals 配置是可选的，对于多个子应用有不同版本的相同第三方依赖，可以直接将依赖打包在子应用中，不需要单独在主应用中加载。（对于这个多版本依赖的问题，并没有明确的最佳实践，官方推荐将比较重的第三方依赖变成共享资源， 如果共享资源有依赖关系例如 react react-dom，可以使用 systemJS 的 amd 扩展，或者将依赖放置到 depcache 字段中，推荐使用 amd 扩展能比较好的统一接管)\nmodule.exports = &#123;  entry: path.resolve(__dirname, &quot;./src/index.js&quot;),  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    publicPath: &quot;/&quot;,    // 设置打包格式为 system    libraryTarget: &quot;system&quot;,  &#125;,  // 排除依赖，通过 cdn 加载  externals: &#123;    react: &quot;react&quot;,    &quot;react-dom&quot;: &quot;react-dom&quot;,  &#125;,  module: &#123;/** loader 配置 */&#125;  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./public/index.html&quot;,      scriptLoading: &quot;systemjs-module&quot;,    &#125;),  ],&#125;;\n\nindex.js 文件编译为 System.register 函数调用\nSystem.register(  [&quot;react&quot;, &quot;react-dom&quot;],  function (__WEBPACK_DYNAMIC_EXPORT__, __system_context__) &#123;    var __WEBPACK_EXTERNAL_MODULE_react__ = &#123;&#125;;    var __WEBPACK_EXTERNAL_MODULE_react_dom__ = &#123;&#125;;    Object.defineProperty(__WEBPACK_EXTERNAL_MODULE_react__, &quot;__esModule&quot;, &#123;      value: true,    &#125;);    Object.defineProperty(__WEBPACK_EXTERNAL_MODULE_react_dom__, &quot;__esModule&quot;, &#123;      value: true,    &#125;);    return &#123;      setters: [        function (module) &#123;          Object.keys(module).forEach(function (key) &#123;            __WEBPACK_EXTERNAL_MODULE_react__[key] = module[key];          &#125;);        &#125;,        function (module) &#123;          Object.keys(module).forEach(function (key) &#123;            __WEBPACK_EXTERNAL_MODULE_react_dom__[key] = module[key];          &#125;);        &#125;,      ],      execute: function () &#123;        __WEBPACK_DYNAMIC_EXPORT__(          (() =&gt; &#123;            &quot;use strict&quot;;            var __webpack_modules__ = &#123;              &quot;./src/index.js&quot;: (                __unused_webpack_module,                __webpack_exports__,                __webpack_require__              ) =&gt; &#123;                eval(/** index.js 编译结果 */);              &#125;,              &quot;./node_modules/react-dom/client.js&quot;: (                __unused_webpack_module,                exports,                __webpack_require__              ) =&gt; &#123;                eval(/**react-dom/client.js 编译结果 */);              &#125;,              react: (module) =&gt; &#123;                module.exports = __WEBPACK_EXTERNAL_MODULE_react__;              &#125;,              &quot;react-dom&quot;: (module) =&gt; &#123;                module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;              &#125;,            &#125;;            /************************************************************************/            // The module cache            var __webpack_module_cache__ = &#123;&#125;;            // The require function            function __webpack_require__(moduleId) &#123;              // Check if module is in cache              var cachedModule = __webpack_module_cache__[moduleId];              if (cachedModule !== undefined) &#123;                return cachedModule.exports;              &#125;              // Create a new module (and put it into the cache)              var module = (__webpack_module_cache__[moduleId] = &#123;                // no module.id needed                // no module.loaded needed                exports: &#123;&#125;,              &#125;);              // Execute the module function              __webpack_modules__[moduleId](                module,                module.exports,                __webpack_require__              );              // Return the exports of the module              return module.exports;            &#125;            // startup            // Load entry module and return exports            // This entry module can&#x27;t be inlined because the eval devtool is used.            var __webpack_exports__ = __webpack_require__(&quot;./src/index.js&quot;);            return __webpack_exports__;          &#125;)()        );      &#125;,    &#125;;  &#125;);\n\nsystemJs 加载流程\nQ: systemjs-importmap 的作用是什么\nA: systemjs-importmap 作用是建立资源依赖的映射关系，由于浏览器不支持裸导入，因此通过一个自定义的 script 标签建立裸导入名称和资源路径的依赖关系\n\n\n\n以单 React 子应用为例，加载主应用以及子应用的过程。\nindex.html 页面配置如下\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;title&gt;Root Config&lt;/title&gt;    &lt;meta name=&quot;importmap-type&quot; content=&quot;systemjs-importmap&quot; /&gt;    &lt;script type=&quot;systemjs-importmap&quot;&gt;      &#123;        &quot;imports&quot;: &#123;          &quot;single-spa&quot;: &quot;https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js&quot;,          &quot;react&quot;: &quot;https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js&quot;,          &quot;react-dom&quot;: &quot;https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js&quot;,          &quot;@root/root-config&quot;: &quot;//localhost:9000/root-config.js&quot;,          &quot;@supos/supos-react-1&quot;: &quot;//localhost:3000/supos-supos-react-1.js&quot;        &#125;      &#125;    &lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/systemjs@6.8.3/dist/system.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/systemjs@6.8.3/dist/extras/amd.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;main id=&quot;root&quot;&gt;&lt;/main&gt;    &lt;div id=&quot;aa&quot;&gt;&lt;/div&gt;    &lt;script&gt;      System.import(&quot;@root/root-config&quot;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n主应用是一个编译后的 root-config.js 文件，先忽略 single-spa 相关的概念，简单理解为主应用通过 system.import 加载 @root/root-config 也就是通过 systemJS 映射之后的 root-config.js，在文件加载前 systemJS 已经分析了 systemjs-importmap script 标签中的依赖项，并生成了依赖图\n\n&#123;  depcache:&#123;&#125;,  imports:&#123;    &quot;single-spa&quot;: &quot;https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js&quot;,    &quot;react&quot;: &quot;https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js&quot;,    &quot;react-dom&quot;: &quot;https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js&quot;,    &quot;@fefw/root-config&quot;: &quot;http://localhost:9000/fefw-root-config.js&quot;,    &quot;@supos/supos-react-1&quot;: &quot;http://localhost:3000/supos-supos-react-1.js&quot;,    &quot;@supos/supos-react-2&quot;: &quot;http://localhost:8081/supos-supos-react-2.js&quot;  &#125;,  integrity:&#123;&#125;,  scope:&#123;&#125;&#125;\n\n\n解析并获取 @root/root-config 的资源路径 http:////localhost:9000/root-config.js， 只要请求的资源与依赖途中匹配，就会解析资源的请求路径，并记录当前环境变量快照后，尝试加载资源。\n\n资源加载后\n如果资源是 systemJS 模块会自动执行 system.register, 再执行上下文中保存依赖数组，和声明函数。\n如果不是 systemJS 模块，例如公用的 react, react-dom, 会将资源直接包装成 systemJS 声明函数的执行结果，通常会使用 amd 扩展，如果不使用 amd 扩展，例如 react 等 umd 格式的资源会将导出对象直接挂载在 window 对象上，systemJS 会尝试与上一次的环境变量快照比对找到资源导出的对象。但是这种方式将导致污染全局对象，且不能多版本共存。请查看 amd 扩展源码实现\n紧接着执行声明函数，声明函数接受一个 export 函数，用于接受第三方资源中暴露的对象，同时返回一个包含 setters 数组和 execute 方法的对象，如果加载的资源没有依赖项，那就不会有 setters 数组（例如： 主应用无第三方依赖), 延迟执行声明函数可以有时机处理依赖项。\n\n当资源的声明函数检查无额外依赖，则执行 execute 方法，内部执行 webpack 等构建工具打包后的代码，将返回的对象传递给 export 函数\n\n此时主应用资源已经执行，会尝试匹配路由，并通过 system.import 加载子应用，再次进入到第 2 步的流程，当子应用加载完成并执行后，获取到了子应用的依赖 [&#39;react&#39;,&#39;react-dom&#39;], 以及子应用的声明函数，由于此时有依赖项所以需要等待依赖项加载完成，依赖项的加载也会进入到第 2 步的流程，通过 Promise.all 保证所有的依赖加载完成后再，执行声明函数。而第三步的 setter 方法会在子应用加载后调用，依赖中暴露的对象注入到声明函数中。\n\nreact 资源加载后，由于并不是一个 systemJS 模块，会通过 amd 扩展，包装成 systemjs 注册的对象，而且由于 react 没有依赖，会在稍后直接执行 execute 方法, 由于 react-dom 不是 systemjs 模块， 声明函数的执行也会被包装成 systemjs 注册的对象, 因为 react-dom 依赖 react, 所以会在缓存中找到已经加载的 react 包装对象， 需要注意这时的 execute 都还没有执行。在所有资源都准备好之后，topLevelLoad 会统一执行 execute 方法，将资源导出对象暴露给依赖对象，接着执行父级资源的 setter 方法，将暴露出的依赖对象注入到，父级资源中。从而完成整个依赖关系的加载。\n\n\n总结一下 systemJS 核心方法， import 可以递归的加载资源以及其依赖项， setter 方法将依赖资源暴漏的对象注入到父资源中。\nsystemjs 实现原理// 1. 序列化import map// importMap 只用作描述资源，建立映射关系，不会主动加载资源function System() &#123;&#125;var global = window;// 记录加载的资源System[&quot;@&quot;] = &#123;&#125;;// 记录import资源隐射var importMap = &#123; imports: &#123;&#125; &#125;;// baseURL 为当前的资源加载路径var baseUrl = location.href.split(&quot;#&quot;)[0].split(&quot;?&quot;)[0];var importMapPromise = Promise.resolve();function processScripts() &#123;  document.querySelectorAll(&quot;script&quot;).forEach((script) =&gt; &#123;    // 处理 importmap    if (script.type === &quot;systemjs-importmap&quot;) &#123;      if (script.src) &#123;        /** 如果是远程资源，则发起请求 */      &#125; else &#123;        // 解析 importmap        importMapPromise = importMapPromise.then(() =&gt;          extendImportMap(importMap, script.innerHTML, baseUrl)        );      &#125;    &#125;    // 处理systemjs 模块    else if (script.type === &quot;systemjs-module&quot;) &#123;      System.import(script.src);    &#125;  &#125;);&#125;// 尽早执行, 并在 dom 全部加载后重新检测processScripts();window.addEventListener(&quot;DOMContentLoaded&quot;, processScripts);function extendImportMap(importMap, content, baseUrl) &#123;  const packages = JSON.parse(content);  for (let k in packages) &#123;    importMap[k] = packages[k];  &#125;&#125;// 用于加载 system-module 以及依赖项var firstGlobalProp = (secondGlobalProp = undefined);function shouldSkipProperty(p) &#123;  return !global.hasOwnProperty(p) || (!isNaN(p) &amp;&amp; p &lt; global.length);&#125;function noteGlobalProps() &#123;  firstGlobalProp = secondGlobalProp = undefined;  for (var p in global) &#123;    if (shouldSkipProperty(p)) continue;    if (!firstGlobalProp) firstGlobalProp = p;    else if (!secondGlobalProp) secondGlobalProp = p;    lastGlobalProp = p;  &#125;  return lastGlobalProp;&#125;System.import = function (id) &#123;  // 加载前记录下当前环境中的属性，依赖加载后和上次环境中的属性做对比，可以知道在环境中挂载了那些新的属性  noteGlobalProps();  return Promise.resolve().then(() =&gt; &#123;    var load = getOrCreateLoad(id);    return load.completion || topLevelLoad(load);  &#125;);&#125;;function getOrCreateLoad(id) &#123;  var load = System[&quot;@&quot;][id];  if (load) return load;  var ns = Object.create(null);  Object.defineProperty(ns, Symbol.toStringTag, &#123; value: &quot;Module&quot; &#125;);  var instantiatePromise = Promise.resolve()    .then(() =&gt; &#123;      return System.instantiate(id);    &#125;)    .then((registration) =&gt; &#123;      //依赖项      var deps = registration[0];      var _export = (name) =&gt; &#123;        for (var p in name) &#123;          ns[p] = name[p];        &#125;        load.setter.forEach((setter) =&gt; setter(ns));      &#125;;      // 参数 __WEBPACK_DYNAMIC_EXPORT__ 函数，接受 webpack 模块化对象      var declare = registration[1](_export);      load.execute = declare.execute;      return [deps, declare.setters];    &#125;);  var linkPromise = instantiatePromise.then((res) =&gt; &#123;    return Promise.all(      res[0].map((dep, index) =&gt; &#123;        var setter = res[1][index];        var depLoad = getOrCreateLoad(importMap.imports[dep]);        if (setter) &#123;          depLoad.setter.push(setter);        &#125;        return depLoad;      &#125;)    ).then((deps) =&gt; &#123;      load.deps = deps;    &#125;);  &#125;);  return (load = System[&quot;@&quot;][id] =    &#123;      id,      importMapPromise,      linkPromise,      ns,      setter: [],      deps: [],      execute: () =&gt; &#123;&#125;,      completion: void 0,    &#125;);&#125;System.instantiate = function (id) &#123;  var script = document.createElement(&quot;script&quot;);  script.async = true;  script.src = id;  // 异步等待 system 模块加载，并执行，执行结束后可以获取到模块注册的依赖信息  return new Promise((resolve, reject) =&gt; &#123;    script.addEventListener(&quot;load&quot;, function () &#123;      document.head.removeChild(script);      var register = System.getRegister();      resolve(register);    &#125;);    document.head.appendChild(script);  &#125;);&#125;;// 保存注册依赖以及回调函数var lastRegister;System.register = function (deps, declare) &#123;  lastRegister = [deps, declare];&#125;;function getGlobalProp() &#123;  var foundLastProp, result;  var n = 0;  // 依赖js引擎的行为  for (var p in global) &#123;    if (shouldSkipProperty(p)) continue;    if ((n == 0 &amp;&amp; p !== firstGlobalProp) || (n == 1 &amp;&amp; secondGlobalProp !== p))      return p;    if (foundLastProp) &#123;      // 下一个属性就是最新被赋值的属性      lastGlobalProp = p;      result = p;    &#125; else &#123;      // 匹配上一次最后一个属性      foundLastProp = p === lastGlobalProp;    &#125;    n++;  &#125;  return result;&#125;System.getRegister = function () &#123;  var _lastRegister = lastRegister;  lastRegister = void 0;  if (_lastRegister) return _lastRegister;  // 检查js文件执行之后在环境中添加的属性  var prop = getGlobalProp();  var globalExport = global[prop];  return [    [],    function (_exports) &#123;      return &#123;        execute: function () &#123;          _exports(globalExport);          // 兼容esModule          _exports(&#123; default: globalExport, __useDefault: true &#125;);        &#125;,      &#125;;    &#125;,  ];&#125;;function topLevelLoad(load) &#123;  return Promise.resolve(load.linkPromise)    .then(() =&gt; &#123;      return Promise.all(load.deps.map((dep) =&gt; dep.linkPromise));    &#125;)    .then(() =&gt; &#123;      // 等待所有依赖加载完成执行      postOrderExec(load);    &#125;);&#125;function postOrderExec(load) &#123;  var execute = load.execute;  // 首先执行依赖  load.deps.forEach((dep) =&gt; &#123;    postOrderExec(dep);  &#125;);  execute();&#125;\n\namd 扩展源码实现systemJS amd 扩展用于解决资源加载时对 window 对象的污染，还可以解决资源加载时的依赖问题， 例如 react-dom 依赖 react\n以 react 和 react-dom 为例展示资源加载过程, 资源已经被打包为 umd 格式，所以可以兼容 amd 规范。\n\n首先在全局创建 define 方法，作为 amd 规范定义模块的方法。react 加载后自动执行 define 方法，在执行上下文中保存资源的依赖和执行函数。依赖默认有 exports\n\nfunction getDepsAndExec(arg1, arg2) &#123;  // define([], function () &#123;&#125;)  if (arg1 instanceof Array) &#123;    return [arg1, arg2];  &#125;&#125;let amdDefineDeps, amdDefineExec;global.define = function (name, deps, execute) &#123;  var depsAndExec;  depsAndExec = getDepsAndExec(name, deps);  amdDefineDeps = depsAndExec[0];  amdDefineExec = depsAndExec[1];&#125;;\n\n\n当资源加载成功后，会执行 systemJS.getRegister, amd 扩展会重写此方法\n\nvar getRegister = systemPrototype.getRegister;var lastRegisterDeclare;var systemRegister = systemPrototype.register;systemPrototype.register = function (name, deps, declare) &#123;  lastRegisterDeclare = typeof name === &quot;string&quot; ? declare : deps;  systemRegister.apply(this, arguments);&#125;;systemPrototype.getRegister = function () &#123;  var register = getRegister.call(this); //[[], function () &#123; return &#123;&#125; &#125;];  // 如果可以获取到 register 注册的依赖，表示此资源是标准的 systemJS 模块，直接返回  if (register &amp;&amp; register[1] === lastRegisterDeclare) return register;  // 由于 amd 接管了模块的加载过程，所以在 window 上不会挂载 react 对象，getRegister 会返回空的声明函数结果，作为返回值  // amd 模块默认有 [&quot;exports&quot;] 依赖  // 此时 react 资源的 依赖对象和执行函数 都已经获取到 amdDefineDeps amdDefineExec  createAMDRegister(amdDefineDeps, amdDefineExec);&#125;;\n\n\n将 react 的加载包装成 systemJS register 数据结构， 后面继续执行 systemJS 第 4 步的加载逻辑\n\nfunction createAMDRegister(amdDefineDeps, amdDefineExec) &#123;  var exports = &#123;&#125;;  var module = &#123; exports: exports &#125;;  var depModules = [];  var setters = [];  var splice = 0;  for (var i = 0; i &lt; amdDefineDeps.length; i++) &#123;    var id = amdDefineDeps[i];    var index = setters.length;    if (id === &quot;require&quot;) &#123;      depModules[i] = unsupportedRequire;      splice++;    &#125; else if (id === &quot;module&quot;) &#123;      depModules[i] = module;      splice++;    &#125; else if (id === &quot;exports&quot;) &#123;      depModules[i] = exports;      splice++;    &#125; else &#123;      createSetter(i);    &#125;    if (splice) amdDefineDeps[index] = id;  &#125;  if (splice) amdDefineDeps.length -= splice;  var amdExec = amdDefineExec;  return [    amdDefineDeps,    function (_export) &#123;      _export(&#123; default: exports, __useDefault: true &#125;);      return &#123;        setters: setters,        execute: function () &#123;          var amdResult = amdExec.apply(exports, depModules);          if (amdResult !== undefined) module.exports = amdResult;          _export(module.exports);          _export(&quot;default&quot;, module.exports);        &#125;,      &#125;;    &#125;,  ];  // needed to avoid iteration scope issues  function createSetter(idx) &#123;    setters.push(function (ns) &#123;      depModules[idx] = ns.__useDefault ? ns.default : ns;    &#125;);  &#125;&#125;\n","categories":["JavaScript"],"tags":["微前端","systemJs"]},{"title":"微前端 ① 什么是微前端","url":"/posts/0c443d994e0b/","content":"什么是微前端可以多团队，多框架共同构建 web 应用程序的技术。\n微前端的价值\n技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权\n独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n独立运行时 每个子应用之间状态隔离，运行时状态不共享\n\n微前端场景解决方案\n单实例：即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期。通常基于 url 的变化来做子应用的切换。\n\n多实例：同一时刻可展示多个子应用。通常使用 Web Components 方案来做子应用封装，子应用更像是一个业务组件而不是应用。\n\n\n最终目的是将不同框架，不同项目的中的页面或组件整合在指定的路由下同时展示，并能实现数据的隔离和消息的传递等。\n架构实践微前端正是将不同的框架和不同的项目整合在一个路由中，因此微前端框架的定位仅仅是 导航路由 + 资源加载框架。\nFuture State，一个基于前端路由的应用，整个应用可以看作是一个状态树，每一个分支都可以 lazy load, 在程序启动时，描述 lazy load 状态数分支的对象，就可以叫做 Future State。\n当主应用导航到 https://a.com/subApp1 的时候子应用加载， 点击子应用的某个链接可能被导航到 https://a.com/subApp1/project，一个微前端框架应该能在路由匹配的时候加载子应用，路由不匹配的时候卸载子应用， 这就是 single-spa 做的工作。\n应该用什么集成方式，主应用应该用何种资源形式加载子应用?, 一种方式是 JS Entry， 将子应用的资源打包为 js 资源，例如 single-spa 将要求将子应用打包为 systemJs 格式当作子应用入口, qiankun 要求将子应用打包为 umd 格式（考虑到应用需要独立部署）。另一种是 HTML Entry 直接使用子应用打包出的 html 文件当作入口，本质是解析 html 中引用的资源，因此也可以优化为直接使用资源描述的对象，以减少一次请求。\n模块导入singleSpa 采用 systemJs 的模块化方案，使用 singleSpa 提供的工具，默认只会编译出 js 文件，独立部署需要其他工具支持，通过 systemJs amd 扩展，可以避免将资源加载后添加的对象挂载到 windows 上。\nqiankun 采用 umd 的模块化方案。需要使用 windows 快照的方式，获取到哪些对象被注入到 windows 中。\n样式隔离方案css-module，BEM 通过对 class 添加唯一标识保证唯一性。\ncss-in-js 代表库 emotion ，本质还是将样式转换为唯一的 class 类名，通过 style 标签插入。\nshadowDom 浏览器严格隔离\nsingleSpa 并没有提供样式隔离方案，需要子应用单独处理。\nqiankun 提供 experimentalStyleIsolation 配置， 本质上是给最外层元素样式添加唯一标识，相当于 css-module 实现方案，缺点是子应用中的元素如果挂载到了根节点外面会导致样式不生效。如果使用 strictStyleIsolation 配置，会使用 shadowDom 方案，缺点是主应用访问不到子应用的元素。另外，还实现了 Dynamic Stylesheet，原理是应用切出&#x2F;卸载后，同时卸载掉其样式表，浏览器会对样式表的插入、移除做整个 CSSOM 的重构，因此保证只有一个应用的样式表是生效的，但是这种方式对于多实例的微前端场景无法处理。\njs 隔离singleSpa 并没有提供沙箱的实现， qiankun 实现了基于 Proxy 的多实例沙箱。\n一个简单沙箱就是对 windows 快照， 当子应用卸载时，将 windows 对象回滚到之前的状态。\n基于 Proxy 的单实例沙箱，创建 Proxy 对象，将对象的操作反映到 windows 的属性改变， 但是当多个子应用实例的时候，对同一属性的修改会导致 windows 属性混乱。\n基于 Proxy 的多实例沙箱，不在对 windows 对象操作，直接\n框架比较\nsingleSpa 实现了最基本的路由功能，子应用加载功能。\n\nqiankuan 基于 singleSpa 的封装，实现了 css 隔离，以及 js 沙箱，保证应用状态隔离， 还提供了更多的特性：\n子应用并行，多个微前端同时存在子应用嵌套，微前端嵌套其他的微前端父子应用通讯预加载，空闲时加载子应用的资源公共依赖加载按需加载，切换到相应页面的时候才去加载资源\n\n\n","categories":["JavaScript"],"tags":["微前端","systemJs"]},{"title":"性能优化","url":"/posts/9d3898150489/","content":"性能优化开篇Html 数量控制 -&gt; 压缩合并（30k为标准，请求变少） -&gt; 开启CDN， gzip,brotli压缩方式 -&gt; 服务端开启keep-alive http2 -&gt; 测速 -&gt; 缓存\n离线缓存\nlocalStorage 5M 低端机型，不能占用过高\nscript 放在底部，不会影响dom的解析，但是会影响dom的渲染\n&lt;body&gt;  &lt;h1&gt;标题&lt;/h1&gt;  &lt;script&gt;    alert(0)  &lt;/script&gt;&lt;/body&gt;\n同样css不会影响dom的解析，但是影响dom的渲染\n&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;./css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;标题&lt;/h1&gt;&lt;/body&gt;\n\ncss 加载会阻塞js的执行，因为不知道js中是否使用了css, 但是不会影响dom的解析\n&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;./css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;标题&lt;/h1&gt;  &lt;script&gt;    alert(0)  &lt;/script&gt;&lt;/body&gt;\n\ncss的加载不会影响dom ready,但是如果css,下面有js脚本，则不会执行dom ready，因为不知道是否使用了css样式\n&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script&gt;    document.addEventlister(&#x27;DomContentloaded&#x27;,()=&gt;&#123;console.log(&#x27;ready&#x27;)&#125;)  &lt;/script&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;./css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;标题&lt;/h1&gt;  &lt;!-- &lt;script&gt;    alert(0)  &lt;/script&gt; --&gt;&lt;/body&gt;\n\n渲染中的性能优化","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"性能优化基础","url":"/posts/217c8927c3f1/","content":"Navigation Timing\n\nprompt for unload\n\n为卸载页面作准备， 释放js资源\n\nDNS domainLookupStart domainLookupEnd\n\nDNS 服务器会影响解析时间，DNS基于UDP协议\nDNS （Domain Name System) 域名系统，用于将域名转换为IP\n顶级域名: .com .org .club\n域名资源记录： 域名服务商的配置记录 （3A，4A）\n域名解析流程： \n\nTCP\n\n可能会产生ssl的握手（secureConnetionStart），需要放在nigix上处理\n服务器的连接数会影响响应的速度，也受到物理距离的影响\n\nrequest response\n\n请求开始到响应开始包括，数据传输时间，服务器处理时间，服务器请求时间，服务器渲染时间\n服务端优化： 服务端缓存，sql查询时间，服务端渲染，生成数据大小（使用压缩）\n三次握手四次挥手\n序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。\n确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。\n确认ACK：占1位，仅当ACK&#x3D;1时，确认号字段才有效。ACK&#x3D;0时，确认号无效\n同步SYN：连接建立时用于同步序号。当SYN&#x3D;1，ACK&#x3D;0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN&#x3D;1，ACK&#x3D;1。因此，SYN&#x3D;1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。\n终止FIN：用来释放一个连接。FIN&#x3D;1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接\nPS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。\n\n第一次握手：建立连接时，客户端发送syn包（syn&#x3D;x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（syn&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n！\n1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n2）服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n5）客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n为什么连接的时候是三次握手，关闭的时候却是四次握手？\n\n因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n\n为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？\n\n有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。\n\n为什么不能用两次握手进行连接？\n\n3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。\n\n如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\nTCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n缓存策略\n\n强制缓存浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK \n\n200 from disk cache： 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。\n\n200 form memory cache : 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。\nheader参数\nExpires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求\nCache-Control：当值设为max-age&#x3D;300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。\n（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；（2） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；（3）public：指示响应可被任何缓存区缓存；（4）private：只能针对个人用户，而不能被代理服务器缓存；（5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到     请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误     以为是响应不被缓存。实际上Cache-Control:     no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。（6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。\ncache-control是http1.1的头字段，expires是http1.0的头字段,如果expires和cache-control同时存在，cache-control会覆盖expires，建议两个都写。\n协商缓存\n向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；\nheader参数\nEtag&#x2F;If-None-Match：\nEtag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\n当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304\nLast-Modifed&#x2F;If-Modified-Since：\nLast-Modified 浏览器向服务器发送资源最后的修改时间\nIf-Modified-Since 当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。\nLast-Modifed&#x2F;If-Modified-Since的时间精度是秒，而Etag可以更精确。Etag优先级是高于Last-Modifed的，所以服务器会优先验证EtagLast-Modifed&#x2F;If-Modified-Since是http1.0的头字段\n","categories":["JavaScript"],"tags":["JavaScript","应用案例","性能优化"]},{"title":"Javascript 执行机制","url":"/posts/b672c2864ca4/","content":"变量提升与执行上下文JS 代码运行会分为编译和执行两个阶段\n所谓的变量提升，是指在 JavaScript 代码编译过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值并存到内存中，这个默认值就是我们熟悉的 undefined。\n最终在编译阶段会生成两部分内容：执行上下文（Execution context）和 可执行代码。\n执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。\n\n\n当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。\n当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。\n当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。\n\n调用栈先进先出,执行上下文通过调用栈来管理\n全局执行是上下文最先被压入栈中, 接下来如果有函数执行,当为函数创建好执行上下文后,也会被压入栈中,当函数返回时,执行上下文会从栈顶弹出.\n调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。\n使用 console.trace() 可以查看当前的调用栈信息.\n作用域作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。\nES6 总共有三种作用于, 全局作用域,函数作用域,块级作用域,如果没有块级作用域会存在两个问题\n\n变量容易在不被察觉的情况下被覆盖掉\n本应销毁的变量没有被销毁\n\nJS 通过 const, let 实现块级作用域,在创建执行上下文的时候, 这两个关键字会单独存放在词法环境中,而 var 声明的变量于函数会存放在变量环境中.\nfunction foo() &#123;  var a = 1;  let b = 2;  &#123;    let b = 3;    var c = 4;    let d = 5;  &#125;&#125;foo();\n\n在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。这里所讲的变量是指通过 let 或者 const 声明的变量。\n\n查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。\n\n作用域链于词法作用域作用域链是由词法作用域决定的.\n下面的代码当 bar 在 foo 内部调用的时候, 会先查找自己的词法环境中有没有 name, 然后查找自己的环境变量.\n但是当发现都没有的时候并不会在 foo 的词法环境和变量环境中查找,而是直接查找全局执行上下文中的词法环境和变量环境\nfunction bar() &#123;  console.log(name);&#125;function foo() &#123;  var name = &quot;one&quot;;  bar();&#125;var name = &quot;tow&quot;;foo();\n\n控制变量查找顺序的就是作用域链,其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外 部的执行上下文，这个外部引用称为 outer. 但是决定作用域链的不是执行上下文,而是词法作用域\n词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。\nfoo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。\n闭包根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量\nfunction foo() &#123;  let name = &quot;one&quot;;  const obj = &#123;    getName() &#123;      return name;    &#125;,    setName(_name) &#123;      name = _name;    &#125;,  &#125;;  return obj;&#125;var bar = foo();bar.setName(&quot;two&quot;);bar.getName();\n\n当 obj 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 name.\n虽然 foo 函数执行结束后执行上下文已经从调用栈中弹出,但是由于 obj 对象的方法使用了内部 name 变量,所以 name 变量还是保存在内存中,而保存 name 变量称作闭包. 无论在那里调用 obj 对象的方法,都可以访问到 name 变量.\n在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。\n而调用 obj 方法的时候,作用域链的顺序就是:当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文\n闭包回收如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。\n如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。\nthis实现 this 的一个初衷就是 在对象内部的方法中使用对象内部的属性\n因为作用域链由词法作用域决定,所以调用 getName 并不会获取对象属性而是在全局的执行上下文中查找\nconst obj = &#123;  name: &quot;one&quot;,  getName() &#123;    console.log(name);  &#125;,&#125;;\n\n全局执行上下文中的 thisthis 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。\n这种设计很容易误操作,所以严格模式下默认执行一个函数 this 为 undefined\n函数执行上下文中的 this直接调用一个函数，其执行上下文中的 this 也是指向 window 对象的. 但是可以通过 call apply bind 修改 this 的指向\n通过对象调用方法 thisthis 是指向对象本身的。 也可以理解为在调用的时候转化为了这样的形式 myObj.showThis.call(myObj)\n构造函数中的 thisthis 指向创建的实例. new 操作符实际上做了一下几件事.\n\n创建一个空的简单 JavaScript 对象（即{}）；\n为步骤 1 新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；\n将步骤 1 新创建的对象作为 this 的上下文 ；\n如果该函数没有返回对象，则返回 this。\n\n","categories":["JavaScript","基础"],"tags":["JavaScript","ES6基础"]},{"title":"js文件上传","url":"/posts/f6e280c02b0d/","content":"在web应用程序中使用文件\n选择文件&lt;input type=&quot;file&quot; id=&quot;input&quot;&gt;\n\nconst selectedFile = document.getElementById(&#x27;input&#x27;).files[0];\n\n通过事件选择文件\ndocument.getElementById(&#x27;input&#x27;).addEventListener(&#x27;change&#x27;,function(e)&#123;  const file = this.files[0]&#125;)\n\n上传选择的文件const input = document.getElementById(&#x27;input&#x27;)const fd = new FormData();fd.append(&#x27;data&#x27;, input.files[0]);fetch(&#x27;http://xxx.xxx.xxx&#x27;, &#123;  method: &#x27;POST&#x27;,  body:fd&#125;).then(res =&gt; res.json())\n\n创建文件并上传Blob\nconst input = document.getElementById(&#x27;input&#x27;)const fd = new FormData();const blob = new Blob([&quot;[]&quot;], &#123; type: &#x27;plain/text&#x27; &#125;);fd.append(&#x27;data&#x27;, blob,&#x27;script.txt&#x27;);fetch(&#x27;http://xxx.xxx.xxx&#x27;, &#123;  method: &#x27;POST&#x27;,  body:fd&#125;).then(res =&gt; res.json())\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"身份认证","url":"/posts/e7bf899671a2/","content":"认证(Authentication)在互联网中证明自己的身份:\n\n用户名密码登录\n邮箱发送登录链接\n手机号接收验证码\n通过第三方受信任的程序登陆,例如微信登陆\n\n授权(Authorization)用户授予第三方应用访问该用户某些资源的权限,在使用微信登陆第三方系统前,需要给第三方系统授权,允许使用微信登陆\n实现授权的方式有：cookie、session、token、OAuth\n凭证(Credentials)实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身\n什么是 Cookie\nHTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。\n\ncookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\n\ncookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。\n\n\n\n\n\n属性\n说明\n\n\n\nname&#x3D;value\n键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型- 如果值为 Unicode 字符，需要为字符编码。- 如果值为二进制数据，则需要使用 BASE64 编码。\n\n\ndomain\n指定 cookie 所属域名，默认是当前域名\n\n\npath\n指定 cookie 在哪个路径（路由）下生效，默认是 ‘&#x2F;‘。如果设置为 &#x2F;abc，则只有 &#x2F;abc 下的路由可以访问到该 cookie，如：&#x2F;abc&#x2F;read。\n\n\nmaxAge\ncookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。\n\n\nexpires\n过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除\n\n\nsecure\n该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。\n\n\nhttpOnly\n如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全\n\n\n什么是 SessionSession 一般配合 Cookie 使用,是一种记录服务器和客户端会话状态的机制\n\n\n用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session\n请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器\n浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名\n当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。\n\nCookie 和 Session 的问题\n在做负载均衡的时候, 需要把每一个请求分配到上一次处理他的服务器中, 这个问题可以通过 IP hash 来解决.\n\n如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session. 在同一服务中的所有不同域名的网站都可以自动登陆.一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。\n\n\nJWT首先说明 Token 是一个宽泛的概念, 其本质都是让客户端保存一些信息, 从而降低服务器的压力. JWT 是其中比较好的实现.\nJWT(JSON Web Token) 服务器认证以后，字符串发回给用户，就像下面这样。服务器完全只靠这个对象认定用户身份。服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n\n\nHeader\n\nHeader 部分是一个 JSON 对象，描述 JWT 的元数据.alg 属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256), typ 属性表示这个令牌（token）的类型（type），JWT 令牌统一写为 JWT。\n最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。\n\nPayload\n\nPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了 7 个官方字段，供选用。也可以添加自己定义的字段, JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个 JSON 对象也要使用 Base64URL 算法转成字符串。\niss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号\n\n\nSignature\n\nSignature 部分是对前两部分的签名，防止数据篡改。\n首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照图片中的公式产生签名。\n算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。\nJWT 使用方法客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。\n此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 Authorization 字段里面。\nAuthorization: Bearer &lt;token&gt;\n\n另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。\nJWT 的特点（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。\n（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"TypeScript 练习题","url":"/posts/448ff5304ffa/","content":"① 实现 Pick② 实现 Readonly③ 元组转换为对象④ 第一个元素⑤ 实现 Exclude⑥ Promise 返回值类型⑦ 实现 Array.Concat⑧ 实现 Array.includes⑨ 实现 Parameters⑩ 实现 ReturnType⑪ 实现 Omit⑫ Pick Readonly⑬ Deep Readonly⑭ 链式调用的类型⑮ Promise.all ⑯ Type Lookup⑰ Trim⑱ Type Replace⑲ 追加参数⑳ Flatten㉑ AppendToObject㉒ 数字转字符串㉓ StringToUnion㉔ MergeKey㉕ CamelCase &amp; KebabCase㉖ Diff㉗ anyOf㉘ isUnion\n实现 Picktype Pick&lt;T, K extends keyof T&gt; = &#123;  [P in K]: T[P];&#125;;\n\n利用 keyof 将对象类型转换成键值的联合类型\n利用 extends 进行泛型约束, K 可以分配给 T, 表示 K 是 T 的子集.\n利用 in 运算符,遍历联合类型\n实现 Readonlytype Readonly&lt;T&gt; = &#123;  readonly [P in keyof T]: T[P];&#125;;\n\n元组转换为对象const tuple = [&quot;tesla&quot;, &quot;model 3&quot;, &quot;model X&quot;, &quot;model Y&quot;] as const;type TupleToObject&lt;T extends readonly any[]&gt; = &#123;  [K in T[number]]: K;&#125;;type result = TupleToObject&lt;typeof tuple&gt;;// expected &#123; tesla: &#x27;tesla&#x27;, &#x27;model 3&#x27;: &#x27;model 3&#x27;, &#x27;model X&#x27;: &#x27;model X&#x27;, &#x27;model Y&#x27;: &#x27;model Y&#x27;&#125;\n\n因为 in 运算符可以遍历联合类型,所以把元组 T 转换成联合类型,在进行遍历\n第一个元素实现一个通用 First，它接受一个数组 T 并返回它的第一个元素的类型。\ntype arr2 = [3, 2, 1];type First&lt;T extends readonly any[]&gt; = T[0];type First&lt;T extends readonly any[]&gt; = T extends [infer F, ...infer R]  ? F  : never;type head1 = First&lt;arr1&gt;; // expected to be &#x27;a&#x27;\n\n利用条件语句中 infer 类型推断,返回第一个元素所代表的类型\n实现 ExcludeExclude 的用法是从联合类型中,排除指定的属性\ntype Exclude&lt;T, U&gt; = T extends U ? never : T;\n\nextends 条件类型, T 是否能分配给 U, 会去拿 T 中的每一项与 U 进行匹配, 如果当前项可以分配,表示 U 中存在这种类型,需要排除,所以返回 never. 如果不存在则返回这一项的类型.\nPromise 返回值类型type Awaited&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer R&gt; ? R : T;\n\n实现 Array.Concattype Concat&lt;T extends any[], U extends any[]&gt; = [...T, ...U];\n\n实现 Array.includestype Includes&lt;T extends any[], U&gt; = U extends T[number] ? true : false;\n\n利用 extends 条件类型可以进行联合类型的判断,, 首先吧元组转换为联合类型, 如果类型可分配表示 U 存在与元组中.\n实现 ParametersParameters 作用是用于获得函数的参数类型组成的元组类型。\ntype Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (  ...args: infer P) =&gt; any  ? P  : never;\n\n实现 ReturnTypetype ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (  ...args: any) =&gt; infer R  ? R  : any;\n\n实现 Omittype Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;\n\nPick Readonly指定属性 ReadOnly\ntype PickReadonly&lt;T, K extends keyof T = keyof T&gt; = &#123;  [Key in Exclude&lt;keyof T, K&gt;]: T[Key];&#125; &amp; &#123;  readonly [Key in K]: T[Key];&#125;;interface Todo &#123;  title: string;  description: string;  completed: boolean;&#125;const todo: MyReadonly2&lt;Todo, &quot;title&quot; | &quot;description&quot;&gt; = &#123;  title: &quot;Hey&quot;,  description: &quot;foobar&quot;,  completed: false,&#125;;todo.title = &quot;Hello&quot;; // Error: cannot reassign a readonly propertytodo.description = &quot;barFoo&quot;; // Error: cannot reassign a readonly propertytodo.completed = true; // OK\n\nDeep Readonlytype X = &#123;  x: &#123;    a: 1;    b: &quot;hi&quot;;  &#125;;  y: &quot;hey&quot;;&#125;;type DeepReadonly&lt;T&gt; = &#123;  readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K];&#125;;type Todo = DeepReadonly&lt;X&gt;; // should be same as `Expected`type Expected = &#123;  readonly x: &#123;    readonly a: 1;    readonly b: &quot;hi&quot;;  &#125;;  readonly y: &quot;hey&quot;;&#125;;\n\n链式调用的类型假设 key 只接受字符串而 value 接受任何类型，你只需要暴露它传递的类型而不需要进行任何处理。同样的 key 只会被使用一次。\ntype Chainable&lt;T = &#123;&#125;&gt; = &#123;  option: &lt;K extends string, V&gt;(k: K, v: V) =&gt; Chainable&lt;T &amp; &#123; [P in K]: V &#125;&gt;;  get: () =&gt; T;&#125;;declare const config: Chainable;const result = config  .option(&quot;foo&quot;, 123)  .option(&quot;name&quot;, &quot;type-challenges&quot;)  .option(&quot;bar&quot;, &#123; value: &quot;Hello World&quot; &#125;)  .get();// 期望 result 的类型是：interface Result &#123;  foo: number;  name: string;  bar: &#123;    value: string;  &#125;;&#125;\n\n实现 Promise.allts 允许像遍历一个对象一样遍历类数组\ntype Awaited&lt;T&gt; =  T extends null | undefined ? T :  // special case for `null | undefined` when not in `--strictNullChecks` mode    T extends object &amp; &#123; then(onfulfilled: infer F): any &#125; ?    // `await` only unwraps object types with a callable `then`. Non-object types are not unwrapped      F extends ((value: infer V, ...args: any) =&gt; any) ? // if the argument to `then` is callable, extracts the first argument          Awaited&lt;V&gt; :          // recursively unwrap the value          never :          // the argument to `then` was not callable    T;    // non-object or non-thenabletype PromiseAll&lt;T extends readonly unknown[] | []&gt;(values: T): Promise&lt;&#123; -readonly [P in keyof T]: Awaited&lt;T[P]&gt; &#125;&gt;;\n\nType Lookuptype LookUp&lt;U, T extends string&gt; = &#123;  [K in T]: U extends &#123; type: T &#125; ? U : never;&#125;[T];\n\n实现 Trim类型推断可以用于字符串\ntype Trim&lt;T extends string&gt; = T extends ` $&#123;infer R&#125;`  ? Trim&lt;R&gt;  : T extends `$&#123;infer R&#125; `  ? Trim&lt;R&gt;  : T;\n\nType Replacets 没有 indexOf 的能力, 通过条件类型判断两个类型是否匹配\ntype Replace&lt;  T extends string,  P extends string,  U extends string&gt; = T extends `$&#123;infer F&#125;$&#123;P&#125;$&#123;infer R&#125;` ? `$&#123;F&#125;$&#123;U&#125;$&#123;R&#125;` : T;\n\n追加参数type AppendArgument&lt;F extends (...args: any[]) =&gt; any, P&gt; = F extends (  ...args: infer R) =&gt; infer L  ? (...args: [...R, P]) =&gt; L  : F;\n\nFlattentype Flatten&lt;T extends any[], A extends any[] = []&gt; = T extends [  infer F,  ...infer R]  ? F extends any[]    ? Flatten&lt;R, Flatten&lt;F, A&gt;&gt;    : Flatten&lt;R, [...A, F]&gt;  : A;\n\nAppendToObject对象 Key 的类型约束,有两种方式\n// K extends PropertyKey 其中 PropertyKey 为内置属性// K extends keyof anytype AppendToObject&lt;T, K extends PropertyKey, V&gt; = &#123;  [Key in keyof T | K]: Key extends keyof T ? T[Key] : V;&#125;;\n\n另一种是现实是重新遍历一次组合后的对象\ntype MapKey&lt;T&gt; = &#123; [K in keyof T]: T[K] &#125;;type AppendToObject&lt;T, K extends keyof any, V&gt; = MapKey&lt;  T &amp; &#123;    [K1 in K]: V;  &#125;&gt;;\n\n数子转字符串type Test&lt;T extends number&gt; = `$&#123;T&#125;`;\n\n可以把非字符串类型转为字符串,利用类型系统处理\ntype Test&lt;T extends number | string | bigint&gt; = `$&#123;T&#125;` extends `-$&#123;infer R&#125;`  ? R  : T;type dd = Test&lt;&quot;-123&quot;&gt;; //123\n\nStringToUniontype StringToUnion&lt;  T extends string,  A extends string[] = []&gt; = T extends `$&#123;infer F&#125;$&#123;infer R&#125;` ? StringToUnion&lt;R, [...A, F]&gt; : A[number];type StringToUnion&lt;  T extends string,  A = never&gt; = T extends `$&#123;infer F&#125;$&#123;infer R&#125;` ? StringToUnion&lt;R, A | F&gt; : A;type Result = StringToUnion&lt;Test&gt;; // expected to be &quot;1&quot; | &quot;2&quot; | &quot;3&quot;\n\nMergeKeytype Merge&lt;T, P extends &#123; [k in PropertyKey]: any &#125;&gt; = &#123;  [K in keyof foo | keyof coo]: (foo &amp; coo)[K] extends never    ? P[K]    : (foo &amp; coo)[K];&#125;;type Merge&lt;F, S&gt; = &#123;  [K in keyof F | keyof S]: K extends keyof S    ? S[K]    : K extends keyof F    ? F[K]    : never;&#125;;\n\nCamelCase &amp; KebabCaseaa-bb-cc &#x3D;&gt; aaBbCc\ntype CamelCase&lt;T extends string&gt; = T extends `$&#123;infer F&#125;-$&#123;infer D&#125;$&#123;infer R&#125;`  ? CamelCase&lt;`$&#123;F&#125;$&#123;Uppercase&lt;D&gt;&#125;$&#123;R&#125;`&gt;  : T;type CamelCase&lt;T extends string&gt; = T extends `$&#123;infer F&#125;-$&#123;infer D&#125;`  ? CamelCase&lt;`$&#123;F&#125;$&#123;Capitalize&lt;D&gt;&#125;`&gt;  : T;\n\nAaBbCc &#x3D;&gt; aa-bb-cc\ntype KebabCase&lt;  T extends string,  P extends string = &quot;&quot;&gt; = T extends `$&#123;infer F&#125;$&#123;infer R&#125;`  ? Lowercase&lt;F&gt; extends F    ? KebabCase&lt;R, `$&#123;P&#125;$&#123;F&#125;`&gt;    : KebabCase&lt;R, `$&#123;P&#125;-$&#123;Lowercase&lt;F&gt;&#125;`&gt;  : P extends `-$&#123;infer R&#125;`  ? R  : never;\n\nDifftype Diff&lt;T extends object, P extends object&gt; = &#123;  [K in    | Exclude&lt;keyof T, keyof P&gt;    | Exclude&lt;keyof P, keyof T&gt;]: K extends keyof T    ? T[K]    : K extends keyof P    ? P[K]    : never;&#125;;\n\nanyOf实现一个类型,接受一个元组,如果元组中的每一个都为 false,返回 false,有一个为 true 则返回 true\n需要注意联合类型是通过 T[number] 得到的,并不会进行条件类型分配,所以当联合类型可以分配给指定联合类型, 也就是联合类型中的每一个都在指定的联合类型中的时候返回 false\ntype AnyOf&lt;T extends any[]&gt; = T[number] extends  | &quot;&quot;  | 0  | false  | []  | Record&lt;any, never&gt;  ? false  : true;\n\nisUnion利用 分配条件类型,联合类型在条件分配后会被转换为复合联合类型\ntype IsUnion&lt;T, O = T&gt; = T extends O ? ([O] extends [T] ? false : true) : never;type case1 = IsUnion&lt;string&gt;;type case2 = IsUnion&lt;string | number&gt;; // truetype case3 = IsUnion&lt;[string | number]&gt;; // false// 利用分配条件类型把基本类型的联合类型转换为符合类型的联合类型type Test&lt;T, O = T&gt; = T extends O ? [T] : never;type case1 = Test&lt;string&gt;; //[string]type case2 = Test&lt;string | number&gt;; // [string] | [number]type case3 = Test&lt;[string | number]&gt;; // [[string|number]]\n","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"调试第三方模块","url":"/posts/eb5495bfdf9d/","content":"存在的问题有时候需要在react项目中打断点调试，或者调试react源码\n如果直接在node_modules中的文件打断点，添加注释或修改，在某些vsCode的版本中会提示nobonud breakPoint,不能进入断点\n但最主要的问题，当项目重新初始化，所有的修改会被删除\n安装插件在vsCode市场中安装 Debugger for Chrome 插件\n\n添加配置文件\n选择Chrome\n\n修改配置文件端口为项目端口\n&#123;  // Use IntelliSense to learn about possible attributes.  // Hover to view descriptions of existing attributes.  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;type&quot;: &quot;pwa-chrome&quot;,      &quot;request&quot;: &quot;launch&quot;,      &quot;name&quot;: &quot;Launch Chrome against localhost&quot;,      &quot;url&quot;: &quot;http://localhost:3000&quot;, //把端口修改为项目端口      &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&quot;    &#125;  ]&#125;\n\n使用 yarn link\n将需要调试的第三方包复制到本地，并在node_modules中删除\n\n进入第三方包的文件夹根目录执行，yarn link 创建一个链接\n\n进入项目文件夹根目录执行，yarn link &quot;package name&quot; 将依赖添加到node_modules中\n\n这时查看依赖包的路径为本地第三方包的路径\n\n\n\n使用 yarn unlink\n进入项目文件夹根目录执行，yarn unlink &quot;package name&quot; 将依赖添从node_modules中删除\n\n进入第三方包的文件夹根目录执行，yarn unlink, 不在链接到全局\n\n\n调试如果react项目打断点不能被捕获，可以尝试在入口index.js文件中添加一行 debugger;\n这样在调试器中点击下一步，会跳到下一个断点\n","categories":["JavaScript"],"tags":["JavaScript","Node"]},{"title":"跨域CORS","url":"/posts/2db9089a78d8/","content":"cors是什么由于浏览器的同源策略，不允许访问非同源的资源，cors的目的就是解决这个问题，也就是常说的跨域访问。\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\n整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。\n两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求。\n\n1.请求方法是以下三种方法之一： HEAD GET POST2.HTTP的头信息不超出以下几种字段： Accept | Accept-Language | Content-Language | Last-Event-IDContent-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain\n\nfetch(&quot;http://xxx&quot;,&#123;  headers:&#123;      &#x27;content-type&#x27;:&#x27;application/json&#x27;  &#125;  method:&#x27;POST&#x27;,  body: JSON.stringify(body)&#125;)\n\n\n这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。\n凡是不同时满足上面两个条件，就属于非简单请求。\n简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n\nOrigin: http://xxx\n\n上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。\n如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\n\nAccess-Control-Allow-Origin: http://xxxAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。\n\nAccess-Control-Allow-Origin\n\n该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\n\nAccess-Control-Allow-Credentials\n\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。\n\nAccess-Control-Expose-Headers\n\n该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。\n\nwithCredentials 属性\n\n上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。\n\nAccess-Control-Allow-Credentials: true\n\n另一方面，开发者必须在AJAX请求中打开withCredentials属性。\nvar xhr = new XMLHttpRequest();xhr.withCredentials = true;\n\n否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。\n但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。\nxhr.withCredentials = false;\n\n需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。\n非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application&#x2F;json。\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\nOPTIONS /cors HTTP/1.1Origin: xxxAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...\n\n“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\n除了Origin字段，”预检”请求的头信息包括两个特殊字段。\n\nAccess-Control-Request-Method\n\n该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。\n\nAccess-Control-Request-Headers\n\n该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\n预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\nHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://xxxAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain\n\n上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://xxx可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。\nAccess-Control-Allow-Origin: *\n\n如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。\nXMLHttpRequest cannot load http://xxxOrigin http://xxx is not allowed by Access-Control-Allow-Origin.\n\n服务器回应的其他CORS相关字段如下。\nAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000\n\n\nAccess-Control-Allow-Methods\n\n该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。\n\nAccess-Control-Allow-Headers\n\n如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。\n\nAccess-Control-Allow-Credentials\n\n该字段与简单请求时的含义相同。\n\nAccess-Control-Max-Age\n\n该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。\n浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n下面是”预检”请求之后，浏览器的正常CORS请求。\nPUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...\n\n上面头信息的Origin字段是浏览器自动添加的。\n下面是服务器正常的回应。\nAccess-Control-Allow-Origin: http://xxxContent-Type: text/html; charset=utf-8\n\n上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。\n与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。\nJSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。\nfetch跨域遇到的问题如果服务器不支持CORS，fetch提供了三种模式，其中no-cors可以继续访问服务器\nfetch的mode配置项有3个值，如下:\n\nsame-origin：该模式是不允许跨域的，它需要遵守同源策略，否则浏览器会返回一个error告知不能跨域；其对应的response type为basic。\n\ncors: 该模式支持跨域请求，顾名思义它是以CORS的形式跨域；当然该模式也可以同域请求不需要后端额外的CORS支持；其对应的response type为cors。\n\nno-cors: 该模式用于跨域请求但是服务器不带CORS响应头，也就是服务端不支持CORS；这也是fetch的特殊跨域请求方式；其对应的response type为opaque。\n\n\nno-cors该模式允许浏览器发送本次跨域请求，但是不能访问响应返回的内容，这也是其response type为opaque透明的原因。\n","categories":["JavaScript"],"tags":["跨域cors"]},{"title":"隐式转换","url":"/posts/400347728533/","content":"一元操作符一元操作符包括，+, -, ~, !,其中 +, - 需要和加法运算符区分开。\nECMA 规定了 一元操作符 求值过程。\nconsole.log(+true); // 1console.log(+[]); // 0console.log(+&#123;&#125;); //NaNconsole.log(+&quot;123&quot;); // 123\n\n对于 + 一元表达式求值，需要首先对操作数（V）取值（GetValue, 对取值结果进行 ToNumber 操作。\nToNumber:\n\n如果 V 是 Number，返回 V\n如果 V 是 Symbol 或 BigInt 抛出错误 TypeError\n如果 V undefined, 返回 NaN\n如果 V 是 null 或 false 返回 +0\n如果 V 是 true 返回 1 （案例 1）\n如果 V 是 String 返回 StringToNumber(argument) StringToNumber 规定如果不能转成数字，返回 NaN 如果可以则返回 Number （案例 4）\nV 如果是一个 Object\n将 V 转换为原始值 ToPrimitive 数组将会通过 toString 转换为 &quot;&quot;, 再次执行第 6 步，最终数组被转换为 0 (案例 2)，对象在经过 ToPrimitive 转换为 [Object object], 在执行 StringToNumber 由于不能转换为数字，最终返回 NaN (案例 3)\n原始值不是对象，再次执行 ToNumber\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"TypeScript 面向对象","url":"/posts/2c316c8d5104/","content":"定义类class C &#123;  constructor(n: string) &#123;     this.name = n;// 构造函数，为定义的属性赋值  &#125;  name: string; // 定义属性 省略前面的public关键字  readonly age:number =  18 // 只读属性  static readonly age: number = 1;  run():void&#123; // 定义方法    console.log(&#x27;void&#x27;)  &#125;&#125;\n\n\n\n接口定义类的结构，声明包含的属性和方法，接口也可以当作类型声明去使用\n接口可以在定义类的时候限制类的结构，接口中所有属性都不应该有实际的值\n接口只定义对象的结构，接口中的所有方法都是抽象方法\n同名结构声明的类型会合并，如果一个对象使用了该接口，必须包含所有的属性\ninterface MyObj &#123;  prop1: string,  prop2: number&#125;interface MyObj &#123;  prop3: Boolean&#125;const obj: MyObj = &#123;  prop1: &#x27;1&#x27;,  prop2: 2,  prop3: true,&#125;\n\n接口可以描述类的行为定义类时可以让类去实现一个接口\ninterface PersonInterface &#123;  // 只读属性  readyonly name: string,  age: number,  say(method: string): boolean&#125;class JiaZhen implements PersonInterface &#123;  name: string = &#x27;1&#x27;;  age: number = 1;  say(method: string): boolean &#123;    return true;  &#125;&#125;\n\n使用接口描述一个类的实例化\ninterface PersonInterface&#123;  name:string,  new(name:string):Person&#125;class Person&#123;  constructor(name:string) &#123;  &#125;&#125;function  createPerson(Clsss:PersonInterface,name:string) &#123;    return new Clsss(name);&#125;createPerson(Person,&#x27;aaa&#x27;);\n\n属性的封装类的属性如果可以随意被修改，可能导致运算时的错误\nTS提供了三种属性的修饰符\npublic: 公有 在类，子类 类外面都可以访问\nclass Person &#123;  constructor(pubilc name:string)&#123;    // 表示添加到实例上。可以通过属性访问  &#125;&#125;new Person().name\n\nprotected: 保护类型 在类里面，子类里面可以访问，在类外部没法访问\nprivate: 私有 在类里面可以方法，子类，类外都不能访问\n属性如果不加修饰符就是共有\n泛型定义函数或者类时遇到类型不确定时使用泛型，可以使用多个\nfunction jiazhen&lt;Z&gt;(age: Z): Z &#123;  return age;&#125;jiazhen(19);jiazhen&lt;Number&gt;(19) // 主动指明泛型\n\n指明泛型Z必须是interface的实现类\ninterface Zhen &#123;  age: number,  love(who: string): boolean&#125;function jiazhen&lt;Z extends Zhen&gt;(obj: Z): any &#123;  return obj.love;&#125;jiazhen&lt;Zhen&gt;(&#123;  age: 1,  love(a) &#123;    return true;  &#125;&#125;)\n\n指明类初始化时的泛型\nclass A&lt;T&gt;&#123;  name: T;  constructor(a: T) &#123;    this.name = a  &#125;&#125;new A&lt;string&gt;(&#x27;10&#x27;)\n\n类装饰器function enhancer(target:any)&#123;  target.prototype.name = &#x27;11&#x27;;&#125;interface Person&#123;  name:string&#125;@enhancerclass Person &#123;  constructor()&#123;  &#125;&#125;const p = new Person();p.name;\n\n属性装饰器// 如果装饰的是普通的属性，target指向类的原型// 如果是static属性，target指向类的定义function upperCase(target:any,propname:string) &#123;  let v = target[propname];  const getter = ()=&gt;v;  const setter = (newValue:string)=&gt;&#123;    v =  newValue.toUpperCase();  &#125;  delete target[propname];  Object.defineProperty(target,propname,&#123;    set:setter,    get:getter,    enumerable:true,    configurable:true  &#125;)&#125;interface Person&#123;  name:string&#125;class Person &#123;  @upperCase  name = &#x27;girl&#x27;  constructor()&#123;      &#125;&#125;const p = new Person();console.log(p.name);\n\nfunction unEnumber(enumConfig:boolean) &#123;  //                                                       属性描述器  return function unEnumber(target:any,propname:string,propertyDescriptor:PropertyDescriptor) &#123;    propertyDescriptor.enumerable  = enumConfig;  &#125;&#125;interface Person&#123;  name:string&#125;class Person &#123;  name = &#x27;girl&#x27;  constructor()&#123;&#125;    // getname 不能枚举  @unEnumber(false)  getName()&#123;&#125;&#125;const p = new Person();console.log(p.name);for(let key in p)&#123;  console.log(key)&#125;\n\n可以对方法的逻辑进行包装\nfunction trans(target:any,propname:string,propertyDescriptor:PropertyDescriptor) &#123;  const oldValue = propertyDescriptor.value;  console.log(&quot;1------------&quot;)  propertyDescriptor.value = function getNumber(...args:any[]) &#123;    args = args.map(item=&gt;Number(item));    console.log(&quot;2------------&quot;)    return oldValue.apply(this,args);  &#125;&#125;interface Person&#123;  name:string&#125;class Person &#123;  name = &#x27;girl&#x27;  constructor()&#123;&#125;  @trans  getNumber(...args:any[])&#123;    console.log(&quot;3------------&quot;)    return args.reduce((sum,item)=&gt;&#123; sum+=item; return sum &#125;,0);  &#125;&#125;const p = new Person();console.log(p.getNumber(&#x27;1&#x27;,2,&#x27;3&#x27;));\n\n参数修饰器//              类的原型    方法名             被修饰参数的索引function dubble(target:any,methodName:string,index:number) &#123;  target.num = &#x27;num&#x27;&#125;class Person &#123;  getNumber(@dubble num:number)&#123;    console.log(num);    console.log(this.num);  &#125;&#125;const p = new Person();p.getNumber(2);\n\n抽象类不能当作构造函数，抽象方法必须被子类实现\nabstract class Person &#123;  abstract say(): void&#125;class Lisa extends Person &#123;  say() &#123; &#125;&#125;\n\n\n重写和重载重写:子类中重写继承自父类的方法\nclass Person &#123;  say()&#123;&#125;&#125;class Boy extends Person&#123;  say()&#123;&#125;&#125;\n\n重载：为一个函数提供多个类型的定义\n// 函数重载表示同名的函数如果参数不同函数会重载// 但是JS中没有重载的概念，下面同名的函数会覆盖上面的函数// TS中模拟函数重载, 通过不同的参数类型校验function fn(a: number): number;function fn(b: string): string;function fn(c: any): any &#123;  if (typeof c === &#x27;number&#x27;) &#123;    return c + 1;  &#125;&#125;;\n\n","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"高级用法","url":"/posts/7042a9e618ec/","content":"泛型定义泛型（Generics）是只在定义函数，接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特征\n泛型 T 作用于只限在函数的内部\n必须要把val指定为any类型，可以传入任意类型，但是不够灵活val不是所有类型都可以，所以需要使用泛型\nfunction  createArray(length:number,val:any):Array&lt;any&gt; &#123;  let result:Array&lt;any&gt; =[];   for(let i=0;i&lt;length;i++)&#123;    result.push(val);  &#125;  return result;&#125;let result = createArray(3,&quot;x&quot;);console.log(result);\n\n期望的是val的什么类型，最终返回的就是这个类型的数组\nfunction  createArray&lt;T&gt;(length:number,val:T):Array&lt;T&gt; &#123;  let result:Array&lt;T&gt; =[];   for(let i=0;i&lt;length;i++)&#123;    result.push(val);  &#125;  return result;&#125;// 在是用的时候传入声明的类型let result = createArray&lt;string&gt;(3,&quot;x&quot;);console.log(result);\n\n接口泛型因为T是未知类型，所以返回值中不能经行运算\ninterface M &#123;  &lt;T&gt;(a:T,b:number):T&#125;const fn:M = function &lt;T&gt;(a:T,b:number) &#123;  return a;&#125;fn(&quot;1&quot;,1);\n\n多类型参数const swap = function swap&lt;A,B&gt;(arr:[A,B]):[B,A] &#123;  return [arr[1],arr[0]];&#125;console.log(swap&lt;string,number&gt;([&#x27;a&#x27;,2]))\n\n\n默认泛型const swap = function swap&lt;A,B=number&gt;(arr:[A,B]):[B,A] &#123;  return [arr[1],arr[0]];&#125;console.log(swap&lt;string&gt;([&#x27;a&#x27;,2]))\n\n泛型约束在函数中使用泛型的时候，由于预先不知道具体使用的类型，所以不能访问相应类型的方法\nfunction logger&lt;T&gt;(val:T):number &#123;  // 报错： 不能确定val的类型，所以不能检查  return val.length;&#125;\n\ninterface Logger &#123;  length:number&#125;function logger&lt;T extends Logger&gt;(val:T):number &#123;  return val.length;&#125;\n\n\n泛型类型别名interface定义一个真实的接口，是一个真正的类型\ntype 一般用来定义别名，并不是一个真正的类型\ninterface Cart&lt;T&gt; &#123;  list:T[]&#125;// 泛型类型别名type Cart2&lt;T&gt; =&#123;list:T[]&#125;|T[];const c1:Cart2&lt;string&gt; = [&#x27;1&#x27;]const c2:Cart2&lt;string&gt; = &#123;list:[&#x27;1&#x27;]&#125;\n\n\n交叉类型interface Bird&#123;  fly():void&#125;interface Boy&#123;  name:string&#125;type BirdBoy = Bird &amp; Boy\n\ntypeof 获取类型const boy  = &#123;  name:&#x27;1&#x27;&#125;type Boy = typeof boy;const p:Boy =&#123;  name:&quot;123&quot;&#125;\n\n索引访问interface Boy&#123;  name:string,  info:&#123;    id:number  &#125;&#125;const boy:Boy[&#x27;info&#x27;][&#x27;id&#x27;] = 123\n\n索引类型查询操作符const boy:Boy = &#123;  name:&quot;boy&quot;,  id:1,  info:&#123;    aaa:123  &#125;&#125;type PropType = keyof Boy;function getData(target:Boy,prop:PropType) &#123;  return target[prop];&#125;getData(boy,&#x27;info&#x27;)\n\n\n映射类型部分属性\ninterface Boy&#123;  name:string,  id:number,  info:&#123;    aaa:number  &#125;&#125;// 部分属性type PartialBoy = &#123;  [k in keyof Boy]?:Boy[k]&#125;const boy:PartialBoy = &#123;  name:&#x27;123&#x27;&#125;\n\n原生提供的方法及实现\n// Partial 实现type Partial&lt;T&gt; =&#123;  [key in keyof T]?:T[key]&#125;// 原生方法type PartialBoy = Partial&lt;Boy&gt;;const boy:PartialBoy = &#123;  name: &quot;name&quot;&#125;\n\n所有属性必须有\n// Required 实现type Required&lt;T&gt; =&#123;  [key in keyof T]-？:T[key]&#125;// 原生方法type PartialBoy = Required&lt;Boy&gt;;const boy:PartialBoy = &#123;  name: &quot;name&quot;,  id:123,  info:&#123;    aaa:111  &#125;&#125;\n\n属性只读\n// Readonly 实现type Readonly&lt;T&gt; =&#123;  readonly [key in keyof T]:T[key]&#125;// 原生方法type PartialBoy = Readonly&lt;Boy&gt;;const boy:PartialBoy = &#123;  name: &quot;name&quot;,  id:123,  info:&#123;    aaa:111  &#125;&#125;// 报错boy.name = 1;\n\npick 指定属性\n// Pick 实现// 只能摘取某一项返回type Pick&lt;T,K extends keyof T&gt; =&#123;  [key in K]:T[key]&#125;// 原生方法type PartialBoy = Pick&lt;Boy,&#x27;id&#x27;&gt;;const boy:PartialBoy = &#123;  id:123,  name:&#x27;123&#x27; // 报错&#125;\n\n\n条件类型interface Bird &#123;  name1:string&#125;interface Fish &#123;  name2:string&#125;interface Water &#123;  name3:string&#125;interface Sky &#123;  name4:string&#125;type Combin&lt;T&gt; = T extends Bird ? Sky : Water;const ins:Combin&lt;Fish | Bird&gt; = &#123;  name4: &#x27;123&#x27;,  name3:&#x27;123&#x27;&#125;\n\n","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"鼠标，触摸，指针事件","url":"/posts/1430ebf25b0e/","content":"触摸事件Safari 不支持 Touch 事件\n| touches | 正在触摸屏幕所有手指的一个列表 || targetTouches | 正在触摸当前 DOM 元素上的手指的一个列表 || changedTouches | 相对上一次触摸事件改变的 Touch 对象， 从无到有，从有到无变化 |\n模拟一个触摸事件// 获取按钮元素var button = document.getElementById(&quot;myButton&quot;);// 创建一个触摸点var touch = new Touch(&#123;  identifier: Date.now(),  target: button,  clientX: 50, // X坐标  clientY: 50, // Y坐标  radiusX: 2.5,  radiusY: 2.5,  rotationAngle: 10,  force: 0.5,&#125;);// 创建一个触摸事件var touchEvent = new TouchEvent(&quot;touchstart&quot;, &#123;  cancelable: true,  bubbles: true,  touches: [touch],  targetTouches: [],  changedTouches: [touch],  shiftKey: true,&#125;);button.dispatchEvent(touchEvent);\n\n指针事件历史chrome 55 版本之前，同时期浏览器浏览器都只有 MouseEvent, 然而，近年来的新兴设备支持更多不同方式的指针定点输入，如各类触控笔和触摸屏幕等。这就有必要扩展现存的定点设备事件模型，以有效追踪各类指针事件。\nPointerEvent 接口继承了所有 MouseEvent 中的属性，以保障原有为鼠标事件所开发的内容能更加有效的迁移到指针事件。\n不同事件对应表\n\n\nMouseEvent\nTouchEvent\nPointerEvent\n\n\n\nmousedown\ntouchstart\npointerdown\n\n\nmousemove\ntouchmove\npointermove\n\n\nmouseup\ntouchend\npointerup\n\n\n\ntouchcancel\npointercancel\n\n\nmouseenter\n\npointerenter\n\n\nmouseleave\n\npointerleave\n\n\nmouseover\n\npointerover\n\n\nmouseout\n\npointerout\n\n\n\n\ngotpointercapture\n\n\n\n\nlostpointercapture\n\n\nsetPointerCapture用于将特定元素指定为未来指针事件的捕获目标。指针的后续事件将以捕获元素为目标，直到捕获被释放\n通常用于实现，在元素外拖动的时候让元素保持响应\n&lt;body&gt;  &lt;div id=&quot;slider&quot;&gt;SLIDE ME&lt;/div&gt;  &lt;script&gt;    function beginSliding(e) &#123;      slider.onpointermove = slide;      slider.setPointerCapture(e.pointerId);    &#125;    function stopSliding(e) &#123;      slider.onpointermove = null;      slider.releasePointerCapture(e.pointerId);    &#125;    function slide(e) &#123;      slider.style.transform = `translate($&#123;e.clientX - 70&#125;px)`;    &#125;    const slider = document.getElementById(&quot;slider&quot;);    slider.onpointerdown = beginSliding;    slider.onpointerup = stopSliding;  &lt;/script&gt;&lt;/body&gt;\n\nevent.pointerType用于区分各类设备，以兼容不同的事件类型.\n\nmouse 鼠标触发的事件\n\npen 笔或手写笔设备\n\ntouch 手指等触摸事件\n\n\n多指触控// 通过id区分document.onpointerdown = (e) =&gt; &#123;  console.log(e.pointerId);&#125;;\n","categories":["JavaScript"],"tags":["鼠标事件"]},{"title":"IP地址、子网掩码、网关","url":"/posts/36c6d9747dce/","content":"什么是IP地址？假如有一群人在一个密闭房间里面，用什么方式能够快速的叫到某一个人呢？没错,一个简单的方式，就是每个人编一个号码，例如，叫到一号，就知道是谁了。\n在网络世界中也是一样的，要想快速访问某一台设备，就需要每台设备有一个编号，而这个编号就是网络设备的IP地址。在这个房间里面，如果有两个人的编号相同，那么会怎么样，肯定就是当叫到这个编号的时候，不知道叫的是谁，所以一个房间里面不允许有两个编号相同的人，在一个局域网里面不允许有两个IP地址相同的设备，如果有就被称为IP冲突，会严重危害到网络的稳定。\n扩展一下，在一栋大楼里面，有好多个这样的密闭房间，每个密闭的房间也都有一群人，那么要怎么定位到某一个房间里面的一个人呢？\n答案肯定也还是编号，给每个房间编号，例如1号房间里面的1号，这样就能定位到特定的那一个人了，这时候我们把房间号也加入到人的编号当中去，房间号和人的编号用一个”.”间隔开来，例如1.1号，说明就这个人就是1号房间里面的1号人。\n网络设备中的IP地址也是如此，例如192.168.1.100，我们可以这样理解，192.168.1号房间，也就是我们会提到的网段，100就是在这个网段里面的编号100的设备。\n什么是子网掩码？根据上面提出的编号：192.168.1.100，会引发一个新的疑问，为什么房间号是：192.168.1，而人的编号是100，可不可以把房间号设置成为192.168，人的编号设置成为1.100呢？\n答案当然是可以的，但是这样设置会引发一个问题，同样192.168.1.100这个编号就会有歧义，可以表示192.168.1房间里面的100号人，也可以表示192.168号房间里面的1.100号人，这时候就要引入另外一个规则，告诉人们多少就是房间编号，多少就是人的编号，而这个规则就是子网掩码。\n都知道网络时间就是数字世界，所以这个规则设计得很讨巧，长度设置和编号一样长，通过和编号的于运算，最后告诉人们那些是房间号，那些事是人的编号。\n举个例子：子网掩码是255.255.255.0这个最常用的规则意思是255.255.255这前三位是房间号，后面0那一位是人编号，再比如192.168.1.100这个IP地址和255.255.0.0这个子网掩码，说明192.168是房间号，也就是网段，而1.100是人的编号，也就是设备在这个网段的编号。\n换句话说:子网掩码的作用就是确定设备出于哪个网段。子网掩码 255.255.0.0 表示前两位是网络部分,后两位是主机部分. 所以子网掩码相同且前两位相同的IP (例如:192.168.0.12 与 192.168.1.13) 在同一网段. \n什么是网关？接着上面的问题，一群人在一个密闭房间里面，已经每一个人都有了一个编号，就是网络设备中的IP地址，那么这时候需求升级了，房间里面的人需要和房间外面的人们进行沟通对话，这时候怎么办呢，就需要一个会穿墙术的超能力者当传话筒，在这个房间里面穿梭，把房间里面的人的话传到外面去，把外面的人回应传回给房间里面的人。\n这个有超能力的人就是网络世界中的网关，他负责把内部网络的讯息传递到外网， 把外网信息传递回来，对于一个家庭网络而言，这个角色不正是我们的路由器吗？\n路由器是唯一一个和宽带连接的设备，家里所有的设备都要经过路由器才能连接到宽带，进行上网冲浪。所以网关也就是我们家庭宽带网络中的路由器，如果网关设置错误，就好像你把要传递出去的话语传给了一个没有超能力的人，自然也就无法把话语传达到房间外面。\n所以这里所说的穿墙只的就是两个设备不在同一网段,如果在同一网段就可以利用交换机通信,如果不是就需要路由器,也就会用到网关的概念.\n网关就是跨网段通讯的“关口”。当数据包从本网段设备传输到路由器时，首先要保证网关一致。网关可以使用本网段中任何一个地址，但是有一个不成文的规定，一般网关使用本网段中第一个可用的地址，这是为了避免与局域网中其他设备IP产生冲突。所以上面例子中的局域网1中，所有设备的网关都应该是10.0.0.1。局域网2中所有设备的网关都应该是12.0.0.1。有了网关，局域网内的设备才可以通过路由器与其他网段的设备进行通讯。\n","categories":["Linux","运维"],"tags":["Linux"]},{"title":"Ubuntu Server 安装","url":"/posts/65837ed3d57c/","content":"\n选择语言\n\n\n\n是否版本更新，可以选择跳过\n\n\n\n键盘配置选择英文\n\n\n\n选择安装方式\n\n\n\n网络配置，选择 DHCP\n\n\n\n代理配置,保持默认空\n\n\n\n镜像源配置，保持默认或填写国内镜像源\n\n\n\n存储配置，保持默认\n\n\n\n\n配置用户和密码\n\n\n\n是否升级到专业版\n\n\n\nSSH 配置， 勾选安装 OpenSSH Server\n\n\n\n额外的安装包，按情况勾选\n\n\n\n等待系统安装\n\n\n","categories":["Linux"],"tags":["Ubuntu"]},{"title":".bashr 和 .profile的区别","url":"/posts/dfd660b48c0a/","content":"要搞清bashrc与profile的区别，首先要弄明白什么是交互式shell和非交互式shell，什么是login shell 和non-login shell。\n交互式模式\nshell等待你的输入，并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。\n这种模式也是大多数用户非常熟悉的：登录、执行一些命令、签退。当你签退后，shell也终止了\n非交互式模式\nshell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾，shell也就终止了。\nbashrc与profile都用于保存用户的环境信息，bashrc用于非交互式non-loginshell，而profile用于交互式login shell。\n系统中存在许多bashrc和profile文件：\n\n&#x2F;etc&#x2F;profile 此文件为系统的每个用户设置环境信息,当第一个用户登录时,该文件被执行.并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置.\n每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,它设置一些环境变量,然后执行用户的.bashrc文件.\n\n&#x2F;etc&#x2F;bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。有些linux版本中的&#x2F;etc目录下已经没有了bashrc文件。\n该文件包含专用于某个用户的bash shell的bash信息,当该用户登录时以及每次打开新的shell时,该文件被读取.另外,&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而~&#x2F;.bashrc等中设定的变量(局部)只能继承&#x2F;etc&#x2F;profile中的变量,他们是”父子”关系.\n\n\n&#x2F;etc&#x2F;profile，&#x2F;etc&#x2F;bashrc 是系统全局环境变量设定\n&#x2F;.profile，&#x2F;.bashrc用户家目录下的私有环境变量设定\n当登入系统时候获得一个shell进程时，其读取环境设定档有三步\n\n首先读入的是全局环境变量设定档&#x2F;etc&#x2F;profile，然后根据其内容读取额外的设定的文档，如&#x2F;etc&#x2F;profile.d和&#x2F;etc&#x2F;inputrc\n\n然后根据不同使用者帐号，去其家目录读取&#x2F;.bash_profile，如果这读取不了就读取&#x2F;.bash_login，这个也读取不了才会读取~&#x2F;.profile，这三个文档设定基本上是一样的，读取有优先关系\n\n然后在根据用户帐号读取&#x2F;.bashrc至于&#x2F;.profile与~&#x2F;.bashrc的不区别都具有个性化定制功能\n\n\n  ~&#x2F;.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次  ~&#x2F;.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次\n","categories":["Linux","常见问题"],"tags":["Linux"]},{"title":"拷贝和移动命令","url":"/posts/4892b516be78/","content":"\n\n\n序号\n命令\n对应英文\n作用\n\n\n\n01\ntree [ 目录名 ]\ntree\n以树状图列出文件目录结构\n\n\n02\ncp 源文件 目标文件\ncopy\n复制文件或者目录\n\n\n03\nmv 源文件 目标文件\nmove\n移动文件或者目录&#x2F;文件或者目录重命名\n\n\ntree\ntree 命令可以以树状图列出文件目录结构\n\n\n\n\n选项\n含义\n\n\n\n-d\n只显示目录\n\n\ncpcp 命令的功能是将给出的 文件 或 目录 复制到另一个 文件 或 目录 中,相当于 DOS 下的 copy 命令\n\n\n\n选项\n含义\n\n\n\n-f\n已经存在的目标文件直接覆盖不会提示\n\n\n-i\n覆盖文件前提示 n&#x2F;y\n\n\n-r\n若给出的源文件是目录文件,则 cp 将递归复制该目录下的所有子目录和文件,目标文件必须为一个目录名\n\n\n如果文件名相同可以不指定目标文件名，只写目标路径\n\nmvmv 命令可以用来 移动 文件 或 目录 ,也可以给 文件或目录重命名\n\n\n\n选项\n含义\n\n\n\n-i\n覆盖文件前提示\n\n\n在同目录下移动实现修改文件的名字,为了防止覆盖可以加上 -i参数\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"文件内容命令","url":"/posts/95e57fd38e47/","content":"查看文件内容\n\n\n序号\n命令\n对应英文\n作用\n\n\n\n01\ncat 文件名\nconcatenate\n查看文件内容、创建文件、文件合并、追加文件内容等功能\n\n\n02\nmore 文件名\nmore\n分屏显示文件内容\n\n\n03\ngrep 搜索文本 文件名\ngrep\n搜索文本文件内容\n\n\n内容较多时more命令会分页显示，cat命令会一次性显示\n\n\n\n操作键\n功能\n\n\n\n空格键\n显示手册页的下一屏\n\n\nEnter 键\n一次滚动手册页的一行\n\n\nb\n回滚一屏\n\n\nf\n前滚一屏\n\n\nq\n退出\n\n\n&#x2F;word\n搜索 word 字符串\n\n\ncat\ncat 命令可以用来 查看文件内容 、创建文件 、 文件合并 、追加文件内容 等功能\n\ncat 会一次显示所有的内容,适合 查看内容较少 的文本文件\n\n\n\n\n\n选项\n含义\n\n\n\n-b\n对非空输出行编号\n\n\n-n\n对输出的所有行编号\n\n\n\nLinux 中还有一个 nl 的命令和 cat -b 的效果等价\n\ngrep\nLinux 系统中 grep 命令是一种强大的文本搜索工具\ngrep 允许对文本文件进行 模式 查找,所谓模式查找,又被称为正则表达式\n\n\n\n\n选项\n含义\n\n\n\n-n\n显示匹配行及行号\n\n\n-v\n显示不包含匹配文本的所有行(相当于求反)\n\n\n-i\n忽略大小写\n\n\n\n\n\n\n参数\n含义\n\n\n\n^a\n行首,搜寻以 a 开头的行\n\n\nke$\n行尾,搜寻以 ke 结束的行\n\n\nvim使用方法\n安装\nsudo apt install vim\n\n基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：\n\n命令模式\n\n用户刚刚启动 vi&#x2F;vim，便进入了命令模式。\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n以下是常用的几个命令：\n\ni 切换到输入模式，以输入字符。\n\nx 删除当前光标所在处的字符。\n\n: 切换到底线命令模式，以在最底一行输入命令。\n\n\n若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n\n输入模式\n\n在命令模式下按下i就进入了输入模式。\n在输入模式中，可以使用以下按键：\n\n字符按键以及Shift组合，输入字符\n\nENTER，回车键，换行\n\nBACK SPACE，退格键，删除光标前一个字符\n\nDEL，删除键，删除光标后一个字符\n\n方向键，在文本中移动光标\n\nHOME&#x2F;END，移动光标到行首&#x2F;行尾\n\nPage Up&#x2F;Page Down，上&#x2F;下翻页\n\nInsert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线\n\nESC，退出输入模式，切换到命令模式\n\n底线命令模式\n\n\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\n\nw 保存文件\n\n\n按ESC键可随时退出底线命令模式。\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"文件和目录命令","url":"/posts/ba62e525246f/","content":"\n\n\n目录\n说明\n\n\n\n&#x2F;bin\n存放⼆二进制可执⾏行行⽂文件(ls,cat,mkdir等)，常⽤用命令⼀一般都在这⾥里里。\n\n\n&#x2F;etc\n存放系统管理理和配置⽂文件\n\n\n&#x2F;home\n存放所有⽤用户⽂文件的根⽬目录，是⽤用户主⽬目录的基点，⽐比如⽤用户user的主⽬目录就是&#x2F;home&#x2F;user，可以⽤用~user表示\n\n\n&#x2F;usr\n⽤用于存放系统应⽤用程序，⽐比较重要的⽬目录&#x2F;usr&#x2F;local 本地系统管理理员软件安装⽬目录（安装系统级的应⽤用）。这是最庞⼤大的⽬目录，要⽤用到的应⽤用程序和⽂文件⼏几乎都在这个⽬目录。&#x2F;usr&#x2F;x11r6 存放x window的⽬目录&#x2F;usr&#x2F;bin 众多的应⽤用程序&#x2F;usr&#x2F;sbin超级⽤用户的⼀一些管理理程序&#x2F;usr&#x2F;doc linux⽂文档&#x2F;usr&#x2F;include linux下开发和编译应⽤用程序所需要的头⽂文件&#x2F;usr&#x2F;lib 常⽤用的动态链接库和软件包的配置⽂文件&#x2F;usr&#x2F;man 帮助⽂文档&#x2F;usr&#x2F;src 源代码，linux内核的源代码就放在&#x2F;usr&#x2F;src&#x2F;linux⾥里里&#x2F;usr&#x2F;local&#x2F;bin本地增加的命令&#x2F;usr&#x2F;local&#x2F;lib 本地增加的库\n\n\n&#x2F;opt\n额外安装的可选应⽤用程序包所放置的位置。⼀一般情况下，我们可以把tomcat等都安装到这⾥里里。\n\n\n&#x2F;proc\n虚拟⽂文件系统⽬目录，是系统内存的映射。可直接访问这个⽬目录来获取系统信息。\n\n\n&#x2F;root\n超级⽤用户（系统管理理员）的主⽬目录（特权阶级^o^）\n\n\n&#x2F;sbin\n存放⼆二进制可执⾏行行⽂文件，只有root才能访问。这⾥里里存放的是系统管理理员使⽤用的系统级别的管理理命令和程序。如ifconfig等。\n\n\n&#x2F;dev\n⽤用于存放设备⽂文件。\n\n\n&#x2F;mnt\n系统管理理员安装临时⽂文件系统的安装点，系统提供这个⽬目录是让⽤用户临时挂载其他的⽂文件系统。\n\n\n&#x2F;boot\n存放⽤用于系统引导时使⽤用的各种⽂文件\n\n\n&#x2F;lib\n存放跟⽂文件系统中的程序运⾏行行所需要的共享库及内核模块。共享库⼜又叫动态链接共享库，作⽤用类似windows⾥里里的.dll⽂文件，存放了了根⽂文件系统程序运⾏行行所需的共享⽂文件。\n\n\n&#x2F;tmp\n⽤用于存放各种临时⽂文件，是公⽤用的临时⽂文件存储点。\n\n\n&#x2F;var\n⽤用于存放运⾏行行时需要改变数据的⽂文件，也是某些⼤大⽂文件的溢出区，⽐比⽅方说各种服务的⽇日志⽂文件（系统启动⽇日志等。）等。\n\n\n&#x2F;lost+found\n这个⽬目录平时是空的，系统⾮非正常关机⽽而留留下“⽆无家可归”的⽂文件（windows下叫什什么.chk）就在这⾥里里\n\n\n\n\n\n序号\n命令\n对应英文\n作用\n\n\n\n01\nls\nlist\n查看当前文件夹下内容\n\n\n02\npwd\nprint work directory\n查看当前所在文件夹\n\n\nls命令linux 下文件和目录的特点\n\nLinux 文件或目录名称最长可以有256个字符\n以.开头的文件为隐藏文件\n.代表当前目录\n..代表上一级目录\n\nls 命令常用选项\n\n\n\n参数\n意义\n\n\n\n-a\n显示指定目录下所有子目录和文件，包括隐藏文件\n\n\n-l\n以列表方式显示文件详细信息\n\n\n-h\n配合-l命令更直观的方式显示文件大小\n\n\nls -lh\n\n\nls 通配符\n\n\n\n通配符\n含义\n\n\n\n*\n代表人一个数字符\n\n\n？\n代表任意一个字符，至少一个\n\n\n[]\n匹配其中的任意一个\n\n\nls [abc].txt\n\ncd\n\n\n命令\n含义\n\n\n\ncd\n切换到当前用户的主目录（&#x2F;home&#x2F;用户目录）\n\n\ncd ~\n切换到当前用户的主目录（&#x2F;home&#x2F;用户目录）\n\n\ncd .\n保持当前目录不变\n\n\ncd ..\n上级目录\n\n\ncd -\n可以在最近两次工作目录间切换\n\n\n相对路径和绝对路径\n\n相对路经：在输入路径时，最前面的不是&#x2F;或者～，表示相对当前目录所在位置的目录位置\n\n绝对路径：在输入路径时，最前面是&#x2F;或者～，表示从根目录&#x2F;家目录开始的目录位置\n\n\npwd其功能是显示当前所在工作目录的全路径。主要用在当不确定当前所在位置时，通过pwd来查看当前目录的绝对路径。\n-L --logical 显示当前的路径，有连接文件时，直接显示连接文件的路径，(不加参数时默认此方式).-p --physical，显示当前的路径，有连接文件时，不使用连接路径，直接显示连接文件所指向的文件，参考示例2。 当包含多层连接文件时，显示连接文件最终指向的文件.\n创建和删除创建文件touch创建文件或修改文件时间\n\n如果文件不存在，可以创建一个空白文件\n\n如果文件存在，可以修改文件的修改日期\n\n\n创建目录mkdir\n\n\n选项\n含义\n\n\n\n-p\n可以递归创建目录\n\n\nmkdir -p a/b/c\n\n\n新建目录名称不能与当前目录中已有的目录或文件重复\n\n删除命令rm删除文件或目录，不能恢复\n\n\n\n选项\n含义\n\n\n\n-f\n强制删除，忽略不存在的文件，无需提示\n\n\n-r\n递归删除目录下面的内容，删除文件必须添加此参数\n\n\nrm -rf workspace\n\n\n修改文件权限\n\n\n序号\n命令\n作用\n\n\n\n01\nchown\n修改拥有者\n\n\n02\nchgrp\n修改组\n\n\n03\nchmod\n修改权限\n\n\n\n修改文件|目录的拥有者\nchown 用户名 文件名|目录名\n\n递归修改文件|目录的组\nchown 用户名 文件名|目录名\n\n常见数字组合有（u表示用户／g表示组／o表示其他）：\n\n777 &#x3D;&#x3D;&#x3D;&gt; u&#x3D;rwx,g&#x3D;rwx,o&#x3D;rwx\n755 &#x3D;&#x3D;&#x3D;&gt; u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx\n644 &#x3D;&#x3D;&#x3D;&gt; u&#x3D;rw,g&#x3D;r,o&#x3D;r\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"linux 架构","url":"/posts/2c907a6074a4/","content":"\n\n内核5大核心功能\n\n操作系统用于管理计算机资源，cpu资源，外围设备，内存\n\n\n\n\n程序在调用文件的读写时，需要调用内核的功能，也叫做内核模式\n\n用户在写自己的逻辑的时候，就是用户模式\n\n\n\n\nProcess mannagement (进程管理) linux多任务系统，进程管理用于调度cpu\n\nMemory management 用于内存分配\n\nFile systems 读写文件，终端输入输出，保存文件，linux树状结构也是有文件系统维护\n\nDevice drivers 如何与硬件对接\n\nNetwork 对上提供socket, ssh http 都是应用层协议\n\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"重定向和管道","url":"/posts/a8099615d4f2/","content":"echo (有重复的意思)echo 会在终端中显示参数指定的文字,通常会和 重定向 联合使用\n重定向 &gt; 和 &gt;&gt;\nLinux 允许将命令执行结果 重定向 到一个 文件\n\n将本应显示在终端上的内容 输出&#x2F;追加 到指定文件中\n\n\n其中\n\n&gt; 表示输出,会覆盖文件原有的内容\n\n&gt;&gt; 表示追加,会将内容追加到已有文件的末尾\n\n\n\n注意: 通过touch创建的文件只能是空文件,但是配合echo使用,可以在创建文件的时候添加内容\n管道 |\nLinux 允许将 一个命令的输出 可以通过管道 做为 另一个命令的输入\n\n可以理解现实生活中的管子,管子的一头塞东西进去,另一头取出来,这里 | 的左右分为两端,左端塞东西(写),右端取东西(读)常用的管道命令有:\n\nmore :分屏显示内容\n\ngrep :在命令执行结果的基础上查询指定的文本\n\n\n\n\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"硬件","url":"/posts/cb964b1de0de/","content":"","categories":["Linux","运维"],"tags":["Linux"]},{"title":"用户权限和组管理","url":"/posts/46724e800c60/","content":"基本概念\n用户 是 Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理\n\n在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限\n\n在 Linux 中，可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限对 文件／目录 的权限包括：\n\n\n\n\n\n序号\n权限\n英文\n缩写\n数字代号\n\n\n\n01\n读\nread\nr\n4\n\n\n02\n写\nwrite\nw\n2\n\n\n03\n执行\nexcute\nx\n1\n\n\n组\n为了方便用户管理，提出了 组 的概念，如下图所示\n\n在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限\n\n\nls -l 扩展\nls -l 可以查看文件夹下文件的详细信息，从左到右依次是：\n\n权限，第 1 个字符如果是 d 表示目录\n\n硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件\n文件硬链接数为1，只能通过一种绝对路径访问\n文件夹的硬连接数取决于子文件夹的数量，可以在当前文件夹通过 .方法，也可以在子文件夹通过 .. 访问\n\n拥有者，家目录下 文件／目录 的拥有者通常都是当前用户\n\n组，在 Linux 中，很多时候，会出现组名和用户名相同的情况\n\n大小\n\n创建&#x2F;修改时间\n\n名称\n\n\n\n\n\nchmodchmod 可以修改 用户／组 对 文件／目录 的权限\nchmod +/-rwx 文件名|目录名\n\n\n以上方式会一次性修改 拥有者 &#x2F; 组 权限\n\n读权限控制目录是否可以被访问\n取消文件的可读可写权限\nchmod -rw xxx.md\n增加文件的可读权限\nchmod +r xxx.md\n\n在添加文件的可执行权限后,文件名变为绿色\nchmod +x test.js\n\n\n对目录的权限操作\n\n可读权限控制目录是否可以被访问\n\n\n\n可读权限控制目录中是否可以创建文件\n\n\n\n可读可写都需要可执行权限,且如果没有可执行权限目录不能被访问\n\n\n超级用户\nLinux 系统中的 root 账号通常 用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限\n\n在大多数版本的 Linux 中，都不推荐 直接使用 root 账号登录系统\n\n在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”\n\n\nsudo\n\nsu 是 substitute user 的缩写，表示 使用另一个用户的身份\n\nsudo 命令用来以其他身份来执行命令，预设的身份为 root\n\n用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码\n\n\n\n若其未经授权的用户企图使用 sudo，则会发出警告邮件给管理员\n\n组管理\n创建组 &#x2F; 删除组 的终端命令都需要通过 sudo 执行\n\n\n\n\n序号\n命令\n作用\n\n\n\n01\ngroupadd 组名\n添加组\n\n\n02\ngroupdel 组名\n删除组\n\n\n03\ncat &#x2F;etc&#x2F;group\n确认组信息\n\n\n04\nchgrp -R 组名 文件&#x2F;目录名\n递归修改文件&#x2F;目录的所属组\n\n\n\n 组信息保存在 &#x2F;etc&#x2F;group 文件中\n\n   &#x2F;etc 目录是专门用来保存 系统配置信息 的目录\n在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限\n\n新建文件夹dev\n\nmkdir zhen\n\n\n新建组zhengrp\n\nsudo groupadd zhengrp\n\n\n把zhen目录的组修改为zhengrp\n\nsudo chgrp -R zhengrp zhen\n\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"其他命令","url":"/posts/84aaaa1df65b/","content":"查找文件find 命令功能非常强大,通常用来在 特定的目录下 搜索 符合条件的文件\n\n\n\n序号\n命令\n作用\n\n\n\n01\nfind [ 路径 ] -name “*.py”\n查找指定路径下扩展名是 .py 的文件,包括子目录\n\n\n如果省略路径,表示在当前文件夹下查找\n之前学习的通配符,在使用 find 命令时同时可用\n软链接\n\n\n序号\n命令\n作用\n\n\n\n01\nln -s 被链接的源文件 链接文件(名称)\n建立文件的软链接,用通俗的方式讲类似于 Windows 下的快捷方式\n\n\n注意:\n\n没有 -s 选项建立的是一个 硬链接文件\n两个文件占用相同大小的硬盘空间,工作中几乎不会建立文件的硬链接\n源文件要使用绝对路径 ,不能使用相对路径,这样可以方便移动链接文件后,仍然能够正常使用\n\n\n打包&#x2F;解压tar 是 Linux 中最常用的 备份 工具,此命令可以 把一系列文件 打包到 一个大文件中 ,也可以把一个 打包的大文件恢复成一系列文件\n\n\n\n选项\n含义\n\n\n\nc\n生成档案文件,创建打包文件\n\n\nx\n解开档案文件\n\n\nv\n列出归档解档的详细过程,显示进度\n\n\nf\n指定档案文件名称, f 后面一定是 .tar 文件,所以必须放选项最后\n\n\n\n注意:f 选项必须放在最后,其他选项顺序可以随意\n\n打包\ntar -cvf 打包名称.tar 被打包的文件/路径 ...\n\n解包\ntar -xvf 打包文件.tar\n\n解包到指定路径\ntar -xvf [文件名].tar -C  /path\n\n压缩\ntar 与 gzip 命令结合可以使用实现文件 打包和压缩\n\ntar 只负责打包文件,但不压缩\n\n用 gzip 压缩 tar 打包后的文件,其扩展名一般用 xxx.tar.gz\n\n\n\n在 Linux 中,最常见的压缩文件格式就是 xxx.tar.gz\n\n\n在 tar 命令中有一个选项 -z 可以调用 gzip ,从而可以方便的实现压缩和解压缩的功能\n\n压缩文件\ntar -zcvf 打包文件.tar.gz 被压缩的文件/路径 ...\n\n解压文件\ntar -zxvf 打包文件.tar.gz\n\n解压缩到指定路径\ntar -zxvf 打包文件.tar.gz -C 目标路径 \n\n\n\n\n选项\n含义\n\n\n\n-C\n解压缩到指定目录,注意:要解压缩的目录必须存在\n\n\nbzip2(two)\n\ntar 与 bzip2 命令结合可以使用实现文件 打包和压缩 (用法和 gzip 一样)\n\ntar 只负责打包文件,但不压缩,\n\n用 bzip2 压缩 tar 打包后的文件,其扩展名一般用 xxx.tar.bz2\n\n在 tar 命令中有一个选项 -j 可以调用 bzip2 ,从而可以方便的实现压缩和解压缩的功能\n\n\n压缩\ntar -jcvf 打包文件.tar.bz2 被压缩的文件/路径 ...\n\n解压\ntar -jxvf 打包文件.tar.bz2\n\n软件安装\napt 是 Advanced Packaging Tool ,是 Linux 下的一款安装包管理工具\n\n可以在终端中方便的 安装 &#x2F;卸载 &#x2F; 更新软件包\n\n\n安装软件\nsudo apt install 软件包\n\n卸载软件\nsudo apt remove 软件名\n\n升级软件\nsudo apt upgrade\n\n如果希望在 ubuntu 中安装软件,更加快速 ,可以通过设置镜像源 ,选择一个访问网速更快的服务器,来提供软件下载&#x2F;安装服务提示:更换服务器之后,需要一个相对比较长时间的更新过程,需要耐心等待。更新完成后,再安装软件都会从新设置的服务器下载软件了\n\n下载\nwget 下载地址","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"远程管理命令","url":"/posts/a850340a54d8/","content":"关机 &#x2F; 重启\n\n\n序号\n命令\n对应英文\n作用\n\n\n\n01\nshutdown 选项 时间\nshutdown\n关机&#x2F;重新启动\n\n\nshutdown 命令可以 安全 关闭 或者 重新启动系统\n\n\n\n选项\n含义\n\n\n\n-r\n重新启动\n\n\n\n提示:不指定选项和参数 ,默认表示 1 分钟 之后 关闭电脑远程维护服务器时,最好不要关闭系统,而应该重新启动系统\n\n\n重新启动操作系统,其中 now 表示现在\n\n$ shutdown -r now\n\n\n立刻关机,其中 now 表示现在\n\n$ shutdown now\n\n\n系统在今天的 20:25 会关机\n\n$ shutdown 20:25\n\n\n系统再过十分钟后自动关机\n\n$ shutdown +10\n\n\n取消之前指定的关机计划\n\n$ shutdown -c\n\n查看或配置网卡信息\n\n\n序号\n命令\n对应英文\n作用\n\n\n\n01\nifconfig\nconfigure a network interface\n查看 &#x2F; 配置计算机当前的网卡配置信息\n\n\n02\nping ip 地址\nping\n检测到目标 ip 地址 的连接是否正常\n\n\n网卡\n\n网卡是一个专门负责网络通讯的硬件设备\nIP 地址 是设置在网卡上的地址信息\n\n\n们可以把 电脑 比作 电话 , 网卡 相当于 SIM 卡 , IP 地址 相当于 电话号码\n\nIP 地址\n\n每台联网的电脑上 都有 IP 地址 , 是保证电脑之间正常通讯的重要设置\n\n\n注意:每台电脑的 IP 地址不能相同,否则会出现 IP 地址冲突,并且没有办法正常通讯提示:有关 IP 地址 的详细内容,在就业班会详细讲解!\n\nifconfigifconfig 可以查看&#x2F;配置计算机当前的网卡配置信息\n需要现安装net-tools软件\n\n查看网卡配置信息\n\n$ ifconfig\n\n\n查看网卡对应的 IP 地址\n\n$ ifconfig | grep inet\n\n提示:一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡 ,在 Linux 中物理网卡的名字通常以 ensXX 表示\n\n  127.0.0.1 被称为 本地回环 &#x2F; 环回地址 ,一般用来测试本机网卡是否正常\nping检测到目标主机是否连接正常\n$ ping IP 地址\n\n检测本地网卡工作正常\n$ ping 127.0.0.1\n\n\nping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅 ,数值越大,速度越慢\n\n\n\nping 的工作原理与潜水艇的声纳相似,ping 这个命令就是取自 声纳的声音  网络管理员之间也常将 ping 用作动词 —— ping 一下计算机 X ,看他是否开着\n\n原理:网络上的机器都有 唯一确定的 IP 地址 ,我们给目标 IP 地址 发送一个数据包,对方就要返回一个数据包,根据返回的数据包以及时间,我们可以确定目标主机的存在\n\n提示:在 Linux 中,想要终止一个终端程序的执行,绝大多数都可以使用 CTRL + C\n\n远程登录和复制文件\n\n\n序号\n命令\n对应英文\n作用\n\n\n\n01\nssh 用户名@ip\nsecure shell\n关机／重新启动\n\n\n02\nscp 用户名@ip:文件名或路径 用户名@ip:文件名或路径\nsecure copy\n远程复制文件\n\n\nssh 基础在 Linux 中 SSH 是 非常常用 的工具，通过 SSH 客户端 我们可以连接到运行了 SSH 服务器 的远程机器上\n\n\nSSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序\n\nSSH 是目前较可靠，专为远程登录会话和其他网络服务 提供安全性的协议\n\n利用 SSH 协议 可以有效防止远程管理过程中的信息泄露\n\n通过 SSH 协议 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗\n\n\n\nSSH 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度\n\n\n域名 和 端口号域名\n\n由一串 用点分隔 的名字组成，例如：www.iftrue.club\n是 IP 地址 的别名，方便用户记忆\n\n端口号\n\nIP 地址：通过 IP 地址 找到网络上的 计算机\n\n端口号：通过 端口号 可以找到 计算机上运行的应用程序\n\nSSH 服务器 的默认端口号是 22，如果是默认端口号，在连接的时候，可以省略常\n\n\n常见服务端口号列表：\n\n\n\n\n\n序号\n服务\n端口号\n\n\n\n01\nSSH 服务器\n22\n\n\n02\nWeb 服务器\n80\n\n\n03\nHTTPS\n443\n\n\n04\nFTP 服务器\n21\n\n\nSSH 客户端的简单使用如果没有安装先通过sudo apt install openssh-server安装ssh\nssh [-p port] user@remote\n\n\nuser 是在远程机器上的用户名，如果不指定的话默认为当前用户\nremote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名\nport 是 SSH Server 监听的端口，如果不指定，就为默认值 22\n\n\n\n使用 exit 退出当前用户的登录\n\n\n\nssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用,如果在 Windows 系统中，可以安装 PuTTY 或XShell 客户端软件即可\n\n在工作中，SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器\n\n\nscp\nscp 就是 secure copy，是一个在 Linux 下用来进行 远程拷贝文件 的命令\n它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的\n\n常见操作\n\n把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop&#x2F;01.py注意：: 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径\n\nscp -P port 01.py user@remote:Desktop/01.py\n\n\n加上 -r 选项可以传送文件夹,把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop\n\nscp -r demo user@remote:Desktop\n\n\n把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹\n\nscp -r user@remote:Desktop demo\n\n\n复制windows下面的文件到远程服务器\n\n\n\n\n\n选项\n含义\n\n\n\n-r\n若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名\n\n\n-P\n若远程 SSH服务器的端口不是 22，需要使用大写字母 -P 选项指定端口\n\n\n\n注意：  scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用  如果在 Windows 系统中，可以安装 PuTTY，使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输\n\n免密码登录\n提示：有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下\n\n\n配置公钥\n执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可\n\n上传公钥到服务器\n执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥\n\n\n\n\n非对称加密算法\n\n  使用 公钥 加密的数据，需要使用 私钥 解密\n  使用 私钥 加密的数据，需要使用 公钥 解密\n配置别名每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user , remote 和 port 都得输入\n在 ~&#x2F;.ssh&#x2F;config 里面追加以下内容：\nHost 别名  HostName ip地址  User 用户名  Port 22\n保存之后，即可用 ssh mac 实现远程登录了， scp 同样可以使用\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"系统信息","url":"/posts/91a157ca52b3/","content":"时间和日期\n\n\n序号\n命令\n作用\n\n\n\n01\ndate\n查看系统时间\n\n\n02\ncal\ncalendar 查看日历，-y 选项可以查看一年的日历\n\n\n磁盘信息\n\n\n序号\n命令\n作用\n\n\n\n01\ndf -h\ndisk free 显示磁盘剩余空间\n\n\n02\ndu -h [目录名]\ndisk usage 显示目录下的文件大小\n\n\n\n-h 以人性化的方式显示文件大小\n\n进程信息\n所谓 进程，通俗地说就是 当前正在执行的一个程序\n\n\n\n\n序号\n命令\n作用\n\n\n\n01\nps aux\nprocess status 查看进程的详细状况\n\n\n02\ntop\n动态显示运行中的进程并且排序\n\n\n03\nkill [-9] 进程代号\n终止指定代号的进程，-9 表示强行终止\n\n\n\nps 默认只会显示当前用户通过终端启动的应用程序\n\nps 选项说明\n\n\n\n选项\n含义\n\n\n\na\n显示终端上的所有进程，包括其他用户的进程\n\n\nu\n显示进程的详细状态\n\n\nx\n显示没有控制终端的进程\n\n\n\n提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃  要退出 top 可以直接输入 q\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"终端控制","url":"/posts/d0ba48ae2430/","content":"终端窗口字体大小ctrl + shift + = 放大终端窗口字体\nctrl + - 缩小终端窗口字体\n命令格式parameter 参数options 选项[] 表示可选\ncommand [-options] [parameter]\n\n查阅命令帮助信息\n显示command 命令的帮助信息\n\ncommand --help\n\n\n查询command命令的使用手册 man是manual手册的意思，包含命令的详细信息\n\nman command\n\n显示内容较多时可以使用操作键\n\n\n\n操作键\n功能\n\n\n\n空格键\n显示手册下一屏\n\n\nEnter键\n一次滚动手册的一行\n\n\nb键\n回滚一屏\n\n\nf键\n前滚一屏\n\n\nq键\n退出\n\n\n自动补全打出文件&#x2F;目录&#x2F;命令之后，按下tab键\n\n如果没有歧义（包含输入字母有唯一的对应），系统会自动补全\n\n如果有多个包含当前输入字母的 文件&#x2F;目录&#x2F;命令，再次按下tab键会自动提示\n\n\n曾经使用过的命令按 上&#x2F;下 光标键可以在曾经使用过的命令之间切换\n如果想退出按ctrl+c\n快捷方式\n\n\n按键\n作用\n\n\n\nctrl+c\n结束正在运行的程序 ping,telent 等\n\n\nctrl+d\n结束输入或退出shell\n\n\nctrl+s\n暂停屏幕输出\n\n\nctrl+q\n恢复屏幕输出\n\n\nctrl+l\n清屏 等同于 clear\n\n\nctrl+a&#x2F;ctrl+e\n快速移动光标到行首&#x2F;行尾\n\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"ubuntu取消代理","url":"/posts/a7fed883bbc5/","content":"如果设置过代理可能导致pip3下载不可用，yarn安装错误\n\n查看当前使用代理，如果有，需要去掉。\n\nenv | grep -i proxy\n\n\n去掉相关代理\n\ngedit /etc/enviroment \n\n\n还有~&#x2F;.bashrc &#x2F;etc&#x2F;profile中的代理，然后source两个文件。\n\nsource .bashrcsource /etc/profile\n\n\n如果还存在代理，运行：\n\nunset http_proxyunset https_proxyexport -n http_proxyexport -n https_proxyexport -n no_proxy","categories":["Linux","常见问题"],"tags":["Linux"]},{"title":"用户管理","url":"/posts/5ef896dee89e/","content":"创建用户／设置密码／删除用户\n提示：创建用户 &#x2F; 删除用户 &#x2F; 修改其他用户密码 的终端命令都需要通过 sudo 执行\n\n\n\n\n序号\n命令\n作用\n说明\n\n\n\n01\nuseradd -m -g 组 新建用户名\n添加新用户\n-m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组\n\n\n02\npasswd 用户名\n设置用户密码\n使用sudo运行，如果是普通用户，直接用 passwd 可以修改自己的账户密码\n\n\n03\nuserdel -r 用户名\n删除用户\n-r 选项会自动删除用户家目录\n\n\n04\ncat &#x2F;etc&#x2F;passwd | grep 用户名\n确认用户信息\n新建用户后，用户信息会保存在 &#x2F;etc&#x2F;passwd 文件中\n\n\n\n提示：\n\n\n创建用户时，如果忘记添加 -m 选项指定新用户的家目录,最简单的方法就是删除用户。\n\n重新创建创建用户时,默认会创建一个和用户名同名的组名,用户信息保存在 &#x2F;etc&#x2F;passwd 文件中\n\n\n查看用户信息\n\n\n序号\n命令\n作用\n\n\n\n01\nid [用户名]\n查看用户 UID 和 GID 信息,没写用户名默认是当前用户信息\n\n\n02\nwho\n查看当前所有登录的用户列表\n\n\n03\nwhoami\n查看当前登录用户的账户名\n\n\n\npasswd 文件\n\n&#x2F;etc&#x2F;passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是\n\n\n用户名\n密码（x，表示加密的密码）\nUID（用户标识）\nGID（组标识）\n用户全名或本地帐号\n家目录\n登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash\n\n\nusermod\n\nusermod 可以用来设置 用户 的 主组 ／ 附加组 和 登录 Shell\n\n主组：通常在新建用户时指定，在 etc&#x2F;passwd 的第 4 列 GID 对应的组\n\n附加组：在 etc&#x2F;group 中最后一列表示该组的用户列表，用于指定 用户的附加权限\n\n\n\n提示：设置了用户的附加组之后，需要重新登录才能生效！\n\n修改用户的主组（passwd 中的 GID）\nusermod -g 组 用户名\n\n修改用户的附加组\nusermod -G 组 用户名\n\n修改用户登录 Shell\n由于新建用户默认使用的shell是dash,会导致windows下终端中没有文件高亮，不能使用方向键，所以要修改新建用户的默认shell\n\n提示：设置了用户登录 Shell之后，需要重新登录才能生效！\n\n\nusermod -s /bin/bash 用户名\n\nwhich\n\n&#x2F;etc&#x2F;passwd 是用于保存用户信息的文件\n\n  &#x2F;usr&#x2F;bin&#x2F;passwd 是用于修改用户密码的程序\nwhich 命令可以查看执行命令所在位置，例如:\nwhich ls\n\nwhich useradd///usr/sbin/useradd\n\nbin 和 sbin\n\n在 Linux 中，绝大多数可执行文件都是保存在 &#x2F;bin、&#x2F;sbin、&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;sbin\n\n&#x2F;bin（binary）是二进制执行文件目录，主要用于具体应用\n\n&#x2F;sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理\n\n&#x2F;usr&#x2F;bin（user commands for applications）后期安装的一些软件\n\n&#x2F;usr&#x2F;sbin（super user commands for applications）超级用户的一些管理程序\n\n\n\ncd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd 命令的位置\n\n切换用户\n\n\n序号\n命令\n作用\n说明\n\n\n\n01\nsu - 用户名\n切换用户，并且切换目录\n- 可以切换到用户家目录，否则保持位置不变\n\n\n02\nexit\n退出当前登录账户\n\n\n\n\nsu 不接用户名，可以切换到 root，但是不推荐使用，因为不安全\n\nexit 示意图如下：\n\n\n\n","categories":["Linux","基础命令"],"tags":["Linux"]},{"title":"网络配置问题","url":"/posts/5598ffff28da/","content":"可以使用type +命令来查看命令所在目录\n查看网络配置基本信息centenOS 6 之前使用 ifconfg 命令, 之后使用ip 命令， 也可以安装 ifconfig命令包\n重启网卡如果可以直接操作服务其 可以使用 ifup ,ifdown\n如果提示系统没有命令可以使用 apt install ifupdown安装\n如果是远程不能使用这个两个命令重启网卡，使用ifdown后会断开网络连接\n可以在确保网络配置修改成功之后，使用 systemctl restar network\n如果命令不可用可以使用 service network-manager restart\n如果是 Kali Linux（Debian），则需要service networking restart\n如果是Centos 8 需要nmcli c reload\n查找占用端口可以使用 ss 或 netstat 命令 后面加  -anp \n如果没有 netstat 命令，可以通过 apt install net-tools 安装\n最后使用 kill 命令杀掉端口\n","categories":["Linux","常见问题"],"tags":["Linux"]},{"title":"进程，线程，协程","url":"/posts/e94f15211058/","content":"程序执行\n\n写在硬盘上的静态程序文件 \ncpu从磁盘上找到程序文件\n.exe 文件中包含操作cpu的指令\n把指令放到内存中\n在内存中的指令就可以叫做cpu的进程\n\n进程对于cpu来讲，有一个时间线的概念，时间线上的每一个点对应着一个操作指令\n操作系统把时间线分割为不同的时间片，时间片是执行程序的小单位\n按照 1，2，1，2的顺序，来回切换任务的分配，可以让cpu调度进程，看起来在同时执行多个操作\n进程比较重，每个任务分配一个进程，频繁切换的时候损耗比较大，所以有了线程的概念\n进程之间内存相互独立，进程之间相互通信需要内核转发（系统调用）。也就是进程之间的通信需要经过操作系统，损耗比较大\n进程主要占据的内存代码（进程的实现代码），数据（需要处理的数据），文件（和硬盘文件关联的文件句柄，需要通过系统内核，来完成文件的操作）\n执行的时候需要写寄存器，在进程切换的时候需要保存寄存器中信息的状态，把寄存器中的数据写到内存中。\n栈 函数调用栈\n线程线程比较轻，线程依附与进程，是多个线程对应一个进程的关系，\n线程共享进程的内存（代码，数据，文件），但是有自己独立的寄存器和栈，所以线程比较轻\n线程共享数据存在的问题，可能读写同时操作，需要线程锁\nIO 密集型输入输出的速度远小于CPU的速度。 \n多任务 -&gt; 多线程 -&gt; 时间驱动 -&gt; 协程\nCPU密集型多进程 -&gt; 多线程\n","categories":["Linux","常见问题"],"tags":["Linux"]},{"title":"动静分离","url":"/posts/a827136236e3/","content":"静态资源部署在nginx服务器nginx来当做静态资源服务器\n来自80端口的请求会去nginx服务器根路径下的data文件夹查找\nhttp://xxx.xxx.xxx.xx/static/a/logo.png 会请求根路径下 /data/static/a/logo.png\nhttp &#123;    include       mime.types;    default_type  application/octet-stream;    server &#123;        listen       80;        server_name  xxx.xxx.xxx.xxx;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location /static/ &#123;            root /data/;        &#125;    &#125;&#125;\n\n转发到静态资源服务器转发时使用负载均衡配置\nhttp &#123;    include       mime.types;    default_type  application/octet-stream;    upstream  stack_pools &#123;            server 172.25.254.134:80 weight=5;    &#125;    upstream  dynamic_pools &#123;            server 172.25.254.135:80 weight=5;    &#125;    server &#123;        listen       80;        server_name  xxx.xxx.xxx.xx;        location / &#123;            root   html;            index  index.html index.htm;            proxy_pass http://dynamic_pools;        &#125;        location /image/ &#123;            proxy_pass http://stack_pools;        &#125;        location /dynamic/ &#123;            roxy_pass http://dynamic_pools;        &#125;    &#125;&#125;","categories":["Nginx"],"tags":["Nginx"]},{"title":"原理","url":"/posts/7b927bac4e00/","content":"Nginx进程模型Nginx默认采用多进程工作方式，Nginx启动后，会运行一个master进程和多个worker进程。其中master充当整个进程组与用户的交互接口，同时对进程进行监护，管理worker进程来实现重启服务、平滑升级、更换日志文件、配置文件实时生效等功能。worker用来处理基本的网络事件，worker之间是平等的，他们共同竞争来处理来自客户端的请求。\n\n在创建master进程时，先建立需要监听的socket（listenfd），然后从master进程中fork()出多个worker进程，如此一来每个worker进程多可以监听用户请求的socket。一般来说，当一个连接进来后，所有在Worker都会收到通知，但是只有一个进程可以接受这个连接请求，其它的都失败，这是所谓的惊群现象。nginx提供了一个accept_mutex（互斥锁），有了这把锁之后，同一时刻，就只会有一个进程在accpet连接，这样就不会有惊群问题了。\n先打开accept_mutex选项，只有获得了accept_mutex的进程才会去添加accept事件。nginx使用一个叫ngx_accept_disabled的变量来控制是否去竞争accept_mutex锁。ngx_accept_disabled &#x3D; nginx单进程的所有连接总数 &#x2F; 8 -空闲连接数量，当ngx_accept_disabled大于0时，不会去尝试获取accept_mutex锁，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，每个worker进程的连接数就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡。\n每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。并且，nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes&#x2F;2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。\nNginx处理HTTP请求流程http请求是典型的请求-响应类型的的网络协议。http是文件协议，所以我们在分析请求行与请求头，以及输出响应行与响应头，往往是一行一行的进行处理。通常在一个连接建立好后，读取一行数据，分析出请求行中包含的method、uri、http_version信息。然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。在将响应发送给客户端之后，一个完整的请求就处理完了。\n\n","categories":["Nginx"],"tags":["Nginx"]},{"title":"反向代理","url":"/posts/b3dc92f3441f/","content":"\nproxy_pass 包含 URI 路径（如 &#x2F;api）：\n无论末尾是否有斜杠，均删除 location 匹配部分，拼接剩余路径。\n例：location &#x2F;webapp + proxy_pass http://xxx/api → &#x2F;api&#x2F;剩余路径。\n\nproxy_pass 不包含 URI 路径（如 http://xxx）：\n末尾无斜杠 → 直接拼接完整请求 URI（http://xxx/完整路径）。\n末尾有斜杠 → 替换 location 匹配部分，拼接剩余路径（http://xxx/剩余路径）。\n\n\n简单反向代理把本机 80 端口的请求转发到其他的服务器\nhttp &#123;    include       mime.types;    default_type  application/octet-stream;    server &#123;        listen       80;        server_name  xxx.xxx.xxx.xxx;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / &#123;            root   xxx.xxx.xxx.xxx:port;            index  index.html index.htm;        &#125;    &#125;&#125;\n\n通过正则匹配路径转发根据路径中不同字段转，把 80 端口的请求，转发到不同的服务器\nhttp &#123;    include       mime.types;    default_type  application/octet-stream;    server &#123;        listen       80;        server_name  xxx.xxx.xxx.xxx;        location ~ /api/ &#123;            proxy_pass   xxx.xxx.xxx.xxx:port;        &#125;        location ~ /server/ &#123;            proxy_pass   xxx.xxx.xxx.xxx:port;        &#125;    &#125;&#125;\n","categories":["Nginx"],"tags":["Nginx"]},{"title":"基本概念","url":"/posts/5f1ed9c82da0/","content":"Nginx是什么Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器。最高支持50000的并发链接。\n正向代理\n正向代理的用途：\n（1）访问原来无法访问的资源，如google\n（2）可以做缓存，加速访问资源\n（3）对客户端访问授权，上网进行认证\n（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息\n反向代理反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器\n\n反向代理的作用：\n（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网\n（2）负载均衡，通过反向代理服务器来优化网站的负载\n负载均衡增加服务器的数量，在大量请求的时候，把请求平均分发到不同的服务器\n动静分离在请求资源的时候，区分静态资源（js,html.css）和动态资源(serverlet,jsp)，把不同资源的请求转发到不同的服务器\n","categories":["Nginx"],"tags":["Nginx"]},{"title":"nginx安装","url":"/posts/93833a74178a/","content":"命令安装ubuntu\nsudo apt updatesudo apt install nginx\n\n安装成功后会默认启动在80端口，直接访问会显示nginx主页\n查看可执行文件which nginx\n\n查看安装位置whereis nginx\n\n修改防火墙规则UFW 全称为Uncomplicated Firewall，是Ubuntu 系统上默认的防火墙组件, 为了轻量化配置iptables 而开发的一款工具。\n启用防火墙\nsudo ufw enable\n\n允许80端口访问\nsudo ufw allow 80\n\n","categories":["Nginx"],"tags":["Nginx"]},{"title":"常用命令","url":"/posts/5e364d61a375/","content":"使用nginx命令需要进入到nginx可执行文件目录 /usr/sbin/\nnginx document\n查看版本nginx -v\n\n启动nginx./nginx\n\n快速关闭nginx -s stop\n\n安全关闭nginx -s quit\n\n重新加载配置文件nginx -s reload","categories":["Nginx"],"tags":["Nginx"]},{"title":"负载均衡","url":"/posts/830ecdc6d0af/","content":"配置http &#123;  upstream myServer&#123;      ip_hash;      server localhost:1111 weight=10;      server localhost:2222;      fair;  &#125;  listen       port;  server_name  xxx.xxx.xxx.xx;  #charset koi8-r;  #access_log  logs/host.access.log  main;  location / &#123;      proxy_pass http://myServer;   &#125;&#125;\n\n\n轮询策略每个请求按时间的顺序逐一分配到不同德尔服务器中，如果服务器挂了，可以自动剔除。\n权重策略权重越高，被分配的请求越多\nip hash每个请求按访问ip的hash结果分配，这样每个访客固定访问一个服务器后，可以解决session问题。\nfair 第三方根据请求的响应时间来分配，响应时间短的先分配\n","categories":["Nginx"],"tags":["Nginx"]},{"title":"配置文件","url":"/posts/20d037d3afeb/","content":"位置/etc/nginx/nginx.conf\n\n配置结构\n...              #全局块events &#123;         #events块   ...&#125;http      #http块&#123;    ...   #http全局块    server        #server块    &#123;         ...       #server全局块        location [PATTERN]   #location块        &#123;            ...        &#125;        location [PATTERN]         &#123;            ...        &#125;    &#125;    server    &#123;      ...    &#125;    ...     #http全局块&#125;\n\n全局块# 值越大，可支持的并发数量越多worker_processes 1 \n\nevents块主要涉及Nginx服务器和用户的网络连接\nhttp块最常用的配置，代理，缓存，日志定义等绝大多数功能和第三方模块的配置都在这里\nhttp全局块http全局配置包括文件引入，MIME-TYPE定义，日志自定义，链接超时时间，单链接请求上限等\nserver块这块和虚拟主机有密切的关系，虚拟主机从用户的角度看，一台独立的硬件主机是完全一样的，该技术的产生是为了节约互联网服务器硬件成本\n每个http块又可以包括多个server块，每个server块就相当于一个虚拟主机\n每个server块也分为全局server块，以及可以同时包含多个location块\nserver &#123;  # 监听80端口  listen 80;   # 主机名称  server_name localhost;&#125;\n\n全局server块最常见的配置是本虚拟主机的监听配置和本虚拟主机的名称或IP配置。\nlocation块主要作用是基于Nginx服务器接受到的请求字符串（例如，server_name&#x2F;uri-string）,对虚拟主机名称（也可以是ip别名）之外的字符串（例如 前面的uri-string）进行匹配，对待定的请求进行处理，地址定向，数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行\n详细配置########### 每个指令必须有分号结束。##################user administrator administrators;  #配置用户或者组，默认为nobody nobody。#worker_processes 2;  #允许生成的进程数，默认为1#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emergevents &#123;    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport    worker_connections  1024;    #最大连接数，默认为512&#125;http &#123;    include       mime.types;   #文件扩展名与文件类型映射表    default_type  application/octet-stream; #默认文件类型，默认为text/plain    #access_log off; #取消服务日志        log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;; #自定义格式    access_log log/access.log myFormat;  #combined为日志格式的默认值    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。    upstream mysvr &#123;         server 127.0.0.1:7878;      server 192.168.10.121:3333 backup;  #热备    &#125;    error_page 404 https://www.baidu.com; #错误页    server &#123;        keepalive_requests 120; #单连接请求上限次数。        listen       4545;   #监听端口        server_name  127.0.0.1;   #监听地址               location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。           #root path;  #根目录           #index vv.txt;  #设置默认页           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表           deny 127.0.0.1;  #拒绝的ip           allow 172.18.5.54; #允许的ip                   &#125;     &#125;&#125;\n\nlocation匹配优先级匹配优先级从上之下\nlocation = / &#123;#规则A&#125;location = /login &#123;#规则B&#125;location ^~ /static/ &#123;#规则C&#125;location ~ .(gif|jpg|png|js|css)$ &#123;#规则D&#125;location ~* .png$ &#123;#规则E&#125;location / &#123;#规则F&#125;","categories":["Nginx"],"tags":["Nginx"]},{"title":"高可用","url":"/posts/b4afbac0f6af/","content":"什么是高可用高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。如果一个系统能够一直提供服务，那么这个可用性则是百分之百，但是天有不测风云。所以我们只能尽可能的去减少服务的故障。\n解决的问题在生产环境上很多时候是以Nginx做反向代理对外提供服务，但是一天Nginx难免遇见故障，如：服务器宕机。当Nginx宕机那么所有对外提供的接口都将导致无法访问。\n虽然我们无法保证服务器百分之百可用，但是也得想办法避免这种悲剧，今天我们使用keepalived来实现Nginx的高可用。\n双机热备方案这种方案是国内企业中最为普遍的一种高可用方案，双机热备其实就是指一台服务器在提供服务，另一台为某服务的备用状态，当一台服务器不可用另外一台就会顶替上去。\nkeepalived是什么？Keepalived软件起初是专为LVS负载均衡软件设计的，用来管理并监控LVS集群系统中各个服务节点的状态，后来又加入了可以实现高可用的VRRP (Virtual Router Redundancy Protocol ,虚拟路由器冗余协议）功能。因此，Keepalived除了能够管理LVS软件外，还可以作为其他服务（例如：Nginx、Haproxy、MySQL等）的高可用解决方案软件\n故障转移机制Keepalived高可用服务之间的故障切换转移，是通过VRRP 来实现的。在 Keepalived服务正常工作时，主 Master节点会不断地向备节点发送（多播的方式）心跳消息，用以告诉备Backup节点自己还活着，当主 Master节点发生故障时，就无法发送心跳消息，备节点也就因此无法继续检测到来自主 Master节点的心跳了，于是调用自身的接管程序，接管主Master节点的 IP资源及服务。而当主 Master节点恢复时，备Backup节点又会释放主节点故障时自身接管的IP资源及服务，恢复到原来的备用角色。\n实现过程安装keepalived\nsudo apt install keepalived\n\n修改主机（192.168.16.128）keepalived配置文件\nyum方式安装的会生产配置文件在&#x2F;etc&#x2F;keepalived下：\nvi keepalived.conf\n\nkeepalived.conf:\n#检测脚本vrrp_script chk_http_port &#123;    script &quot;/usr/local/src/check_nginx_pid.sh&quot; #心跳执行的脚本，检测nginx是否启动    interval 2                          #（检测脚本执行的间隔，单位是秒）    weight 2                            #权重&#125;#vrrp 实例定义部分vrrp_instance VI_1 &#123;    state MASTER            # 指定keepalived的角色，MASTER为主，BACKUP为备    interface ens33         # 当前进行vrrp通讯的网络接口卡(当前centos的网卡) 用ifconfig查看你具体的网卡    virtual_router_id 66    # 虚拟路由编号，主从要一直    priority 100            # 优先级，数值越大，获取处理请求的优先级越高    advert_int 1            # 检查间隔，默认为1s(vrrp组播周期秒数)    #授权访问    authentication &#123;        auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信        auth_pass 1111    &#125;    track_script &#123;        chk_http_port            #（调用检测脚本）    &#125;    virtual_ipaddress &#123;        192.168.16.130            # 定义虚拟ip(VIP)，可多设，每行一个    &#125;&#125;\n\nvirtual_ipaddress 里面可以配置vip,在线上通过vip来访问服务。\ninterface需要根据服务器网卡进行设置通常查看方式ip addr\nauthentication配置授权访问后备机也需要相同配置\n修改备机keepalived配置文件#检测脚本vrrp_script chk_http_port &#123;    script &quot;/usr/local/src/check_nginx_pid.sh&quot; #心跳执行的脚本，检测nginx是否启动    interval 2                          #（检测脚本执行的间隔）    weight 2                            #权重&#125;#vrrp 实例定义部分vrrp_instance VI_1 &#123;    state BACKUP                        # 指定keepalived的角色，MASTER为主，BACKUP为备    interface ens33                      # 当前进行vrrp通讯的网络接口卡(当前centos的网卡) 用ifconfig查看你具体的网卡    virtual_router_id 66                # 虚拟路由编号，主从要一直    priority 99                         # 优先级，数值越大，获取处理请求的优先级越高    advert_int 1                        # 检查间隔，默认为1s(vrrp组播周期秒数)    #授权访问    authentication &#123;        auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信        auth_pass 1111    &#125;    track_script &#123;        chk_http_port                   #（调用检测脚本）    &#125;    virtual_ipaddress &#123;        192.168.16.130                   # 定义虚拟ip(VIP)，可多设，每行一个    &#125;&#125;\n\n检测脚本：\n#!/bin/bash#检测nginx是否启动了A=`ps -C nginx --no-header |wc -l`        if [ $A -eq 0 ];then    #如果nginx没有启动就启动nginx                              systemctl start nginx                #重启nginx      if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then    #nginx重启失败，则停掉keepalived服务，进行VIP转移              killall keepalived                          fifi\n\n脚本授权:chmod 775 check_nginx_pid.sh\n说明：脚本必须通过授权，不然没权限访问啊，在这里我们两条服务器执行、VIP(virtual_ipaddress:192.168.16.130),我们在生产环境是直接通过vip来访问服务。\n模拟nginx故障：\n修改两个服务器默认访问的Nginx的html页面作为区别。\n首先访问192.168.16.130,通过vip进行访问，页面显示192.168.16.128；说明当前是主服务器提供的服务。\n这个时候192.168.16.128主服务器执行命令：\nsystemctl stop nginx; #停止nginx\n再次访问vip(192.168.16.130)发现这个时候页面显示的还是：192.168.16.128，这是脚本里面自动重启。\n现在直接将192.168.16.128服务器关闭，在此访问vip(192.168.16.130)现在发现页面显示192.168.16.129这个时候keepalived就自动故障转移了，一套企业级生产环境的高可用方案就搭建好了。\nkeepalived中还有许多功能比如：邮箱提醒等\n","categories":["Nginx"],"tags":["Nginx"]},{"title":"Express实践 ① 用 sequelize 实现 CRUD","url":"/posts/f43388a8eda0/","content":"安装初始化项目 express-generator\n# --no-view 表示不生成视图文件npx express-generator --no-view [项目名称]\n\n安装 ORM 相关依赖,并初始化\nnpm install -D sequelize mysql2# 初始化ORMnpx sequelize-cli init\n\n修改 sequelize 配置文件\n所有的参数都需要使用字符串格式\n// config/config.js&#123;  &quot;development&quot;: &#123;    &quot;username&quot;: &quot;用户名&quot;,    &quot;password&quot;: &quot;密码&quot;,    &quot;port&quot;: &quot;端口号&quot;,    &quot;database&quot;: &quot;数据库名称&quot;,    &quot;host&quot;: &quot;127.0.0.1&quot;,    &quot;dialect&quot;: &quot;mysql&quot;,    &quot;timezone&quot;: &quot;+8:00&quot;  &#125;&#125;\n\n创建数据库字符集 utf8mb4utf8mb4 支持 Unicode 字符集中的所有字符，包括表情符号（emoji）。一些其他语言字符，utf8 字符集无法处理的字符。\n**字符集排序规则 utf8mb4_general_ci **\n是一种常见的 不区分大小写（case-insensitive, CI） 排序规则，ci 代表 Case Insensitive，即不区分字母的大小写。它会将大写字母和小写字母视为相同的字符进行排序。例如，字母 a 和 A 会被视为相同，而在某些排序规则下它们可能会被视为不同。\nutf8mb4_unicode_ci — 精确排序\n适用场景：多语言支持、需要精确排序的应用。优点：符合 Unicode 排序规则，处理复杂字符（如带有重音符号的字母）时表现更好，能够准确地处理所有 Unicode 字符，适用于全球多种语言的应用。缺点：与 utf8mb4_general_ci 相比，性能略差一些，因为它会考虑更多的字符特性进行排序。\n创建模型Creating the first Model (and Migration), 模型的名字用单数命名，生成的表名是复数\nnpx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string\n\n可以为模型添加校验条件 Validations &amp; Constraints\n// models\\user.js&quot;use strict&quot;;const &#123; Model &#125; = require(&quot;sequelize&quot;);module.exports = (sequelize, DataTypes) =&gt; &#123;  class User extends Model &#123;    static associate(models) &#123;      // define association here    &#125;  &#125;  User.init(    &#123;      email: DataTypes.STRING,      username: &#123;        type: DataTypes.STRING,        allowNull: false,        validate: &#123;          notNull: &#123;            msg: &quot;用户名不能为空&quot;,          &#125;,          notEmpty: &#123;            msg: &quot;用户名不能为空&quot;,          &#125;,          async isUnique(value) &#123;            const user = await User.findOne(&#123; where: &#123; username: value &#125; &#125;);            if (user) &#123;              throw new Error(&quot;用户名已存在&quot;);            &#125;          &#125;,          len: &#123;            args: [2, 20],            msg: &quot;用户名长度在 2 到 20 之间&quot;,          &#125;,        &#125;,      &#125;,      password: DataTypes.STRING,      nickname: DataTypes.STRING,      sex: DataTypes.TINYINT,      company: DataTypes.STRING,      introduce: DataTypes.TEXT,      role: DataTypes.TINYINT,      avatar: DataTypes.STRING,    &#125;,    &#123;      sequelize,      modelName: &quot;User&quot;,    &#125;  );  return User;&#125;;\n\n还可以通过 mysql-workbench 创建 ER 图，其中实线表示关联表没有自己的主键。\n如果数据库不是在 Docker 环境，而是使用集成环境运行,迁移后表名可能是小写的，这会导致部署到服务器上之后 Mysql 严格区分大小写导致报错,可以在服务器上重新运行迁移\n对于已经存在的表，如果可以在模型中对表名做映射的配置\nclass User extends Model &#123;  static associate(models) &#123;    models.User.belongsToMany(models.Course, &#123;      through: models.Like,      // 指明特殊的外键字段      foreignKey: &quot;user_name&quot;,      as: &quot;likeCourses&quot;,    &#125;);  &#125;&#125;User.init(  &#123;    user_name: DataTypes.STRING,  &#125;,  &#123;    sequelize,    modelName: &quot;User&quot;,    //指定模型和表名的对应关系    tableName: &quot;user_table&quot;,    // 不需要时间字段    timestamps: false,  &#125;);\n\n执行迁移文件Running Migrations, 创建模型会自动生成迁移文件,迁移文件需要按情况手动修改,修改字段类型，添加索引，等操作都是在迁移文件中完成的。\n// migrations\\20250117092337-create-user.jsmodule.exports = &#123;  async up(queryInterface, Sequelize) &#123;    const transaction = await queryInterface.sequelize.transaction();    await queryInterface.createTable(&quot;Users&quot;, &#123;      id: &#123;        allowNull: false,        autoIncrement: true,        primaryKey: true,        type: Sequelize.INTEGER.UNSIGNED,      &#125;,      email: &#123;        allowNull: false,        type: Sequelize.STRING,      &#125;,      username: &#123;        allowNull: false,        type: Sequelize.STRING,      &#125;,      password: &#123;        allowNull: false,        type: Sequelize.STRING,      &#125;,      nickname: &#123;        allowNull: false,        type: Sequelize.STRING,      &#125;,      sex: &#123;        type: Sequelize.TINYINT,      &#125;,      company: &#123;        type: Sequelize.STRING,      &#125;,      introduce: &#123;        type: Sequelize.TEXT,      &#125;,      role: &#123;        type: Sequelize.TINYINT,      &#125;,      createdAt: &#123;        allowNull: false,        type: Sequelize.DATE,      &#125;,      updatedAt: &#123;        allowNull: false,        type: Sequelize.DATE,      &#125;,    &#125;);    //添加索引    await queryInterface.addIndex(&quot;Users&quot;, [&quot;email&quot;], &#123;      unique: true,    &#125;);    await queryInterface.addIndex(&quot;Users&quot;, [&quot;username&quot;], &#123;      unique: true,    &#125;);  &#125;,  async down(queryInterface, Sequelize) &#123;    // 回滚    await queryInterface.dropTable(&quot;Users&quot;);  &#125;,&#125;;\n\n修改完成后，执行迁移文件，这会在数据库中创建真正的数据表。\nnpx sequelize-cli db:migrate\n\n如果数据表已经存在数据可以使用一下命令回归，这会执行迁移文件中的 down 方法，删除数据表\nnpx sequelize-cli db:migrate:undo  --name [迁移文件名称]\n\n如果数据表数据有效不能删除，还需要对字段修改，就需要额外创建一个迁移文件, 并单独执行这个迁移文件, 并同步修改 model 文件新增或修改字段属性\nnpx sequelize-cli migration:generate --name add-avatar-to-usernpx sequelize-cli db:migrate --name xxxx-add-avatar-to-user\n\n创建种子文件Creating the first Seed 用于快速生成初始化的测试数据。\nseed:all 会执行所有的种子文件，因此已经用 seed 初始化的表，还会再插入一遍数据\n种子文件字段校验受到模型（索引字段），迁移文件（校验字段，类型）影响,需要注意字段是否匹配，否则命令执行可能报错\nnpx sequelize-cli seed:generate --name demo-user\n\n需要手动修改种子文件，添加新增数据和删除数据的方法\n// seeders\\20250117101059-user.jsmodule.exports = &#123;  async up(queryInterface, Sequelize) &#123;    await queryInterface.bulkInsert(&quot;Users&quot;, [      &#123;        email: &quot;admin@live.com&quot;,        username: &quot;admin&quot;,        password: &quot;12345&quot;,        nickname: &quot;admin&quot;,        sex: 1,        role: 0,        createdAt: new Date(),        updatedAt: new Date(),      &#125;,    ]);  &#125;,  async down(queryInterface, Sequelize) &#123;    await queryInterface.bulkDelete(&quot;Users&quot;, null);  &#125;,&#125;;\n\n开发路由\n在 router 文件夹下添加一个新的路由文件，并注册到 express 中\n// app.jsvar app = express();var courseRouter = require(&quot;./routes/course&quot;);app.use(&quot;/course&quot;, courseRouter);\n\n使用 模糊查询\n\n常用 查询方法\n\n201 响应码表示请求成功，且修改或创建了资源\n\n必须对用户提交的数据过滤，字段验证可以用模型实现，而且可以自定义异步方法，从数据库中查询校验\n\n避免孤儿数据外键约束影响性能，一般不允许使用。删除关联数据有风险，有些关联数据是用户数据不能删除可以检测只有没有关联信息的数据才能被删除\n\n查询 关联字段，文档只有语法，但是没有自动生成文件中如何添加的示例。\n在 model 文件中添加关联信息\n// models\\course.jsconst &#123; Model &#125; = require(&quot;sequelize&quot;);module.exports = (sequelize, DataTypes) =&gt; &#123;  class Course extends Model &#123;    static associate(models) &#123;      // as 关联字段的别名, 在路由中使用的代码也需要改      models.Course.belongsTo(models.User, &#123; as: &quot;user&quot; &#125;);      models.Course.belongsTo(models.Category, &#123; as: &quot;category&quot; &#125;);    &#125;  &#125;  // ...  return Course;&#125;;\n\n查询条件中需要添加关联字段\nconst condition = &#123;  // 排序字段  order: [[&quot;id&quot;, &quot;DESC&quot;]],  // 全局过滤 两个关联的外键  attributes: &#123;    exclude: [&quot;categoryId&quot;, &quot;userId&quot;],  &#125;,  include: [    // as 关联字段别名，需要和model中的对应    // attributes 用于过滤关联模型中的字段    &#123; model: User, as: &quot;user&quot;, attributes: [&quot;id&quot;, &quot;username&quot;] &#125;,    &#123; model: Category, as: &quot;category&quot;, attributes: [&quot;id&quot;, &quot;name&quot;] &#125;,  ],&#125;;\n\n路由代码如下， 可以优化统一的错误处理以及参数的解析\n// routes\\course.jsvar express = require(&quot;express&quot;);var router = express.Router();const &#123; Course, User, Category &#125; = require(&quot;../../models&quot;);const &#123; Op &#125; = require(&quot;sequelize&quot;);router.get(&quot;/&quot;, async function (req, res, next) &#123;  try &#123;    const condition = &#123;      order: [[&quot;id&quot;, &quot;DESC&quot;]],      // 全局过滤 两个关联的外键      attributes: &#123;        exclude: [&quot;categoryId&quot;, &quot;userId&quot;],      &#125;,      include: [        // as 关联字段别名，需要和model中的对应        // attributes 用于过滤关联模型中的字段        &#123; model: User, as: &quot;user&quot;, attributes: [&quot;id&quot;, &quot;username&quot;] &#125;,        &#123; model: Category, as: &quot;category&quot;, attributes: [&quot;id&quot;, &quot;name&quot;] &#125;,      ],    &#125;;    const page = req.query.page || 1;    const pageSize = req.query.pageSize || 10;    condition.limit = pageSize;    condition.offset = (page - 1) * pageSize;    if (req.query.title) &#123;      condition.where = &#123;        title: &#123;          [Op.like]: `%$&#123;req.query.title&#125;%`,        &#125;,      &#125;;    &#125;    const &#123; count, rows &#125; = await Course.findAndCountAll(condition);    res.json(&#123;      status: true,      message: null,      data: &#123;        course: rows,        pagination: &#123;          total: count,          page,          pageSize,        &#125;,      &#125;,    &#125;);  &#125; catch (err) &#123;    console.log(err);    res.status(500).json(&#123;      status: false,      message: err,    &#125;);  &#125;&#125;);router.get(&quot;/:id&quot;, async function (req, res, next) &#123;  try &#123;    const &#123; id &#125; = req.params;    const data = await Article.findByPk(id);    if (data) &#123;      res.json(&#123;        status: true,        message: null,        data,      &#125;);    &#125; else &#123;      res.status(404).json(&#123;        status: false,      &#125;);    &#125;  &#125; catch &#123;    res.status(500).json(&#123;      status: false,    &#125;);  &#125;&#125;);router.post(&quot;/&quot;, async function (req, res, next) &#123;  try &#123;    const data = await Article.create(req.body);    res.status(201).json(&#123;      status: true,    &#125;);  &#125; catch (err) &#123;    res.status(500).json(&#123;      err: err,    &#125;);  &#125;&#125;);router.delete(&quot;/:id&quot;, async function (req, res, next) &#123;  try &#123;    const data = await Article.destroy(&#123;      where: &#123;        id: req.params.id,      &#125;,    &#125;);    console.log(data);    res.status(201).json(&#123;      status: true,    &#125;);  &#125; catch &#123;    res.status(500).json(&#123;      status: false,    &#125;);  &#125;&#125;);router.put(&quot;/:id&quot;, async function (req, res, next) &#123;  try &#123;    const count = await Article.count(&#123;      where: &#123; id: req.params.id &#125;,    &#125;);    if (count == 0) &#123;      res.status(404).json(&#123;        status: false,        message: &quot;文章不存在&quot;,      &#125;);    &#125; else &#123;      await Article.update(req.body, &#123;        where: &#123; id: req.params.id &#125;,      &#125;);      res.status(201).json(&#123;        status: true,        message: &quot;更新成功&quot;,      &#125;);    &#125;  &#125; catch &#123;    res.status(500).json(&#123;      status: false,    &#125;);  &#125;&#125;);module.exports = router;\n\n","categories":["NodeJS"],"tags":["NodeJS"]},{"title":"Express实践 ② 完善核心功能","url":"/posts/5b26283fba38/","content":"密码加密&#x2F;校验\n密码不可以明文存储，需要生成 hash,在模型文件中，可以使用 Getters, Setters &amp; Virtuals 方法并配合 bcrypt 模块 实现\n// models\\user.jsconst &#123; Model, Op &#125; = require(&quot;sequelize&quot;);const bcrypt = require(&quot;bcrypt&quot;);module.exports = (sequelize, DataTypes) =&gt; &#123;  class User extends Model &#123;&#125;  User.init(    &#123;      password: &#123;        type: DataTypes.STRING,        set(value) &#123;          // 在设置值或更新值得时候会执行这个方法          this.setDataValue(&quot;password&quot;, bcrypt.hashSync(value, 10));        &#125;,      &#125;,    &#125;,    &#123;      sequelize,      modelName: &quot;User&quot;,    &#125;  );  return User;&#125;;\n\n密码校验，模型校验方法只有设置或更新数据时触发，所以可以考虑将验证方法写在模型的类上，或是在路由中实现\n// routes\\user.js// 路由中校验数据router.post(&quot;/login&quot;, async function (req, res, next) &#123;  try &#123;    const data = await User.findOne(&#123;      where: &#123;        username: req.body.username,        email: req.body.email,      &#125;,    &#125;);    if (!bcrypt.compareSync(req.body.password, data.password)) &#123;      throw new Error(&quot;密码错误&quot;);      res.status(401);      return;    &#125;    res.end();  &#125; catch (err) &#123;&#125;&#125;);\n\n生成 jwt，用户保存用户的登录状态, 需要依赖 jsonwebtoken\n// routes\\user.jsconst bcrypt = require(&quot;bcrypt&quot;);const jwt = require(&quot;jsonwebtoken&quot;);router.post(&quot;/login&quot;, async function (req, res, next) &#123;  try &#123;    const data = await User.findOne(&#123;      // ...    &#125;);    const token = jwt.sign(      &#123;        data: &quot;foobar&quot;,      &#125;,      process.env.SECRET,      &#123; expiresIn: &quot;30d&quot; &#125;    );    res.end(token);  &#125; catch (err) &#123;&#125;&#125;);\n\nSECRET 通常作为环境变量，且禁止提交到仓库, 可以使用 crypto 生成随机密钥\ncrypto.randomBytes(64).toString(&quot;hex&quot;);\n\n中间件&#x2F;校验 jwt对接口的校验权限的校验不止一个，所以不会再每个路由文件中实现一边逻辑，这就是用到了 中间件\n下面是一个路由级别的中间件，用于处理用户的 token 是否有效\n// middleware\\auth.jsconst jwt = require(&quot;jsonwebtoken&quot;);const &#123; User &#125; = require(&quot;../models&quot;);module.exports = async function (req, res, next) &#123;  try &#123;    const &#123; token &#125; = req.headers;    if (!token) &#123;      throw new Error(&quot;用户未登录&quot;);    &#125;    const &#123; userId &#125; = jwt.verify(token, process.env.SECRET);    const user = await User.findByPk(userId);    if (!user) throw new Error(&quot;用户不存在&quot;);    if (user.role === &quot;[some role]&quot;) throw new Error(&quot;用户权限错误&quot;);    // 可以直接再路由的req上获取用户信息    req.user = user;    next();  &#125; catch (err) &#123;    // 客户端需要处理token失效的情况    res.status(500).json(&#123;      err: err.message,    &#125;);  &#125;&#125;;\n\n嵌套关联查询上一章讲解了一对多的关联查询，但是关联字段中可能还需要关联另一张表，也就是嵌套关联查询\nrouter.get(&quot;/&quot;, async function (req, res, next) &#123;  try &#123;    const condition = &#123;      order: [[&quot;id&quot;, &quot;DESC&quot;]],      // 全局过滤 两个关联的外键      attributes: &#123;        exclude: [&quot;categoryId&quot;, &quot;userId&quot;],      &#125;,      include: [        // as 关联字段别名，需要和model中的对应        // attributes 用于过滤关联模型中的字段        &#123; model: User, as: &quot;user&quot;, attributes: [&quot;id&quot;, &quot;username&quot;] &#125;,        &#123;          model: Category,          as: &quot;category&quot;,          attributes: [&quot;id&quot;, &quot;name&quot;],          // 通过嵌套 include 关联查询          include: &#123;            model: Article,            as: &quot;article&quot;,            attributes: [&quot;id&quot;, &quot;title&quot;],          &#125;,        &#125;,      ],    &#125;;    const page = req.query.page || 1;    const pageSize = req.query.pageSize || 10;    condition.limit = pageSize;    condition.offset = (page - 1) * pageSize;    const &#123; count, rows &#125; = await Course.findAndCountAll(condition);    res.json(rows);  &#125; catch (err) &#123;&#125;&#125;);\n\n这会查出来如下嵌套的返回格式， 他们的关系是\n\n一个课程数据多个用户，也属于多个分类。或者说一个用户有多个课程，一个分类包含多个课程。\n一个分类属于多篇文章。或者说一个文章有多个分类。\n\n&#123;  &quot;status&quot;: true,  &quot;message&quot;: null,  &quot;data&quot;: &#123;    &quot;course&quot;: [      &#123;        &quot;id&quot;: 12,        &quot;name&quot;: &quot;后端课程2&quot;,        &quot;image&quot;: &quot;xxx&quot;,        &quot;recommended&quot;: true,        &quot;introductory&quot;: false,        &quot;content&quot;: &quot;后端课程1,描述&quot;,        &quot;likesCount&quot;: 10,        &quot;chaptersCount&quot;: 10,        &quot;createdAt&quot;: &quot;2025-01-17T12:48:54.000Z&quot;,        &quot;updatedAt&quot;: &quot;2025-01-17T12:48:54.000Z&quot;,        &quot;user&quot;: &#123;          &quot;id&quot;: 7,          &quot;username&quot;: &quot;user1&quot;        &#125;,        &quot;category&quot;: &#123;          &quot;id&quot;: 2,          &quot;name&quot;: &quot;后端课程&quot;,          &quot;article&quot;: &#123;            &quot;id&quot;: 16,            &quot;title&quot;: &quot;标题100&quot;          &#125;        &#125;      &#125;      // ...剩余7条数据    ],    &quot;pagination&quot;: &#123;      &quot;total&quot;: 8,      &quot;page&quot;: 1,      &quot;pageSize&quot;: 10    &#125;  &#125;&#125;\n\n但是其我们是以课程的视角去查询，用户，分类，以及文章都属于当前课程的附属属性，并不需要用层级关系去体现。会希望他们以同级的字段展示。这也是 sequelize 中 Eager Loading vs Lazy Loading 的概念。\ninclude 关联字段表示 Eager Loading, 会直接把数据返回。而 Lazy Loading 允许用方法调用的方式，选择哪些数据需要，而这种方式正好处理数据的层级问题。\n上面的 findAndCountAll 是无法使用 Lazy 关联查询的，因为它查询的是整个列表，必须明确用数据结构说面关联关系，并不是针对某个课程的关联查询\n下面是查询单独一个课程的关联信息， 需要查询出关联的字段\nrouter.get(&quot;/:id&quot;, async function (req, res, next) &#123;  try &#123;    const condition = &#123;      order: [[&quot;id&quot;, &quot;DESC&quot;]],      //  注意不要排除了关联 ID, 否则查询不到      //   attributes: &#123;      //     exclude: [&quot;categoryId&quot;, &quot;userId&quot;],      //   &#125;,    &#125;;    const course = await Course.findByPk(req.params.id, condition);    // 通过课程查询分类，注意要带上关联的 articleId    const category = await course.getCategory(&#123;      attributes: [&quot;id&quot;, &quot;name&quot;, &quot;articleId&quot;],    &#125;);    // 通过分类查询文章    const article = await category.getArticle(&#123;      attributes: [&quot;id&quot;, &quot;title&quot;],    &#125;);    res.json(&#123;      status: true,      message: null,      data: &#123;        course,        category,        article,      &#125;,    &#125;);  &#125; catch (err) &#123;&#125;&#125;);\n\n多对多的查询实现一个点赞的功能：\n\n一个用户可以可以给多个课程点赞\n一个课程也可以被多个用户点赞\n\n虽然可以直接在用户表中储存点赞课程，但不是一个好的做法, 存在以下问题：\n无法保证数据一致性：难以通过外键验证课程是否存在。查询复杂：查找特定课程的所有学生需要额外的解析逻辑。扩展性差：不适合大规模、多条件查询的场景。\n最佳实践是使用中间表：\n数据一致性：中间表中的外键可以确保关联数据的完整性。灵活性：中间表允许添加额外的信息（如时间戳、状态等）。查询效率：数据库的索引可以优化多对多查询性能。扩展性：关系较复杂时，可以轻松扩展中间表的结构。\n修改模型，通过点赞中间表建立课程表和用户之间的关系\n// models\\user.jsclass User extends Model &#123;  static associate(models) &#123;    models.User.belongsToMany(models.Course, &#123;      through: models.Like,      as: &quot;likeCourse&quot;,    &#125;);  &#125;&#125;// models\\course.jsclass User extends Model &#123;  static associate(models) &#123;    models.Course.belongsToMany(models.User, &#123;      through: models.Like,      as: &quot;courseWithUsers&quot;,    &#125;);  &#125;&#125;\n\n查询某个用户喜欢的课程， 如果使用 include 做查询在多对多的关系中无法实现分页,在 include 中无法对关联查询的数据分页，且模型中的 foreignKey 是必填的，否则会报错\nrouter.get(&quot;/:id&quot;, async function (req, res, next) &#123;  try &#123;    // 获取user实例    const user = await User.findByPk(req.params.id, &#123;      include: [        &#123;          model: Course,          as: &quot;likeCourses&quot;,          // 无法使用分页          // limit: pageSize,          // offset: (page - 1) * pageSize,        &#125;,      ],    &#125;);    res.json(&#123;      //...    &#125;);  &#125; catch (err) &#123;&#125;&#125;);\n\n所以可以使用 Lazy Loading 手动请求数据, 模型中提供了内置的方法，可以用于获取分页数据\n另外需要控制 不显示中间表的数据\nrouter.get(&quot;/:id&quot;, async function (req, res, next) &#123;  try &#123;    const page = req.query.page || 1;    const pageSize = req.query.pageSize || 10;    const limit = pageSize;    const offset = (page - 1) * pageSize;    const user = await User.findByPk(req.params.id);    // getLikeCourses 是模型内部映射的方法，通过 get + as别名 命名    const course = await user.getLikeCourses(&#123;      // 不显示中间表的数据      joinTableAttributes: [],      attributes: [&quot;id&quot;, &quot;name&quot;],      limit,      offset,    &#125;);    // 另一个映射方法用于获取总条数    const total = await user.countLikeCourses();    res.json(&#123;      //...    &#125;);  &#125; catch (err) &#123;&#125;&#125;);\n\n处理跨域\nnginx\ncors\n\n","categories":["NodeJS"],"tags":["NodeJS"]},{"title":"Express实践 ③ 项目部署","url":"/posts/69d4b43ca84c/","content":"统一的错误处理http-errors 可以统一错误抛出，避免自定义错误对象。\nvar E = require(&quot;http-errors&quot;);throw new E.BadRequest([&quot;报错了&quot;]);\n\n可以使用统一的错误处理函数\nmodule.exports = function errorHandle(res, err) &#123;  let status = 500;  let message = [];  if (err instanceof E.HttpError) &#123;    status = err.status;    message = err.message;  &#125;  res.status(status).json(&#123;    status: false,    errors: message,  &#125;);&#125;;\n\n腾讯 OSS 服务端上传// 引入模块var COS = require(&quot;cos-nodejs-sdk-v5&quot;);var crypto = require(&quot;crypto&quot;);var multer = require(&quot;multer&quot;);// 创建实例var cos = new COS(&#123;  SecretId: &quot;xxx&quot;,  SecretKey: &quot;xxx&quot;,&#125;);// 存储桶名称，由bucketname-appid 组成，appid必须填入，可以在COS控制台查看存储桶名称。 https://console.cloud.tencent.com/cos5/bucketvar Bucket = &quot;xxx-1255610650&quot;;// 存储桶Region可以在COS控制台指定存储桶的概览页查看 https://console.cloud.tencent.com/cos5/bucket/// 关于地域的详情见 https://cloud.tencent.com/document/product/436/6224var Region = &quot;ap-nanjing&quot;;const storage = multer.memoryStorage();const upload = multer(&#123;  storage: storage,  limits: &#123; fileSize: 10 * 1024 * 1024 &#125;, // 限制文件大小（10MB）  fileFilter: (req, file, cb) =&gt; &#123;    // 可选：限制文件类型    const allowedTypes = [&quot;image/jpeg&quot;, &quot;image/png&quot;];    if (allowedTypes.includes(file.mimetype)) &#123;      cb(null, true);    &#125; else &#123;      cb(new Error(&quot;只允许上传 JPG/PNG 文件&quot;));    &#125;  &#125;,&#125;);const push = async (req, res) =&gt; &#123;  if (!req.file) &#123;    throw new E[400]([&quot;你没有选择文件&quot;]);  &#125;  const ext = req.file.originalname.split(&quot;.&quot;).pop();  const fileName = `$&#123;crypto.randomBytes(64).toString(&quot;hex&quot;)&#125;.$&#123;ext&#125;`;  return cos.putObject(&#123;    Bucket,    Region,    Key: fileName, // 对象存储路径    Body: req.file.buffer, // 文件内容（Buffer）    ContentType: req.file.mimetype, // 文件类型  &#125;);&#125;;module.exports = &#123; middleware: upload.single(&quot;file&quot;), push &#125;;\n\n接口添加中间件\nconst &#123; middleware: uploadMiddleware &#125; = require(&quot;./utils/upload&quot;);app.use(&quot;/upload&quot;, uploadMiddleware, uploadRouter);\n\nrouter.post(&quot;/&quot;, async function (req, res, next) &#123;  try &#123;    if (!req.file) &#123;      throw new Error();    &#125;    const result = await push(req);    // 同时保存到数据库中    // ...    res.json(result);  &#125; catch (error) &#123;    res.errorHandle(error);  &#125;&#125;);\n\n腾讯 OSS 客户端上传需要先获取临时令牌,服务端提供接口, allowPrefix allowActions 必填\n服务端可以把桶的名称，地区统一返回\nrouter.get(&quot;/sts&quot;, (req, res, next) =&gt; &#123;  var config = &#123;    secretId: &quot;xxx&quot;, // 固定密钥    secretKey: &quot;xxx&quot;, // 固定密钥    proxy: &quot;&quot;,    durationSeconds: 1800,    // host: &#x27;sts.tencentcloudapi.com&#x27;, // 域名，非必须，默认为 sts.tencentcloudapi.com    endpoint: &quot;sts.tencentcloudapi.com&quot;, // 域名，非必须，与host二选一，默认为 sts.tencentcloudapi.com    // 放行判断相关参数    bucket: &quot;node-learn-1255610650&quot;,    region: &quot;ap-nanjing&quot;,    allowPrefix: &quot;*&quot;,    allowActions: [      // 简单上传      &quot;name/cos:PutObject&quot;,      // 分块上传      &quot;name/cos:InitiateMultipartUpload&quot;,      &quot;name/cos:ListMultipartUploads&quot;,      &quot;name/cos:ListParts&quot;,      &quot;name/cos:UploadPart&quot;,      &quot;name/cos:CompleteMultipartUpload&quot;,    ],  &#125;;  var shortBucketName = config.bucket.substr(0, config.bucket.lastIndexOf(&quot;-&quot;));  var appId = config.bucket.substr(1 + config.bucket.lastIndexOf(&quot;-&quot;));  var policy = &#123;    version: &quot;2.0&quot;,    statement: [      &#123;        action: config.allowActions,        effect: &quot;allow&quot;,        principal: &#123; qcs: [&quot;*&quot;] &#125;,        resource: [          &quot;qcs::cos:&quot; +            config.region +            &quot;:uid/&quot; +            appId +            &quot;:prefix//&quot; +            appId +            &quot;/&quot; +            shortBucketName +            &quot;/&quot; +            config.allowPrefix,        ],        // condition生效条件，关于 condition 的详细设置规则和COS支持的condition类型可以参考https://cloud.tencent.com/document/product/436/71306        // &#x27;condition&#x27;: &#123;        //   // 比如限定ip访问        //   &#x27;ip_equal&#x27;: &#123;        //     &#x27;qcs:ip&#x27;: &#x27;10.121.2.10/24&#x27;        //   &#125;        // &#125;      &#125;,    ],  &#125;;  STS.getCredential(    &#123;      secretId: config.secretId,      secretKey: config.secretKey,      proxy: config.proxy,      durationSeconds: config.durationSeconds,      endpoint: config.endpoint,      policy: policy,    &#125;,    function (err, tempKeys) &#123;      res.json(&#123;        ...tempKeys,        bucket: &quot;xxx-1255610650&quot;,        region: &quot;ap-nanjing&quot;,      &#125;);    &#125;  );&#125;);\n\n客户端调用\nfetch(&quot;/upload/sts&quot;)  .then((res) =&gt; res.json())  .then((res) =&gt; &#123;    const cos = new COS(&#123;      SecretId: res.credentials.tmpSecretId, // sts服务下发的临时 secretId      SecretKey: res.credentials.tmpSecretKey, // sts服务下发的临时 secretKey      SecurityToken: res.credentials.sessionToken, // sts服务下发的临时 SessionToken      StartTime: res.startTime, // 建议传入服务端时间，可避免客户端时间不准导致的签名错误      ExpiredTime: res.expiredTime, // 临时密钥过期时间    &#125;);    cos.uploadFile(      &#123;        Bucket: res.bucket,        Region: res.region,        Key: &quot;xxx.txt&quot;,        Body: document.getElementById(&quot;file&quot;).files[0], // 要上传的文件对象。        onProgress: function (progressData) &#123;          console.log(&quot;上传进度：&quot;, progressData);        &#125;,      &#125;,      function (err, data) &#123;        console.log(&quot;上传结束&quot;, err || data);      &#125;    );  &#125;);\n\nredis安装 redis 并提供一个简单的工具文件\n// redis-utils.jsconst &#123; createClient &#125; = require(&quot;redis&quot;);// 全局 Redis 客户端实例let client = null;/** * 初始化 Redis 客户端（单例模式） */const initializeRedis = async () =&gt; &#123;  if (client?.isOpen) return;  try &#123;    client = createClient(&#123;      url: &quot;redis://localhost:6379&quot;, // 默认连接地址      // password: &#x27;your_password&#x27;,  // 如果需要密码验证    &#125;);    // 监听连接错误事件    client.on(&quot;error&quot;, (err) =&gt; console.error(&quot;Redis connection error:&quot;, err));    await client.connect();    console.log(&quot;Redis client connected&quot;);  &#125; catch (err) &#123;    console.error(&quot;Failed to connect to Redis:&quot;, err);    throw err;  &#125;&#125;;/** * 存储数据（支持对象/数组自动序列化） * @param &#123;string&#125; key - 存储键名 * @param &#123;object|array|string|number|boolean&#125; value - 存储值 * @param &#123;number&#125; [ttl] - 过期时间（秒），不传则永久保存 */const setKey = async (key, value, ttl) =&gt; &#123;  if (!client?.isOpen) await initializeRedis();  try &#123;    const serializedValue =      typeof value === &quot;string&quot; ? value : JSON.stringify(value);    if (ttl) &#123;      await client.setEx(key, ttl, serializedValue);    &#125; else &#123;      await client.set(key, serializedValue);    &#125;  &#125; catch (err) &#123;    console.error(`Failed to set key &quot;$&#123;key&#125;&quot;:`, err);    throw err;  &#125;&#125;;/** * 获取存储的数据（自动反序列化对象/数组） * @param &#123;string&#125; key - 要获取的键名 * @returns &#123;Promise&lt;any&gt;&#125; */const getKey = async (key) =&gt; &#123;  if (!client?.isOpen) await initializeRedis();  try &#123;    const value = await client.get(key);    if (!value) return null;    try &#123;      return JSON.parse(value);    &#125; catch &#123;      return value;    &#125;  &#125; catch (err) &#123;    console.error(`Failed to get key &quot;$&#123;key&#125;&quot;:`, err);    throw err;  &#125;&#125;;/** * 删除指定键 * @param &#123;string&#125; key - 要删除的键名 * @returns &#123;Promise&lt;boolean&gt;&#125; */const deleteKey = async (key) =&gt; &#123;  if (!client?.isOpen) await initializeRedis();  const result = await client.del(key);  return result &gt; 0;&#125;;const scanKeys = async (pattern, count = 100) =&gt; &#123;  if (!client?.isOpen) await initializeRedis();  const foundKeys = [];  let cursor = 0;  do &#123;    const reply = await client.scan(cursor, &#123; MATCH: pattern, COUNT: count &#125;);    cursor = reply.cursor;    foundKeys.push(...reply.keys);  &#125; while (cursor !== 0);  return foundKeys;&#125;;/** * 关闭 Redis 连接 */const closeRedis = async () =&gt; &#123;  if (client?.isOpen) &#123;    await client.quit();    console.log(&quot;Redis connection closed&quot;);  &#125;&#125;;module.exports = &#123;  initializeRedis,  setKey,  getKey,  deleteKey,  closeRedis,&#125;;\n\n安装 redis insight 客户端， 并通过 docker 启动 redis 服务\nversion: &#x27;3.8&#x27; # 指定 Docker Compose 文件格式版本services:  redis:    # 服务名称    image: redis:7.4 # Redis 镜像版本（注意：Redis 官方镜像没有 7.4 版本，建议使用最新稳定版如 7.2）    ports:      - &quot;6379:6379&quot; # 端口映射（宿主机:容器）    restart: unless-stopped # 容器自动重启策略\n\n分页缓存策略,使用 ： 拼接字段作为 key，冒号在 redis 中有特殊的意义，\nconst key = &quot;article:math:1&quot;;redis.setKey(key, value);// 使用通配符查询所有keyconst userKeys = await scanKeys(&quot;user:*&quot;);\n\n发送邮件搜索 Google App Passwords 创建新密码\nconst nodemailer = require(&quot;nodemailer&quot;);const sendEmail = async () =&gt; &#123;  const transporter = nodemailer.createTransport(&#123;    service: &quot;gmail&quot;,    auth: &#123;      user: &quot;fengaiqi000@gmail.com&quot;,      pass: &quot;创建的google账户免密&quot;,    &#125;,  &#125;);  const mailOptions = &#123;    from: &quot;fengaiqi000@gmail.com&quot;,    to: &quot;sunzhiqi@live.com&quot;,    subject: &quot;Test Email&quot;,    text: &quot;Hello, this is a test email sent using Nodemailer and OAuth2!&quot;,  &#125;;  transporter.sendMail(mailOptions, (error, info) =&gt; &#123;    if (error) &#123;      return console.log(error);    &#125;    console.log(&quot;Email sent: &quot; + info.response);  &#125;);&#125;;sendEmail().catch(console.error);\n\nRabbit MQ常用于,发送电子邮件、发送短信、应用内通知、文件处理、数据分析与报告生成、订单处理、秒杀。\n// send.jsvar amqplib = require(&quot;amqplib&quot;);const url = `amqp://localhost`;const QUEUE_NAME = &quot;task1&quot;;async function sendMessage(message) &#123;  let connection;  try &#123;    connection = await amqplib.connect(url, &#123;      username: &quot;node&quot;,      password: &quot;123456&quot;,      port: &quot;5672&quot;,      vhost: &quot;/&quot;,    &#125;);    console.log(&quot;✅ 成功连接到 RabbitMQ 服务器&quot;);    // 2. 创建通道    const channel = await connection.createChannel();    console.log(&quot;🔄 通道已创建&quot;);    // 3. 声明队列（如果不存在则创建）    await channel.assertQueue(QUEUE_NAME, &#123;      durable: true, // 持久化队列（服务器重启后保留）    &#125;);    // 4. 发送消息    const sent = channel.sendToQueue(      QUEUE_NAME,      Buffer.from(message),      &#123; persistent: true &#125; // 消息持久化    );    if (sent) &#123;      console.log(`📤 消息已发送: $&#123;message&#125;`);    &#125; else &#123;      console.error(&quot;❌ 消息发送失败&quot;);    &#125;  &#125; catch (error) &#123;    console.error(&quot;🔥 发生错误:&quot;, error);  &#125; finally &#123;    // 5. 延迟500ms后关闭连接    if (connection) &#123;      await new Promise((resolve) =&gt; setTimeout(resolve, 500));      await connection.close();      console.log(&quot;🚪 连接已关闭&quot;);    &#125;    process.exit(0);  &#125;&#125;// 执行发送const message = process.argv[2] || &quot;你好，RabbitMQ！&quot;;sendMessage(message);\n\n// receiver.jsvar amqplib = require(&quot;amqplib&quot;);const QUEUE_NAME = &quot;task1&quot;;// 构造连接URL（处理密码特殊字符）const url = `amqp://localhost`;async function startConsumer() &#123;  let connection;  try &#123;    // 1. 建立连接    connection = await amqplib.connect(url, &#123;      username: &quot;node&quot;,      password: &quot;123456&quot;,      port: &quot;5672&quot;,      vhost: &quot;/&quot;,    &#125;);    console.log(&quot;✅ 成功连接到 RabbitMQ 服务器&quot;);    // 2. 创建通道    const channel = await connection.createChannel();    console.log(&quot;🔄 通道已创建&quot;);    // 3. 声明队列（与发送端配置一致）    await channel.assertQueue(QUEUE_NAME, &#123;      durable: true, // 必须与发送端队列声明一致    &#125;);    console.log(`📭 正在监听队列：$&#123;QUEUE_NAME&#125;`);    // 4. 设置消费参数    channel.prefetch(1); // 每次只处理一个消息    console.log(&quot;⏳ 等待消息中... (按 CTRL+C 退出)&quot;);    // 5. 启动消费者    channel.consume(      QUEUE_NAME,      async (msg) =&gt; &#123;        if (msg) &#123;          try &#123;            const content = msg.content.toString();            console.log(`📥 收到消息: $&#123;content&#125;`);            // 模拟业务处理（例如耗时操作）            await new Promise((resolve) =&gt; setTimeout(resolve, 1000));            // 手动确认消息（确保 noAck: false）            channel.ack(msg);            console.log(&quot;✔️ 消息已确认&quot;);          &#125; catch (error) &#123;            console.error(&quot;⚠️ 消息处理失败:&quot;, error);            channel.nack(msg); // 否定确认并重新入队          &#125;        &#125;      &#125;,      &#123;        noAck: false, // 关闭自动确认      &#125;    );    // 保持进程运行    await new Promise(() =&gt; &#123;&#125;);  &#125; catch (error) &#123;    console.error(&quot;🔥 发生错误:&quot;, error);    process.exit(1);  &#125; finally &#123;    if (connection) &#123;      await connection.close();      console.log(&quot;🚪 连接已关闭&quot;);    &#125;  &#125;&#125;// 启动消费者startConsumer();\n\n日志记录创建一个日志表方便管理\nnpx sequelize model:generate --name Log --attributes level:string,message:string,meta:string,timestamp:date\n\n修改对应的迁移文件\n&quot;use strict&quot;;/** @type &#123;import(&#x27;sequelize-cli&#x27;).Migration&#125; */module.exports = &#123;  async up(queryInterface, Sequelize) &#123;    await queryInterface.createTable(&quot;Logs&quot;, &#123;      id: &#123;        allowNull: false,        autoIncrement: true,        primaryKey: true,        type: Sequelize.INTEGER.UNSIGNED,      &#125;,      level: &#123;        allowNull: false,        type: Sequelize.STRING(16),      &#125;,      message: &#123;        allowNull: false,        type: Sequelize.STRING(2048),      &#125;,      meta: &#123;        allowNull: false,        type: Sequelize.STRING(2048),      &#125;,      timestamp: &#123;        allowNull: false,        type: Sequelize.DATE,      &#125;,    &#125;);  &#125;,  async down(queryInterface) &#123;    await queryInterface.dropTable(&quot;Logs&quot;);  &#125;,&#125;;\n\n修改一下模型\nconst &#123; Model &#125; = require(&quot;sequelize&quot;);module.exports = (sequelize, DataTypes) =&gt; &#123;  class Log extends Model &#123;    static associate(models) &#123;&#125;  &#125;  Log.init(    &#123;      level: DataTypes.STRING(16),      message: DataTypes.STRING(2048),      meta: &#123;        type: DataTypes.STRING,        get() &#123;          // 转换报错信息          try &#123;            return JSON.parse(this.getDataValue(&quot;meta&quot;));          &#125; catch (error) &#123;            return this.getDataValue(&quot;meta&quot;);          &#125;        &#125;,      &#125;,      timestamp: DataTypes.DATE,    &#125;,    &#123;      sequelize, // 使用传入的 Sequelize 实例      modelName: &quot;Log&quot;,      timestamps: false, // 禁用自动生成 createdAt 和 updatedAt 字段      tableName: &quot;Logs&quot;, // 显式指定表名（可选）    &#125;  );  return Log;&#125;;\n\n创建日志工具文件\n// config/logger.jsconst &#123; createLogger, format, transports &#125; = require(&quot;winston&quot;);const MySQLTransport = require(&quot;winston-mysql&quot;).MySQLTransport;const path = require(&quot;path&quot;);// 根据环境变量加载数据库配置const env = process.env.NODE_ENV || &quot;development&quot;;const dbConfig = require(path.join(__dirname, &quot;../config/config.json&quot;))[env];// MySQL 传输配置const mysqlTransportOptions = &#123;  host: dbConfig.host,  user: dbConfig.username,  password: dbConfig.password,  database: dbConfig.database,  table: &quot;logs&quot;, // 存储日志的表名  fields: &#123;    // 字段映射配置    level: &quot;level&quot;,    meta: &quot;meta&quot;,    message: &quot;message&quot;,    timestamp: &quot;timestamp&quot;,    service: &quot;service&quot;,  &#125;,&#125;;// 创建日志记录器const logger = createLogger(&#123;  level: &quot;info&quot;, // 默认日志级别  format: format.combine(    format.timestamp(&#123; format: &quot;YYYY-MM-DD HH:mm:ss&quot; &#125;),    format.errors(&#123; stack: true &#125;), // 捕获错误堆栈    format.json() // JSON 格式输出  ),  defaultMeta: &#123; service: &quot;clwy-api&quot; &#125;, // 全局元数据  transports: [    // MySQL 日志传输（生产环境使用）    new MySQLTransport(mysqlTransportOptions),  ],&#125;);// 开发环境添加控制台输出if (env !== &quot;production&quot;) &#123;  logger.add(    new transports.Console(&#123;      format: format.combine(        format.colorize(), // 终端颜色输出        format.printf((info) =&gt; &#123;          return `$&#123;info.timestamp&#125; [$&#123;info.level&#125;] $&#123;info.message&#125; $&#123;            info.stack || &quot;&quot;          &#125;`;        &#125;)      ),    &#125;)  );&#125;module.exports = logger;\n","categories":["NodeJS"],"tags":["NodeJS"]},{"title":"Nodejs 基础 API","url":"/posts/4decf4c02ef8/","content":"Buffer// 20个字节const b1 = Buffer.alloc(20);// 直接去一块连续内存，可能有没有回收的垃圾数据const b2 = Buffer.allocUnsafe(20);// 为什么是 31 而不是01， 因为uft8 编码下并不是1const b3 = Buffer.from(&quot;1&quot;);// 无法保存文字的信息, 数组中的每一个必须是16进制 8 或2const b4 = Buffer.from([1, &quot;维护&quot;]);// 两块内存不会相同，内存上是分开的const b5 = Buffer.alloc(3);const b6 = Buffer.from(b5);// 填充const b7 = Buffer.alloc(5);//会把整个buffer填满，如果长度不够，会截断//                       开始字节位置，结束字节位置console.log(b7.fill(&quot;中&quot;, 1, 2));console.log(b7.toString());// 写入const b8 = Buffer.alloc(5);console.log(b8.write(&quot;中&quot;, 1, 4));// toString 可以选择从哪一个字节下标开始解析console.log(b7.toString(&quot;utf-8&quot;, 3, 6));// slice 截取操作const b9 = Buffer.from(&quot;为各位&quot;);console.log(b9.slice());// 查找可以指定从哪一位后面开始查找console.log(b9.indexOf(&quot;为&quot;, 2));// copyconst b10 = Buffer.from(&quot;为各位&quot;);const b11 = Buffer.alloc(39);// 开始结束位置b10.copy(b11, 3, 6);// concatconst b12 = Buffer.from(&quot;1&quot;);const b13 = Buffer.from(&quot;2&quot;);const b14 = Buffer.concat([b12, b13]);// slice 方法已经被标记为过时，使用 subarray 从 Buffer 中截取一段数据//                      start endconst b15 = b14.subarray(0，2);// 判断Buffer.isBuffer;// 实现对 Buffer 的splitBuffer.prototype.split = function (sep) &#123;  const length = Buffer.from(sep).length;  let ret = [];  let start = 0;  let offset = 0;  while ((offset = this.indexOf(sep, start)) !== -1) &#123;    ret.push(this.subarray(start, offset).toString());    start = offset + length;  &#125;  ret.push(this.subarray(start).toString());  return ret;&#125;;// 向buffer中写入数据// value 必须是指定进制的整数// offset从哪个字节开始写入// LE 表示按小端字节序写入  1 =&gt; [01,00,00,00]// LB 表示按大端字节序写入  1 =&gt; [00,00,00,01]buf.writeInt32LE(value,offset);// 从buffer中读取数据// offset 表示从哪个位置开始读取// 注意： 不能设置读取长度，他读取的长度是固定的，4个字节32位buf.readInt32LE(offset)\n\nEvent LoopNode.js 的事件循环基于 libuv，用于管理异步操作。事件循环分为多个阶段，每个阶段负责处理特定类型的回调。\n1. Timers 阶段\n\n作用：处理由 setTimeout() 和 setInterval() 创建的回调。\n行为：\n检查到期的定时器，并执行其回调。\n如果没有到期的定时器，则直接跳到下一个阶段。\n\n\n\n2. I&#x2F;O Callbacks 阶段\n\n作用：处理几乎所有延迟的 I&#x2F;O 回调（除了 close 事件、setImmediate 和定时器回调）。\n行为：\n处理如网络请求错误等 I&#x2F;O 回调。\n较少用在用户代码中，因为大多数 I&#x2F;O 会在 Poll 阶段完成。\n\n\n\n3. Idle, Prepare 阶段\n\n作用：供内部使用，用于准备事件循环和一些内部操作。\n行为：\n通常不处理用户定义的回调。\n主要为 Node.js 引擎的内部运行服务。\n\n\n\n4. Poll 阶段\n\n作用：处理新到达的 I&#x2F;O 事件并执行相关回调。\n行为：\n如果没有到期的定时器，这个阶段会阻塞，等待新的 I&#x2F;O 事件。\n如果有定时器到期，会直接跳到 Timers 阶段。\n\n\n\n5. Check 阶段\n\n作用：执行 setImmediate() 的回调。\n行为：\n优先于下一次 Poll 阶段任务执行。\n在 Poll 阶段结束后立即执行。\n\n\n\n6. Close Callbacks 阶段\n\n作用：处理关闭事件的回调。\n行为：\n例如处理 socket.on(&#39;close&#39;) 或 fs.close() 的回调。\n用于释放资源时执行相关任务。\n\n\n\n特殊任务：微任务队列（Microtask Queue）\n\n并不属于事件循环的某个阶段，而是会在每个阶段完成后执行。\n\n包括以下两种任务：\n\nprocess.nextTick() 回调。\nPromise 的 .then()、.catch() 和 .finally()。\n\n\n微任务优先于下一个事件循环阶段执行。\n\n例如，在 Timers 阶段执行完所有回调后，会立即执行微任务队列中的任务。\n\n\n// setTimeout  setImmediate 执行时机并不确定setTimeout(() =&gt; console.log(&quot;Timers&quot;), 0);setImmediate(() =&gt; console.log(&quot;Check&quot;));Promise.resolve().then(() =&gt; console.log(&quot;Microtask&quot;));process.nextTick(() =&gt; console.log(&quot;Next Tick&quot;));// 1. Next Tick// 2. Microtask// 3. Timers// 4. Check\n\nfs.readFileSync(() =&gt; &#123;  setTimeout(() =&gt; console.log(&quot;Timers&quot;), 0);  // setImmediate 永远先执行，因为 fs队列是在poll中  // 下一步会执行 check 队列中的 setImmediate  setImmediate(() =&gt; console.log(&quot;Check&quot;));&#125;);\n\n模拟一个模块加载函数const path = require(&quot;path&quot;);const fs = require(&quot;fs&quot;);const vm = require(&quot;vm&quot;);class Module &#123;  // 模块的导出对象，类似于 CommonJS 中的 `module.exports`  exports = &#123;&#125;;  // 模块缓存，用于存储已加载的模块，避免重复加载  static cache = &#123;&#125;;  // 文件扩展名及对应的加载器方法  static extensions = &#123;    &quot;.js&quot;: (module) =&gt; &#123;      // 读取 JavaScript 文件内容      let content = fs.readFileSync(module.id, &quot;utf-8&quot;);      // 将文件内容包装成 CommonJS 模块的函数形式      content = Module.wrap(content);      // 将包装后的代码编译为可执行的函数      const script = new vm.Script(content);      const fn = script.runInThisContext();      // 调用包装函数，将 `exports`、`require` 等注入到模块上下文      fn(module.exports, myRequire, module, module.id, path.dirname(module.id));    &#125;,    &quot;.json&quot;: (module) =&gt; &#123;      // 读取 JSON 文件内容      const content = fs.readFileSync(module.id, &quot;utf-8&quot;);      // 将 JSON 内容解析为对象，并赋值给模块的 `exports`      module.exports = JSON.parse(content);    &#125;,  &#125;;  constructor(id) &#123;    // 模块的唯一标识符，通常为文件的绝对路径    this.id = id;  &#125;  // 包装模块代码，模拟 CommonJS 的运行环境  static wrap(content) &#123;    return `(function(exports, require, module, __filename, __dirname) &#123; $&#123;content&#125; &#125;)`;  &#125;  // 解析文件名，包括支持自动添加扩展名  static resolveFileName(filePath) &#123;    // 将文件路径转换为绝对路径    const absolutePath = path.resolve(filePath);    // 检查文件是否存在    if (fs.existsSync(absolutePath)) &#123;      return absolutePath;    &#125;    // 检查支持的文件扩展名    for (const ext of Object.keys(Module.extensions)) &#123;      const fullPath = absolutePath + ext;      if (fs.existsSync(fullPath)) &#123;        return fullPath;      &#125;    &#125;    // 如果文件未找到，抛出错误    throw new Error(`无法找到模块 &#x27;$&#123;filePath&#125;&#x27;`);  &#125;  // 加载模块，根据扩展名选择合适的加载器  load() &#123;    const ext = path.extname(this.id); // 获取文件扩展名    const loader = Module.extensions[ext]; // 根据扩展名找到对应的加载器    if (loader) &#123;      loader(this); // 执行加载器    &#125; else &#123;      throw new Error(`不支持的文件扩展名 &#x27;$&#123;ext&#125;&#x27;`);    &#125;  &#125;&#125;// 自定义的 `require` 方法，用于加载模块function myRequire(filePath) &#123;  // 解析文件名，确保获取的是有效路径  const resolvedPath = Module.resolveFileName(filePath);  // 如果模块已缓存，直接返回缓存中的 `exports`  if (Module.cache[resolvedPath]) &#123;    return Module.cache[resolvedPath].exports;  &#125;  // 创建一个新的模块实例  const module = new Module(resolvedPath);  // 将模块实例存入缓存  Module.cache[resolvedPath] = module;  // 加载模块内容  module.load();  // 返回模块的导出对象  return module.exports;&#125;// 示例：加载一个模块const res = myRequire(&quot;./path&quot;);\n\n模拟一个 WriteStreamconst fs = require(&quot;fs&quot;);const EventEmitter = require(&quot;events&quot;);function createWriteStream(path, options = &#123;&#125;) &#123;  // 解构并设置默认参数  const &#123;    flags = &quot;w&quot;, // 文件打开模式（默认为写入模式）    encoding = &quot;utf8&quot;, // 默认编码    autoClose = true, // 是否自动关闭文件描述符    emitClose = true, // 是否在关闭时触发 &quot;close&quot; 事件    start = 0, // 文件写入的起始位置    highWaterMark = 16 * 1024, // 写入的高水位标记（默认 16KB）  &#125; = options;  // 内部状态变量  let offset = start; // 文件写入偏移量  let written = 0; // 当前已写入的字节数  let writing = false; // 是否正在写入  let cache = []; // 缓存区，用于存储等待写入的数据  // 定义一个可写流类  class WriteStream extends EventEmitter &#123;    fd = null; // 文件描述符    // 打开文件    open() &#123;      fs.open(path, flags, (err, fd) =&gt; &#123;        if (err) &#123;          this.emit(&quot;error&quot;, err); // 打开文件失败，触发错误事件          if (autoClose) &#123;            this.destroy(); // 发生错误时自动关闭          &#125;          return;        &#125;        this.fd = fd; // 保存文件描述符        this.emit(&quot;open&quot;, fd); // 触发 open 事件      &#125;);    &#125;    // 写入数据    write(chunk, encoding = &quot;utf8&quot;, callback = () =&gt; &#123;&#125;) &#123;      const buffer = Buffer.isBuffer(chunk)        ? chunk        : Buffer.from(chunk, encoding);      const canWrite = written &lt; highWaterMark; // 判断当前写入是否超出高水位标记      // writeStream 首次会直接写入数据，后面的数据会写入缓存      if (writing) &#123;        // 如果正在写入，缓存数据并延迟写入        cache.push(&#123; buffer, callback &#125;);      &#125; else &#123;        writing = true;        this._write(buffer, callback);      &#125;      return canWrite; // 返回是否可以继续写入    &#125;    // 实际写入操作    _write(buffer, callback) &#123;      if (this.fd === null) &#123;        // 如果文件描述符尚未打开，等待 open 事件后再写入        return this.once(&quot;open&quot;, () =&gt; this._write(buffer, callback));      &#125;      fs.write(        this.fd,        buffer,        0,        buffer.length,        offset,        (err, bytesWritten) =&gt; &#123;          if (err) &#123;            this.emit(&quot;error&quot;, err); // 写入失败，触发错误事件            if (autoClose) &#123;              this.destroy();            &#125;            return;          &#125;          offset += bytesWritten; // 更新写入偏移量          written -= bytesWritten; // 更新已写入的字节数          // 检查缓存区中是否还有待写入的数据          const next = cache.shift();          if (next) &#123;            this._write(next.buffer, next.callback);          &#125; else &#123;            writing = false; // 当前写入完成            callback(); // 执行回调            if (written &lt; highWaterMark) &#123;              this.emit(&quot;drain&quot;); // 缓存区清空，触发 drain 事件            &#125;          &#125;        &#125;      );    &#125;    // 销毁流（关闭文件描述符）    destroy() &#123;      if (this.fd !== null) &#123;        fs.close(this.fd, (err) =&gt; &#123;          if (emitClose) &#123;            this.emit(&quot;close&quot;); // 触发 close 事件          &#125;        &#125;);        this.fd = null;      &#125;    &#125;  &#125;  // 创建流实例并打开文件  const stream = new WriteStream();  stream.open();  return stream;&#125;// 使用示例const writeStream = createWriteStream(&quot;./package.txt&quot;);// 监听事件writeStream.on(&quot;open&quot;, (fd) =&gt; console.log(&quot;文件已打开，描述符:&quot;, fd));writeStream.on(&quot;error&quot;, (err) =&gt; console.error(&quot;发生错误:&quot;, err));writeStream.on(&quot;drain&quot;, () =&gt; console.log(&quot;缓存已清空，可以继续写入&quot;));// 写入数据writeStream.write(&quot;Hello, World!&quot;, &quot;utf-8&quot;, (err) =&gt; &#123;  if (err) console.error(&quot;写入失败:&quot;, err);  else console.log(&quot;写入成功&quot;);&#125;);writeStream.write(&quot;Another line.&quot;, &quot;utf-8&quot;, (err) =&gt; &#123;  if (err) console.error(&quot;写入失败:&quot;, err);  else console.log(&quot;写入成功&quot;);&#125;);\n\n模拟 TCP 粘包的解决方法// util.jsconst Buffer = require(&quot;buffer&quot;).Buffer;// 获取数据包长度const getLength = (chunk) =&gt; &#123;  if (chunk.length &lt; 12) return 0; // 不满足最小长度的包直接返回 0  return 12 + chunk.readInt32LE(4); // 长度字段存储在偏移量为 4 的位置&#125;;// 编码消息为特定格式的 Bufferconst encode = (string, id = 1) =&gt; &#123;  const strBuffer = Buffer.from(string); // 将字符串转为 Buffer  const headerBuffer = Buffer.allocUnsafe(12); // 创建 12 字节的头部  headerBuffer.writeInt32LE(id, 0); // 写入消息 ID (4 字节)  headerBuffer.writeInt32LE(strBuffer.length, 4); // 写入消息长度 (4 字节)  return Buffer.concat([headerBuffer, strBuffer]); // 合并头部和消息&#125;;// 解码 Buffer 为字符串const decode = (chunk) =&gt; &#123;  const bodyLength = chunk.readInt32LE(4); // 获取消息体的长度  return chunk.subarray(12, 12 + bodyLength).toString(); // 提取消息体并转为字符串&#125;;module.exports = &#123; getLength, encode, decode &#125;;\n\n// server.jsconst net = require(&quot;net&quot;);const &#123; getLength, encode, decode &#125; = require(&quot;./utils&quot;);// 创建服务端const server = net.createServer();server.listen(8080, &quot;127.0.0.1&quot;, () =&gt; &#123;  console.log(&quot;服务端启动，监听端口 8080&quot;);&#125;);server.on(&quot;connection&quot;, (socket) =&gt; &#123;  console.log(&quot;客户端连接成功&quot;);  let unReadChunks = Buffer.alloc(0); // 存储未处理的缓冲区数据  socket.on(&quot;data&quot;, (chunk) =&gt; &#123;    unReadChunks = Buffer.concat([unReadChunks, chunk]); // 拼接收到的数据    let len;    // 循环处理完整的数据包    while ((len = getLength(unReadChunks))) &#123;      const cur = unReadChunks.subarray(0, len); // 提取当前完整数据包      unReadChunks = unReadChunks.subarray(len); // 更新未处理数据      // 解码消息，生成回复      const response = encode(decode(cur) + &quot; 服务端恢复&quot;, cur.readInt32LE(0));      socket.write(response); // 发送回复消息    &#125;  &#125;);  socket.on(&quot;close&quot;, () =&gt; console.log(&quot;客户端连接关闭&quot;));  socket.on(&quot;error&quot;, (err) =&gt; console.error(&quot;服务端错误:&quot;, err));&#125;);\n\n// client.jsconst net = require(&quot;net&quot;);const &#123; getLength, encode, decode &#125; = require(&quot;./utils&quot;);// 创建客户端const client = net.createConnection(8080, &quot;127.0.0.1&quot;, () =&gt; &#123;  console.log(&quot;客户端连接成功&quot;);  // 发送多条消息  client.write(encode(&quot;消息1&quot;));  client.write(encode(&quot;消息2&quot;));  client.write(encode(&quot;消息3&quot;));  client.write(encode(&quot;消息4&quot;));  client.write(encode(&quot;消息5&quot;));&#125;);let unReadChunks = Buffer.alloc(0); // 存储未处理的缓冲区数据client.on(&quot;data&quot;, (chunk) =&gt; &#123;  unReadChunks = Buffer.concat([unReadChunks, chunk]); // 拼接收到的数据  let len;  // 循环处理完整的数据包  while ((len = getLength(unReadChunks))) &#123;    const cur = unReadChunks.subarray(0, len); // 提取当前完整数据包    unReadChunks = unReadChunks.subarray(len); // 更新未处理数据    // 解码消息并输出    console.log(&quot;收到服务端回复:&quot;, decode(cur));  &#125;&#125;);client.on(&quot;close&quot;, () =&gt; console.log(&quot;客户端连接关闭&quot;));client.on(&quot;error&quot;, (err) =&gt; console.error(&quot;客户端错误:&quot;, err));\n","categories":["NodeJS"],"tags":["NodeJS"]},{"title":"Docker 安装 nextcloud","url":"/posts/8d0fd81a8531/","content":"配置文件\n&#x2F;docker&#x2F;nextCloud&#x2F;docker-compose.yml\n\nversion: &#x27;3&#x27;services:  db:    image: mariadb:10.5    command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW    restart: always    volumes:      - ./db:/var/lib/mysql    environment:      - MYSQL_ROOT_PASSWORD=myPassword # db.env环境变量中的相同    env_file:      - db.env  redis:    image: redis:alpine    restart: always  app:    image: nextcloud:apache    restart: always    volumes:      - ./nextcloud:/var/www/html    environment:      - VIRTUAL_HOST=nextcloud.iftrue.club      - LETSENCRYPT_HOST=nextcloud.iftrue.club      - LETSENCRYPT_EMAIL=sunzhiqi@live.com      - MYSQL_HOST=db      - REDIS_HOST=redis    env_file:      - db.env    depends_on:      - db      - redis    networks:      - proxy-tier      - default  cron:    image: nextcloud:apache    restart: always    volumes:      - ./nextcloud:/var/www/html    entrypoint: /cron.sh    depends_on:      - db      - redis  proxy:    build: ./proxy    restart: always    ports:      - 7186:80      - 37186:443    labels:      com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy: &quot;true&quot;    volumes:      - ./certs:/etc/nginx/certs:ro      - ./vhost.d:/etc/nginx/vhost.d      - ./html:/usr/share/nginx/html      - /var/run/docker.sock:/tmp/docker.sock:ro    networks:      - proxy-tier  letsencrypt-companion:    image: nginxproxy/acme-companion    restart: always    volumes:      - ./certs:/etc/nginx/certs      - ./acme:/etc/acme.sh      - ./vhost.d:/etc/nginx/vhost.d      - ./html:/usr/share/nginx/html      - /var/run/docker.sock:/var/run/docker.sock:ro    networks:      - proxy-tier    depends_on:      - proxy# self signed#  omgwtfssl:#    image: paulczar/omgwtfssl#    restart: &quot;no&quot;#    volumes:#      - certs:/certs#    environment:#      - SSL_SUBJECT=servhostname.local#      - CA_SUBJECT=my@example.com#      - SSL_KEY=/certs/servhostname.local.key#      - SSL_CSR=/certs/servhostname.local.csr#      - SSL_CERT=/certs/servhostname.local.crt#    networks:#      - proxy-tiervolumes:  db:  nextcloud:  certs:  acme:  vhost.d:  html:networks:  proxy-tier:\n\n\n\n&#x2F;docker&#x2F;nextCloud&#x2F;db.env\n\nMYSQL_PASSWORD=myPasswordMYSQL_DATABASE=nextcloudMYSQL_USER=nextcloud\n\n\n&#x2F;docker&#x2F;nextCloud&#x2F;proxy&#x2F;Dockerfile\n\nFROM nginxproxy/nginx-proxy:alpineCOPY uploadsize.conf /etc/nginx/conf.d/uploadsize.conf\n\n\n&#x2F;docker&#x2F;nextCloud&#x2F;proxy&#x2F;uploadsize.conf\n\nclient_max_body_size 10G;proxy_request_buffering off;\n\n启动cd /docker/nextClouddocker-compose","categories":["其他"],"tags":["Docker","nextcloud"]},{"title":"Docker 部署Jira + 破解","url":"/posts/84719102d07f/","content":"创建必要目录mkdir -p docker-compose/jira\n\n创建 docker-compose.yml\n修改映射路径为当前文件夹下的相对路径\nJIRA_PROXY_NAME &#x3D; 域名\nJIRA_PROXY_PORT &#x3D; 外部端口\nJIRA_PROXY_SCHEME &#x3D; 协议\nPOSTGRES_PASSWORD 修改数据库密码\n\nservices:  jira_db:    image: mysql:8.0    container_name: jira_mysql    environment:      MYSQL_ROOT_PASSWORD: w.521@@ong.COM      MYSQL_DATABASE: jira      MYSQL_USER: jira      MYSQL_PASSWORD: w.521@@ong.COM    ports:      - 19306:3306    volumes:      - ./data:/var/lib/mysql    networks:      - jira_network # 将 mysql 服务连接到 mynetwork 网络    restart: always  jira:    image: atlassian/jira-software    container_name: jira    ports:      - 19140:8080    volumes:      - ./jiraVolume:/var/atlassian/application-data/jira      - ./lib:/opt/atlassian/jira/lib #驱动的目录，需要映射    networks:      - jira_network # 将 jira 服务连接到 mynetwork 网络    restart: unless-stoppedvolumes:  mysql-data:    driver: local  jiraVolume:    driver: localnetworks:  jira_network:    # 定义名为 mynetwork 的网络    driver: bridge # 使用默认的 bridge 驱动\n\n破解\n下载 atlassian-agent.jar 文件压缩包，并解压\n\n将 atlassian-agent.jar 复制到容器内 docker cp ./atlassian-agent.jar jira容器名称:/opt/jira\n\n在 docker-compose/jira 目录下执行 docker-compose up 启动动容器\n\n进入容器 docker exec -it jira 容器名称 /bin/bash\n\n修改环境变量 cd /opt/jira/bin vi setenv.sh\n\n\n\nexport JAVA_OPTS 修改为 export JAVA_OPTS&#x3D;”-javaagent:&#x2F;opt&#x2F;jira&#x2F;atlassian-agent.jar ${JAVA_OPTS}”\n\n重启容器, 在日志中可以看到 ========= agent working ========= 字样表示成功\n\n再次进入容器 执行 java -jar atlassian-agent.jar -p jsm -m aaa@bbb.com -n my_name -o https://zhile.io -s ABCD-1234-EFGH-5678\n\n\n特别注意 -p 参数设置，通过 java -jar atlassian-agent.jar 查看使用帮助，每种产品有不同的标识\n-m 邮箱任意填写-n 名称任意填写-o 网址任意填写-s server id 再安装时查看\n复制执行命令之后产生的激活码，复制到激活码的窗口完成激活。\nFAQ\n连接时报错 Could not find driver with class name: com.mysql.cj.jdbc.Driver\n下载 对应版本的驱动\n将驱动放在 jira 安装目录(或 docker 映射的目录)&#x2F;lib 下面\n重启 jira 服务\n\n\n","categories":["其他"],"tags":["Docker"]},{"title":"FocalBoard 私有化部署","url":"/posts/c753f6a1fa26/","content":"最后更新2024-12-13\n官方安装包安装 官方包, [官方文档]\nwget https://github.com/mattermost/focalboard/releases/download/v0.15.0/focalboard-server-linux-amd64.tar.gztar -xvzf focalboard-server-linux-amd64.tar.gzsudo mv focalboard /opt\n\n安装数据库sudo apt install postgresql postgresql-contrib\n\n以 postgres 用户创建一个新的数据库\nsudo --login --user postgrespsqlCREATE DATABASE &lt;your-db-user&gt;;CREATE USER &lt;your-db-user&gt; WITH PASSWORD &lt;&#x27;your-password&#x27;&gt;;# 查看schema列表\\dn# 查看用户列表\\du# 查看数据库列表\\l+# 赋予用于操作数据库的所有权限GRANT ALL PRIVILEGES ON DATABASE &lt;your-db&gt; TO &lt;your-db-user&gt;;GRANT ALL ON SCHEMA public TO &lt;your-db-user&gt;;\\c &lt;your-db-user&gt; postgres# You are now connected to database &quot;your-db-user&quot; as user &quot;postgres&quot;.# 赋予有用操作public schema的权限GRANT ALL ON SCHEMA public TO &lt;your-db-user&gt;;# 退出 postgres 用户\\qexit\n\n配置链接信息\nvi /opt/focalboard/config.json&quot;dbtype&quot;: &quot;postgres&quot;,&quot;dbconfig&quot;: &quot;postgres://your-db-user:your-db-password@localhost/boards?sslmode=disable&amp;connect_timeout=10&quot;\n\n启动服务sudo vi /lib/systemd/system/focalboard.service[Unit]Description=Focalboard server[Service]Type=simpleRestart=alwaysRestartSec=5sExecStart=/opt/focalboard/bin/focalboard-serverWorkingDirectory=/opt/focalboard[Install]WantedBy=multi-user.target\n\nsudo systemctl daemon-reloadsudo systemctl start focalboard.servicesudo systemctl enable focalboard.servicecurl localhost:8000\n\nnginx 配置server &#123;   listen      443;   listen [::]:443;   server_name focal.iftrue.club;   location ~ /ws/* &#123;       proxy_set_header Upgrade $http_upgrade;       proxy_set_header Connection &quot;upgrade&quot;;       client_max_body_size 50M;       proxy_set_header Host $http_host;       proxy_set_header X-Real-IP $remote_addr;       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;       proxy_set_header X-Forwarded-Proto $scheme;       proxy_set_header X-Frame-Options SAMEORIGIN;       proxy_buffers 256 16k;       proxy_buffer_size 16k;       client_body_timeout 60;       send_timeout 300;       lingering_timeout 5;       proxy_connect_timeout 1d;       proxy_send_timeout 1d;       proxy_read_timeout 1d;       proxy_pass http://192.168.48.148:8000;   &#125;   location / &#123;       client_max_body_size 50M;       proxy_set_header Connection &quot;&quot;;       proxy_set_header Host $http_host;       proxy_set_header X-Real-IP $remote_addr;       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;       proxy_set_header X-Forwarded-Proto $scheme;       proxy_set_header X-Frame-Options SAMEORIGIN;       proxy_buffers 256 16k;       proxy_buffer_size 16k;       proxy_read_timeout 600s;       proxy_cache_revalidate on;       proxy_cache_min_uses 2;       proxy_cache_use_stale timeout;       proxy_cache_lock on;       proxy_http_version 1.1;       proxy_pass http://192.168.48.148:8000;   &#125;&#125;\n\nFAQ\nerror [2025-03-17 04:28:23.400 Z] Table creation &#x2F; migration failed caller&#x3D;”sqlstore&#x2F;sqlstore.go:75” error&#x3D;”pq: permission denied for schema public”\n参照数据库配置步骤，需要赋予用户操作 public schema 的权限\n\n\n","categories":["其他"],"tags":["focalBoard"]},{"title":"Gitlab 私有化部署","url":"/posts/07254c59e161/","content":"最后更新2024-08-12\n官方安装包安装必要依赖\nsudo apt-get updatesudo apt-get install -y curl openssh-server ca-certificates tzdata perl\n\n安装邮件服务，配置项选择 Internet Site，mail name 填写当前服务器 DNS.\nsudo apt-get install -y postfix\n\n添加仓库\ncurl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash\n\n安装, 填写需要访问的域名\nsudo EXTERNAL_URL=&quot;https://gitlab.example.com&quot; apt-get install gitlab-ee\n\nnginx 配置\nserver &#123;    listen      80  ssl;    listen [::]:443  ssl;    server_name gitlab.iftrue.club;    location / &#123;        proxy_pass http://192.168.48.160; # 按照 gitlab.rb 是否开启了 https 访问，选择 http 或 https            proxy_set_header X-Forwarded-Host $host:$server_port;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;   &#125;&#125;\n\n配置自动启动\n[Unit]Description=SonarQube serviceAfter=syslog.target network.target[Service]Type=simpleUser=sonarGroup=sonarPermissionsStartOnly=true# java 路径使用 whereis java 插卡# /opt/sonarqube/lib/sonar-application-&lt;sonar-version&gt;.jarExecStart=/bin/nohup /opt/java/bin/java -Xms32m -Xmx32m -Djava.net.preferIPv4Stack=true -jar /opt/sonarqube/lib/sonar-application-25.1.0.102122.jarStandardOutput=journalLimitNOFILE=131072LimitNPROC=8192TimeoutStartSec=5Restart=alwaysSuccessExitStatus=143[Install]WantedBy=multi-user.target\n\n修改配置文件 /etc/gitlab/gitlab.rb\n# 修改外部访问地址，用于项目的下载地址，需要有完整的协议和端口号external_url &quot;https://gitlab.iftrue.club:9348&quot;# 修改ssh端口，用于 ssh 克隆项目gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 24922# 保存后应用配置sudo gitlab-ctl stopsudo gitlab-ctl reconfiguresudo gitlab-ctl start\n\n如果在 Gitlab 前面有统一的反向代理，无需 Gitlab 本身处理 SSL 证书，可以将 Gitlab 的 nginx 配置为 80 端口。[文档]\nnginx[&#x27;enable&#x27;] = truenginx[&#x27;listen_port&#x27;] = 80nginx[&#x27;listen_https&#x27;] = falsesudo gitlab-ctl reconfigure\n\nnginx 配置参照 docker 的配置\nDocker 方式安装只需要准备好证书文件，配置.yml 文件即可使用\n\n&#x2F;docker&#x2F;gitlab&#x2F;docker-compose.yml\n\nversion: &#x27;3.6&#x27;services:  gitlab:    image: gitlab/gitlab-ee:latest    container_name: gitlab    restart: always    # 必填：访问gitlab的域名    hostname: &#x27;gitlab.iftrue&#x27;    environment:      GITLAB_OMNIBUS_CONFIG: |        # 必填： 外部访问gitlab的地址        # 用于内部生成外部访问的链接，例如 clone地址        # 即使通过nginx代理访问gitlab, 协议也必须相同        external_url &#x27;https://gitlab.iftrue.com:9348&#x27;        # 首次登录时的免密        gitlab_rails[&#x27;initial_root_password&#x27;]=&#x27;xxxx&#x27;        # ssh 端口        gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 24922    ports:      # 外部和内部端口必须与external_url端口相同      - &#x27;9348:9348&#x27;      - &#x27;24922:22&#x27;    volumes:      - &#x27;./config:/etc/gitlab&#x27;      - &#x27;./logs:/var/log/gitlab&#x27;      - &#x27;./data:/var/opt/gitlab&#x27;    shm_size: &#x27;256m&#x27;    # 设置日志大小，避免磁盘写满    logging:      driver: &quot;json-file&quot;      options:        max-size: &quot;50m&quot;  # 单个日志文件最大为 50MB        max-file: &quot;5&quot;    # 最多保留 5 个日志文件\n\n启动服务，需要等待一段时间，观察 docker 状态是否是 healthy\n#  拉取最新镜像docker compose pulldocker compose up -d\n\n获取&#x2F;修改 初始密码\ndocker exec -it  gitlab /bin/bash\n\n查看初始密码，安装 gitlab 后 24 小时会自动删除\ncat /etc/gitlab/initial_root_password\n\n修改初始密码\ngitlab-rails console                   # 进入命令行u=User.where(id:1).first               # 查找root用户u.password=&#x27;12345678&#x27;                  # 修改密码u.password_confirmation=&#x27;12345678&#x27;     # 确认密码u.save                                 # 保存配置\n\nnginx 配置\nserver &#123;  listen      443  ssl;  listen [::]:443  ssl;  server_name gitlab.iftrue.club;  location / &#123;    # 如果 external_url 设置了 https 就要访问https地址    # 可以选择关闭强制https跳转的配置    proxy_pass https://192.168.48.213:9348;    proxy_set_header X-Forwarded-Host $host:$server_port;    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;    proxy_http_version 1.1;    proxy_set_header Upgrade $http_upgrade;    proxy_set_header Connection &quot;upgrade&quot;;  &#125;&#125;# 因为社区版的 nginx 不支持 tcp 流量转发，因此下面配置无效# 可以使用防火墙进行转发# server &#123;#   listen      24922  ssl;#     listen [::]:24922  ssl;#     server_name gitlab.iftrue.club;#     location / &#123;#     proxy_pass https://192.168.48.213:24922;#   &#125;# &#125;\n","categories":["其他"],"tags":["gitlab"]},{"title":"Google 搜索提示您的连接不是私密连接 NET::ERR_CERT_AUTHORITY_INVALID","url":"/posts/a19d9a8cdd43/","content":"\nGoogle 浏览器搜索报错，但是可以使用翻译等功能，但不能搜索。\n\n\n原因\n\nchrome将你输入的字符转换成google搜索指令时出错所致。新版chrome为增强安全性，对非https的地址会报如上错误。\n\n也可能是运营商网络原因\n\n\n解决办法\n删除原来的goole搜索引擎，手动输入一个新的即可。\n\n进入设置\n\n\n\n进入管理搜索引擎\n\n\n\n点击添加\n\n\n\n填入下面几项\n\n搜索引擎： Goolge 或任意名字\n关键字： www.google.com.hk\n网址格式： https://www.google.com.hk/search?q=%s&amp;&#123;google:RLZ&#125;&#123;google:originalQueryForSuggestion&#125;&#123;google:assistedQueryStats&#125;&#123;google:searchFieldtrialParameter&#125;&#123;google:iOSSearchLanguage&#125;&#123;google:searchClient&#125;&#123;google:sourceId&#125;&#123;google:instantExtendedEnabledParameter&#125;&#123;google:contextualSearchVersion&#125;ie=&#123;inputEncoding&#125;\n\n\n保存并选设为默认选项\n\n\n","categories":["其他"],"tags":["浏览器"]},{"title":"LVM模式安装manjaro","url":"/posts/71298d9bd5e3/","content":"安装流程首先对物理磁盘分区，对于 UEFI 引导方式，需要划分 efi 分区 并把磁盘挂载到 &#x2F;boot&#x2F;efi 路径\n注意： 所有的分区和格式化操作都需要在命令行中执行， manjaro 的 GUI 只用来挂载分区\n如果使用 window 环境下的虚拟机安装， 在 启用或关闭 windows 功能 配置中，关闭 windows 沙箱， Hyper-v 两个配置， 这功能可能导致虚拟死机。\n\n启动前将系统的引导方式修改为 UEFI,进入系统时选择专有驱动的选项启动方式\n\n\n\n\n使用 fdisk 查看磁盘信息\n\n\n\n格式化磁盘为 GPT 格式，划分出 500M 作为 efi 分区，剩余空间给 LVM 使用\n\n\n\n分区成功后将 efi 分区格式化为 FAT32 格式\n\n\n\n\n将剩余的空间转为 LVM, 创建出 &#x2F;dev&#x2F;vgdisk&#x2F;lvhome 分区，并将 lvhome 分区格式化为 ext4\n\n\n分配成功后使用以下命令查看分区信息：\nsudo pvssudo vgssudo lvs# 查看详细信息sudo pvdisplaysudo vgdisplaysudo lvdisplay\n\n删除分区\nsudo pvremove /dev/somethingsudo vgremove somethingsudo lvremove /dev/something\n\n\n通过 GUI 界面将分区挂载到指定路径，挂载磁盘时一定不要重新格式化磁盘\n\n\n\n\n\n错误处理\n开机时提示一下错误，可能是遗留的 bug,解决方案如下\n\n\n# /etc/default/grubGRUB_SAVDEFAULT=falseupdate-grub\n\n\n手动挂载分区系统安装成功后，可能需要挂载更多自定义分区, 首先创建一个 workspace lv分区\n查看分区信息\nsudo blkid#指定分区sudo blkid /dev/sda1\n\n添加信息到 &#x2F;etc&#x2F;fstab, 实现自动挂载\n\n扩容 lvm\n扩容虚拟磁盘， vmware 磁盘设置中增加磁盘容量。\n\n使用 gdisk 为剩余磁盘创建分区，创建成功后磁盘可能无法使用，使用以下命令刷新分区表\nsudo partprobe\n使用 pvcreate 将新的分区创建为新的pv\n\n扩容 vg 将新的 pv 添加至 指定卷组\nvgextend vgdisk /dev/sda3vgs #查看容量\n\n扩容 lv\n-l +  ：指定逻辑卷的LE个数，如 -l +200  一般一个为 4M-L + ：表示增加多少空间，如 -L +15G ，单位有bBsSkKmMgGtTpPeE-l +100%FREE\t：表示增加vg的全部可用空间\nlvextend -L +15G /dev/vgname/lvname\n\n扩展文件系统\nresize2fs /dev/something\n\n","categories":["其他"],"tags":["Linux","Manajro"]},{"title":"O2OA 私有化部署","url":"/posts/682c074451f7/","content":"安装 mysql 数据库# 安装服务sudo apt install -y mysql-server# 检查服务是否启动systemctl status mysql# 首次登录没有密码sudo mysql -u root -p# 创建对应的数据库CREATE DATABASE my_databaseCHARACTER SET utf8mb4COLLATE utf8mb4_general_ci;# 查看所有数据库SHOW DATABASES;# 删除数据库DROP DATABASE database_name;# 修改字符集和排序ALTER DATABASE database_nameCHARACTER SET utf8mb4COLLATE utf8mb4_general_ci;# 创建新用户# &#x27;localhost&#x27;：表示该用户只能从本地机器连接到数据库。如果希望该用户可以从任何主机连接，可以使用 &#x27;%&#x27;，如 &#x27;new_user&#x27;@&#x27;%&#x27;。CREATE USER &#x27;new_user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;your_password&#x27;;# 查看所有用户SELECT User, Host FROM mysql.user;#ALL PRIVILEGES：赋予所有权限。# my_database.*：指示该用户可以对 my_database 数据库中的所有表进行操作。# &#x27;localhost&#x27;：表示该用户只能从本地连接。GRANT ALL PRIVILEGES ON my_database.* TO &#x27;new_user&#x27;@&#x27;localhost&#x27;;# 刷新权限FLUSH PRIVILEGES;# 查看端口SHOW VARIABLES LIKE &#x27;port&#x27;;cat /etc/mysql/mysql.conf.d/mysqld.cnf\n\n下载安装包下载 安装包\n解压并复制到 &#x2F;opt\nunzip  o2server-8.2.3-linux-x64.zipmv o2server /opt\n\n配置服务器端口O2OA 服务器端口配置文件所在位置：o2server&#x2F;config&#x2F;node_127.0.0.1.json\n如果目录里没有该文件或者没有 config 目录，可以新建一个 config 目录，然后从 configSample 目录里 COPY 一个到新建的 config 目录下。\n# 自行修改web端口配置\n\n自启动服务因为需要用 root 用户启动服务，所以先配置开机启动服务\n./service_linux.sh o2server start_linux.shsystemctl enable o2serversystemctl start o2server\n\n配置数据库链接jdbc:mysql://127.0.0.1:3306/o2oa_db?autoReconnect=true&amp;allowPublicKeyRetrieval=true&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8\n","categories":["其他"],"tags":["o2oa"]},{"title":"OpenWrt 安装与设置","url":"/posts/0d8a7ae7bced/","content":"下载固件OpenWrt 官方版本，所有的第三方版本都是基于官方的自定义编译，immortalwrt 是针对国内用户编译的第三方版本，推荐优先使用。[GitHub]\n点击 All Downloads\n\n选择适配的 x86 版本\n\nSquashFS 和 Ext4 是两种不同的文件系统，各自有不同的特点和应用场景：\n\nSquashFS 只读的文件系统，经过压缩后可以节省存储空间。默认情况下不支持直接写入，因此需要将可写数据放在单独的 Overlay 文件系统上。\nExt4 一种常用的可读写文件系统，支持动态修改。\n\n\n\n由于 OpenWrt 并不会将所有硬盘剩余空间作为根路径，因此不同的文件格式对应不同的磁盘组成，在安装后需要对根分区扩容。\n\nExt4: /boot + /根分区(读写) + 剩余未分区磁盘\nSquashFS： /boot + /rom(只读) + /根分区(读写) + 剩余未分区磁盘 (优先选择此版本，方便迁移和系统恢复)\n\n安装参考官方安装文档，采用写入镜像文件方式，由于 OpenWrt 没有提供安装引导，所以需要用 微 PE 或 老毛桃[https://www.laomaotao.net/] 等工具制作一个 WinPE 启动盘, 将用到的固件，和固件写入工具保存到启动盘中，当进入 WinPE 系统后是用写入工具写入镜像。\n\nWindows Preinstallation Environment（Windows PE），Windows 预安装环境，是带有有限服务的最小 Win32 子系统，基于以完整 Windows 环境或者保护模式运行的 Windows 3.x 及以上内核。这类系统一般很小。它包括了运行 Windows 安装程序及脚本、连接网络共享、自动化基本过程以及执行硬件验证所需的最小功能。\n\n另外需要下载一个镜像写入工具 Win32 Disk Imager 或 balenaEtcher\n将镜像写入工具, 解压出的 OpenWrt 镜像(.iso)文件, 复制到制作好的 WinPE 启动 U 盘中。\n\n将 U 盘插入到软路由中(软路由需要接上鼠标，键盘，显示器)，开机时入到软路由的 BIOS，将默认的固态硬盘启动改为 U 盘启动。\n\n保存重启后，进入 WinPE 系统，首先使用 WinPE 自带的 DiskGenius 工具，删除软路由硬盘的所有分区并保存。打开写入工具，选择磁盘和镜像并写入。\n\n写入成功后，重启系统再次进入 BIOS,将 U 盘启动修改回硬盘启动，保存并再次重启。\n启动成功后，会看见有命令行信息，如果卡住不动，尝试按一下回车键，这样会进入 OpenWrt 系统。\n首次登录提示修改密码，执行 passwd 命令，修改 root 账户密码，此密码也是网页登录的密码。\n\n修改网络配置信息，执行命令 vi /etc/config/network,\n将 config device 的 list_ports 修改为 eth1将 interface lan 的 option ipaddr 修改为内网不会冲突的 IP 地址例如 192.168.100.1 或 10.10.0.1将 interface wan 和 interface wan6 的 option device 修改为 eth0\n\nwan 口表示外网，也就是网络运营商的网线，通常更习惯将第一个网口作为插入外网网线，后面插入的都是内网设备，这样更有条理性\n\n\n保存后重启设备,访问前需要重新连接一下设备：\n\n软路由插入电源并开机\n运营商光猫的网线，链接到软路由的 eth0 网口。\nwifi 路由器需要在管理后台，设置为 AP 有线中继模式，用一个网线将软路由的 eth1 网口，链接到路由器的第一个网口。\n其他内网设备可以通过网线连接软路由或路由器，也可以直接通过 wifi 网络链接.\n\n这是虽然不能上网，单已经可以通过内网中其他设备访问 /etc/config/network 中设置的 lan 口的 ipaddr 访问到 OpenWrt 的 UI 界面。\npve 虚拟机安装上传镜像文件到 pve， 创建虚拟机， 删除虚拟机的默认磁盘\nqm importdisk [虚拟机ID] [镜像路径] [磁盘]qm importdisk 4444 /var/lib/vz/template/iso/immortalwrt-24.10.3-x86-64-generic-squashfs-combined-efi__1_.img storage\n\n虚拟机 &#x3D;&gt; 硬件 添加未启用的磁盘虚拟机 &#x3D;&gt; 选线 修改刚刚添加的磁盘为第一启动项\nwan 口配置最先的配置一定是软路由可以上网，输入账号密码进入到软路由的 UI 界面，点击菜单 网络 &#x3D;&gt; 接口 点击 wan 口的编辑按钮，协议切换为 PPPoE ，输入账号密码，即可上网。\n\n此方式是通过 PPPoE 拨号上网，需要致电运营商，将网络改为桥接模式，并提供账号密码。\n\n\nlan 口配置网络 &#x3D;&gt; 接口 &#x3D;&gt; 设备 选择 br_lan, 在网桥端口中将其他的端口都添加到 br_lan 这个网桥中，方便让局域网中的设备互相访问\n磁盘扩容在菜单 状态 &#x3D;&gt; 概览 中可以看到，磁盘空间只有几百 M, 这是因为 OpenWrt 默认不会将剩余空间作为根节点。\n官方 openwrt 参考 官方的扩容操作\nimmortalwrt 在安装前可以使用以下命令修改镜像的分区大小\n# 将镜像文件扩容dd if=/dev/zero bs=1M count=98304 &gt;&gt; immortalwrt-24.10.3-x86-64-generic-squashfs-combined-efi__1_.img# 使用parted扩容文件系统parted immortalwrt-24.10.3-x86-64-generic-squashfs-combined-efi__1_.imgGNU Parted 3.5Using /var/lib/vz/template/iso/immortalwrt-24.10.3-x86-64-generic-squashfs-combined-efi__1_.imgWelcome to GNU Parted! Type &#x27;help&#x27; to view a list of commands.(parted) pError: The backup GPT table is corrupt, but the primary appears OK, so that will be used.OK/Cancel? OKWarning: Not all of the space available to/var/lib/vz/template/iso/immortalwrt-24.10.3-x86-64-generic-squashfs-combined-efi__1_.img appears to be used, you can fix the GPTto use all of the space (an extra 30 blocks) or continue with the current setting?Fix/Ignore? FixModel:  (file)Disk /var/lib/vz/template/iso/immortalwrt-24.10.3-x86-64-generic-squashfs-combined-efi__1_.img: 348MBSector size (logical/physical): 512B/512BPartition Table: gptDisk Flags:Number  Start   End     Size    File system  Name  Flags128     17.4kB  262kB   245kB                      bios_grub 1      262kB   33.8MB  33.6MB  fat16              legacy_boot 2      33.8MB  348MB   315MB(parted) resizepart 2 100%(parted) q\n\nimmortalwrt 也可以安装后扩容\nopkg updateopkg install fdisk lsblk losetup f2fs-toolsopkg install lsblk fdisk resize2fs losetup blkid f2fs-tools tree# 查看磁盘信息# df -h# fdisk -l# 替换为自己的磁盘fdisk /dev/sda# 查看磁盘Command (m for help): pDevice         Boot  Start    End Sectors  Size Id Type/dev/sda1            65536  98303   32768   16M 83 Linux/dev/sda2            131072 745471  614400  300M 83 Linux# 删除Command (m for help): dPartition number (1,2, default 2): 2Partition 2 has been deleted.# 新建磁盘 需要注意 sector 起始位置一定要与原有磁盘信息中 start 大小相同Command (m for help): nPartition type   p   primary (1 primary, 0 extended, 3 free)   e   extended (container for logical partitions)Select (default p): pPartition number (2-4, default 2): 2First sector (2048-31268863, default 2048): 131072Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (131072-31268863, default 31268863):Created a new partition 2 of type &#x27;Linux&#x27; and of size 14.8 GiB.Partition #2 contains a squashfs signature.# 一定要选 n ，不要修改标识符Do you want to remove the signature? [Y]es/[N]o: n# 保存Command (m for help): wThe partition table has been altered.\n\n对文件系统扩容\nlosetup# 记录 offset 的值# NAME       SIZELIMIT  OFFSET AUTOCLEAR RO BACK-FILE  DIO LOG-SEC# /dev/loop0         0 6291456         1  0 /mmcblk0p2   0     512# 使用相同的 offset 创建一个临时的 循环设备losetup -f -o 6291456 /dev/sda2# 挂在这个设备以便于记录日志， 如果不挂在会导致不能访问mount /dev/loop1 /mnt# 卸载设备后可以执行扩容umount /dev/loop1resize.f2fs /dev/loop1\n\n修改分区大小后会导致磁盘 UUID 改变，需要更新\nblkid# /dev/loop0: LABEL=&quot;rootfs_data&quot; UUID=&quot;b32ce334-3193-428b-9ae3-2a156379ecc8&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;f2fs&quot;# 记录 sda2 的新的 PARTUUID# /dev/sda2: BLOCK_SIZE=&quot;262144&quot; TYPE=&quot;squashfs&quot; PARTUUID=&quot;ff2d03b0-3d06-4001-bb97-367a0265a03f&quot;vi /boot/grub/grub.cfg# 修改对应的 PARTUUID 为最新值# menuentry &quot;ImmortalWrt&quot; &#123;#         linux /boot/vmlinuz root=PARTUUID=484c7fc2-ae74-a97d-23da-c3b75cf79602 rootwait  console=tty1 console=ttyS0,115200n8 noinit# &#125;# menuentry &quot;ImmortalWrt (failsafe)&quot; &#123;#         linux /boot/vmlinuz failsafe=true root=PARTUUID=484c7fc2-ae74-a97d-23da-c3b75cf79602 rootwait  console=tty1 console=ttyS0,1# &#125;# 或者使用以下脚本更新ROOT_BLK=&quot;$(readlink -f /sys/dev/block/&quot;$(awk -e \\&#x27;$9==&quot;/dev/root&quot;&#123;print $3&#125;&#x27; /proc/self/mountinfo)&quot;)&quot;ROOT_DISK=&quot;/dev/$(basename &quot;$&#123;ROOT_BLK%/*&#125;&quot;)&quot;ROOT_DEV=&quot;/dev/$&#123;ROOT_BLK##*/&#125;&quot;ROOT_UUID=&quot;$(partx -g -o UUID &quot;$&#123;ROOT_DEV&#125;&quot; &quot;$&#123;ROOT_DISK&#125;&quot;)&quot;sed -i -r -e &quot;s|(PARTUUID=)\\S+|\\1$&#123;ROOT_UUID&#125;|g&quot; /boot/grub/grub.cfg# 最后重启reboot\n\n软件安装docker安装后菜单不显示，尝试退出系统重新登陆\nopkg updateopkg install docker dockerd luci-app-dockerman\n\n将 docker 区域设置为 lan 区域的目标区域，以便于可以在局域网中访问 docker 应用\n\nttydttyd 是一个在线的命令行工具，安装 luci-i18n-ttyd-zh-cn 中文版本，会显示在系统菜单中，如果不显示重启设备。\npasswall安装 passwall 插件， 如果安装时提示 无法执行 opkg install 命令:SyntaxError: Unexpected end of JSON input 尝试更换其他的软件源再次尝试\n导入 x2ray 分享链接后，一定要把节点配置中 [域名] 和 [WebSocket Host] 都设置为分享链接中的域名，并在基本设置中开启主开关，选择节点后才能使用。如果配置正确还是不能使用，重新启动后再次使用。\n\nDDns由于家庭网络等外界因素，导致 IP 会不定时的修改，如果想要无论何时都能让 绑定的域名解析到当前 IP 上就需要 DDns 服务。\nDDns 服务会定时在后台检测当前 IP 是否修改，如果 IP 已经发生变动，DDns 服务会发送请求通知域名服务商，重新绑定域名解析的 IP 地址，从而实现动态域名解析。\n在 OpenWrt 软件库中安装 ddns-go 和 luci-i18n-ddns-go-zh-cn 软件包, 可以方便的选择常用的运营商进行配置。\n启用 ddns-go 服务并打开 web 界面， 跳转到 腾讯云 DNDSPOD 创建密钥。\nIPv4 中选择通过网卡获取 IP， 并添加域名。\n\n在运营商的域名解析页面，添加一条记录，先默认填入软路由的内网地址。\n\n点击保存可以看到域名已经被正确的解析\n\n外网访问内网应用本设置的目的是使用不同的二级域名访问内网的各个应用，由于 OpenWrt 的防火墙只提供网络层的接口转发，而域名访问属于应用层，需要使用 nginx 作为反向代理工具代理域名请求并指向内网地址.[说明文档]\n完整的请求过程是，外网的 https 请求进入防火墙，防火墙放行 &#x3D;&gt; 软路由配置 nginx 监听指定域名和端口的请求 &#x3D;&gt; 转发请求到内网的其他服务器\n\n在 系统 &#x3D;&gt; 软件包 中安装 luci-nginx , 由于 luci-nginx 默认配置中包括强制将 http 重定向为 https 所以在软件安装后 OpenWrt 需要重新刷新登录。\n\n如果使用 ssh 工具登录时提示以下错误\n[user@hostname ~]$ ssh root@pong@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host is6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.Please contact your system administrator.Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.Offending RSA key in /var/lib/sss/pubconf/known_hosts:4RSA host key for pong has changed and you have requested strict checking.Host key verification failed.\n\n可以使用以下命令\n# 移除 known_hosts 此 ip 的所有记录值ssh-keygen -R 192.168.3.10# 也可以使用rm ~/.ssh/known_hosts\n\n如果使用的是 ttyd 插件，可以在 ttyd 配置中开启 ssl, 证书的默认路径是\n/etc/nginx/conf.d/_lan.crt/etc/nginx/conf.d/_lan.key\n\nluci-nginx 使用 cui 统一了系统的配置，会通过 /etc/config/nginx 配置文件和模板文件(/etc/nginx/uci.conf.template) 生成 /etc/nginx/uci.conf 文件， uci.conf 文件最终会被 nginx 使用，并且 nginx 每次重启前都会重新生成此文件，因此不要手动更改生成的 /etc/nginx/uci.conf 文件中的内容。\n如果想要保持 http 访问可以修改 /etc/config/nginx 配置文件中的内容，注释掉 _lan 和 _redirect2ssl 添加一个新的配置 http_lan\nconfig main global      option uci_enable &#x27;true&#x27;#config server &#x27;_lan&#x27;#       list listen &#x27;443 ssl default_server&#x27;#       list listen &#x27;[::]:443 ssl default_server&#x27;#       option server_name &#x27;_lan&#x27;#       list include &#x27;restrict_locally&#x27;#       list include &#x27;conf.d/*.locations&#x27;#       option uci_manage_ssl &#x27;self-signed&#x27;#       option ssl_certificate &#x27;/etc/nginx/conf.d/_lan.crt&#x27;#       option ssl_certificate_key &#x27;/etc/nginx/conf.d/_lan.key&#x27;#       option ssl_session_cache &#x27;shared:SSL:32k&#x27;#       option ssl_session_timeout &#x27;64m&#x27;#       option access_log &#x27;off; # logd openwrt&#x27;#config server &#x27;_redirect2ssl&#x27;#       list listen &#x27;80&#x27;#       list listen &#x27;[::]:80&#x27;#       option server_name &#x27;_redirect2ssl&#x27;#       option return &#x27;302 https://$host$request_uri&#x27;config server &#x27;http_lan&#x27;        list listen &#x27;80&#x27;        list listen &#x27;[::]:80&#x27;        #注意不要添加这个配置规则        #因为限制了对nginx的访问地址为内网设备，会导致外网访问失效。        #list include &#x27;restrict_locally&#x27;        list include &#x27;conf.d/*.locations&#x27;\n\n使用命令 service nginx reload 重启 nginx, 这样就恢复了 http 访问\n\n重启过程中会提示错误, 可以按照提示使用 nginx -T -c ‘&#x2F;etc&#x2F;nginx&#x2F;uci.conf’ 命令测试配置文件\nroot@ImmortalWrt:~# service nginx reloadnginx_init: NOT using conf file!show config to be used by: nginx -T -c &#x27;/etc/nginx/uci.conf&#x27;\n\n如果文件报错会提示具体错误，并指明所在位置\n\n\n外网使用域名访问\n目前的网络环境是，外网使用 _.iftrue.me 访问， 内网使用 _.iftrue.club 访问， 因此配置好外网的访问端口后，可以直接把内网的请求转发到外网的监听端口\n首先配置外网域名解析， 在 cloudflare 选中域名 &#x3D;》 DNS 添加一条 AAAA 解析， Name 填入 * 表示泛域名， Content 地址临时填入一个 192.168.48.1 本地地址\n添加 DDNS GO 解析将域名同步到 cloudflare ， 需要添加一个 cloudflare Api token ， Overview &#x3D;》Get your Api token &#x3D;》create token &#x3D;》 Edit zone DNS &#x3D;》选择对应的域名， 在 DDNS GO 中添加 token, 并解析域名\n添加 cloudflare 规则， Rules &#x3D;》 Overview &#x3D;》 添加 Origin Rules &#x3D;》 可以将对域名的请求转发到特定的端口\n创建一个 Origin Certificates 用于 Origin server 和 cloudflare 之间的验证， SSL&#x2F;TSL &#x3D;&gt; Origin Certificates, 保存 PEM 和 KEY\n修改 uci 模板 /etc/nginx/uci.conf.template,在 http 模块中添加 ssl 通用配置\nssl_certificate /etc/nginx/conf.d/_lan.crt;ssl_certificate_key /etc/nginx/conf.d/_lan.key;ssl_protocols TLSv1.2 TLSv1.3;ssl_prefer_server_ciphers on;ssl_session_cache shared:SSL:10m;ssl_session_timeout 10m;\n\n将证书传到服务器的执行目录下\n\n如果使用 scp 命令包错 ash: /usr/libexec/sftp-server: not found, 需要在软件包中安装 sftp-server\n\n配置一个反向代理的案例，&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;openwrt.conf\nserver &#123;    listen      9348 ssl;    listen [::]:9348 ssl;    # qb.iftrue.club 用于内网域名的请求    server_name qb.iftrue.me qb.iftrue.club;    location / &#123;        proxy_pass http://192.168.48.189:10095;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;    &#125;&#125;\n\n最后需要防火墙放行外网请求，Incoming Ipv6 from Wan to this device ,port 9348\n\n内网使用域名访问\n给 openwrt lan 配置一个额外的 ip 用于转发，将 内网域名全部解析到此 ip， nginx 监听 443 端口，并将所有请求转发到外网的反向代理配置中\nNetwork &#x3D;》 DHCP DNS &#x3D;》 添加地址 &#x2F;iftrue.club&#x2F;192.168.48.3 把 *.iftrue.club 解析到 192.168.48.3\n# 添加一个默认规则，如果所有的都没有匹配走404server &#123;  listen 9348 default_server;  listen [::]:9348 default_server;  server_name _;  return 404;&#125;server &#123;    listen      443 ssl;    listen [::]:443 ssl;    server_name *.iftrue.club;    ssl_certificate /etc/nginx/conf.d/_club.crt;    ssl_certificate_key /etc/nginx/conf.d/_club.key;    ssl_protocols TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    ssl_session_cache shared:SSL:10m;    ssl_session_timeout 10m;    location / &#123;        proxy_pass https://192.168.48.1:9348;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;    &#125;&#125;\n\nOpenVPN软件包中安装 luci-app-openvpn-server\n\n协议 udp ipv4\n端口 1194\n客户端网段： 自动\n客户端推送配置comp-lzo adaptiveredirect-gateway def1 bypass-dhcpdhcp-option DNS 192.168.48.1 （填写 openWrt 的 IP）route 192.168.48.0 255.255.255.0 （填写 openWrt 的 网段，最后一位需要是 0）\n下载客户端配置文件，客户端安装 openvpn, 配置存放在 user&#x2F;openvpn&#x2F;client.opvn\n\n\n可以重新生成证书文件，时间比较长，需要等待浏览器加载结束\n\n点击网络接口，重新加载会多出一个 vpn0 的接口\n编辑配置文件，允许多个客户端链接\nvi /etc/config/openvpn# 添加配置option duplicate_cn &quot;1&quot;\n\n配置 NAT 转发规则，允许访问内网设备，网络 &#x3D;&gt; 防火墙 &#x3D;&gt; NAT 规则\n\nopenWrt 23.05.4 以及以后版本不需要配置\n\n# 使用 POSTROUTING 进行规则转发iptables -t nat -A POSTROUTING -o br-lan -j MASQUERADE\n\nHomeProxy 自定义路由\n创建路由节点，可以定义流量使用哪个 vpn 代理，一定要先设置，因为默认出站会用到这些节点。节点的出站选择直接出站\n\n创建 DNS 服务\n标签: Google\n类型: HTTPS\n地址: dns.google\n路径: &#x2F;dns-query\n端口: 443\n出站: 选择路由节点中最稳定的节点（BWG）\n\nDNS 设置\n默认策略: 仅 IPV4\n默认 DNS 服务器: Google\n缓存: 关闭\nEDNS 客户端子网： （202.101.172.36 浙江） 选择一个距离当前宽带运营商最近的一个 IP 地址，这可以让 Google DNS 查询的时候选择一个离运营商最近的服务器\n\n路由设置\n路由模式: 自定义路由\n绕过国内流量: 开启，可以在防火墙就直接转发国内流量，性能更好\n复写目标地址: 一般用于视频网站解锁，Google DNS 获取到了目标 IP，sing-box 通过嗅探获取到了 netflix 域名，发送的目标是代理服务器，发送数据中的内容为请求 netflix 的 IP 以及 netflix 网站的域名，当代理受到这个请求后发现当前服务器不支持解锁，导致访问失败开启复写后，发送数据中的目标地址变为 netflix 域名，当发送到代理服务器后会在代理服务器的环境中做 DNS 解析， 它获取到的不是真实 IP, 而是专门的反代服务器 IP 用于解锁。\n默认出站: 选择路由节点中最稳定的节点（BWG）\n默认 DNS 出站： Google\n\n规则集\nhttps://github.com/MetaCubeX/meta-rules-dat/raw/refs/heads/sing/geo-lite/geoip/cn.srs 国内 iphttps://github.com/MetaCubeX/meta-rules-dat/raw/refs/heads/sing/geo-lite/geosite/cn.srs 国内网址https://raw.githubusercontent.com/xmdhs/sing-box-ruleset/rule-set/AdGuardSDNSFilterSingBox.srs 广告网址\n出站选择默认，这会使用路由设置中的默认出站用于访问这些资源。\n\n路由规则\n直连，选择国内的两个规则集内网设备，可以通过 IP 来指定一个路由规则，以便于在出站时使用其他的代理 vpn\n\nDNS 规则\nBlock，选择广告的资源集，在 DNS 解析的时候就禁止访问直连，选择国内的域名规则集，DNS 服务器选择 WAN 自动下发的 DNS 服务，这样当请求一个国内的域名时，可以直接用运营商的 DNS 解析\n\n\nWireGuard安装 luci-proto-wireguard  qrencode\nNetword &#x3D;》 Interfaces &#x3D;》新建协议 Wireguard Vpn\n通用设置 &#x3D;》 生成新的密钥对 &#x3D;》 添加监听端口 &#x3D;》Ip 地址选择一个与内网不冲突的网段 10.0.6.0\n防火墙设置 &#x3D;》 加入 lan 区域\n对端设置 &#x3D;》 创建新的密钥对 &#x3D;》ip 地址选择一个网段内的 ip &#x3D;》生成二维码 &#x3D;》修改链接地址为配置了 DDNS 的域名 &#x3D;》扫描二维码或复制配置添加\n","categories":["其他"],"tags":["OpenWrt"]},{"title":"TrueNas 应用配置","url":"/posts/9aadbf0e844b/","content":"MinIO参考安装文档, 挂载点配置需要开启 ACL, 文件默认保存 export 目录下。\nNginx 配置参考MinIO 配置文档, 需要添加chunked_transfer_encoding off;\nNextCloud\ndataSet 创建父文件夹需要有以下权限 user:www-data,group:www-data,user:netdata,group:docker,user:root,group:root,user:appsuser 文件夹需要有以下权限 user:www-data,group:www-data,user:appsdata 文件夹需要有以下权限 user:www-data,group:www-data,user:appsdb 文件夹需要有以下权限 user:netdata,group:docker,user:root,group:root,user:apps\n\nAPT Packages 需要添加 ffmpeg smbclient\n\nhost 需要填写真实访问的域名\n\nDatabase Password 注意不要有 #@?&amp; 等特殊符号\n\nCertificate ID 选择默认证书，避免 nextCloud 提示警告，如果前端有 nginx 代理，需要使用 https\n\n在 config&#x2F;config.php 中添加 maintenance_window_start 消除调度任务的警告\n\nnginx配置\n\n\n虚拟机配置Nas 服务器开机虚拟化功能,配置以下字段,其余字段可以保持默认\nBoot Method ： UEFI\nCPU Mode : Host Passthrough\nSelect Disk Type : VirtIOvirtIO 是一个优化的虚拟磁盘驱动程序，专为虚拟化环境设计，提供更高的性能和较低的开销。它支持更高的数据传输速率，特别适用于 I&#x2F;O 密集型的应用场景。\nAdapter Type：VirtIO\n如果安装后提示 CD-ROM 加载错误，可以删除 CD-ROM 设备后重试\nJellyfinnginx 代理按照官方文档操作\n","categories":["其他"],"tags":["TrueNas"]},{"title":"Ubuntu20.04安装VMwarePlayer","url":"/posts/5c182e47d957/","content":"workstation 和 player之间有什么区别\n前期准备安装 build-essential\nsudo apt install build-essential\n\n下载 VMware PlayerVMware Workstation Player\n安装 VMware Player添加可执行权限\nsudo chmod a+x ./VMware-Player-xxx.bundle\n\n安装\nsudo ./VMware-Player-xxx.bundle\n\n或\nsudo sh VMware-Player-xxx.bundle\n\n启动按步骤安装 \n\n在BIOS中开启虚拟化技术一般为BIOS中，【Configuration】选项下的【Intel Virtual Technology】\n为 vmnet 和 vmmon 服务创建私有密钥官方文档中解决找不到&#x2F;dev&#x2F;vmmon的问题\n“Cannot open &#x2F;dev&#x2F;vmmon: No such file or directory” error when powering on a VM (2146460)\n最后一步执行需要用root权限执行,并输入密码\nsudo sumokutil –import MOK.der\n\n重启电脑，在UEFI BIOS中选择Enroll MOK\n\n\n\n\n\n重启后就可以正常使用\n","categories":["其他"],"tags":["Ubuntu"]},{"title":"Ubuntu20.04安装utorrent","url":"/posts/83061c23c0c9/","content":"原文\n安装虽然官网显示的最后版本是ubuntu13.04,但是仍然可以安装\n\n也可以使用下面的命令下载\n64 bits\nwget http://download-hr.utorrent.com/track/beta/endpoint/utserver/os/linux-x64-ubuntu-13-04 -O utserver.tar.gz\n\n32 bits\nwget http://download-hr.utorrent.com/track/beta/endpoint/utserver/os/linux-x64-ubuntu-13-04 -O utserver.tar.gz\n\n下载完成后把文件解压到 /opt目录\nsudo tar xvf utserver.tar.gz -C /opt/\n\n安装所需要的依赖\n文件列表\nsudo apt install libssl-devwget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl1.0/libssl1.0.0_1.0.2n-1ubuntu5.6_amd64.debsudo apt install ./libssl1.0.0_1.0.2n-1ubuntu5.3_amd64.deb\n\n创建一个链接\nsudo ln -s /opt/utorrent-server-alpha-v3_3/utserver /usr/bin/utserver\n\n通过一下命令可以启动 utorrent server,默认utorrent server监听在 0.0.0.0:8080 端口，如果被占用，请先停止占用的服务，utorrent server 同样会使用10000 和 6881 端口，添加 -daemon 参数后服务会在后台运行\nutserver -settingspath /opt/utorrent-server-alpha-v3_3/ -daemon\n\n现在可以通过图形界面来访问\nlocalhost:8080/gui\n\n请注意url中必须有gui,默认的用户名为admin,密码不用填写，登录之后可以在设置中修改，账户信息和端口\n\n再改配置后需要通过一下命令重启服务\nsudo pkill utserverutserver -settingspath /opt/utorrent-server-alpha-v3_3/ &amp;\n\n配置自动启动服务使用下面的命令创建一个系统服务\nsudo nano /etc/systemd/system/utserver.service\n\n把下面的配置添加到文件中，因为我们使用的是系统服务，所以不需要加-daemon\n[Unit]Description=uTorrent ServerAfter=network.target[Service]Type=simpleUser=utorrentGroup=utorrentExecStart=/usr/bin/utserver -settingspath /opt/utorrent-server-alpha-v3_3/ExecStop=/usr/bin/pkill utserverRestart=alwaysSyslogIdentifier=uTorrent Server[Install]WantedBy=multi-user.target\n\n按下 Ctrl+O ， 按下 Enter键保存文件，按 Ctrl+X 退出，然后重新加载\nsudo systemctl daemon-reload\n\n注意：以root权限运行 utorrent server是不被允许的，我们已经在server的文件中明确规定了utorrent server 必须以utorrent用户&#x2F;组来运行，所以用下面的命令来添加这个用户\nsudo adduser --system --group utorrent\n\n启动服务\nsudo systemctl start utserver\n\n添加开机启动项\nsudo systemctl enable utserver\n\n检查服务\nsystemctl status utserver","categories":["其他"],"tags":["Ubuntu"]},{"title":"Dify 工作流","url":"/posts/280eafda3a35/","content":"下载 Dify 源码git clone https://github.com/langgenius/dify.git\n\n启动 Dify进入 Dify 源代码的 docker 目录，执行一键启动命令：\ncd dify/dockerdocker compose up -d\n\n如果您的系统安装了 Docker Compose V2 而不是 V1，请使用 docker compose 而不是 docker-compose。通过$ docker compose version 检查版本号：Docker\n[+] Running 7/7✔ Container docker-web-1 Started 1.0s✔ Container docker-redis-1 Started 1.1s✔ Container docker-weaviate-1 Started 0.9s✔ Container docker-db-1 Started 0.0s✔ Container docker-worker-1 Started 0.7s✔ Container docker-api-1 Started 0.8s✔ Container docker-nginx-1 Started\n\n检查容器是否正常运行,包括 3 个业务服务 api &#x2F; worker &#x2F; web，以及 4 个基础组件 weaviate &#x2F; db &#x2F; redis &#x2F; nginx，都要处于启动状态。注意下面每一个服务的 status 都要是 Up 状态才算真正启动成功。\ndocker compose psNAME IMAGE COMMAND SERVICE CREATED STATUS PORTSdocker-api-1 langgenius/dify-api:0.3.2 &quot;/entrypoint.sh&quot; api 4 seconds ago Up 2 seconds 80/tcp, 5001/tcpdocker-db-1 postgres:15-alpine &quot;docker-entrypoint.s…&quot; db 4 seconds ago Up 2 seconds 0.0.0.0:5432-&gt;5432/tcpdocker-nginx-1 nginx:latest &quot;/docker-entrypoint.…&quot; nginx 4 seconds ago Up 2 seconds 0.0.0.0:80-&gt;80/tcpdocker-redis-1 redis:6-alpine &quot;docker-entrypoint.s…&quot; redis 4 seconds ago Up 3 seconds 6379/tcpdocker-weaviate-1 semitechnologies/weaviate:1.18.4 &quot;/bin/weaviate --hos…&quot; weaviate 4 seconds ago Up 3 secondsdocker-web-1 langgenius/dify-web:0.3.2 &quot;/entrypoint.sh&quot; web 4 seconds ago Up 3 seconds 80/tcp, 3000/tcpdocker-worker-1 langgenius/dify-api:0.3.2 &quot;/entrypoint.sh&quot; worker 4 seconds ago Up 2 seconds 80/tcp, 5001/tcp\n\n升级 Dify进入 Dify 源代码的 docker 目录，按顺序执行以下命令：\ncd dify/dockergit pull origin maindocker compose downdocker compose pulldocker compose up -d\n\nFAQ\n首页正常显示，当点击设置管理员用户页面一直在加载中，浏览器控制台报错,\n\n/console/api/setup 502\n\n检查服务的状态 status 栏并是不是 Up 状态\ndocker compose ps\n\n查看日志\ndocker logs docker-api-1\n\n\n这是由于 Docker 运行权限不够，需要被赋予更高的权限。\n在 docker-compose.yaml 文件中，给 services 下每一个 service 最后一行都加上 privileged: true,然后重新启动 Dify 即可。\n\n由于在第一个问题中，Ubuntu 系统中，本地修改了 docker-compose.yaml 文件，在使用 git pull origin main 会提示本地有文件没有提交：\n\nerror: Your local changes to the following files would be overwritten by merge:docker/docker-compose.yamlPlease, commit your changes or stash them before you can merge.# 需要提交修改git config --global user.email &quot;xxx&quot;git config --global user.name &quot;xxx&quot;git add docker-compose.yamlgit commit -m &quot;local change&quot;\n\n\nDocker 无法拉取镜像\n\n// daemon.json可能会不存在，直接 vi /etc/docker/daemon.json可以创建sudo vi /etc/docker/daemon.json&#123;  &quot;registry-mirrors&quot;: [&quot;新的镜像源地址&quot;]&#125;systemctl restart  docker //重启dockerdocker info //查看镜像源有没有配置成功\n","categories":["其他"],"tags":["AI","Dify"]},{"title":"Puppeteer + 火山 OCR 实现自动登录和爬虫操作","url":"/posts/999fc3e99003/","content":"火山 OCR Api 接入需要在用户中心获取 AK,SK 密钥\n// request.js&quot;use strict&quot;;const crypto = require(&quot;crypto&quot;);const util = require(&quot;util&quot;);const url = require(&quot;url&quot;);const qs = require(&quot;querystring&quot;);const fs = require(&quot;fs&quot;);/** * 不参与加签过程的 header key */const HEADER_KEYS_TO_IGNORE = new Set([  &quot;authorization&quot;,  &quot;content-type&quot;,  &quot;content-length&quot;,  &quot;user-agent&quot;,  &quot;presigned-expires&quot;,  &quot;expect&quot;,]);// do request examplefunction request(signParams) &#123;  signParams.headers = &#123;    ...signParams.headers,    [&quot;X-Date&quot;]: getDateTimeNow(),  &#125;;  signParams.bodySha = getBodySha(signParams.body);  // 正规化 query object， 防止串化后出现 query 值为 undefined 情况  for (const [key, val] of Object.entries(signParams.query)) &#123;    if (val === undefined || val === null) &#123;      signParams.query[key] = &quot;&quot;;    &#125;  &#125;  const authorization = sign(signParams);  return fetch(    `https://iam.volcengineapi.com/?$&#123;qs.stringify(signParams.query)&#125;`,    &#123;      headers: &#123;        ...signParams.headers,        Authorization: authorization,      &#125;,      method: signParams.method,      body: signParams.body,    &#125;  );&#125;function sign(params) &#123;  const &#123;    headers = &#123;&#125;,    query = &#123;&#125;,    region = &quot;&quot;,    serviceName = &quot;&quot;,    method = &quot;&quot;,    pathName = &quot;/&quot;,    accessKeyId = &quot;&quot;,    secretAccessKey = &quot;&quot;,    needSignHeaderKeys = [],    bodySha,  &#125; = params;  const datetime = headers[&quot;X-Date&quot;];  const date = datetime.substring(0, 8); // YYYYMMDD  // 创建正规化请求  const [signedHeaders, canonicalHeaders] = getSignHeaders(    headers,    needSignHeaderKeys  );  const canonicalRequest = [    method.toUpperCase(),    pathName,    queryParamsToString(query) || &quot;&quot;,    `$&#123;canonicalHeaders&#125;\\n`,    signedHeaders,    bodySha || hash(&quot;&quot;),  ].join(&quot;\\n&quot;);  const credentialScope = [date, region, serviceName, &quot;request&quot;].join(&quot;/&quot;);  // 创建签名字符串  const stringToSign = [    &quot;HMAC-SHA256&quot;,    datetime,    credentialScope,    hash(canonicalRequest),  ].join(&quot;\\n&quot;);  // 计算签名  const kDate = hmac(secretAccessKey, date);  const kRegion = hmac(kDate, region);  const kService = hmac(kRegion, serviceName);  const kSigning = hmac(kService, &quot;request&quot;);  const signature = hmac(kSigning, stringToSign).toString(&quot;hex&quot;);  return [    &quot;HMAC-SHA256&quot;,    `Credential=$&#123;accessKeyId&#125;/$&#123;credentialScope&#125;,`,    `SignedHeaders=$&#123;signedHeaders&#125;,`,    `Signature=$&#123;signature&#125;`,  ].join(&quot; &quot;);&#125;function hmac(secret, s) &#123;  return crypto.createHmac(&quot;sha256&quot;, secret).update(s, &quot;utf8&quot;).digest();&#125;function hash(s) &#123;  return crypto.createHash(&quot;sha256&quot;).update(s, &quot;utf8&quot;).digest(&quot;hex&quot;);&#125;function queryParamsToString(params) &#123;  return Object.keys(params)    .sort()    .map((key) =&gt; &#123;      const val = params[key];      if (typeof val === &quot;undefined&quot; || val === null) &#123;        return undefined;      &#125;      const escapedKey = uriEscape(key);      if (!escapedKey) &#123;        return undefined;      &#125;      if (Array.isArray(val)) &#123;        return `$&#123;escapedKey&#125;=$&#123;val          .map(uriEscape)          .sort()          .join(`&amp;$&#123;escapedKey&#125;=`)&#125;`;      &#125;      return `$&#123;escapedKey&#125;=$&#123;uriEscape(val)&#125;`;    &#125;)    .filter((v) =&gt; v)    .join(&quot;&amp;&quot;);&#125;function getSignHeaders(originHeaders, needSignHeaders) &#123;  function trimHeaderValue(header) &#123;    return header.toString?.().trim().replace(/\\s+/g, &quot; &quot;) ?? &quot;&quot;;  &#125;  let h = Object.keys(originHeaders);  // 根据 needSignHeaders 过滤  if (Array.isArray(needSignHeaders)) &#123;    const needSignSet = new Set(      [...needSignHeaders, &quot;x-date&quot;, &quot;host&quot;].map((k) =&gt; k.toLowerCase())    );    h = h.filter((k) =&gt; needSignSet.has(k.toLowerCase()));  &#125;  // 根据 ignore headers 过滤  h = h.filter((k) =&gt; !HEADER_KEYS_TO_IGNORE.has(k.toLowerCase()));  const signedHeaderKeys = h    .slice()    .map((k) =&gt; k.toLowerCase())    .sort()    .join(&quot;;&quot;);  const canonicalHeaders = h    .sort((a, b) =&gt; (a.toLowerCase() &lt; b.toLowerCase() ? -1 : 1))    .map((k) =&gt; `$&#123;k.toLowerCase()&#125;:$&#123;trimHeaderValue(originHeaders[k])&#125;`)    .join(&quot;\\n&quot;);  return [signedHeaderKeys, canonicalHeaders];&#125;function uriEscape(str) &#123;  try &#123;    return encodeURIComponent(str)      .replace(/[^A-Za-z0-9_.~\\-%]+/g, escape)      .replace(        /[*]/g,        (ch) =&gt; `%$&#123;ch.charCodeAt(0).toString(16).toUpperCase()&#125;`      );  &#125; catch (e) &#123;    return &quot;&quot;;  &#125;&#125;function getDateTimeNow() &#123;  const now = new Date();  return now.toISOString().replace(/[:-]|\\.\\d&#123;3&#125;/g, &quot;&quot;);&#125;// 获取 body sha256function getBodySha(body) &#123;  const hash = crypto.createHash(&quot;sha256&quot;);  if (typeof body === &quot;string&quot;) &#123;    hash.update(body);  &#125; else if (body instanceof url.URLSearchParams) &#123;    hash.update(body.toString());  &#125; else if (util.isBuffer(body)) &#123;    hash.update(body);  &#125;  return hash.digest(&quot;hex&quot;);&#125;module.exports = request;\n\npuppeteer 爬虫const puppeteer = require(&quot;puppeteer&quot;);const fs = require(&quot;fs&quot;);const request = require(&quot;./request&quot;);// const &#123; createWorker &#125; = require(&quot;tesseract.js&quot;);// const worker = await createWorker(&quot;eng&quot;);// const ret = await worker.recognize(fs.readFileSync(&quot;./authCode.jpg&quot;));// console.log(ret.data.text);(async () =&gt; &#123;  const browser = await puppeteer.launch(&#123;    headless: true,    defaultViewport: &#123; width: 1400, height: 900 &#125;,  &#125;);  const page = await browser.newPage();  // 设置导航的默认超时时间为永不超时  page.setDefaultNavigationTimeout(0);  // 如果添加请求拦截器，需要添加下面一句代码  // 如果使用响应拦截器，则不需要添加，添加会导致代码不向下执行  //  await page.setRequestInterception(true);  page.on(&quot;response&quot;, async (response) =&gt; &#123;    const url = response.url();    // 拦截验证码图片，保存到本地    if (url.includes(&quot;image.php&quot;)) &#123;      const img = await response.buffer();      fs.writeFileSync(`./authCode.jpg`, img);    &#125;  &#125;);  await Promise.all([    page.waitForNavigation(),    page.goto(&quot;https://hdsky.me/login.php&quot;),  ]);  await page.type(&quot;input[name=&#x27;username&#x27;]&quot;, &quot;username&quot;);  await page.type(&quot;input[name=&#x27;password&#x27;]&quot;, &quot;password&quot;);  // 调用 OCR api 识别验证码  const AccessKeyId = &quot;___YOUR_ACCESS_KEY___&quot;;  const SecretKey = &quot;___YOUR_SECRET_KEY___&quot;;  const img = fs.readFileSync(&quot;./authCode.jpg&quot;);  const imgBase64 = img.toString(&quot;base64&quot;);  const body = new URLSearchParams();  body.append(&quot;image_base64&quot;, imgBase64);  const &#123;    data: &#123;      line_texts: [authCode],    &#125;,  &#125; = await request(&#123;    headers: &#123;      // 火山文档提示必传，但是 sdk 会过滤掉      &quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;,    &#125;,    method: &quot;POST&quot;,    // api 文档必填参数    query: &#123;      Action: &quot;OCRNormal&quot;,      Version: &quot;2020-08-26&quot;,    &#125;,    accessKeyId: AccessKeyId,    secretAccessKey: SecretKey,    serviceName: &quot;cv&quot;,    region: &quot;cn-north-1&quot;,    body,  &#125;).then((res) =&gt; res.json());  console.log(authCode);  await page.type(&quot;input[name=&#x27;imagestring&#x27;]&quot;, authCode);  // 点击事件导致页面导航，需要等待导航结束  await Promise.all([    page.waitForNavigation(),    page.click(&quot;input[type=&#x27;submit&#x27;]&quot;),  ]);  await Promise.all([    page.waitForNavigation(),    page.click(&quot;a[href=&#x27;torrents.php&#x27;]&quot;),  ]);  const loop = async (startPage) =&gt; &#123;    const list = await page.$$(&quot;table tr[class*=progresstr]&quot;);    for (let i = 0; i &lt; list.length; i++) &#123;      const item = list[i];      // 监听新页面创建事件，并获取详情页的 page 对象      const detailPromise = new Promise((resolve) =&gt; &#123;        browser.once(&quot;targetcreated&quot;, async (target) =&gt; &#123;          if (target.type() === &quot;page&quot;) &#123;            const newPage = await target.page();            resolve(newPage);          &#125;        &#125;);      &#125;);      const a = await item.$(        &quot;td:nth-child(2) table &gt; tbody &gt; tr &gt; td:nth-child(1) &gt; a&quot;      );      await a.click();      const detailPage = await detailPromise;      await detailPage.waitForSelector(&quot;#saythanks&quot;, &#123;        timeout: 0,      &#125;);      await detailPage.click(&quot;#saythanks&quot;);      console.log(`第 $&#123;startPage&#125; 页，第 $&#123;i + 1&#125; 条已点赞`);      await new Promise((resolve) =&gt; setTimeout(resolve, 4000));      await detailPage.close();    &#125;  &#125;;  const loop2 = async () =&gt; &#123;    const startPage = fs.readFileSync(&quot;./skypage.txt&quot;, &quot;utf8&quot;);    const search = await page.$(&quot;input[type=number]:nth-child(2)&quot;);    await search.click(&#123; clickCount: 3 &#125;);    await search.type(startPage);    await Promise.all([      page.waitForNavigation(),      page.click(&quot;input[type=submit]:nth-child(3)&quot;),    ]);    await loop(startPage);    if (startPage &gt; 0) &#123;      fs.writeFileSync(&quot;./skypage.txt&quot;, (startPage - 1).toString(), &quot;utf8&quot;);      loop2();    &#125;  &#125;;  loop2();  // await browser.close();&#125;)();\n\ndebian 执行任务报错Failed to launch the browser process: error while loading shared libraries: libnss3.so: cannot open shared object file\n可能是没想相关的执行环境安装以下依赖\nsudo apt-get install libpangocairo-1.0-0 libx11-xcb1 libxcomposite1 libxcursor1 libxdamage1 libxi6 libxtst6 libnss3 libcups2 libxss1 libxrandr2 libasound2 libatk1.0-0 libgtk-3-0sudo apt-get install -y libgbm-dev\n\n","categories":["其他"],"tags":["Puppeteer"]},{"title":"manjaro美化","url":"/posts/83a61cb886df/","content":"添加 archlinux 源mirrorlist-repo 官方仓库地址\n# /etc/pacman.conf[archlinuxcn]Server = https://repo.archlinuxcn.org/$arch\n\n设置源\n软件仓库中选择 Preferences, use mirrors 选择指定源\n\n通过命令行选择\n# 手动选择镜像列表sudo pacman-mirrors -i -c China -m rank# 自动生成配置列表 -g 表示从活动池中选择镜像列表sudo pacman-mirrors -c China -g\n\n更新系统sudo pacman -Syyu\n\n安装 yay 助手sudo pacman -S yay\n\n输入法Fcitx5\nsudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-material-color\n\n系统设置中添加拼音输入法\n\n配置环境变量，让应用程序可以使用输入法\n# /etc/environmentGTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitx\n\n配置插件：\n\n点击 configure addons, 选择 classic user interface 勾选 use per screen DPI, 保证输入法随系统缩放。\n\n设置联想:\n\n使用云拼音实现联想功能\n点击 configure addons, 选择 PinYin, 开启云拼音，并选择 Baidu\n\n\noh-my-zshoh-my-zsh\nSSHGNOME&#x2F;Keyring\n如果安装的是 KDE 桌面等桌面环境的版本，可能无法自动获取 SSH Key 的密码，导致每次使用都会提示输入密钥密码\n安装 Cinnamon 它是一个独立的桌面环境，包含了 Keyring 所需要的工具包，首次认证会弹出一个 GUI 窗口填写密码，后续可以免密登录\nyay cinnamon\n\n开启 gcr 守护进程\nsystemctl --user enable --now gcr-ssh-agent.service\n\n添加环境变量\nexport SSH_AUTH_SOCK=&quot;$&#123;XDG_RUNTIME_DIR&#125;/gcr/ssh&quot;\n\n\n虚拟化环境配置显卡直通X11 环境中强制 Xorg 使用 NVIDIA GPU, 需要注意 PCI设备不要填错， 通过命令lspci | grep -i nvidia 查看\nsudo rm /etc/X11/xorg.confsudo nvidia-xconfig --busid=PCI:1:0:0 --force-generate\n\n设置环境变量\necho &#x27;export __NV_PRIME_RENDER_OFFLOAD=1&#x27; &gt;&gt; ~/.zshrcecho &#x27;export __GLX_VENDOR_LIBRARY_NAME=nvidia&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc\n\n","categories":["其他"],"tags":["Linux","Manajro"]},{"title":"nginx 证书自动续期","url":"/posts/09fa145bf28a/","content":"目标使用 acme.sh 提供的自动化工具实现证书自动续期。\n登录服务器登录服务器并切换为 root 用户\n安装 acme.sh其中会下载 github 资源，尽可能切换为可用网络直接安装\ncurl https://get.acme.sh | sh -s email=&lt;替换自己的邮箱&gt;\n\n域名授权&#x2F;申请证书整个过程参考 ACME 自动化快速入门\n在 https://freessl.cn/ 选择 ACME 自动化 注册账号并登录\n首先添加域名并在购买的云服务器上验证，验证通过后申请证书。\n选择相关域名后会提示申请证书命令。 例如：\nbash /root/acme.sh/.acme.sh --issue -d &lt;你的域名&gt; --dns dns_dp --server https://acme.freessl.cn/v2/DV90/directory/xxxx-xxx\n\n找到合适的目录执行脚本,证书文件会在当前执行目录中生成。 需要注意 .acme.sh 的路径是否可以访问， 如果无法找到该命令，可以切换为相对根路径的地址。\n执行后会生成证书文件，如下\n[Thu Aug  1 22:23:17 CST 2024] Your cert is in: /root/.acme.sh/home.iftrue.club_ecc/home.iftrue.club.cer             # 证书文件 对应 nginx 中 cert.pem[Thu Aug  1 22:23:17 CST 2024] Your cert key is in: /root/.acme.sh/home.iftrue.club_ecc/home.iftrue.club.key         # 私钥文件 对应 nginx 中 cert.key[Thu Aug  1 22:23:17 CST 2024] The intermediate CA cert is in: /root/.acme.sh/home.iftrue.club_ecc/ca.cer[Thu Aug  1 22:23:17 CST 2024] And the full-chain cert is in: /root/.acme.sh/home.iftrue.club_ecc/fullchain.cer\n\n自动续期执行 ACME 自动化快速入门中提示的脚本, 执行命令的位置需要在生成证书的路径下。\nbash /root/acme.sh/.acme.sh --install-cert -d &lt;你的域名&gt;--key-file /etc/nginx/conf.d/cert.key            # nginx 配置路径中证书的路径--fullchain-file /etc/nginx/conf.d/cert.pem      # nginx 配置路径中私钥的路径--reloadcmd &quot;nginx -s reload&quot;                    # 重启 nginx 命令\n\nacme.sh 会在证书还有 30 天到到期时尝试自动续期。\n","categories":["其他"],"tags":["证书"]},{"title":"inotify + rsync 实现数据本地实时备份","url":"/posts/e5a73bbf0194/","content":"实现过程用 inotify 工具监听文件改变，将改变的文件使用 rsync 同步\ninotify介绍inotify 是一种强大的、细粒度的、异步文件系统监控机制，它满足各种各样的文件监控需要，可以监控文件系统的访问属性、读写属性、权限属性、创建删除、移动等操作，也可以监控文件发生的一切变化。\ninotify-tools 是一个C库和一组命令行的工作提供Linux下inotify的简单接口。\ninotify-tools 中包含 inotifywait 和 inotifywatch 两个命令\ninotifywatch 命令用于收集关于被监控的文件系统的统计数据，包括每个inotify事件发生多少次。\n[root@backup ~]# inotifywait --helpinotifywait 3.14Wait for a particular event on a file or set of files.Usage: inotifywait [ options ] file1 [ file2 ] [ file3 ] [ ... ]Options:    -h|--help         Show this help text.    @&lt;file&gt;           Exclude the specified file from being watched.    --exclude &lt;pattern&gt;                      Exclude all events on files matching the                      extended regular expression &lt;pattern&gt;.指定排除部分文件    --excludei &lt;pattern&gt;                      Like --exclude but case insensitive.（同上，排除且忽略大小写）    -m|--monitor      Keep listening for events forever.  Without                      this option, inotifywait will exit after one                      event is received.(持续监听）    -d|--daemon       Same as --monitor, except run in the background                      logging events to a file specified by --outfile.                      Implies --syslog.（daemon模式）    -r|--recursive    Watch directories recursively.（递归子目录）    --fromfile &lt;file&gt;                      Read files to watch from &lt;file&gt; or &#x27;-&#x27; for stdin.    -o|--outfile &lt;file&gt;                      Print events to &lt;file&gt; rather than stdout. （将事件输出到文件，而不是屏幕）    -s|--syslog       Send errors to syslog rather than stderr.    -q|--quiet        Print less (only print events).（打印事件）    -qq               Print nothing (not even events).（不打印事件）    --format &lt;fmt&gt;    Print using a specified printf-like format                      string; read the man page for more details. (设置打印格式%T时间；%w触发事件文件所在绝对路径；%f触发事件文件名称；%e触发的事件名称；)    --timefmt &lt;fmt&gt;    strftime-compatible format string for use with                      %T in --format string.（指定输出内容，相当于将时间赋值给%T）    -c|--csv          Print events in CSV format.    -t|--timeout &lt;seconds&gt;                      When listening for a single event, time out after                      waiting for an event for &lt;seconds&gt; seconds.                      If &lt;seconds&gt; is 0, inotifywait will never time out.    -e|--event &lt;event1&gt; [ -e|--event &lt;event2&gt; ... ]        Listen for specific event(s).  If omitted, all events are         listened for.（指定要监听的事件，多个事件用逗号隔开）Exit status:    0  -  An event you asked to watch for was received.    1  -  An event you did not ask to watch for was received          (usually delete_self or unmount), or some error occurred.    2  -  The --timeout option was given and no events occurred          in the specified interval of time.Events:     （事件）    access        file or directory contents were read    modify        file or directory contents were written    attrib        file or directory attributes changed    close_write    file or directory closed, after being opened in                   writeable mode    close_nowrite    file or directory closed, after being opened in                   read-only mode    close        file or directory closed, regardless of read/write mode    open        file or directory opened    moved_to    file or directory moved to watched directory    moved_from    file or directory moved from watched directory    move        file or directory moved to or from watched directory    create        file or directory created within watched directory    delete        file or directory deleted within watched directory    delete_self    file or directory was deleted    unmount        file system containing file or directory unmounted\n\n示例 监听&#x2F;backup&#x2F;目录下所有文件和目录的增删改操作\ninotifywait -mrq -e &#x27;create,delete,close_write,attrib,moved_to&#x27; --timefmt &#x27;%Y-%m-%d %H:%M&#x27; --format &#x27;%T %w%f %e&#x27; /backup/\n\nrsync介绍rsync是可以实现增量备份的工具。配合任务计划，rsync能实现定时或间隔同步，配合inotify或sersync，可以实现触发式的实时同步。\nRsync的命令格式可以为以下六种：\nrsync [OPTION]... SRC DESTrsync [OPTION]... SRC [USER@]HOST:DESTrsync [OPTION]... [USER@]HOST:SRC DESTrsync [OPTION]... [USER@]HOST::SRC DESTrsync [OPTION]... SRC [USER@]HOST::DESTrsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n\n对应于以上六种命令格式，rsync有六种不同的工作模式：\n　　1)拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号”:”分隔符时就启动这种工作模式。如：rsync -a &#x2F;data &#x2F;backup\n　　2)使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号”:”分隔符时启动该模式。如：rsync -avz *.c foo:src\n　　3)使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号”:”分隔符时启动该模式。如：rsync -avz foo:src&#x2F;bar &#x2F;data\n　　4)从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含”::”分隔符时启动该模式。如：rsync -av &#114;&#x6f;&#111;&#x74;&#x40;&#49;&#x37;&#50;&#46;&#49;&#54;&#x2e;&#55;&#56;&#46;&#49;&#x39;&#x32;::www &#x2F;databack\n　　5)从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含”::”分隔符时启动该模式。如：rsync -av &#x2F;databack &#114;&#x6f;&#111;&#116;&#x40;&#x31;&#x37;&#x32;&#x2e;&#49;&#x36;&#x2e;&#55;&#56;&#x2e;&#49;&#57;&#x32;::www\n　　6)列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync:&#x2F;&#x2F;172.16.78.192&#x2F;www\nrsync参数的具体解释如下：\n-v, --verbose 详细模式输出-q, --quiet 精简输出模式-c, --checksum 打开校验开关，强制对文件传输进行校验-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD-r, --recursive 对子目录以递归模式处理-R, --relative 使用相对路径信息-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。--backup-dir 将备份文件(如~filename)存放在在目录下。-suffix=SUFFIX 定义备份文件前缀-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)-l, --links 保留软链结-L, --copy-links 想对待常规文件一样处理软链结--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结--safe-links 忽略指向SRC路径目录树以外的链结-H, --hard-links 保留硬链结-p, --perms 保持文件权限-o, --owner 保持文件属主信息-g, --group 保持文件属组信息-D, --devices 保持设备文件信息-t, --times 保持文件时间信息-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间-n, --dry-run现实哪些文件将被传输-W, --whole-file 拷贝文件，不进行增量检测-x, --one-file-system 不要跨越文件系统边界-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节-e, --rsh=COMMAND 指定使用rsh、ssh方式进行数据同步--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件--delete 删除那些DST中SRC没有的文件--delete-excluded 同样删除接收端那些被该选项指定排除的文件--delete-after 传输结束以后再删除--ignore-errors 及时出现IO错误也进行删除--max-delete=NUM 最多删除NUM个文件--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输--force 强制删除目录，即使不为空--numeric-ids 不将数字的用户和组ID匹配为用户名和组名--timeout=TIME IP超时时间，单位为秒-I, --ignore-times 不跳过那些有同样的时间和长度的文件--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0-T --temp-dir=DIR 在DIR中创建临时文件--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份-P 等同于 --partial--progress 显示备份过程-z, --compress 对备份的文件在传输时进行压缩处理--exclude=PATTERN 指定排除不需要传输的文件模式--include=PATTERN 指定不排除而需要传输的文件模式--exclude-from=FILE 排除FILE中指定模式的文件--include-from=FILE 不排除FILE指定模式匹配的文件--version 打印版本信息--address 绑定到特定的地址--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件--port=PORT 指定其他的rsync服务端口--blocking-io 对远程shell使用阻塞IO-stats 给出某些文件的传输状态--progress 在传输时现实传输过程--log-format=formAT 指定日志文件格式--password-file=FILE 从FILE中得到密码--bwlimit=KBPS 限制I/O带宽，KBytes per second-h, --help 显示帮助信息\n\n示例1 将&#x2F;etc&#x2F;fstab拷贝到&#x2F;tmp目录下。\nrsync /etc/fstab /tmp\n\n示例2 将&#x2F;etc&#x2F;cron.d目录拷贝到&#x2F;tmp下。\nrsync -r /etc/cron.d /tmp\n\n说明：为了保持文件夹一致，可以将路径写为\nrsync -avr /src/ /backup/\n\n这样src下面的所有目录会被备份到 backup目录下面,而不会在backup文件夹下面创建src文件夹\n创建同步脚本#!/bin/bashfn() &#123;\tsrc=$1     # 需要同步的源路径\tdes=$2     # 目标路径\tcd $&#123;src&#125; #定位到源文件下面\t# 此方法中，由于rsync同步的特性，这里必须要先cd到源目录，inotify再监听 ./ 才能rsync同步后目录结构一致\t# 把监控到有发生更改的&quot;文件路径列表&quot;循环\t/usr/bin/inotifywait -mrq --format &#x27;%Xe %w%f&#x27; -e modify,create,delete,attrib,close_write,move ./ | while read file; do\t\tINO_EVENT=$(echo $file | awk &#x27;&#123;print $1&#125;&#x27;) # 把inotify输出切割 把事件类型部分赋值给INO_EVENT\t\tINO_FILE=$(echo $file | awk &#x27;&#123;print $2&#125;&#x27;)  # 把inotify输出切割 把文件路径部分赋值给INO_FILE\t\techo &quot;-------------------------------$(date)------------------------------------&quot;\t\techo $file\t\t#增加、修改、写入完成、移动进事件\t\t#增、改放在同一个判断，因为他们都肯定是针对文件的操作，即使是新建目录，要同步的也只是一个空目录，不会影响速度。\t\tif [[ $INO_EVENT =~ &#x27;CREATE&#x27; ]] || [[ $INO_EVENT =~ &#x27;MODIFY&#x27; ]] || [[ $INO_EVENT =~ &#x27;CLOSE_WRITE&#x27; ]] || [[ $INO_EVENT =~ &#x27;MOVED_TO&#x27; ]]; then # 判断事件类型\t\t\techo &#x27;CREATE or MODIFY or CLOSE_WRITE or MOVED_TO&#x27;\t\t\t# INO_FILE变量代表路径  -c校验文件内容\t\t\trsync -avzcR $(dirname $&#123;INO_FILE&#125;) $&#123;des&#125;\t\t\t#上面的rsync同步命令 源是用了$(dirname $&#123;INO_FILE&#125;)变量 即每次只针对性的同步发生改变的文件的目录\t\t\t#只同步目标文件的方法在生产环境的某些极端环境下会漏文件 现在可以在不漏文件下也有不错的速度 做到平衡)\t\t\t#然后用-R参数把源的目录结构递归到目标后面 保证目录结构一致性\t\tfi\t\t#删除、移动出事件\t\tif [[ $INO_EVENT =~ &#x27;DELETE&#x27; ]] || [[ $INO_EVENT =~ &#x27;MOVED_FROM&#x27; ]]; then\t\t\techo &#x27;DELETE or MOVED_FROM&#x27;\t\t\t#并加上--delete来删除目标上有而源中没有的文件，这里不能做到指定文件删除，如果删除的路径越靠近根，则同步的目录月多，同步删除的操作就越花时间。\t\t\trsync -avzr --delete $(dirname $&#123;INO_FILE&#125;) $&#123;des&#125;\t\tfi\t\t#修改属性事件 指 touch chmod chown等操作\t\tif [[ $INO_EVENT =~ &#x27;ATTRIB&#x27; ]]; then\t\t\techo &#x27;ATTRIB&#x27;\t\t\tif [ ! -d &quot;$INO_FILE&quot; ]; then # 如果修改属性的是目录 则不同步，因为同步目录会发生递归扫描，等此目录下的文件发生同步时，rsync会顺带更新此目录。\t\t\t\trsync -avzcR $(dirname $&#123;INO_FILE&#125;) $&#123;des&#125;\t\t\tfi\t\tfi\tdone &#125;fn /home/supreme/Workspace/ /media/supreme/yes/Workspace/ &amp; #加上&amp;符号表示在后台执行fn 源路径2 目标路径2 &amp; #加上&amp;符号表示在后台执行\n\n添加开机启动项将写好的脚本放到指定目录中\nsudo cp ./sync.sh /usr/sbin\n创建一个服务文件 sync.service\nsystemd有系统和用户区分；系统（&#x2F;user&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;）、用户（&#x2F;etc&#x2F;lib&#x2F;systemd&#x2F;user&#x2F;）.\n一般系统管理员手工创建的单元文件建议存放在&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;目录下面。\n[Unit]Description= 服务的简单描述Documentation= 服务文档# Before、After:定义启动顺序。Before=xxx.service,代表本服务在xxx.service启动之前启动。After=xxx.service,代表本服务在xxx.service之后启动。After=network.target[Service]# systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程 daemon# 除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 PIDFile=，以便systemd能够跟踪服务的主进程。Type=forkingExecStart=/usr/sbin/sync.sh[Install]# 单元被允许运行需要的弱依赖性单元，WantBy从Want列表获得依赖信息。WantedBy=multi-user.target\n\n添加开机启动并重载服务\nsudo systemctl daemon-reloadsudo systemctl enable sync.servicesudo systemctl start sync.servicesudo systemctl stop sync.servicesudo systemctl reload sync.service","categories":["其他"],"tags":["Ubuntu","rsync","inotify"]},{"title":"VMWare 使用SSH链接","url":"/posts/a3838b1f2d96/","content":"SSH客户端与服务端openssh-client 客户端,如果想通过 ssh 链接其他服务器需要安装客户端\nssh-server 服务端,如果想让其他机器通过 ssh 链接本机,需要在本机开机 ssh 服务,即安装服务端\nUbuntu server版 默认没有安装 ssh-clientUbuntu 桌面版    默认没有安装 ssh-server\nUbuntu 安装 ssh 客户端或服务端\n$ sudo apt-get update //更新软件源$ sudo apt-get install openssh-client //安装openssh-client$ sudo apt-get install openssh-server //安装openssh-server$ sudo service ssh start //启动ssh服务\n\ncentOS 安装 ssh\n# 搜索 ssh 包名yum search opensshyum install openssh-clients.x86_64yum install openssh-server.x86_64\n\n检查虚拟机是否安装了 ssh-server\nps -e | grep ssh# 1512 00:00:00 sshd\n\nVMWare 配置查询 IP查询宿主机和虚拟机的 ip 备用\n \n宿主机IP\n \n虚拟机IP\n建立映射接下来就需要将宿主机和虚拟机的IP映射起来。\n打开VMware的虚拟网络编辑器（编辑&gt;虚拟网络编辑器）：\n\n检查子网Ip(Subnet IP) 和 子网掩码(Subnet mask), 正常情况下无需修改\n如果保存时报错 子网ip和子网掩码不匹配,请检查子网IP, 格式为 xxx.xxx.xxx.0 他与子网掩码 255.255.255.0 对应\n不可以写为 xxx.xxx.xxx.120 等其他数字,这表示具体子网中的一个网络设备,并不是子网IP\n配置完成后可以使用 ssh 工具链接\nssh root@192.168.255.128","categories":["其他"],"tags":["Linux","VMWare"]},{"title":"VMWare 配置桥接模式","url":"/posts/30cddabb36aa/","content":"桥接模式配置\n管理员模式启动VMware \n\nVMware虚拟网络管理中，选择桥接模式并选择当前网卡\n\n\n虚拟机网络配置，选择桥接模式\n\n\n虚拟机网络链接配置，选择手动模式ip 地址前三位相同，最后一位保证在当前网段唯一其他信息与宿主机保持一致\n\n\n\n","categories":["其他"],"tags":["VMWare"]},{"title":"修改 GPT/MBR 分区","url":"/posts/2e6e3b5aca8c/","content":"添加新的磁盘，或在虚拟机中扩容磁盘，需要修改分区。\n查看分区现状lsblk# 或者fdisk -l /dev/sda# 先使用 sudo apt install parted 安装 partedparted /dev/sda print\n\n可以看到磁盘容量变大，但是分区没有变化\nDisk /dev/sda: 105 GiB, 112742891520 bytes, 220200960 sectorsDisk model: QEMU HARDDISKUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x94a3b99fDevice     Boot   Start      End Sectors  Size Id Type/dev/sda1  *       2048  8484863 8482816    4G 83 Linux/dev/sda2       8486910 10483711 1996802  975M  5 Extended/dev/sda5       8486912 10483711 1996800  975M 82 Linux swap / Solaris\n\n","categories":["其他"],"tags":["Linux"]},{"title":"国内服务器中转流量","url":"/posts/9bd88f9d9822/","content":"firewalld 流量转发firewalld是CentOS7&#x2F;8默认的防火墙前端软件，绝大多数主机商提供的镜像都已经安装。\n判断防火墙是否已经开启\nfirewall-cmd --state\n\n如果状态不是 running,使用下面命令安装或开启防火墙\nyum install -y firewalld         # 安装systemctl enable firewalld       # 开机启动systemctl start firewalld        # 开启防火墙\n\n配置转发。假设你将国内服务器9090端口流量转发到国外vps的9091端口，转发命令如下：\necho &#x27;net.ipv4.ip_forward = 1&#x27; &gt;&gt; /etc/sysctl.confsysctl -p                        # 使配置生效# 启用伪装 --permanent 配置永久生效firewall-cmd --permanent --add-masquerade# 查看伪装是否生效firewall-cmd --permanent --query-masquerade# 开启端口firewall-cmd --permanent --add-port=8080/tcpfirewall-cmd --permanent --add-port=8080/udp# 配置转发firewall-cmd --permanent --add-forward-port=port=9090:proto=tcp:toaddr=xxx.xx.xxx.xx:toport=9091firewall-cmd --permanent --add-forward-port=port=9090:proto=udp:toaddr=xxx.xx.xxx.xx:toport=9091# 重启防火墙生效 firewall-cmd --reload\n\n注意：\n云服务器需要在控制页面开启端口\nssr 等工具，ip和端口填写为国内转发服务器，链接时间和加密方式，和外网服务器配置相同\n","categories":["其他"],"tags":["CentOS"]},{"title":"Debian 作为时间服务器","url":"/posts/9359a86c8939/","content":"配置权限添加 sudo 命令\nsu # 切换到root用户apt install sudo# 添加用户到sudo组vi /etc/sudoersusername ALL=(ALL) ALL# 添加环境路径，防止找不到安装的软件vi ~/.bashrcexport PATH=$PATH:/usr/sbin::/sbin. ~/.bashrc\n\n安装 ntpapt install ntp\n\n配置 ntp\nvi /etc/ntpsec/ntp.confserver 127.127.1.0 prefer # 本地时间服务器# 注释# pool 0.debian.pool.ntp.org iburst# pool 1.debian.pool.ntp.org iburst# pool 2.debian.pool.ntp.org iburst# pool 3.debian.pool.ntp.org iburst\n\n启动服务\nsudo systemctl start ntpsecsudo systemctl enable ntpsec\n\n同步在需要同步的服务器上安装\nsudo apt install ntpdate# 同步时间sudo ntpdate &lt;时间服务器ip&gt;\n\ncrontab 定时同步\nsudo apt install cron# 编辑定时任务crontab -e# 添加定时任务，每天执行一次0 0 * * * sudo /usr/sbin/ntpdate &lt;时间服务器ip&gt;\n","categories":["其他"],"tags":["Debian"]},{"title":"计算机基础","url":"/posts/0d59fc724f48/","content":"位&#x2F;字节\n\n\n特性\n位（bit）\n字节（byte）\n\n\n\n定义\n最小信息单位\n基本存储和处理单位\n\n\n大小\n1 位 &#x3D; 1 个二进制值\n1 字节 &#x3D; 8 位（现代标准）\n\n\n状态数量\n2^1 &#x3D; 2\n2^8 &#x3D; 256\n\n\n用途\n表示简单状态或逻辑值\n存储字符、数据或文件\n\n\n典型应用\n网络传输速率、标志位\n内存大小、文件大小\n\n\n单位转换\n\n\n单位\n换算为 Byte\n换算为 bit\n\n\n\n1 Byte\n1 Byte\n8 bit\n\n\n1 KB\n1024 Bytes (二进制)\n8192 bit (二进制)\n\n\n1 MB\n1024 × 1024 Bytes (二进制)\n8,388,608 bit (二进制)\n\n\n1 GB\n1024 × 1024 × 1024 Bytes (二进制)\n8,589,934,592 bit (二进制)\n\n\n1 TB\n1024^4 Bytes (二进制)\n8,796,093,022,208 bit (二进制)\n\n\n继电器&#x2F;MOS 管\n继电器\n继电器通过机械开关的闭合和断开，完成逻辑门（如与门、或门、非门）的功能。\n通过组合继电器，可以实现复杂的逻辑电路和算术运算，如加法器和条件判断。\n继电器的输入和输出电路物理隔离，适合处理不同电压和电流的控制任务。\n\nMOS 管\nMOS 管作为场效应晶体管（FET）的一个重要分支，是构建逻辑门（如与、或、非等）的基础元件。\n数十亿个 MOS 管可以集成在单个芯片上，构成现代计算机的中央处理器（CPU）、存储器和其他数字电路。\n静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM）都基于 MOS 管设计。DRAM 中，每个存储单元使用一个 MOS 管和一个电容，极大地提高了存储密度。\n静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM）都基于 MOS 管设计。DRAM 中，每个存储单元使用一个 MOS 管和一个电容，极大地提高了存储密度。\nMOS 管非常小，可以集成到硅芯片中，从而实现计算机的小型化。集成电路（IC）和超大规模集成电路（VLSI）都是基于 MOS 技术。\n\n\n计算机内存原理\nMOS 管原理 \n半加器&#x2F;全加器半加器：处理一位二进制运算的逻辑电路，本位值相当于异或运算（00，11 相同的时候为 0，01，10 不同的时候为 1），进位值相当于与运算（相同时发生进位，值为 1）\n全加器：相比于半加器的两个输入外，多一个上一次进位的输入，因此用两个半加器可以实现一个全加器,最后通过一个或门，确认进位的输出。\n\n将多个全加器连接起来实现波纹进位加法器，可以实现多位的加法运算。但是由于用到的门过多造成延时过长，因此还有超前进位加法器，分层超前进位加法器。\n","categories":["其他"],"tags":["计算机"]},{"title":"①从继承中解脱-策略模式","url":"/posts/179e99c7ede5/","content":"继承真的合理么想象一下有一个汽车类，你用它创造了很多汽车，他们都跑在虚拟游戏世界里面。\nclass CarSuper &#123;  public run() &#123;    console.log(&quot;快快跑&quot;);  &#125;  public blow() &#123;    console.log(&quot;滴滴叫&quot;);  &#125;&#125;const benz = new CarSuper();const bmw = new CarSuper();\n\n但是并不是所有的汽车都是 快快跑 ，它们都有自己的极限速度，所以你很容易想到应该有一个子类，让子类去实现特有方法。\nclass Benz extends CarSuper &#123;  public run() &#123;    console.log(&quot;飞速跑&quot;);  &#125;&#125;const benz = new Benz();\n\n现在你已经在继承中体会到了好处，突然有一天，你觉得创造出来的汽车应该可以载人，这正是你擅长的东西，所以不假思索的在 CarSuper类上添加了 carrying 公用方法,并开心的睡觉去了。\nclass CarSuper &#123;  public run() &#123;    console.log(&quot;快快跑&quot;);  &#125;  public blow() &#123;    console.log(&quot;滴滴叫&quot;);  &#125;  public carrying() &#123;&#125;&#125;\n\n第二天起来，你不敢相信自己的眼睛，一位乘客上了一辆玩具车，所以你赶紧关停了游戏服务。并紧急的思考对策，显然载人的行为并不通用，每一个不能载人的车，都需要重写载人的方法，例如玩具车。\n其实你还有一个想法，既然载人的方法不通用，不如把类似载人这样的功能看作是一个接口，每一个子类都需要实现这个接口\ninterface Carrying &#123;  carrying: () =&gt; void;&#125;class Benz extends CarSuper implements Carrying &#123;  public run() &#123;    console.log(&quot;飞速跑&quot;);  &#125;  public carrying() &#123;    console.log(&quot;拉商人&quot;);  &#125;&#125;\n\n这显然不是一个好办法，接口不具有实现代码，虽然子类自己实现增加了灵活性，但却使子类显的非常冗余，每一个子类后面都跟着一串各不相同且需要独立实现的接口。\n\n为了复用而是用继承可能是导致难以维护比如上面的玩具车可以载人，是因为没有重写子类载人的方法。\n\n找到变化之处类的行为在不断改变，所以一旦把这个行为变成类的一部分，就需要大量的经历去跟踪这些行为会在那里造成影响，有一个原则能帮助我们 ❤‍🔥 把变化的内容独立出来，不要和稳定的代码混在一起\n现在就可以着手于将载人的行为分离出来，那么这个行为应该以哪种形式存在呢，方法，类，还是对象？ 其实一谈到设计模式绕不开的就是 OO(面向对象设计模式)，所以我们还是采用 OO 的思想，使用类来实现这个行为。\ninterface CarryingBehavior &#123;  carrying: () =&gt; void;&#125;class BusinessCarrying implements CarryingBehavior &#123;  public carrying() &#123;    console.log(&quot;载商人&quot;);  &#125;&#125;class ToyCarrying implements CarryingBehavior &#123;  public carrying() &#123;    console.log(&quot;载玩具&quot;);  &#125;&#125;class CarSuper &#123;  protected carryingBehavior: CarryingBehavior;  // 提供初始化时的参数，以提供默认的行为  constructor(&#123; carryingBehavior &#125;: &#123; carryingBehavior: CarryingBehavior &#125;) &#123;    this.carryingBehavior = carryingBehavior;  &#125;  public run() &#123;&#125;  public blow() &#123;&#125;  public carrying() &#123;    this.carryingBehavior.carrying();  &#125;  // 增加set方法是为了可以在运行时改变对象的行为  public setCarryingBehavior(behavior: CarryingBehavior) &#123;    this.carryingBehavior = behavior;  &#125;&#125;class Benz extends CarSuper &#123;  constructor() &#123;    super(&#123;      carryingBehavior: new BusinessCarrying(),    &#125;);  &#125;  public run() &#123;    console.log(&quot;飞速跑&quot;);  &#125;&#125;const benz = new Benz();benz.carrying();benz.setCarryingBehavior(new ToyCarrying());benz.carrying();\n\n我们将汽车的行为抽象为 BusinessCarrying 类，抽象为类和抽象为接口的区别就是分离了实现。\n而 BusinessCarrying 类有自己的行为类接口，可就保证了行为类的灵活性，为相同的行为实现不同的效果，例如汽车载人坐在前排还是后排。\n通过上面的改造，只需要让汽车类提供一个能设置行为的方法，就可以实现行为的动态化，这也是另一个设计原则 ❤‍🔥 针对接口，而不是实现编程。\n\n这样的话和私有方法有什么区别？ 行为是可抽象的，是可以被穷举的，他会动态的散布在各种各样的汽车子类中。而私有方法是无法被穷举的，一旦定义一个新的子类，那么他就有自己的私有方法和私有属性。\n\n现在我们分离了一种行为类，在共有类中被声明但不会实现，而是在子类中实例化这个行为类，这其中的原则就是 ❤‍🔥 多用组合，少用继承， 巧合的是 React 哲学中也提到了这样的思想。\n最后用官方语言定义策略模式： 定义算法族，分别封装起来，让他们之间可以相互替换，让算法的变换独立于使用算法的客户\n\n知道 OO 基础，并不足以让你设计出良好的 OO 系统。\n良好的 OO 设计必须具备可复用、可扩充、可维护三个特性。\n模式可以让我们建造出具有良好 OO 设计质量的系统。\n模式被认为是历经验证的 O0 设计经验。\n模式不是代码，而是针对设计问题的通用解决方案。你可把它们应用到特定的应用中。\n模式不是被发明，而是被发现。\n大多数的模式和原则，都着眼于软件变化的主题。\n大多数的模式都允许系统局部改变独立于其他部分。\n我们常把系统中会变化的部分抽出来封装。\n模式让开发人员之间有共享的语言，能够最大化沟通的价值。\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"②发布+订阅=观察者模式","url":"/posts/7a81d263951b/","content":"像广播一样发消息思考一个问题，有没有一种可能，另一个人A,不知道你这个人的存在，但是却可以给你发消息。A 就像是一个广播站一样，将你们联系在一起的就是手中的收音机，你等待着 A 发布消息，而你等待消息就是一个订阅的行为。\n或者换一种说法，你就像是一个观察者一样，观察消息有没有到来。无论哪种定义无非都是在描述一种关系，接受消息者和发送消息者之间的关系。\n下面要实现一个新闻广播站，每当有新的新闻，会调用新闻对象的broadcastNews,并向观察者们推送消息。下面是一个非常不好的写法：\ninterface Observer &#123;  update(message?: &#123; news: string[] &#125;): void;&#125;class NewsObserver implements Observer &#123;  update(message): void &#123;    console.log(message);  &#125;&#125;const new1 = new NewsObserver();const new2 = new NewsObserver();interface Subscribe &#123;  register(observer: Observer): void;  unregister(observer: Observer): void;  getWeather(city: string): NewsInfo;  notify(): void;&#125;class NewsSubscribe &#123;  getNews() &#123;    return &quot;获取到新闻&quot;;  &#125;  broadcastNews() &#123;    const news = this.getNews();    new1.update(news);    new2.update(news);  &#125;&#125;const newsSubscribe = new NewsSubscribe();\n\n这种写法存在着很多严重的问题：\n\n观察者与被观察者紧耦合在了一起\n没办法在程序执行的时候动态添加或删除观察者\n观察者是会动态变化的对象，但是没有独立且封装\n\n设计观察者模式首先我们让被观察者有注册观察者和取消注册观察者的能力。这样能让观察者与被观察者解耦，并在程序执行的时候动态的添加或删除。\n观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。\nclass NewsSubscribe implements Subscribe &#123;  private observerList: Observer[];  constructor() &#123;    this.observerList = [];  &#125;  register(observer: Observer): void &#123;    this.observerList.push(observer);  &#125;  unregister(observer: Observer): void &#123;    const index = this.observerList.indexOf(observer);    if (index &gt; 0) &#123;      this.observerList.splice(index, 1);    &#125;  &#125;  notify(): void &#123;    this.observerList.forEach((observer) =&gt; &#123;      observer.update();    &#125;);  &#125;&#125;\n\n被观察者不知道观察者的细节，只知道观察者实现了观察者接口。\ninterface NewsInfo &#123;  news: string[];&#125;interface Observer &#123;  update(subscribe: NewsSubscribe): void;&#125;class NewsObserver implements Observer &#123;  update(subscribe: NewsSubscribe): void &#123;    console.log(subscribe.getNews());  &#125;&#125;const new1 = new NewsObserver();interface Subscribe &#123;  register(observer: Observer): void;  unregister(observer: Observer): void;  getNews(city: string): NewsInfo;  notify(): void;&#125;class NewsSubscribe implements Subscribe &#123;  private observerList: Observer[];  constructor() &#123;    this.observerList = [];  &#125;  register(observer: Observer): void &#123;    this.observerList.push(observer);  &#125;  unregister(observer: Observer): void &#123;    const index = this.observerList.indexOf(observer);    if (index &gt; 0) &#123;      this.observerList.splice(index, 1);    &#125;  &#125;  notify(): void &#123;    this.observerList.forEach((observer) =&gt; &#123;      observer.update(this);    &#125;);  &#125;  getNews(): NewsInfo &#123;    return &#123;      news: [&quot;新闻&quot;],    &#125;;  &#125;&#125;const newsSubscribe = new NewsSubscribe();newsSubscribe.register(new NewsObserver());newsSubscribe.register(new NewsObserver());newsSubscribe.notify();\n\n\n可以为观察者模式设置 setChanged  hasChanged 方法，此方法可以控制通知的条件，避免通知的频率过高\n观察者模式定义了对象之间一对多的关系。主题 (也就是可观察者) 用共同的接口来更新观察者\n观察者和可观察者之间用松耦合方式结合 (loosecoupling)，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。有弹\n使用此模式时，你可从被观察者处推 (push)或拉 (pul1)数据(然而，推的方式被认为更“正确”)。\n有多个观察者时，不可以依赖特定的通知次序\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"③悄无声息的扩展-装饰者模式","url":"/posts/3e1242dd4c72/","content":"简单说装饰可以让你不用修改底层代码给对象赋予新的职责。\n从分离改变，更进一步看了前两个设计模式，相信你一定感觉到继承只能解决静态时对类的扩展，如果想动态的对类的行为扩展就需要用到组合。\n既然我们已经可以用策略模式分离改变的部分，还有什么做不到的么？ 看看下面一个问题：\n\n奶茶店有几十种品种的饮料，他们都需要继承自一个抽象类 Beverage，因为每种饮料有自己的产品说明，并且各自实现了一个计算金额的方法 cost。\n每种奶茶除了自己特有的配料外，还可以额外付费添加配料，比如加两份的珍珠，加一份椰果，并且需要计算总价。\n\n如果想枚举出店内的每一种产品是不现实的，那时非常庞大的一个排列组合，因为不可能知道客户要加那些配料。并且严重的违反了设计中的两个原则：\nabstract class BeverageAbstract &#123;  description = &quot;some description&quot;;  cost() &#123;&#125;&#125;// 果茶加牛奶class FruitTeaWithMilk extends BeverageAbstract &#123;&#125;// 柠檬茶加两份珍珠class LemonTeaWith2Pearls extends BeverageAbstract &#123;&#125;//...\n\n既然不能枚举考虑是不是应该有一个统一的 Beverage 类，用于实现抽象类 BeverageAbstract，并且把所有的配料都添加在 Beverage 上，并记录配料的数量。子类会调用父类 cost 方法计算所有配料，并加上自己品种的价格。\nabstract class BeverageAbstract &#123;  description = &quot;some description&quot;;  cost() &#123;&#125;&#125;class Beverage extends BeverageAbstract &#123;  milk = 2;  milkCount = 0;  setMilk(count: number) &#123;    this.milkCount = count;  &#125;  coffee = 5;  coffeeCount = 0;  setCoffee(count: number) &#123;    this.coffeeCount = count;  &#125;  cost() &#123;    let total = 0;    if (this.milkCount &gt; 0) &#123;      total += this.milkCount * this.milk;    &#125;    if (this.coffeeCount &gt; 0) &#123;      total += this.coffeeCount * this.coffee;    &#125;    return total;  &#125;&#125;class FruitTea extends Beverage &#123;  cost() &#123;    return 10 + super.cost();  &#125;&#125;const fruitTea = new FruitTea();fruitTea.setMilk(2);console.log(fruitTea.cost());const fruitTea2 = new FruitTea();fruitTea2.setMilk(1);console.log(fruitTea.cost());\n\n这样的设计还有一些问题：\n\n并不是所有的配料都需要继承，每种饮料都有自己特有的配料。\n一但需要新的配料或新的品种或价钱的改变，就需要修改父类。\n当有新的品种出现的时候，他可能继承了不必要的方法。\n\n定义装饰者设计类的一个原则是 ❤‍🔥 类应该对扩展开放，对修改关闭，也就是类设计中提到的开放关闭原则。\n开放且关闭并不冲突，想想观察中模式中的案例，可以通过调用类的方法添加观察者，而不改变原有的类的方法。并不需要每一个类都遵循开放关闭原则，避免过度设计，只需要针对可能经常会发生变化的类应用开发-关闭原则。\n装饰者模式：动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。\n对于上面的问题，按以下的方式思考：\n\n我们已经有一个果茶类 FruitTea\n需要加两份额外的牛奶，用两个牛奶配料的类去修饰它\n需要加一份额外的咖啡，用一个咖啡配料的类去修饰它\n依赖修饰者的 cost 方法计算价格\n在编码的时候为了明确修饰者和被修饰者的关系，需要让修饰者和被修饰者继承同样的类或实现相同的接口，因为被修饰的类仍然被视作原有的类，它的属性以及方法的作用不应该发生变化，只是扩展了方法实现。\n\ninterface BeverageInterface &#123;  description: string;  cost(): number;  getDescription(): string;&#125;class MilkDecorator implements BeverageInterface &#123;  beverage: BeverageInterface;  description = &quot;MilkDecorator&quot;;  constructor(beverage: BeverageInterface) &#123;    this.beverage = beverage;  &#125;  getDescription() &#123;    return this.description;  &#125;  cost() &#123;    return 2 + this.beverage.cost();  &#125;&#125;class CoffeeDecorator implements BeverageInterface &#123;  beverage: BeverageInterface;  description = &quot;CoffeeDecorator&quot;;  constructor(beverage: BeverageInterface) &#123;    this.beverage = beverage;  &#125;  getDescription() &#123;    return this.description;  &#125;  cost() &#123;    return 5 + this.beverage.cost();  &#125;&#125;class FruitTea implements BeverageInterface &#123;  description = &quot;FruitTea&quot;;  getDescription() &#123;    return this.description;  &#125;  cost() &#123;    return 10;  &#125;&#125;let fruitTea = new FruitTea();// 原价fruitTeaconsole.log(fruitTea.cost());// 添加配料一份牛奶 一份咖啡fruitTea = new MilkDecorator(fruitTea);fruitTea = new CoffeeDecorator(fruitTea);console.log(fruitTea.cost());\n\n现在已经分离了装饰着对象,但是使用装饰者模式是基于一下几个前提：\n\n被修饰的对象是可以抽象的，也就是说被修饰的对象不会轻易改变，这样针对它的修饰类才有意义\n修饰对象是不关心外部状态的，它只关心被修饰的对象，因为你想让他控制修饰链中的每个节点，需要更好的设计。\n被装饰的对象可能拥有特定的类型，在使用装饰的时候需要小心，避免功能或类型丢失。\n\n与 ES6 修饰器的区别ES6 提供修饰器方提案，在 babel 转译后支持，可以修饰类或类的属性和方法，但并不是一种设计模式。\ninterface BeverageInterface &#123;  description: string;  cost(): number;  getDescription(): string;&#125;function milkDecorator(target: () =&gt; number): () =&gt; number &#123;  return () =&gt; 2 + target();&#125;class FruitTea implements BeverageInterface &#123;  description = &quot;FruitTea&quot;;  getDescription() &#123;    return this.description;  &#125;  cost() &#123;    return 10;  &#125;&#125;class FruitTeaWithMilk extends FruitTea &#123;  @milkDecorator  cost(): number &#123;    return super.cost();  &#125;&#125;let fruitTea = new FruitTeaWithMilk();console.log(fruitTea.cost());\n\n\n\n继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。\n在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。\n组合和委托可用于在运行时动态地加上新的行为。\n除了继承，装饰者模式也可以让我们扩展行为。\n装饰者模式意味着一群装饰者类，这些类用来包装具体组件。\n开放一关闭原则\n装饰者类反映出被装饰的组件类型(事实上，他们具有相同的类型，都经过接口或继承实)\n装饰者可以在被装饰者的行为前面与&#x2F;或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。\n你可以用无数个装饰者包装一个组件。\n装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。\n装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"④隐藏new操作符-工厂模式","url":"/posts/7634c4874d92/","content":"new 有什么不对实例化对象的过程不应该总是公开的进行，这里面会有一些耦合的问题。\n对 new 本身来讲并没有什么不对，需要通过 new 操作符实例化对象。但是对于设计模式来讲，new 操作符让我们针对业务编写代码，初始化的逻辑可能在一段条件语句中，如果添加了新的类，必须修改原来的代码。也就是说我们代码没有对修改关闭。\n当有一些相关类实例化的时候，可能会写出下面的代码，每当加入新的类这段代码就会被修改，也就违反对修改关闭的设计原则。\nif (picnic) &#123;duck = new MallardDuck();&#125;else if (hunting) (duck = new DecoyDuck();)else if (inBathTub) &#123;duck = new RubberDuck()&#125;\n\n简单工厂一个最简单的工厂就是把实例化对象的过程提取出来，单独放到一个工厂类中，并暴露方法，允许第三方类通过这个方法实例化对象。\nabstract class FruitFactory &#123;  // 抽象工厂类的公用方法  common() &#123;&#125;  // 需要子类重新实现  abstract createTea(type: string): AppleTea;&#125;interface AppleTea &#123;  name(): void;&#125;class Type1AppleTea implements AppleTea &#123;  name() &#123;    console.log(&quot;苹果茶类型1&quot;);  &#125;&#125;class Type2AppleTea implements AppleTea &#123;  name() &#123;    console.log(&quot;苹果茶类型2&quot;);  &#125;&#125;class Apple extends FruitFactory &#123;  taste() &#123;    console.log(&quot;苹果很甜&quot;);  &#125;  public createTea(type: string): AppleTea &#123;    if (type == &quot;appleTeaType1&quot;) &#123;      return new Type1AppleTea();    &#125; else if (type == &quot;appleTeaType1&quot;) &#123;      return new Type2AppleTea();    &#125;    return new Type1AppleTea();  &#125;&#125;class FruitStore &#123;  factory: FruitFactory;  constructor(factory: FruitFactory) &#123;    this.factory = factory;  &#125;  makeFruitTea(type: string) &#123;    return this.factory.createTea(&quot;type1&quot;);  &#125;  orderTea() &#123;    const tea = this.makeFruitTea(&quot;type1&quot;);    tea.name();  &#125;  //  公用的茶的制作方法  //  ...&#125;const store = new FruitStore(new Apple());store.orderTea();\n\n工厂方法模式： 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个的，工厂方法让类把实例化推迟到子类。\n上面的代码中可以看到工厂是外部传入，可以创建不同类型的茶，但是茶的制作行为更像是 Store 的一部分，所以做一点改变。\n\n定义一个 Store 的抽象类，所有的 Store 都要实现这个抽象类。\n在 Store 抽象类中定义 createTea 的抽象方法，这个方法的内容就是之前外部传入的工厂。\n换句话说， 工厂方法转移到子类中实现\n\ninterface AppleTea &#123;  name(): void;&#125;class Type1AppleTea implements AppleTea &#123;  name() &#123;    console.log(&quot;苹果茶类型1&quot;);  &#125;&#125;class Type2AppleTea implements AppleTea &#123;  name() &#123;    console.log(&quot;苹果茶类型2&quot;);  &#125;&#125;abstract class FruitStore &#123;  abstract createTea(type: string): any;&#125;class AppleFruitStore extends FruitStore &#123;  constructor() &#123;    super();  &#125;  public createTea(type: string): AppleTea &#123;    if (type == &quot;type1&quot;) &#123;      return new Type1AppleTea();    &#125; else if (type == &quot;type2&quot;) &#123;      return new Type2AppleTea();    &#125;    return new Type1AppleTea();  &#125;  orderTea() &#123;    const tea = this.createTea(&quot;type1&quot;);    tea.name();  &#125;&#125;const store = new AppleFruitStore();store.orderTea();\n\n所有的工厂模式都是用来封装对象创建的。， 创建者类 需要有一个抽象创建者类，定义了一个抽象工厂方法，所有实现了抽象创建者类的子类，都可以用自己实现的工厂方法生产产品。产品类 是在创建者实例的工厂方法中创建出来的。\n依赖倒置与抽象工厂依赖倒置原则：要依赖抽象，不要依赖具体类，这句话很像是要面向接口编程，而不是具体的类。没错，但是这句话更强调，高层的组件不应该依赖低层的组件，而是应该两者都依赖于 抽象。抽象可以是接口，也可以是抽象类。\n抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。\n思考\n当只有一个创建者类的时候是否应该使用工厂模式，答案是肯定的，工厂模式让你便于扩展，并将产品类的创建与使用解耦。\n所有的工厂都是用来封装对象的创建\n简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦。\n工厂方法使用继承:把对象的创建委托给子类，子类实现工厂方法来创建对象。\n抽象工厂使用对象组合:对象的创建被实现在工厂接口所暴露出来的方法中\n所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。\n工厂方法允许类将实例化延迟到子类进行。\n抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。\n依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。\n工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体类编程。\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"⑤独一无二-单例模式","url":"/posts/a63a57329155/","content":"单例模式确保一类只有一个实例，并提供全局访问点。\n这个模式很简单，目的就是让类只能被实例化一次，思路就是如果没有被实例化就实例化类，如果已经实例化直接返回实例化的对象。\n因为在 JS 中，类的静态方法不能访问类的实例属性，所以考虑把类的实例缓存在类的静态属性中。\nclass Singleton &#123;  static instance: InstanceType&lt;typeof Singleton&gt; | null = null;  static getInstance() &#123;    if (!this.instance) &#123;      return (this.instance = new Singleton());    &#125; else &#123;      return this.instance;    &#125;  &#125;&#125;\n\n如果不使用 ES6 class 实现，可以使用函数的方式配合模块化规范，导出创建方法\ninterface ISingleton &#123;&#125;interface ISingletonConstructor &#123;  new (): ISingleton;&#125;class Singleton implements ISingleton &#123;  constructor() &#123;&#125;&#125;let getSingletonInstance = (Singleton: ISingletonConstructor): ISingleton =&gt; &#123;  let instance: ISingleton = new Singleton();  getSingletonInstance = (Singleton?: ISingletonConstructor): ISingleton =&gt;    instance;  return instance;&#125;;export &#123; getSingletonInstance &#125;;\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"⑥封装调用-命令模式","url":"/posts/9c60322820bb/","content":"解耦调用者和请求者现在有 2 个开关需要控制 2 台设备的开机和停止。设备的开机和停止是一个繁琐的过程，需要设置一些参数，并经历几步操作。\n如果我们把对机器的操作都写在开关的实现中，一旦开关流程改变或是更换了设备，都需要重新修改开关的代码。\n所以我们考虑先把设备的开机和停止过程封装在一个对象方法里面，开关只要直接调用这个对象的方法就能实现设备开始和停止，不需要关心实现的细节。\ninterface ICommand &#123;  execute(): void;&#125;class Device1 implements ICommand &#123;  setOption() &#123;&#125;  step1() &#123;&#125;  step2() &#123;&#125;  on() &#123;&#125;  execute() &#123;    this.setOption();    this.step1();    this.step2();    this.on();    console.log(&quot;设备已经开启&quot;);  &#125;&#125;\n\n开关类接受命令类，并直接调用命令类的方法。\nclass ControlA &#123;  command: ICommand;  constructor(command: ICommand) &#123;    this.command = command;  &#125;  setCommand(command: ICommand) &#123;    this.command = command;  &#125;  on() &#123;    this.command.execute();  &#125;&#125;const controlA = new ControlA(new Device1());controlA.on();\n\n对于某些按钮，可能没有实现 execute 方法，而我们又不想通过 if 或 else 判断破坏代码风格，可以使用占位符类。\nclass NoCommand implements ICommand &#123;  execute() &#123;&#125;&#125;const controlB = new ControlA(new NoCommand());controlB.on();\n\n命令模式将请求封装成对象，以便使用不同的请求，队列，或日志来参数化其他的对象，命令模式也支持可撤销的操作。\n宏命令把所有的命令对象通过一个类编排起来，统一执行，就实现了宏命令\nclass MacroCommand implements ICommand &#123;  commandStack: ICommand[] = [];  setCommand(command: ICommand) &#123;    this.commandStack.push(command);  &#125;  execute(): void &#123;    for (let i = 0; i &lt; this.commandStack.length; i++) &#123;      this.commandStack[i].execute();    &#125;  &#125;&#125;\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"⑦适配器模式-外观模式","url":"/posts/531e7354ddad/","content":"适配器模式适配器就像是转换国内充电器和香港充电器的插座一样，能让原本可以使用的插座在另一个地方也能正常使用。\n而转换的过过程中，并没有修改原有插座的功能，只是将他的功能进行转换，这也是适配器的核心逻辑，有别于外观模式，和之前的装饰者模式。\n适配器模式：将一个类的接口，转换为消费方期望的另一个接口。适配器让原本不兼容的类可以正常使用。， 而装饰着模式通常为类提供额外的功能接口，已达到增强类的目的。\n真实的场景中适配器模式可以适配对象或类。\n通常对类的扩展操作会考虑继承，但是 JS 中的扩展方式很灵活，也可以通过函数的形式对对象或类进行操作。\n通过一个适配器，为对象实现 iterator\nconst obj = &#123;  a: 1,  b: 2,&#125;;const objIteratorAdapter = (  obj: Record&lt;string, any&gt;): Record&lt;string, any&gt; &amp; &#123; [Symbol.iterator]: () =&gt; any &#125; =&gt; &#123;  const iterator = (): &#123; next: () =&gt; any &#125; =&gt; &#123;    let keys = Object.keys(obj);    let index = 0;    return &#123;      next() &#123;        return index &lt; keys.length          ? &#123;              value: obj[keys[index++]],              done: false,            &#125;          : &#123;              value: undefined,              done: true,            &#125;;      &#125;,    &#125;;  &#125;;  const iteratorObj = Object.create(obj, &#123;    [Symbol.iterator]: &#123;      value: iterator,      writable: false,      enumerable: false,      configurable: false,    &#125;,  &#125;);  return iteratorObj;&#125;;const newObj = objIteratorAdapter(obj);for (let i of newObj) &#123;  console.log(i);&#125;\n\n外观模式外观模式提供了统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统的接口更容易使用。\n外观模式并不会封装新的功能，而是封装了一段子系统的接口。\n虽然外观模式定义简单，但是引出了一个设计理念， 最少知识原则，只和你的密友谈话。\n在对象的方法调用中，应该遵循几个原则：\n\n调用该对象本身的方法\n调用当作参数出入对象中的方法\n调用通过此方法创建或实例化对象中的方法\n调用对象实例中引用的对象中的方法\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"⑧抽取算法-模板方法模式","url":"/posts/327123b12d40/","content":"抽取公共算法现在有一个场景，需要让你实现煮方便面和挂面，他们的过程如下。\n挂面：\n\n加水\n水开后加入挂面\n一分钟后加入葱花\n装盘\n\n方便面：\n\n加水\n水开后加入方便面\n一分钟后加入调料包\n装盘\n\n可能第一反应会想到继承，父类中抽取加水和装盘的步骤，而中间两步因为实现不同所以不能抽取，而让子类去实现。\n虽然中间的两步他们的逻辑相似但是针对的对象不同，一个需要加葱花，一个需要加调料包。而对与程序而言可以理解成算法相同而参数不同。\nabstract class MakeNoodles &#123;  public addWater() &#123;&#125;  // 加入某种类型的面  public addNoodle(noodleType: string) &#123;    console.log(&quot;加入&quot; + noodleType);  &#125;  // 等一分钟加入调料  public waitMinuteAddCondiment(condiment: string) &#123;    console.log(&quot;一分钟后加入&quot; + condiment);  &#125;  // 装盘  public sabot() &#123;&#125;&#125;// 挂面class MakeFineDriedNoodles extends MakeNoodles &#123;  addNoodle(type: string) &#123;    super.addNoodle(type);  &#125;  waitMinuteAddCondiment(condiment: string) &#123;    super.waitMinuteAddCondiment(condiment);  &#125;&#125;\n\n当然也可以使用组合的方法\ntype MakeNoodlesType = &#123;  new (): any;&#125;;// 挂面class MakeFineDriedNoodles &#123;  makeNoodles: MakeNoodles;  constructor(MakeNoodlesConstructor: MakeNoodlesType) &#123;    this.makeNoodles = new MakeNoodlesConstructor();  &#125;  addNoodle(type: string) &#123;    this.makeNoodles.addNoodle(type);  &#125;  waitMinuteAddCondiment(condiment: string) &#123;    this.makeNoodles.waitMinuteAddCondiment(condiment);  &#125;&#125;\n\n这就是模板方法模式的雏形，最大限度的抽取公共算法，而称为模板方法也是因为此模式经常作为方法调用，而仅限于用于类的继承。\n模板方法模式模板方法模式：在一个方法中定义一个算法骨架，而将一些步骤延续到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。\n另外在类的模板方法中经常会定义 Hooks(钩子方法），为子类实现流程控制提供可能。\n继承的方式:\nabstract class MakeNoodles &#123;  // 等一分钟加入调料  public waitMinuteAddCondiment(condiment: string) &#123;    if (this.likeCondiment()) &#123;      console.log(&quot;一分钟后加入&quot; + condiment);    &#125;  &#125;  public likeCondiment() &#123;    return true;  &#125;&#125;// 挂面class MakeFineDriedNoodles extends MakeNoodles &#123;  likeCondiment() &#123;    return false;  &#125;  waitMinuteAddCondiment(condiment: string) &#123;    super.waitMinuteAddCondiment(condiment);  &#125;&#125;\n\n组合的方式：\nclass MakeNoodles &#123;  // 等一分钟加入调料  public waitMinuteAddCondiment(condiment: string) &#123;    if (this.likeCondiment()) &#123;      console.log(&quot;一分钟后加入&quot; + condiment);    &#125;  &#125;  public likeCondiment() &#123;    return true;  &#125;&#125;type MakeNoodlesType = &#123;  new (): any;&#125;;// 挂面class MakeFineDriedNoodles &#123;  makeNoodles: MakeNoodles;  constructor(MakeNoodlesConstructor: MakeNoodlesType) &#123;    this.makeNoodles = new MakeNoodlesConstructor();  &#125;  likeCondiment() &#123;    return false;  &#125;  waitMinuteAddCondiment(condiment: string) &#123;    this.makeNoodles.likeCondiment = this.likeCondiment;    this.makeNoodles.waitMinuteAddCondiment(condiment);  &#125;&#125;\n\n如果对于某些算法是可选的，可以考虑使用 Hooks, 而 Hooks 不一定只是子类控制模板的算法流程，也能使是子类直接使用模板算法里面的 Hooks 控制子类的逻辑。\n而这种子类和父类互相调用的场景经常存在，这也涉及到一个原则 避免底层和高层组件之间有明显的环状依赖。\n方法中的模板模式很多场景下模板模式体现的并不明显，如 lodash 中的 add 方法.\nconst add = createMathOperation((augend, addend) =&gt; augend + addend, 0);\n\nadd 方法中，你可以将传入的回调函数看作是模板方法，但并没有直接返回相加的结果，而是将相加的算法传入 createMathOperation， 而在这个方法中处理数据类型转换的问题。这个方法补充了模板方法的空白。\n你也可一把他看作是装饰方法，但不是装饰模式，装饰模式通常会被定义为装饰者和被装饰者实现相同的接口。\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"⑨集合管理-迭代器和组合模式","url":"/posts/b72cda69fef3/","content":"统一的遍历方法像是为对象提供 Iterator 接口一样，有时需要遍历一个复杂对象的内部属性，所以需要一个统一的接口，这也是迭代器模式需求的由来。\n迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。\n现在有两个对象保存着一些数据，但是数据使用不同的数据结构保存，数组，对象，链表，或是一些特殊的封装结构。\nclass Test1 &#123;  data = [&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;];&#125;class Test2 &#123;  data = &#123;    a2: &quot;a2&quot;,    b2: &quot;b2&quot;,    c2: &quot;c2&quot;,  &#125;;&#125;\n\n如果想要便利这两个对象中的所有数据，最容易想到的办法就是分别使用数据和对象的遍历方法，通过两次循环依次返回。\n把这个遍历的实现定义为类 MapObject,但这并不是一个合理的办法:\n\n遍历的前提是必须要知道对象的实现细节，违背了针对接口编程，而不是针对实现，也可以说是违背了封装。\n如果需要更换其中的一个类遍历，那么必须修改 MapObject,违背了对扩展开放，对修改关闭。\n\n现在已经清楚了变化之处在于遍历，想办法把遍历封装起来。\ninterface IteratorClass&lt;T&gt; &#123;  new (): T;&#125;interface IIterator &#123;  iterator(): IterableIterator&lt;string&gt;;&#125;// 遵循面向接口编程的原则，两个类都实现了相同的接口class Test1 implements IIterator &#123;  data = [&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;];  iterator() &#123;    return this.data[Symbol.iterator]();  &#125;&#125;class Test2 implements IIterator &#123;  data = &#123;    a2: &quot;a2&quot;,    b2: &quot;b2&quot;,    c2: &quot;c2&quot;,  &#125;;  iterator() &#123;    const iterator = (): IterableIterator&lt;string&gt; =&gt; &#123;      let data = this.data;      let keys = Object.keys(data);      let index = 0;      return &#123;        next() &#123;          return index &lt; keys.length            ? &#123;                value: data[keys[index++] as keyof typeof data],                done: false,              &#125;            : &#123;                value: undefined,                done: true,              &#125;;        &#125;,      &#125; as IterableIterator&lt;string&gt;;    &#125;;    return iterator();  &#125;&#125;class MapObject &#123;  test1: Test1;  test2: Test2;  constructor(test1: IteratorClass&lt;Test1&gt;, test2: IteratorClass&lt;Test2&gt;) &#123;    this.test1 = new test1();    this.test2 = new test2();  &#125;  printItem() &#123;    let stack = [this.test1, this.test2];    stack.forEach((instance) =&gt; &#123;      let iterator = instance.iterator();      let done: any, value: any;      do &#123;        (&#123; done, value &#125; = iterator.next());        if (value) &#123;          console.log(value);        &#125;      &#125; while (!done);    &#125;);  &#125;&#125;\n\n单一职责一个类应该只有一个引起变化的原因。， 当一个类有多个变化的可能时，会增加维护的成本，或导致其他的功能出现错误。\n内聚这个术语也可以看作是衡量单一指责的一个表述。\n组合模式组合模式相对于之前提到的代码组合更加具体，可以理解为代码组合包括组合模式。\n现在有这样的几个对象，每个对象用不同的数据结构保存自己的数据，而且数据还可能分级，下一级是另一个对象，形成一个树的结构。需要实现一个迭代器，能在树的不同节点中以及下一层节点中移动。\n实现这个功能可以使用组合模式，组合模式允许你将对象组合成树形结构来表现 ‘整体&#x2F;部分’ 层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。\n组合的目的是忽略整体和个体的差别，应用在整体上的操作同样可以应用在个体上。\n遵循面向接口的变成方式，首先实现抽象类，所有的对象以及叶子节点的对象都需要实现抽象类，并且从冲向类中继承 print 方法。\nabstract class AbstractDataCollection &#123;  abstract createIterator(): any;  print(): void &#123;    let done: any, value: any;    const iterator = this.createIterator();    do &#123;      (&#123; done, value &#125; = iterator.next());      if (!done) &#123;        value.print();      &#125;    &#125; while (!done);  &#125;&#125;\n\n不同的对象集合可以组合但是由于实现方式不同，需要各自实现抽象相类中的 createIterator 方法\nclass DataCollection1 extends AbstractDataCollection &#123;  data: any[] = [];  add(dataItem: any) &#123;    this.data.push(dataItem);    return this;  &#125;  iterator() &#123;    return this.data[Symbol.iterator]();  &#125;  createIterator() &#123;    return new CompositeIterator(this.iterator());  &#125;&#125;class DataCollection2 extends AbstractDataCollection &#123;  data: &#123; [key: string]: any &#125; = &#123;&#125;;  add(dataItem: any, key: string) &#123;    this.data[key] = dataItem;    return this;  &#125;  iterator() &#123;    let data = this.data;    let keys = Object.keys(data);    let index = 0;    return &#123;      next() &#123;        return index &lt; keys.length          ? &#123;              value: data[keys[index++] as keyof typeof data],              done: false,            &#125;          : &#123;              value: undefined,              done: true,            &#125;;      &#125;,    &#125;;  &#125;  createIterator() &#123;    return new CompositeIterator(this.iterator());  &#125;&#125;type LinkData = &#123;  next: LinkData | null;  value?: any;&#125;;class DataCollection3 extends AbstractDataCollection &#123;  data: LinkData = &#123; next: null &#125;;  last: LinkData = this.data;  add(dataItem: any) &#123;    this.last.next = &#123;      value: dataItem,      next: null,    &#125;;    this.last = this.last.next;    return this;  &#125;  iterator() &#123;    let data: LinkData | null = this.data;    return &#123;      next() &#123;        data = data!.next;        if (data === null) &#123;          return &#123;            done: true,            value: undefined,          &#125;;        &#125; else &#123;          return &#123;            done: false,            value: data.value,          &#125;;        &#125;      &#125;,    &#125;;  &#125;  createIterator() &#123;    return new CompositeIterator(this.iterator());  &#125;&#125;class DataItem extends AbstractDataCollection &#123;  data: any;  constructor(data: any) &#123;    super();    this.data = data;  &#125;  createIterator() &#123;    return new NullIterator();  &#125;  print(): void &#123;    console.log(this.data);  &#125;&#125;\n\n叶子节点的 createIterator 方法返回一个空的迭代器，真实环境中经常会使用这个方式添加占位，让所有对象的行为保持一致。\n对象集合的 createIterator 方法，实现了一个 Iterator 类，把没有迭代完成的迭代器重新放回到队列中\nclass CompositeIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123;  stack: Iterator&lt;T&gt;[] = [];  constructor(iterator: Iterator&lt;T&gt;) &#123;    this.stack.push(iterator);  &#125;  next(...args: [] | [undefined]): IteratorResult&lt;T, any&gt; &#123;    if (this.stack.length) &#123;      const iterator = this.stack.pop();      let component = iterator!.next();      if (!component.done) &#123;        this.stack.push(iterator!);      &#125;      return component;    &#125; else &#123;      return &#123;        value: undefined,        done: true,      &#125;;    &#125;  &#125;&#125;class NullIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123;  next(...args: [] | [undefined]): IteratorResult&lt;T, any&gt; &#123;    return &#123;      done: true,      value: undefined,    &#125;;  &#125;&#125;\n\n最后实现遍历的类\nconst t = new DataCollection1();t.add(new DataItem(1));t.add(new DataItem(2));const p = new DataCollection2();p.add(new DataItem(&quot;a&quot;), &quot;a&quot;);p.add(new DataItem(&quot;b&quot;), &quot;b&quot;);const q = new DataCollection3();q.add(new DataItem(&quot;p&quot;));const w = new DataCollection2();w.add(new DataItem(&quot;w1&quot;), &quot;w1&quot;);w.add(new DataItem(&quot;w2&quot;), &quot;w2&quot;);q.add(w);q.add(new DataItem(&quot;q&quot;));class MapObject extends AbstractDataCollection &#123;  stack: any[] = [];  add(instance: AbstractDataCollection) &#123;    this.stack.push(instance);    return this;  &#125;  iterator() &#123;    return this.stack[Symbol.iterator]();  &#125;  createIterator() &#123;    return new CompositeIterator(this.iterator());  &#125;&#125;const o = new MapObject();o.add(t);o.add(p);o.add(q);o.print();\n\n真实世界中的组合模式没有这么刻板，例如 React 组件的组合，通过单向数据流或状态管理工具，只要调用外层组件的方法即可，无需关心子组件的实现。\n有时不同的节点之间需要双向连接用于回退，或反查父节点。\n如果某个节点作为计算功能，并且频繁调用，可以考虑使用缓存。\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"⑩状态模式","url":"/posts/ff6edceab12a/","content":"避免陷入在 if&#x2F;else 之中考虑以下两种场景，哪种更容易让你深陷在 if&#x2F;else 的逻辑之中。\n订单配送，订单可能处于下面的几种状态\n\n下单状态\n打包状态\n配送状态\n签收状态\n\n自动售卖机\n\n无货状态\n有货状态\n已投币状态\n未投币状态\n出货状态\n\n显然订单配送的状态处理起来更容易一些\n\n下单状态需要备货\n打包状态需要检查时候安全，是否要放入小礼物\n配送状态要同步配送信息\n签收状态要回访客户\n\n虽然这些状态环环相扣，但是一旦状态完成转移就不需要在考虑原有状态中的行为是否还需要关注。\n而自动售售货机可能让你陷入 if&#x2F;else 的深渊，因为不同的状态可能伴随相同的操作，无论处于哪种状态，用户都可能按下取货按钮，但只有投币并且有货，按下取货才有意义。\n状态模式状态模式：允许对象在内部状态改变的时候改变他的行为，对象看起来好像修改了它的类。\n状态模式和策略模式中的组合对象很像，但是状态模式更专注与状态的迁移，和不同状态中的行为。\n\n状态模式允许一个对象基于内部状态而拥有不同的行为。\n和程序状态机（PSM）不同,状态模式用类代表状态\nContext 会将行为委托给当前对象\n通过将每个状态封装进一个类，我们把以后需要做的任何变化都局部化了\n状态模式允许 Context 随着状态改变而改变行为\n状态转移可以由 State 类或 Context 类控制\n使用状态模式通常会导致设计中类的数目大量增加\n状态类可以被多个 Context 实例共享\n\n// 投币// 点击出货abstract class State &#123;  machine: VendingMachine;  constructor(machine: VendingMachine) &#123;    this.machine = machine;  &#125;  addCoin(coin?: Number) &#123;    console.log(&quot;必须实现 addCoin&quot;);  &#125;  getProduct() &#123;    console.log(&quot;必须实现 getProduct&quot;);  &#125;&#125;// 无商品class NoProduct extends State &#123;  addCoin() &#123;    console.log(&quot;机器里无商品，你不能购买&quot;);  &#125;  getProduct() &#123;    console.log(&quot;机器里无商品，你不能购买&quot;);  &#125;&#125;class HasProduct extends State &#123;  addCoin(coin: number) &#123;    this.machine.coin += coin;  &#125;  getProduct() &#123;    console.log(&quot;你已经获取了商品&quot;);    this.machine.count -= 1;    this.machine.coin -= 1;    this.stateTransform();  &#125;  stateTransform() &#123;    const &#123; count, coin &#125; = this.machine;    if (coin === 0) &#123;      this.machine.setState(this.machine.stateNoCoin);    &#125; else if (count === 0) &#123;      this.machine.setState(this.machine.stateNoProduct);    &#125;  &#125;&#125;class NoCoin extends State &#123;&#125;class VendingMachine &#123;  stateNoProduct: NoProduct;  stateHasProduct: HasProduct;  stateNoCoin: NoCoin;  count: number;  coin: number = 0;  state: NoProduct | HasProduct;  constructor(count: number) &#123;    this.count = count || 2;    this.stateNoProduct = new NoProduct(this);    this.stateHasProduct = new HasProduct(this);    this.stateNoCoin = new NoCoin(this);    this.state = this.stateHasProduct;  &#125;  setState(state: NoProduct | HasProduct) &#123;    this.state = state;  &#125;  addCoin(coin = 0) &#123;    this.state.addCoin(coin);  &#125;  getProduct() &#123;    this.state.getProduct();  &#125;&#125;\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"⑪控制访问-代理模式","url":"/posts/973a01881b15/","content":"代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。\n代理模式非常灵活，可能不经意写的一行代码也是代理模式，例如：\n\n分发请求到到远程\n为初始化开销大的对象提供代理\n保护某些对方法不能访问\n\nJS 中提供了 Proxy 这个代理对象，\n图片加载想象一下一个图片的加载过程是不是可以通过代理来实现\n\n发起加载图片并绘制在页面上的请求\n这个请求将发送给代理对象\n代理对象通过网络获取图片\n绘制图片并提供图片控制的接口\n\n防火墙代理控制网络资源的访问，保护主题免于侵害\n只能引用代理当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数\n缓存代理为开销大的运算结果提供暂时存储，它也允许多个客户共享结果，以减少计算或网络延迟。\n同步代理在多线程的情况下，提供安全访问。\n复杂隐藏代理用来隐藏一个类的复杂度，并控制访问，有时候也称为 外观代理。复杂隐藏代理和外观模式不一样，因为代理控制访问，而外观模式提供另一组接口。\n写入时复制代理用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。这是虚拟代理的变体。\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"代码美学（摘要）","url":"/posts/4f8f368f768f/","content":"如何给变量或类型起名字不要使用以下的命名方式\n\n不要使用单字母：简洁的变量命名是来自数学中的命名习惯，数学家喜欢公式的精简和优美，但是会丢失大量的上下文信息，让你读代码的时间比写代码的时间还要长\n\n不要使用缩写：与单字母的方式一样，无法理解上下文的信息，让代码很难阅读\n\n不要在命名中添加类型说明： 新生的程序工作者可能不会接触到这个命名方式，它来自于匈牙利命名法在类型提示不完善的年代，增加对变量类型的说明 intTotal,strName\n\n不要再类型中添加类型描述： 最典型的就是对interface的定义使用 IBoxProps\n\n不要再类或类型中添加 Base 或 Abstract: 可能你会习惯性的把基础类命名中添加 Base, 但是这并不能说明他应该被继承或是被实现，只需要直接命名即可，例如 Box另外你的命名对子类如何使用并不会有影响，例如 (box:Box)=&gt;void, 并不关心 Box 是不是抽象类当你不知道如何给基础类命名的时候，可以考虑是否需要对子类修改命名方式，添加更多信息， 例如子类实现了不同颜色的盒子 YellowBox\n\n\n推荐的命名方式\n\n在命名中增加单位描述： delaySeconds , 对于一些强类型语言可以使用类型标注，例如 C# TimeSpan, 而对于弱类型语言可以在命名中添加单位描述\n\n你可能不需要Utils文件可能你正在用一个Utils方法过滤电影列表\nclass Utils &#123;    filterMove()&#123;&#125;&#125;\n\n但事实上这应该是电影类中的一部分\nclass Movie &#123;    filterMove()&#123;&#125;&#125;\n\n当你准备写一个utils方法的使用请考虑它是否足够抽象， 亦或者考虑将他放到更明确的类或功能模块中去。\n使用组合而不是继承继承最大的问题在于，无法找到一个完美的抽象，随着业务和需求的发展，总是需要调整被继承的类，这将会影响全局。\n如果需要使用类，遵循以下的原则:\n\n需要实现的类中有大量重复的接口\n避免直接访问受保护的成员变量\n显式的为子类创建需要重写的API\n每个方法都需要标注行为 final&#x2F;sealed&#x2F;private, 避免修改时导致错误\n\n如是使用继承，需要注意以下几点：\n\n组合会导致功能定义时产生大量的重复初始化代码\n如果想从类中暴露方法，需要写大量的包装函数class Box&#123;  getName()&#123;      return this.type.getName()  &#125;&#125;\n虽然会导致少量冗余，但是好处远远大于坏处，它可以让你的代码耦合程度更低。\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"FiberNode","url":"/posts/30160e8c26f0/","content":"V16每一个ReactElement对应一个Fiber对象，记录各个节点的状态，由于Fiber对象并不是绑定在组件的实例上，这也给hooks实现时，拿到每个节点的状态提供了方便\nFiber 记录了整个应用的树型结构\n// Fiber对应一个组件需要被处理或者已经处理了，一个组件可以有一个或者多个Fibertype Fiber = &#123;|  // 标记不同的组件类型  tag: WorkTag,  // ReactElement里面的key  key: null | string,  // ReactElement.type，也就是我们调用`createElement`的第一个参数  elementType: any,  // The resolved function/class/ associated with this fiber.  // 异步组件resolved之后返回的内容，一般是`function`或者`class`  type: any,  // The local state associated with this fiber.  // 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）  stateNode: any,  // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回  return: Fiber | null,  // 单链表树结构  // 指向自己的第一个子节点  child: Fiber | null,  // 指向自己的兄弟结构  // 兄弟节点的return指向同一个父节点  sibling: Fiber | null,  index: number,  // ref属性  ref: null | (((handle: mixed) =&gt; void) &amp; &#123;_stringRef: ?string&#125;) | RefObject,  // 新的变动带来的新的props  pendingProps: any,   // 上一次渲染完成之后的props  memoizedProps: any,  // 该Fiber对应的组件产生的Update会存放在这个队列里面  updateQueue: UpdateQueue&lt;any&gt; | null,  // 上一次渲染的时候的state  memoizedState: any,  // 一个列表，存放这个Fiber依赖的context  firstContextDependency: ContextDependency&lt;mixed&gt; | null,  // 用来描述当前Fiber和他子树的`Bitfield`  // 共存的模式表示这个子树是否默认是异步渲染的  // Fiber被创建的时候他会继承父Fiber  // 其他的标识也可以在创建的时候被设置  // 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前  mode: TypeOfMode,  // Effect  // 用来记录Side Effect  effectTag: SideEffectTag,  // 单链表用来快速查找下一个side effect  nextEffect: Fiber | null,  // 子树中第一个side effect  firstEffect: Fiber | null,  // 子树中最后一个side effect  lastEffect: Fiber | null,  // 代表任务在未来的哪个时间点应该被完成  // 不包括他的子树产生的任务  expirationTime: ExpirationTime,  // 快速确定子树中是否有不在等待的变化  childExpirationTime: ExpirationTime,  // 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber  // 镜像Fiber  // 我们称他为`current &lt;==&gt; workInProgress`  // 在渲染完成之后他们会交换位置  alternate: Fiber | null,  // 下面是调试相关的，收集每个Fiber和子树渲染时间的  actualDuration?: number,  // If the Fiber is currently active in the &quot;render&quot; phase,  // This marks the time at which the work began.  // This field is only set when the enableProfilerTimer flag is enabled.  actualStartTime?: number,  // Duration of the most recent render time for this Fiber.  // This value is not updated when we bailout for memoization purposes.  // This field is only set when the enableProfilerTimer flag is enabled.  selfBaseDuration?: number,  // Sum of base times for all descedents of this Fiber.  // This value bubbles up during the &quot;complete&quot; phase.  // This field is only set when the enableProfilerTimer flag is enabled.  treeBaseDuration?: number,  // Conceptual aliases  // workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens  // to be the same as work in progress.  // __DEV__ only  _debugID?: number,  _debugSource?: Source | null,  _debugOwner?: Fiber | null,\n\nV17// A Fiber is work on a Component that needs to be done or was done. There can// be more than one per component.// Fiber 是组件的中的工作内容，需要完成或已经完成，每个组件可以个有多个。export type Fiber = &#123;|  // These first fields are conceptually members of an Instance. This used to  // be split into a separate type and intersected with the other Fiber fields,  // but until Flow fixes its intersection bugs, we&#x27;ve merged them into a  // single type.  // 第一个字段概念上是实例的一部分，它过去被拆分成单独的类型并且存在于其他Fiber节点的字段中。  // 直到Flow修复了交叉错误，我们把它合并成单一类型  // An Instance is shared between all versions of a component. We can easily  // break this out into a separate object to avoid copying so much to the  // alternate versions of the tree. We put this on a single object for now to  // minimize the number of objects created during the initial render.  // 实例在组件的所有的版本中共享，可以很容易的拆分成单个对象避免复制太多内容到镜像树上，  // 现在我们把它放在单独的对象上，为了初始化渲染期间最小化创建对象的数量  // Tag identifying the type of fiber.  // fiber类型， 标签标识  tag: WorkTag,  // Unique identifier of this child.  // 这个子元素的唯一标识  key: null | string,  // The value of element.type which is used to preserve the identity during  // reconciliation of this child.  // element.type的值，用于在调和子节点期间保留标识。  elementType: any,  // The resolved function/class/ associated with this fiber.  // 函数组件或类组件通过type链接，type为函数组件或类组件的引用  type: any,  // The local state associated with this fiber.  // 保存实例化之后的节点对象  stateNode: any,  // Conceptual aliases  // parent : Instance -&gt; return The parent happens to be the same as the  // return fiber since we&#x27;ve merged the fiber and instance.  // Remaining fields belong to Fiber  // The Fiber to return to after finishing processing this one.  // This is effectively the parent, but there can be multiple parents (two)  // so this is only the parent of the thing we&#x27;re currently processing.  // It is conceptually the same as the return address of a stack frame.  return: Fiber | null,  // Singly Linked List Tree Structure.  child: Fiber | null,  sibling: Fiber | null,  index: number,  // The ref last used to attach this node.  // I&#x27;ll avoid adding an owner field for prod and model that as functions.  ref:    | null    | (((handle: mixed) =&gt; void) &amp; &#123;_stringRef: ?string, ...&#125;)    | RefObject,  // Input is the data coming into process this fiber. Arguments. Props.  pendingProps: any, // This type will be more specific once we overload the tag.  memoizedProps: any, // The props used to create the output.  // A queue of state updates and callbacks.  updateQueue: mixed,  // The state used to create the output  memoizedState: any,  // Dependencies (contexts, events) for this fiber, if it has any  dependencies: Dependencies | null,  // Bitfield that describes properties about the fiber and its subtree. E.g.  // the ConcurrentMode flag indicates whether the subtree should be async-by-  // default. When a fiber is created, it inherits the mode of its  // parent. Additional flags can be set at creation time, but after that the  // value should remain unchanged throughout the fiber&#x27;s lifetime, particularly  // before its child fibers are created.  mode: TypeOfMode,  // Effect  flags: Flags,  subtreeFlags: Flags,  deletions: Array&lt;Fiber&gt; | null,  // Singly linked list fast path to the next fiber with side-effects.  nextEffect: Fiber | null,  // The first and last fiber with side-effect within this subtree. This allows  // us to reuse a slice of the linked list when we reuse the work done within  // this fiber.  firstEffect: Fiber | null,  lastEffect: Fiber | null,  lanes: Lanes,  childLanes: Lanes,  // This is a pooled version of a Fiber. Every fiber that gets updated will  // eventually have a pair. There are cases when we can clean up pairs to save  // memory if we need to.  alternate: Fiber | null,  // Time spent rendering this Fiber and its descendants for the current update.  // This tells us how well the tree makes use of sCU for memoization.  // It is reset to 0 each time we render and only updated when we don&#x27;t bailout.  // This field is only set when the enableProfilerTimer flag is enabled.  actualDuration?: number,  // If the Fiber is currently active in the &quot;render&quot; phase,  // This marks the time at which the work began.  // This field is only set when the enableProfilerTimer flag is enabled.  actualStartTime?: number,  // Duration of the most recent render time for this Fiber.  // This value is not updated when we bailout for memoization purposes.  // This field is only set when the enableProfilerTimer flag is enabled.  selfBaseDuration?: number,  // Sum of base times for all descendants of this Fiber.  // This value bubbles up during the &quot;complete&quot; phase.  // This field is only set when the enableProfilerTimer flag is enabled.  treeBaseDuration?: number,  // Conceptual aliases  // workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens  // to be the same as work in progress.  // __DEV__ only  _debugSource?: Source | null,  _debugOwner?: Fiber | null,  _debugIsCurrentlyTiming?: boolean,  _debugNeedsRemount?: boolean,  // Used to verify that the order of hooks does not change between renders.  _debugHookTypes?: Array&lt;HookType&gt; | null,|&#125;;","categories":["React"],"tags":["React"]},{"title":"FiberRoot","url":"/posts/e13a580af543/","content":"FiberRoot\n整个应用的起点\n包含应用挂载的目标节点\n记录整个应用更新过程的各种信息\n\ntype BaseFiberRootProperties = &#123;|  // root节点，render方法接收的第二个参数  containerInfo: any,  // 只有在持久更新中会用到，也就是不支持增量更新的平台，react-dom不会用到  pendingChildren: any,  // 当前应用对应的Fiber对象，是Root Fiber  current: Fiber,  // 一下的优先级是用来区分  // 1) 没有提交(committed)的任务  // 2) 没有提交的挂起任务  // 3) 没有提交的可能被挂起的任务  // 我们选择不追踪每个单独的阻塞登记，为了兼顾性能  // The earliest and latest priority levels that are suspended from committing.  // 最老和新的在提交的时候被挂起的任务  earliestSuspendedTime: ExpirationTime,  latestSuspendedTime: ExpirationTime,  // The earliest and latest priority levels that are not known to be suspended.  // 最老和最新的不确定是否会挂起的优先级（所有任务进来一开始都是这个状态）  earliestPendingTime: ExpirationTime,  latestPendingTime: ExpirationTime,  // The latest priority level that was pinged by a resolved promise and can  // be retried.  // 最新的通过一个promise被reslove并且可以重新尝试的优先级  latestPingedTime: ExpirationTime,  // 如果有错误被抛出并且没有更多的更新存在，我们尝试在处理错误前同步重新从头渲染  // 在`renderRoot`出现无法处理的错误时会被设置为`true`  didError: boolean,  // 正在等待提交的任务的`expirationTime`  pendingCommitExpirationTime: ExpirationTime,  // 已经完成的任务的FiberRoot对象，如果你只有一个Root，那他永远只可能是这个Root对应的Fiber，或者是null  // 在commit阶段只会处理这个值对应的任务  finishedWork: Fiber | null,  // 在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout  timeoutHandle: TimeoutHandle | NoTimeout,  // 顶层context对象，只有主动调用`renderSubtreeIntoContainer`时才会有用  context: Object | null,  pendingContext: Object | null,  // 用来确定第一次渲染的时候是否需要融合  +hydrate: boolean,  // 当前root上剩余的过期时间  // TODO: 提到renderer里面区处理  nextExpirationTimeToWorkOn: ExpirationTime,  // 当前更新对应的过期时间  expirationTime: ExpirationTime,  // List of top-level batches. This list indicates whether a commit should be  // deferred. Also contains completion callbacks.  // TODO: Lift this into the renderer  // 顶层批次（批处理任务？）这个变量指明一个commit是否应该被推迟  // 同时包括完成之后的回调  // 貌似用在测试的时候？  firstBatch: Batch | null,  // root之间关联的链表结构  nextScheduledRoot: FiberRoot | null,|&#125;;\n\n\n\nmode创建跟节点RootFiber时，在current属性上挂载了通过createHostRootFiber创建的fiber对象\nexport function createHostRootFiber(tag: RootTag): Fiber &#123;  let mode;  if (tag === ConcurrentRoot) &#123;    mode = ConcurrentMode | BlockingMode | StrictMode;  &#125; else if (tag === BlockingRoot) &#123;    mode = BlockingMode | StrictMode;  &#125; else &#123;    // tag 为0    mode = NoMode;  &#125;  // 开发时mode为8  if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;    // Always collect profile timings when DevTools are present.    // This enables DevTools to start capturing timing at any point–    // Without some nodes in the tree having empty base times.    mode |= ProfileMode;  &#125;  return createFiber(HostRoot, null, null, mode);&#125;","categories":["React"],"tags":["React"]},{"title":"React Router 解析","url":"/posts/9ef34c07bd32/","content":"整个项目大致分为三个包：\n\nrouter实现了各种类型的 history, 完成了路由配置的底层实现，例如导航，路由 loader，lazy\n\nreact-router实现了各类 hooks, 根组件的 Provider, 可以用组件形式配置的 Route 组件，最终还是会被解析为 routes 配置。\n\nreact-router-com完善了 React 组件，可以直接用组件去声明 BrowserRouter 还是 HashRouter 以及 Link 等业务组件。\n\n\n\nhistory.pushState 参数解释state（状态对象）一个 JavaScript 对象，用于保存与当前历史记录条目关联的状态数据。当用户通过浏览器的前进&#x2F;后退按钮导航到该记录时，可以通过 popstate 事件 (event.state) 获取到这个对象。可以存储当前页面的状态（例如：滚动位置、表单数据、组件状态等），以便在导航回该页面时恢复状态。title（标题）理论上用于设置浏览器历史记录中该条目的标题，但目前所有主流浏览器均忽略此参数。url（新的 URL）指定浏览器地址栏显示的新 URL。页面不会重新加载，但必须满足同源策略（Same-origin Policy）。使用 pushState 不会触发 popstate 事件,popstate 事件仅在用户点击浏览器的后退，前进按钮或通过 JavaScript 调用 history.back()、history.forward() 或 history.go() 方法时触发。\n\n\ngo 方法的行为,不会删除 history 的记录栈，它只是移动指针指向之前或是之后的历史地址。如果地址栏是 hash 改变默认不会刷新页面，如果是 path 改变默认会刷新页面。\n\nBrowser History提供对以下接口对 history 对象进行控制。可以发现并没有对原生对象封装或扩展，而是创建了一个新对象。因此 history 对象只在 react router 内部使用。\nfunction createBrowserLocation() &#123;    return let history: History = &#123;    get action() &#123;      return action;    &#125;,    get location() &#123;      return getLocation(window, globalHistory);    &#125;,    listen(fn: Listener) &#123;      window.addEventListener(PopStateEventType, handlePop);      listener = fn;      return () =&gt; &#123;        window.removeEventListener(PopStateEventType, handlePop);        listener = null;      &#125;;    &#125;,    createHref(to) &#123;      return createHref(window, to);    &#125;,    createURL,    encodeLocation(to) &#123;      let url = createURL(to);      return &#123;        pathname: url.pathname,        search: url.search,        hash: url.hash,      &#125;;    &#125;,    push,    replace,    go(n) &#123;      return globalHistory.go(n);    &#125;,&#125;\n\npush 方法实现\nfunction push(to: To, state?: any) &#123;  action = Action.Push;  let location = createLocation(history.location, to, state);  if (validateLocation) validateLocation(location, to);  index = getIndex() + 1;  let historyState = getHistoryState(location, index);  let url = history.createHref(location);  /// ios 有 100条 pushState 的限制  try &#123;    globalHistory.pushState(historyState, &quot;&quot;, url);  &#125; catch (error) &#123;    if (error instanceof DOMException &amp;&amp; error.name === &quot;DataCloneError&quot;) &#123;      throw error;    &#125;    window.location.assign(url);  &#125;&#125;\n\nHash HistoryHash Router 多用于静态托管环境无法配置服务器将所有路径重定向到入口文件。\nhash router 的设计与 browser router 共用了对外接口的实现，因为对于浏览器来说无论是地址变化还是 hash 变化都是 pushState，当浏览器返回或前进是都会触发 popstate 事件，因此区别只是在于处理的参数不同。\nreact router v6 版本并没有使用 hashchange 实现事件监听。hashchange IE8+ 开始支持，popstate IE10+ 开始支持。\nMemory History使用数组作为历史记录栈，且监听函数不能多次绑定\nexport function createMemoryHistory(  options: MemoryHistoryOptions = &#123;&#125;): MemoryHistory &#123;  let &#123; initialEntries = [&quot;/&quot;], initialIndex, v5Compat = false &#125; = options;  let entries: Location[]; // Declare so we can access from createMemoryLocation  entries = initialEntries.map((entry, index) =&gt;    createMemoryLocation(      entry,      typeof entry === &quot;string&quot; ? null : entry.state,      index === 0 ? &quot;default&quot; : undefined    )  );  let index = clampIndex(    initialIndex == null ? entries.length - 1 : initialIndex  );  let action = Action.Pop;  let listener: Listener | null = null;  function clampIndex(n: number): number &#123;    return Math.min(Math.max(n, 0), entries.length - 1);  &#125;  function getCurrentLocation(): Location &#123;    return entries[index];  &#125;  function createMemoryLocation(    to: To,    state: any = null,    key?: string  ): Location &#123;    let location = createLocation(      entries ? getCurrentLocation().pathname : &quot;/&quot;,      to,      state,      key    );    warning(      location.pathname.charAt(0) === &quot;/&quot;,      `relative pathnames are not supported in memory history: $&#123;JSON.stringify(        to      )&#125;`    );    return location;  &#125;  function createHref(to: To) &#123;    return typeof to === &quot;string&quot; ? to : createPath(to);  &#125;  let history: MemoryHistory = &#123;    get index() &#123;      return index;    &#125;,    get action() &#123;      return action;    &#125;,    get location() &#123;      return getCurrentLocation();    &#125;,    createHref,    createURL(to) &#123;      return new URL(createHref(to), &quot;http://localhost&quot;);    &#125;,    encodeLocation(to: To) &#123;      let path = typeof to === &quot;string&quot; ? parsePath(to) : to;      return &#123;        pathname: path.pathname || &quot;&quot;,        search: path.search || &quot;&quot;,        hash: path.hash || &quot;&quot;,      &#125;;    &#125;,    push(to, state) &#123;      action = Action.Push;      let nextLocation = createMemoryLocation(to, state);      index += 1;      entries.splice(index, entries.length, nextLocation);      if (v5Compat &amp;&amp; listener) &#123;        listener(&#123; action, location: nextLocation, delta: 1 &#125;);      &#125;    &#125;,    replace(to, state) &#123;      action = Action.Replace;      let nextLocation = createMemoryLocation(to, state);      entries[index] = nextLocation;      if (v5Compat &amp;&amp; listener) &#123;        listener(&#123; action, location: nextLocation, delta: 0 &#125;);      &#125;    &#125;,    go(delta) &#123;      action = Action.Pop;      let nextIndex = clampIndex(index + delta);      let nextLocation = entries[nextIndex];      index = nextIndex;      if (listener) &#123;        listener(&#123; action, location: nextLocation, delta &#125;);      &#125;    &#125;,    listen(fn: Listener) &#123;      listener = fn;      return () =&gt; &#123;        listener = null;      &#125;;    &#125;,  &#125;;  return history;&#125;\n\nnavigatenavigate 是 router 包中的核心方法，执行导航流程，中间处理各种配置，数据加载策略，loader,lazy 也会在导航过程中处理\nconst route = createRoute([  &#123;    path: &quot;/&quot;,  &#125;,  &#123;    id: &quot;json&quot;,    path: &quot;/test&quot;,    loader: true,    children: [      &#123;        id: &quot;text&quot;,        index: true,        loader: true,      &#125;,    ],  &#125;,]);await route.navigate(&quot;/test&quot;);\n\nasync function navigate(  to: number | To | null,  opts?: RouterNavigateOptions): Promise&lt;void&gt; &#123;  // 传入数字特殊处理，相当于 history.go  if (typeof to === &quot;number&quot;) &#123;    init.history.go(to);    return;  &#125;  // 根据参数创建将要导航的地址  // &#123;pathname: &#x27;/test&#x27;, search: &#x27;&#x27;, hash: &#x27;&#x27;, state: null, key: &#x27;h5jaikrx&#x27;&#125;  nextLocation = &#123;    ...nextLocation,    ...init.history.encodeLocation(nextLocation),  &#125;;  // 记录滚动条的位置  saveScrollPosition(state.location, state.matches);  // 找出匹配了哪些路由  let matched = matchRoutes(routesToUse, location, basename);  // 处理 lazy 属性  let loadRouteDefinitionsPromises = matches.map((m) =&gt;    m.route.lazy      ? loadLazyRouteModule(m.route, mapRouteProperties, manifest)      : undefined  );  // 处理路由中需要请求的数据  let results = await dataStrategyImpl(&#123;    matches: dsMatches,    request,    params: matches[0].params,    fetcherKey,    context: requestContext,  &#125;);  // 如果 loader 返回 redirect  let redirect = findRedirect(loaderResults);  if (redirect) &#123;    await startRedirectNavigation(request, redirect.result, true, &#123;      replace,    &#125;);    return &#123; shortCircuited: true &#125;;  &#125;  // 更新内部状态，执行 subscribers 添加的监听方法  updateState();  // 获取到数据，pushState 提交导航  if (pendingAction === HistoryAction.Push) &#123;    init.history.push(location, location.state);  &#125;&#125;\n\n组件更新绑定const router = createBrowserRouter([  &#123;    path: &quot;/&quot;,    element: &lt;Root /&gt;,    children: [      &#123;        path: &quot;dashboard&quot;,        element: &lt;Dashboard /&gt;,      &#125;,      &#123;        path: &quot;about&quot;,        element: &lt;About /&gt;,      &#125;,    ],  &#125;,]);&lt;RouterProvider router=&#123;router&#125; fallbackElement=&#123;&lt;BigSpinner /&gt;&#125; /&gt;;\n\nRouterProvider 会注册监听函数到 router 的 subscribes, 当 navigate 执行结束，会执行 subscribes 中注册的回调函数\n当通过 RouterProvider 定义路由时，React Router 会自动优化组件的重用和渲染逻辑 推荐使用上面的写法，而不是组件的写法。\nexport function RouterProvider(&#123;  fallbackElement,  router,  future,&#125;: RouterProviderProps): React.ReactElement &#123;  let [state, setStateImpl] = React.useState(router.state);  let setState = React.useCallback&lt;RouterSubscriber&gt;(    (newState: RouterState) =&gt; &#123;      setStateImpl(newState);    &#125;,    [setStateImpl]  );  // 导航结束会触发更新  React.useLayoutEffect(() =&gt; router.subscribe(setState), [router, setState]);  let navigator = React.useMemo((): Navigator =&gt; &#123;    return &#123;      //...    &#125;;  &#125;, [router]);  let basename = router.basename || &quot;/&quot;;  let dataRouterContext = React.useMemo(    () =&gt; (&#123;      router,      navigator,      static: false,      basename,    &#125;),    [router, navigator, basename]  );  return (    &lt;&gt;      &lt;DataRouterContext.Provider value=&#123;dataRouterContext&#125;&gt;        &lt;DataRouterStateContext.Provider value=&#123;state&#125;&gt;          &lt;Router            basename=&#123;basename&#125;            location=&#123;state.location&#125;            navigationType=&#123;state.historyAction&#125;            navigator=&#123;navigator&#125;          &gt;            &#123;state.initialized || router.future.v7_partialHydration ? (              &lt;DataRoutes                routes=&#123;router.routes&#125;                future=&#123;router.future&#125;                state=&#123;state&#125;              /&gt;            ) : (              fallbackElement            )&#125;          &lt;/Router&gt;        &lt;/DataRouterStateContext.Provider&gt;      &lt;/DataRouterContext.Provider&gt;      &#123;null&#125;    &lt;/&gt;  );&#125;\n\nDataRoutes 会递归处理 routers 数组，生成嵌套关系的组件树。\nif (dataRouterState &amp;&amp; future &amp;&amp; future.v7_partialHydration) &#123;  for (let i = 0; i &lt; renderedMatches.length; i++) &#123;    let match = renderedMatches[i];    if (match.route.HydrateFallback || match.route.hydrateFallbackElement) &#123;      fallbackIndex = i;    &#125;    if (match.route.id) &#123;      let &#123; loaderData, errors &#125; = dataRouterState;      let needsToRunLoader =        match.route.loader &amp;&amp;        loaderData[match.route.id] === undefined &amp;&amp;        (!errors || errors[match.route.id] === undefined);      if (match.route.lazy || needsToRunLoader) &#123;        renderFallback = true;        if (fallbackIndex &gt;= 0) &#123;          renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);        &#125; else &#123;          renderedMatches = [renderedMatches[0]];        &#125;        break;      &#125;    &#125;  &#125;&#125;return renderedMatches.reduceRight((outlet, match, index) =&gt; &#123;    let error: any;    let shouldRenderHydrateFallback = false;    let errorElement: React.ReactNode | null = null;    let hydrateFallbackElement: React.ReactNode | null = null;    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));    let getChildren = () =&gt; &#123;      let children: React.ReactNode;      if (error) &#123;        children = errorElement;      &#125; else if (shouldRenderHydrateFallback) &#123;        children = hydrateFallbackElement;      &#125; else if (match.route.Component) &#123;        children = &lt;match.route.Component /&gt;;      &#125; else if (match.route.element) &#123;        children = match.route.element;      &#125; else &#123;        children = outlet;      &#125;      return (        &lt;RenderedRoute          match=&#123;match&#125;          routeContext=&#123;&#123;            outlet,            matches,            isDataRoute: dataRouterState != null,          &#125;&#125;          children=&#123;children&#125;        /&gt;      );    &#125;;&#125;\n\n组件路由是如何工作的可以使用组件的方式来组织路由，Routes 会收集它下面的所有 Route 并渲染匹配的路由。\nfunction App() &#123;  return (    &lt;BrowserRouter basename=&quot;/app&quot;&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/&quot; /&gt; &#123;/* 👈 Renders at /app/ */&#125;      &lt;/Routes&gt;    &lt;/BrowserRouter&gt;  );&#125;\n\nRouters 会遍历自己所有的子元素，解析出组件的树结构，同样会交给上面处理 renderedMatches 的方法\nexport function Routes(&#123;  children,  location,&#125;: RoutesProps): React.ReactElement | null &#123;  function createRoutesFromChildren(children) &#123;    let routes: RouteObject[] = [];    React.Children.forEach(children, (element, index) =&gt; &#123;      if (!React.isValidElement(element)) &#123;        return;      &#125;      let treePath = [...parentPath, index];      let route: RouteObject = &#123;&#125;;      if (element.props.children) &#123;        route.children = createRoutesFromChildren(          element.props.children,          treePath        );      &#125;      routes.push(route);    &#125;);    return routes;  &#125;  return useRoutes(createRoutesFromChildren(children));&#125;\n\n全局拦截器const GlobalInterceptor = (props) =&gt; &#123;  const location = useLocation();  if (!isAuthenticated() &amp;&amp; location.pathname !== &quot;/login&quot;)    return &lt;Navigate to=&quot;/login&quot; replace=&#123;true&#125; /&gt;;  return props.children;&#125;;const App = () =&gt; &#123;  return (    &lt;Router&gt;      &lt;GlobalInterceptor&gt;        &lt;Routes&gt;          &lt;Route path=&quot;/dashboard&quot; element=&#123;&lt;Dashboard /&gt;&#125; /&gt;        &lt;/Routes&gt;      &lt;/GlobalInterceptor&gt;    &lt;/Router&gt;  );&#125;;\n","categories":["React"],"tags":["React","React Router"]},{"title":"ReactDOM.render","url":"/posts/414b16685f68/","content":"ReactDOM.renderpackages&#x2F;react-dom&#x2F;src&#x2F;client&#x2F;ReactDOMLegacy.js\n\n创建ReactRoot\n创将FiberRoot和RootFiber\n创将更新\n\nexport function render(  element: React$Element&lt;any&gt;,  container: Container,  callback: ?Function,) &#123;   // ...  return legacyRenderSubtreeIntoContainer(    null,    element,    container,    false,    callback,  );&#125;\n\nfunction legacyRenderSubtreeIntoContainer(  parentComponent: ?React$Component&lt;any, any&gt;, // 父组件  children: ReactNodeList, // 渲染组件  container: Container, // 容器  forceHydrate: boolean, // 是否强制注入  callback: ?Function, // 回调函数) &#123;  //...  // 查看是否有复用的节点  let root: RootType = (container._reactRootContainer: any);  let fiberRoot;  if (!root) &#123;    // 初始化加载，在root上挂载创建的ReactRooter     root = container._reactRootContainer = legacyCreateRootFromDOMContainer(      container,      forceHydrate,    );    // _internalRoot 也就是内部使用的fiberRoot    fiberRoot = root._internalRoot;    //...    unbatchedUpdates(() =&gt; &#123;      updateContainer(children, fiberRoot, parentComponent, callback);    &#125;);  &#125; else &#123;    //...     updateContainer(children, fiberRoot, parentComponent, callback);  &#125;  // 最终都是调用了 updateContainer，并把创将的fiberRoot传入  return getPublicRootInstance(fiberRoot);&#125;\n\nlegacyCreateRootFromDOMContainer// 直接返回原生节点function getReactRootElementInContainer(container: any) &#123;  if (!container) &#123;    return null;  &#125;  if (container.nodeType === DOCUMENT_NODE) &#123;    return container.documentElement;  &#125; else &#123;    return container.firstChild;  &#125;&#125;// 如果原生节点存在 shouldHydrate = truefunction shouldHydrateDueToLegacyHeuristic(container) &#123;  const rootElement = getReactRootElementInContainer(container);  return !!(    rootElement &amp;&amp;    rootElement.nodeType === ELEMENT_NODE &amp;&amp;    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)  );&#125;function legacyCreateRootFromDOMContainer(  container: Container,  forceHydrate: boolean,): RootType &#123;  const shouldHydrate =    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);  // First clear any existing content.  if (!shouldHydrate) &#123;    let warned = false;    let rootSibling;    // 清空容器的子节点    while ((rootSibling = container.lastChild)) &#123;      if (__DEV__) &#123;        if (          !warned &amp;&amp;          rootSibling.nodeType === ELEMENT_NODE &amp;&amp;          // ROOT_ATTRIBUTE_NAME 用于服务端渲染的判断，是否需要合并节点          (rootSibling: any).hasAttribute(ROOT_ATTRIBUTE_NAME)        ) &#123;          warned = true;          console.error(            &#x27;render(): Target node has markup rendered by React, but there &#x27; +              &#x27;are unrelated nodes as well. This is most commonly caused by &#x27; +              &#x27;white-space inserted around server-rendered markup.&#x27;,          );        &#125;      &#125;      container.removeChild(rootSibling);    &#125;  &#125;  // ...  return createLegacyRoot(    container,    shouldHydrate      ? &#123;          hydrate: true,        &#125;      : undefined,  );&#125;\n\ncreateLegacyRoot 创建ReactRootexport function createLegacyRoot(  container: Container,  options?: RootOptions,): RootType &#123;  //   return new ReactDOMBlockingRoot(container, LegacyRoot, options);&#125;function ReactDOMBlockingRoot(  container: Container,  tag: RootTag,  options: void | RootOptions,) &#123;  this._internalRoot = createRootImpl(container, tag, options);&#125;function createRootImpl(  container: Container,  // 常量0,标识根节点  tag: RootTag,  options: void | RootOptions,) &#123;  // createContainer 最终调用了createFiberRoot  const root = createContainer(container, tag, hydrate, hydrationCallbacks);  //...  return root;&#125;\n\ncreateFiberRootexport function createFiberRoot(  containerInfo: any,  tag: RootTag,  hydrate: boolean,  hydrationCallbacks: null | SuspenseHydrationCallbacks,): FiberRoot &#123;  // 容器节点本身是FiberRoot对象  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);  // 创建的Fiber对象  const uninitializedFiber = createHostRootFiber(tag);  root.current = uninitializedFiber;  uninitializedFiber.stateNode = root;  // 为原始的fiber节点添加updateQueue信息  // function initializeUpdateQueue(fiber) &#123;  //   var queue = &#123;  //     baseState: fiber.memoizedState,  //     firstBaseUpdate: null,  //     lastBaseUpdate: null,  //     shared: &#123;  //       pending: null  //     &#125;,  //     effects: null  //   &#125;;  //   fiber.updateQueue = queue;  // &#125;  initializeUpdateQueue(uninitializedFiber);  return root;&#125;\n\nupdateContainerexport function updateContainer(  element: ReactNodeList,  container: OpaqueRoot,  parentComponent: ?React$Component&lt;any, any&gt;,  callback: ?Function,): Lane &#123;  // container = container._reactRootContainer = legacyCreateRootFromDOMContainer(container,forceHydrate)._internalRoot;  const current = container.current;  const eventTime = requestEventTime();  //创将事件优先级  const lane = requestUpdateLane(current);  // 创将更新对象  const update = createUpdate(eventTime, lane);  update.payload = &#123;element&#125;;  // 加入到更新队列中  enqueueUpdate(current, update);  // 调度更新  scheduleUpdateOnFiber(current, lane, eventTime);  return lane;&#125;","categories":["React"],"tags":["React"]},{"title":"Recoil状态管理库","url":"/posts/e94b90efdf77/","content":"Recoil 产生背景前端的应用越来越复杂，诸如常见的 Web 监控面板，包含各类的性能数据、节点信息、分类聚合用来进行应用分析。可以想象得到面板中包含各类的交互行为，编辑、删除、添加、将一个数据源绑定多个面板等等。除此之外，还需要对数据持久化，这样就能把 url 分享给其他人，并要确保被分享的人看到的是一致的。\n因此开发过程中要尽量做到页面最小化更新达到高性能的目的，需要对数据流的操作更加精细。\n面对这样的挑战，一般会想到用一些状态管理的函数或者库，如 React 内置的 state 管理，或者 Redux。\nRecoil 想通过一个不一样的方式来解决这些问题，主要分为 3 个方面：\nFlexible shared state: 在 react tree 任意的地方都能灵活共享 state，并保持高性能Derived data and queries: 高效可靠地根据变化的 state 进行计算App-wide state observation: time travel debugging, 支持 undo, 日志持久化\nRecoil 主要设计有一个应用基于这样一个场景，将 List 中更新一个节点，然后对应 Canvas 中的节点也更新\n\n第 1 种方式把 state 传到公共的父节点转发给 canvas 子节点，这样显然会全量 re-render\n第 2 种方式给父节点加 Provider 在子节点加 Consumer，不过每多加一个 item 就要多一层 Provider\n\n第 3 种方式在 react tree 上创建另一个正交的 tree，把每片 item 的 state 抽出来。每个 component 都有对应单独的一片 state，当数据更新的时候对应的组件也会更新。Recoil 把 这每一片的数据称为 Atom，Atom 是可订阅可变的 state 单元。\n\n配合 useRecoilState 可以使用这些 Atom，实践上对多个 item 的 Atom 可以用 memorize 进行优化，具体可以在官方文档查看\nDerived Data有这么一个场景需要根据多个 Item Box 计算 Bounding Box\n\n如果你是 Vue 的爱好者，你可能想到了计算属性。Derived Data 确实有 computed props 的味道，具体思路是选取多个 Atom 进行计算，然后返回一个新的 state。因此在 Recoil 中设计了 select 这样的 API 来选取多个 Atom 进行计算。\n\nselect 的设计和 Proxy 挺像的，属性上有 get 进行读取，有 set 进行设置，函数内部又有 get， set 操作 state\nimport &#123;atom, selector, useRecoilState&#125; from &#x27;recoil&#x27;;const tempFahrenheit = atom(&#123;  key: &#x27;tempFahrenheit&#x27;,  default: 32,&#125;);const tempCelcius = selector(&#123;  key: &#x27;tempCelcius&#x27;,  get: (&#123;get&#125;) =&gt; ((get(tempFahrenheit) - 32) * 5) / 9,  set: (&#123;set&#125;, newValue) =&gt; set(tempFahrenheit, (newValue * 9) / 5 + 32),&#125;);\n\nApp-wide observation这个场景下需要把 url 分享给其他人，别人打开相同的链接也能看到一样的页面。\n那么就需要 observe Atom 的变更，Recoil 使用 useTransactionObservation 进行订阅\nuseTransactionObservation((&#123;atomValues,modifiedAtoms,...&#125; =&gt; &#123;&#125;))\n\n另一方面，打开链接的时候也需要对输入的数据进行校验\nconst counter = atom(&#123;  key: &#x27;myCounter&#x27;,  default: 0,  validator: (untrustedInput),  metadata: ...&#125;)","categories":["React"],"tags":["Recoil"]},{"title":"createUpdate","url":"/posts/5c53cf59bfce/","content":"Update用于记录组件状态的改变，保存到UpdateQueue中，多个Update可以同时存在\n&#x2F;packages&#x2F;react-reconciler&#x2F;src&#x2F;ReactUpdateQueue.new.js \nexport function createUpdate(eventTime: number, lane: Lane): Update&lt;*&gt; &#123;  const update: Update&lt;*&gt; = &#123;    eventTime,    lane,    // export const UpdateState = 0; 更新    // export const ReplaceState = 1; 替换更新    // export const ForceUpdate = 2; 强制更新    // export const CaptureUpdate = 3; 捕获哦错误后更新    tag: UpdateState,    payload: null, // 更新内容，比如`setState`接收的第一个参数    callback: null, // 对应的回调，`setState`，`render`都有    next: null, // 指向下一个更新  &#125;;  return update;&#125;\n\nenqueueUpdateexport function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123;  // fiber 节点中的updateQueue,默认是null  const updateQueue = fiber.updateQueue;  if (updateQueue === null) &#123;    // 只在未挂载时执行    return;  &#125;  const sharedQueue: SharedQueue&lt;State&gt; = (updateQueue: any).shared;  // pending update链表，最新的更新在链表的顶端  // pending = 3-&gt;2-&gt;1-&gt;3....  const pending = sharedQueue.pending;  if (pending === null) &#123;    // 只有一个update时候，循环引用    update.next = update;  &#125; else &#123;    update.next = pending.next;    pending.next = update;  &#125;  sharedQueue.pending = update;","categories":["React"],"tags":["React"]},{"title":"eventTime","url":"/posts/264645bd7a07/","content":"eventTime用于的调度更新的时间戳 通过 requestEventTime 创建\n// 用二进制来表示所处的上下文状态export const NoContext = /*             */ 0b0000000;const BatchedContext = /*               */ 0b0000001;const EventContext = /*                 */ 0b0000010;const DiscreteEventContext = /*         */ 0b0000100;const LegacyUnbatchedContext = /*       */ 0b0001000;const RenderContext = /*                */ 0b0010000;const CommitContext = /*                */ 0b0100000;export const RetryAfterError = /*       */ 0b1000000;var currentEventTime = NoTimestamp = -1;;// executionContext = NoContextexport function requestEventTime() &#123;  if ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;    // We&#x27;re inside React, so it&#x27;s fine to read the actual time.    return now();  &#125;  // 不在react中，可能在浏览器的事件中  if (currentEventTime !== NoTimestamp) &#123;    // 对所有更新使用相同的开始时间，直到再次进入react中    return currentEventTime;  &#125;  // 这是React运行后后的第一次更新。计算新的开始时间。  currentEventTime = now();  return currentEventTime;&#125;\n\n获取时间戳的时候，如果Date对象初始化的时间过长，在使用的时候还需要把初始化的时间减去\nlet getCurrentTime;const hasPerformanceNow =  typeof performance === &#x27;object&#x27; &amp;&amp; typeof performance.now === &#x27;function&#x27;;if (hasPerformanceNow) &#123;  const localPerformance = performance;  getCurrentTime = () =&gt; localPerformance.now();&#125; else &#123;  const localDate = Date;  const initialTime = localDate.now();  getCurrentTime = () =&gt; localDate.now() - initialTime;&#125;var Scheduler_now = Scheduler.unstable_now = getCurrentTime;var initialTimeMs$1 = Scheduler_now$1(); // 如果初始化的事件戳非常小，直接使用 initialTimeMs，对于现代浏览器直接使用performance.now// 在老的浏览器中回退使用Date.now, 返回Unix事件戳，这时需要减去模块初始化的时间来模拟 performance.now// 并把时间控制在32位以内var now = initialTimeMs$1 &lt; 10000 ? Scheduler_now$1 : function () &#123;  return Scheduler_now$1() - initialTimeMs$1;&#125;;","categories":["React"],"tags":["React"]},{"title":"Highcharts wrapper for React","url":"/posts/5735b2be6e00/","content":"简介一个非常精简的包装工具,可以在 React 项目中使用 highcharts\n源码分析服务端渲染的时候 useLayoutEffect 会抛出警告,所以需要按条件使用,如果是浏览器环境使用 useLayoutEffect,如果是服务器环境使用 useEffect\n使用 useLayoutEffect 可以保证在布局阶段, ref 所指向的挂载元素是可以使用的,也可以用在一个父组件的 componentDidMount\n// 区分浏览器环境还是const useIsomorphicLayoutEffect =  typeof window !== &#x27;undefined&#x27; ? useLayoutEffect : useEffect;// 使用 forwardRef 转发 ref, 将 ref 传递到子组件// 如果有需要可以通过传入 ref 属性,获取到挂载节点的真是DOM元素// 也可以配合 useImperativeHandle 使用const HighchartsReact = forwardRef(  function HighchartsReact(props, ref) &#123;    const containerRef = useRef();    const chartRef = useRef();    useIsomorphicLayoutEffect(() =&gt; &#123;      function createChart() &#123;        const H = props.highcharts || (          typeof window === &#x27;object&#x27; &amp;&amp; window.Highcharts        );        // 暴露参数,用于表明实例化图表类型        const constructorType = props.constructorType || &#x27;chart&#x27;;        if (!H) &#123;          console.warn(&#x27;The &quot;highcharts&quot; property was not passed.&#x27;);        &#125; else if (!H[constructorType]) &#123;          console.warn(            &#x27;The &quot;constructorType&quot; property is incorrect or some &#x27; +              &#x27;required module is not imported.&#x27;          );        // options 必填参数,如果没有提示警告        &#125; else if (!props.options) &#123;          console.warn(&#x27;The &quot;options&quot; property was not passed.&#x27;);        &#125; else &#123;          // 创建图表实例          chartRef.current = H[constructorType](            containerRef.current,            props.options,            props.callback ? props.callback : undefined          );        &#125;      &#125;      if (!chartRef.current) &#123;        createChart();      &#125; else &#123;        // 是否允许图表更新,如果为假,在接受到新的 props 之后会直接忽略掉        if (props.allowChartUpdate !== false) &#123;          // immutable 用于指定是否使用不可变数据          // 本质就是不会再原有的图表上更新,而会直接创建新图表的实例          if (!props.immutable &amp;&amp; chartRef.current) &#123;            chartRef.current.update(              props.options,              // 与用指定原生的更新参数,由 highcharts 自己提供              ...(props.updateArgs || [true, true])            );          &#125; else &#123;            createChart();          &#125;        &#125;      &#125;    &#125;);    useIsomorphicLayoutEffect(() =&gt; &#123;      return () =&gt; &#123;        // 组件卸载的时候注销实例        if (chartRef.current) &#123;          chartRef.current.destroy();          chartRef.current = null;        &#125;      &#125;;    &#125;, []);        // 一般配合 forwardRef 使用    // 可以用于暴露封装组件内部的状态    // 通过 ref.current.chart 或 ref.current.chart 可以在外部获取到组件实例,以及挂载节点    useImperativeHandle(      ref,      () =&gt; (&#123;        get chart() &#123;          return chartRef.current;        &#125;,        container: containerRef      &#125;),      []    );    // Create container for the chart    return &lt;div &#123; ...props.containerProps &#125; ref=&#123; containerRef &#125; /&gt;;  &#125;);export default memo(HighchartsReact);\n","categories":["React"],"tags":["React"]},{"title":"React Redux 解析","url":"/posts/395c5c698d67/","content":"如何整合 UI 的更新redux 只有简单的 subscribe 和 dispatch 的方法，而且 subscribe 执行的时候无法从回调函数中获取到数据的更新。\n因此需要将 render 方法添加监听，并在监听中获取 store, 解析出需要的数据用于 UI 渲染。\nconst store = createStore(counter);store.subscribe(render);function render() &#123;  const state = store.getState();  const newValue = state.toString();  const valueEl = document.getElementById(&quot;value&quot;);  valueEl.innerHTML = newValue;&#125;\n\n如果想要手动在 react 中集成，类似于以下的效果。但是这样存在的问题就是任何的 dispatch 都会触发 subscribe 订阅方法的执行，因此为了优化不必要的渲染，还需要做以下的事情\n\n从 store 中解构出需要的数据\n与上一次保存的数据对比, 只有在获取的数据和最后保存的数据不一致时才会更新 UI\n保存当前的数据为了下一次对比使用\n\nimport &#123; store &#125; from &quot;app/store&quot;; // 1class TodoList extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      todos: store.getState().todos, // 4    &#125;;    store.subscribe(this.handleStoreUpdate); // 2  &#125;  handleStoreUpdate = () =&gt; &#123;    const &#123; todos &#125; = store.getState(); // 3.1, 3.2    this.setState(&#123; todos &#125;); // 3.3  &#125;;  render() &#123;    const &#123; todos &#125; = this.state;    const listItems = todos.map((todo) =&gt; &lt;TodoItem todo=&#123;todo&#125; /&gt;);    return &lt;div&gt;&#123;listItems&#125;&lt;/div&gt;;  &#125;&#125;\n\n这也就是 react-redux connect 方法产生的原因，它帮助解析并对比数据，只有在数据改变时才会更新 UI\nconnect 接受 map 方法和组件，会将 map 之后的值和 dispatch 方法传递给组件，消费者只要简单的调用 dispatch 就会触发组件的更新。\nfunction connect(mapStateToProps, mapDispatchToProps) &#123;  return function (WrappedComponent) &#123;    return class ConnectWrapper extends React.Component &#123;      componentDidMount() &#123;        this.unsubscribe = store.subscribe(this.handleChange);      &#125;      componentWillUnmount() &#123;        this.unsubscribe();      &#125;      handleChange = () =&gt; &#123;        this.forceUpdate();      &#125;;      render() &#123;        return (          &lt;WrappedComponent            &#123;...this.props&#125;            // plus props calculated from Redux store            &#123;...mapStateToProps(store.getState(), this.props)&#125;            &#123;...mapDispatchToProps(store.dispatch, this.props)&#125;          /&gt;        );      &#125;    &#125;;  &#125;;&#125;\n\n4.x每个执行 connect 的组件都会添加一个回调函数到 subscribe 中，第一次触发 action 所有的回调函数都会执行\n是否更新的判断依赖于 store 的不可变性, 会进行以下三个检查\n\nprevStoreState !&#x3D;&#x3D; store.getState()\n如果不相等，current &#x3D; mapState() 检查 prev &#x3D;&#x3D;&#x3D; current\n合并所有参数 mergeProps(ownProps,stateProps,dispatchProps)\n\n每次更新都会创建一个新组建，但是由于 React 的检查，只要完全相同的两个组件就会跳过更新，一定程度上避免子组件的渲染。\n5.x核心是优化了自顶向下的更新。下面的例子中点击父组件的按钮，子组件\n","categories":["React"],"tags":["React"]},{"title":"React Router v7 概览","url":"/posts/ce9fece0e470/","content":"v7 可以让 React Router 作为框架来使用，利用提供的 cli 工具创建项目，提供了相关的构建包，以 React Router 的视角开发项目。以下是官方提供的特性说明：\n\nVite 捆绑器和开发服务器集成\n热模块替换\n代码分割\n带类型安全的路由约定\n文件系统或基于配置的路由\n带类型安全的数据加载\n带类型安全的操作\n操作后页面数据的自动重新验证\nSSR、SPA 和静态呈现策略\n待定状态和乐观 UI 的 api\n部署适配器\n\n特殊文件react-router.config.ts可选，全局的配置文件。\nroot.ts必须，唯一的必须路由，是 routes 目录有所有路由的父路由，也用于描述 HTML 文档。\n可以把 React Router 提供的全局组件写在这里，只会渲染一次。\nimport type &#123; LinksFunction &#125; from &quot;react-router&quot;;import &#123; Links, Meta, Outlet, Scripts, ScrollRestoration &#125; from &quot;react-router&quot;;import &quot;./global-styles.css&quot;;export default function App() &#123;  return (    &lt;html lang=&quot;en&quot;&gt;      &lt;head&gt;        &lt;meta charSet=&quot;utf-8&quot; /&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;        &#123;/* 所有路由上的所有meta导出都会在这里渲染 */&#125;        &lt;Meta /&gt;        &#123;/* 所有路由上的所有link导出都会在这里渲染 */&#125;        &lt;Links /&gt;      &lt;/head&gt;      &lt;body&gt;        &#123;/* 子路由*/&#125;        &lt;Outlet /&gt;        &#123;/* 管理客户端渲染时候的滚动条位置 */&#125;        &#123;/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */&#125;        &lt;ScrollRestoration /&gt;        &lt;Scripts /&gt;      &lt;/body&gt;    &lt;/html&gt;  );&#125;\n\nContent Security Policy (CSP)CSP 是一种浏览器安全机制，用于防止跨站脚本攻击（XSS）等安全问题。通过配置 CSP，开发者可以限制页面加载的资源（如脚本、样式等）的来源和执行方式。\nNoncenonce 是 CSP 中的一个概念，表示一个随机生成的字符串（一次性值）。通过在 CSP 中配置 nonce，可以允许特定的内联脚本或动态加载的脚本执行，而不会违反 CSP 规则。\n如果你使用了基于 nonce 的 CSP 策略：如果你的 CSP 配置中使用了 nonce 来允许脚本执行，那么你需要在 React Router 的相关组件中传递 nonce 属性。这是因为 React Router 可能会动态加载或执行一些脚本，这些脚本需要符合你的 CSP 策略。\n如果你没有使用基于 nonce 的 CSP 策略：如果你的 CSP 配置不涉及 nonce，或者你不需要对脚本进行特殊限制，那么你可以忽略 nonce 属性（如示例中所示）.\n假设你的 CSP 配置如下：\nContent-Security-Policy: script-src &#x27;nonce-abc123&#x27;;\n\n这意味着只有带有 nonce&#x3D;”abc123” 的脚本才能执行。在这种情况下，你需要在 React Router 中传递 nonce 属性：\n&lt;Router nonce=&quot;abc123&quot;&gt;&#123;/* Your routes here */&#125;&lt;/Router&gt;\n\nlayout-export\n一个单独导出的组件，可以避免在 Root Component,HydrateFallback, ErrorBoundary 重复声明 app 的框架元素。\nroutes.ts必须， 统一的路由配置文件，它将自动对每个路由进行代码拆分，为参数和数据提供类型安全，并在用户导航到数据时自动加载具有挂起状态访问权的数据。\nimport type &#123; RouteConfig &#125; from &quot;@react-router/dev/routes&quot;;import &#123; route &#125; from &quot;@react-router/dev/routes&quot;;export default [  route(&quot;contacts/:contactId&quot;, &quot;routes/contact.tsx&quot;),] satisfies RouteConfig;\n\nindex route当路由没有匹配任何路径的时候，他会在 Outlet 中显示空白，index 可以当做是默认路由的视图。\n// app/routes.tsimport type &#123; RouteConfig &#125; from &quot;@react-router/dev/routes&quot;;import &#123; index, route &#125; from &quot;@react-router/dev/routes&quot;;export default [  index(&quot;routes/home.tsx&quot;),  route(&quot;contacts/:contactId&quot;, &quot;routes/contact.tsx&quot;),] satisfies RouteConfig;\n\nlayout route可以在路由的配置文件中，描述组件的嵌套关系.\nimport type &#123; RouteConfig &#125; from &quot;@react-router/dev/routes&quot;;import &#123; index, layout, route &#125; from &quot;@react-router/dev/routes&quot;;export default [  layout(&quot;layouts/sidebar.tsx&quot;, [    index(&quot;routes/home.tsx&quot;),    // 会渲染到 layouts/sidebar.tsx 这个 layout 下的 Outlet 里面。    route(&quot;contacts/:contactId&quot;, &quot;routes/contact.tsx&quot;),  ]),  route(&quot;about&quot;, &quot;routes/about.tsx&quot;),] satisfies RouteConfig;\n\n特殊组件用于展示路由\n// app/root.tximport &#123; Outlet &#125; from &quot;react-router&quot;;export default function App() &#123;  return (    &lt;&gt;      &lt;div id=&quot;detail&quot;&gt;        &lt;Outlet /&gt;      &lt;/div&gt;    &lt;/&gt;  );&#125;\n\n核心方法clientLoader只在浏览器中调用，为路由组件提供数据\n// app/root.tsxexport async function clientLoader() &#123;  const contacts = await getContacts();  return &#123; contacts &#125;;&#125;export default function App(&#123; loaderData &#125;: any) &#123;  const &#123; contacts &#125; = loaderData;  // ...&#125;\n\nHydrateFallback如果通过 react-router.config.ts 配置为客户端渲染，那么在 app 根文件执行之前是没有任何内容。\n提供一个 HydrateFallback 方法，在 app 被渲染前提供能内容。他会被直接添加到 index.html 文件中。\n// app/root.tsxexport function HydrateFallback() &#123;  return (    &lt;div id=&quot;loading-splash&quot;&gt;      &lt;p&gt;Loading, please wait...&lt;/p&gt;    &lt;/div&gt;  );&#125;\n\nURL Params Loader在 loader 方法中获取\n// existing importsimport type &#123; Route &#125; from &quot;./+types/contact&quot;;export async function loader(&#123; params &#125;: Route.LoaderArgs) &#123;  const contact = await getContact(params.contactId);  return &#123; contact &#125;;&#125;export default function Contact(&#123; loaderData &#125;: Route.ComponentProps) &#123;  const &#123; contact &#125; = loaderData;  // existing code&#125;\n\n在组件中获取\nexport default function SidebarLayout(&#123; params &#125;: Route.ComponentProps) &#123;  console.log(params);  return; //...&#125;\n\nuseNavigation返回当前导航信息，包括导航状态。 导航需要等到 loader 结束时才会渲染页面，因此可以使用导航状态展示 loading 信息。\nimport &#123; useNavigation &#125; from &quot;react-router&quot;;export default function SidebarLayout() &#123;  const navigation = useNavigation();  return (    &lt;div      id=&quot;detail&quot;      className=&#123;navigation.state === &quot;loading&quot; ? &quot;loading&quot; : &quot;&quot;&#125;    &gt;&lt;/div&gt;  );&#125;\n\n类型安全React Router 自动为每个路由生成类型文件存放在 +types/&lt;route file&gt;.d.ts.\n// app/root.tsximport type &#123; Route &#125; from &quot;./+types/root&quot;;export default function App(&#123; loaderData &#125;: Route.ComponentProps) &#123;  const &#123; contacts &#125; = loaderData;  // ...&#125;\n\n预渲染静态路由对于没有内容的页面，希望在加载的时候不展示 loading,而是直接展示内容。\n指定哪些页面需要预渲染，他们会在打包阶段，打包为静态文件。\n//react-router.config.tsimport &#123; type Config &#125; from &quot;@react-router/dev/config&quot;;export default &#123;  ssr: false,  prerender: [&quot;/about&quot;],&#125; satisfies Config;\n\n抛出错误在 loader 中抛出错误, 会被 root.tsx 的 ErrorBoundary 捕获\nexport async function clientLoader(&#123; params &#125;: Route.LoaderArgs) &#123;  const contact = await getContact(params.contactId);  if (!contact) &#123;    throw new Response(&quot;Not Found&quot;, &#123; status: 404 &#125;);  &#125;  return &#123; contact &#125;;&#125;\n\n表单提交默认情况下，表单的提交会触发 history 的修改，因此使用 Form 组件，它会就近拦截表单的提交，并将请求通过 fetch 发送到最近的 action 中处理。\nForm 组件上的 action 会作为请求提交的地址，用于匹配路由。\naction 的规则是如果路由匹配那么对应的路由文件中必须存在 action 处理函数否则报错，如果没有对应的路由文件(例如写在 layout 文件中)，会使用 root 中的 action 处理。\n需要注意的是使用 action 不能将 react-router.config.ts 中的 ssr 设置为 false,因为这是服务端的功能。\nclientLoader 也需要修改为 loader 从服务端获取数据。\n// root.tsx// 如果在路由上没有其他的文件写 action 就会到root的action中处理export async function action() &#123;  const contact = await createEmptyContact();  return &#123; contact &#125;;&#125;\n\nimport &#123; Form &#125; from &quot;react-router&quot;;export default function SidebarLayout() &#123;  return (    &lt;Form method=&quot;post&quot;&gt;      &lt;button type=&quot;submit&quot;&gt;New&lt;/button&gt;    &lt;/Form&gt;  );&#125;\n\n删除信息\n// 当前文件 app/routes/contact.tsx 对应的路由是 contacts/:contactId// 因此表但会提交到 contacts/:contactId/destroy// 需要为此路由创建对应的文件&lt;Form  action=&quot;destroy&quot;  method=&quot;post&quot;  onSubmit=&#123;(event) =&gt; &#123;    const response = confirm(&quot;Please confirm you want to delete this record.&quot;);    if (!response) &#123;      event.preventDefault();    &#125;  &#125;&#125;&gt;  &lt;button type=&quot;submit&quot;&gt;Delete&lt;/button&gt;&lt;/Form&gt;\n\n// app/routes/destroy-contact.tsximport &#123; redirect &#125; from &quot;react-router&quot;;import type &#123; Route &#125; from &quot;./+types/destroy-contact&quot;;import &#123; deleteContact &#125; from &quot;../data&quot;;export async function action(&#123; params &#125;: Route.ActionArgs) &#123;  await deleteContact(params.contactId);  return redirect(&quot;/&quot;);&#125;\n\n// app/routes.tsexport default [  route(&quot;contacts/:contactId/destroy&quot;, &quot;routes/destroy-contact.tsx&quot;),] satisfies RouteConfig;\n","categories":["React"],"tags":["React"]},{"title":"解析 React Transition Group ①","url":"/posts/ed88f842829f/","content":"Transition 组件优先设计以下用户接口，只考虑最核心的功能。\n\n高阶组件的形式使用\nin 属性，控制元素是否显示\n\n关键在于如何处理状态变化，因为要实现状态切换，需要避免在同一渲染帧中执行。 实现一个 hooks 专门用管理状态改变。\nconst useTransitionState = (props) =&gt; &#123;  const stateRef = useRef();  const propsRef = useRef();  const [state, setState] = useState(() =&gt; &#123;    if (props.in) &#123;      if (props.appear) return &quot;exited&quot;;      return &quot;entered&quot;;    &#125; else &#123;      return &quot;exited&quot;;    &#125;  &#125;);  stateRef.current = state;  propsRef.current = props;  const next = useCallback(() =&gt; &#123;    const state = stateRef.current;    const props = propsRef.current;    let nextState = null;    if (props.in) &#123;      if (        (props.appear &amp;&amp; state === &quot;exited&quot;) ||        (state !== &quot;entering&quot; &amp;&amp; state !== &quot;entered&quot;)      ) &#123;        nextState = &quot;entering&quot;;      &#125;      if (!props.enter) &#123;        nextState = &quot;entered&quot;;      &#125;      if (state === &quot;entering&quot;) &#123;        nextState = &quot;entered&quot;;      &#125;    &#125; else &#123;      if (state === &quot;entering&quot; || state === &quot;entered&quot;) &#123;        nextState = &quot;exiting&quot;;      &#125;      if (!props.exit) &#123;        nextState = &quot;exited&quot;;      &#125;      if (state === &quot;exiting&quot;) &#123;        nextState = &quot;exited&quot;;      &#125;    &#125;    if (nextState !== null) setState(nextState);    return nextState;  &#125;, []);  return [state, next];&#125;;\n\n调用 next 方法即可完成状态切换，在组件渲染后调用 next 实现状态切换。\nuseEffect(() =&gt; &#123;  let nextState = next();  if (nextState === null) return;  if (nextState === &quot;entering&quot;) &#123;    return transitionEnd(      props.timeout,      safeCallback(() =&gt; &#123;        next();      &#125;)    );  &#125;  if (nextState === &quot;exiting&quot;) &#123;    return transitionEnd(      props.timeout,      safeCallback(() =&gt; &#123;        next();      &#125;)    );  &#125;&#125;, [next, props.in, props.timeout]);\n\n在状态切换的过程中，如果状态改变，如何清除副作用？\n当通过用户交互修改了 in 属性，会再次进入到 useEffect 函数中，在进入会执行清理函数， 清理函数需要可以清除执行到一半的中间状态。\n如果使用计时器可以执行 clear 方法，也可以实现一个清除函数，它不会清除定时器的执行，但是会让回调函数失效。\nconst safeCallback = (callback) =&gt; &#123;  let active = true;  const nextCallback = () =&gt; &#123;    if (active) &#123;      callback();    &#125;  &#125;;  nextCallback.cancel = () =&gt; &#123;    active = false;  &#125;;  return nextCallback;&#125;;\n\n更加细节的处理：\n\n考虑组件的类型，函数还是组件\nif (typeof children === &quot;function&quot;) &#123;  renderChildren = children(state);&#125; else &#123;  renderChildren = React.Children.only(children);&#125;\n\n控制进入和退出状态切换是否产生动画 exit enter，需要跳过中间状态\nif (  (props.appear &amp;&amp; state === &quot;exited&quot;) ||  (state !== &quot;entering&quot; &amp;&amp; state !== &quot;entered&quot;)) &#123;  nextState = &quot;entering&quot;;&#125;if (!props.enter) &#123;  nextState = &quot;entered&quot;;&#125;if (state === &quot;entering&quot;) &#123;  nextState = &quot;entered&quot;;&#125;\n\n实现 appear 首次挂载的时候是否展示动画如果需要首次渲染时执行动画，那么即使 in 为 true，内部状态也要初始化为退出状态。然后通过 next 方法进行状态切换\nconst [state, setState] = useState(() =&gt; &#123;  if (props.in) &#123;    if (props.appear) return &quot;exited&quot;;    return &quot;entered&quot;;  &#125; else &#123;    return &quot;exited&quot;;  &#125;&#125;);\n\ntimeout 可以为退出，进入单独配置\n\n剩余属性透传\n\n\n","categories":["React"],"tags":["React"]},{"title":"解析 React Transition Group ①","url":"/posts/2c770da8eb2f/","content":"Transition Group 组件Transition Group 组件用于管理一个 Transition 组件列表，即使 Transition 不声明状态 Transition Group 也会自动为其维护一个内部状态。\n\n自动为子组件列表添加状态并记录\n子组件添加或删除时不会被直接渲染，而是被 Transition Group 拦截，当执行完动画逻辑后，在内部状态中删除，并重新渲染。\n\n首次渲染时可以记录子组件并吸收为内部状态，需要注意以下细节：\n\n子组件可能不合法，或没有 key\nTransition Group 的属性优先级需要高于子组件相同属性的优先级\n需要实现清除逻辑给组件被删除时使用，从内部状态中清除被删除的组件。\n\nconst TransitionGroup = (props) =&gt; &#123;  // 是否首次渲染  const firstRender = useRef(true);  useEffect(() =&gt; &#123;    firstRender.current = false;  &#125;, []);  const [, rerender] = useState([]);  const latestChildrenRef = useRef(props.children);  latestChildrenRef.current = props.children;  // handleOnExit 是一个组件内的方法  // 需要注意的是它通过 latestChildrenRef 保证 children 永远是最新的  // 因为组件可能被重新渲染，而 handleOnExit 方法可能已经被绑定在了组件上  // 因此，在它真正执行的上下文中无法获取到最近的 children 属性  const handleOnExit = (child, node) =&gt; &#123;    const currentMap = getChildrenMapping(latestChildrenRef.current);    // onExit 执行的时候，这个元素可能已经没有了，在外部通过map重新渲染了新列表，所以已经计算的currentChildrenMap 不可靠    if (currentMap.has(child.key)) return;    if (child.props.onExited) &#123;      child.props.onExited(node);    &#125;    preChildrenMap.current.delete(child.key);    rerender([]);  &#125;;  const mappedChildren = firstRender.current    ? getInitialChildMapping(props, handleOnExit)    : getNextChildrenMap(props, preChildrenMap.current, handleOnExit); // 更新时的逻辑&#125;;const getInitialChildMapping = (props, handleExit) =&gt; &#123;  return getChildrenMapping(props.children, (child) =&gt; &#123;    return React.cloneElement(child, &#123;      // 在子组件退出的方法中处理删除内部状态的逻辑      onExited: handleExit(child),      // 初始化状态      in: true,      // Transition Group 的属性优先级需要高于子组件      appear: getProp(child, &quot;appear&quot;, props),      enter: getProp(child, &quot;enter&quot;, props),      exit: getProp(child, &quot;exit&quot;, props),    &#125;);  &#125;);&#125;;const getChildrenMapping = (children, fn) =&gt; &#123;  const childrenMap = new Map();  const mapper = (child) =&gt; &#123;    return fn &amp;&amp; React.isValidElement(child) ? fn(child) : child;  &#125;;  if (children) &#123;    // map 函数可以自动添加key    React.Children.map(children, (child) =&gt; child).forEach((child) =&gt; &#123;      childrenMap.set(child.key, mapper(child));    &#125;);  &#125;  return childrenMap;&#125;;\n\n更新阶段, 新列表并不一定只会删除其中一个元素，而是可以添加或删除多个元素，而删除操作并不是立即执行的，而是当动画结束后，从内部状态中删除。\n这需要一种策略合并两个列表。让旧组件尽量保持在原来的位置上，再将附近的新元素插入到就元素的前面。\n\n\nconst mergeMappingChildren = (preChildrenMap, currentChildrenMap) =&gt; &#123;  const pre = preChildrenMap || new Map();  const next = currentChildrenMap || new Map();  let pendingQueue = [];  let prePendingMap = new Map();  // 如果新列表中有当前这个旧元素  // 记录这个旧元素之前的元素，放进列表  pre.forEach((preChild) =&gt; &#123;    if (next.has(preChild.key)) &#123;      if (pendingQueue.length) &#123;        prePendingMap.set(preChild.key, pendingQueue);        pendingQueue = [];      &#125;    &#125; else &#123;      pendingQueue.push(preChild.key);    &#125;  &#125;);  const mergedChildrenMap = new Map();  next.forEach((nextChild) =&gt; &#123;    // 新元素排在旧元素的前面    // 旧元素尽可能保持在原有的位置。    if (prePendingMap.has(nextChild.key)) &#123;      const pendingQueue = prePendingMap.get(nextChild.key);      pendingQueue.forEach((key) =&gt; &#123;        mergedChildrenMap.set(key, pre.get(key));      &#125;);    &#125;    mergedChildrenMap.set(nextChild.key, next.get(nextChild.key));  &#125;);  if (pendingQueue.length) &#123;    pendingQueue.forEach((preChild) =&gt; &#123;      mergedChildrenMap.set(preChild.key, next.get(preChild.key));    &#125;);  &#125;  return mergedChildrenMap;&#125;;const getNextChildrenMap = (props, preChildrenMap, handleExit) =&gt; &#123;  const nextChildrenMap = getChildrenMapping(props.children);  const mergedChildrenMap = mergeMappingChildren(    preChildrenMap,    nextChildrenMap  );  const childrenMap = new Map();  mergedChildrenMap.forEach((child) =&gt; &#123;    const preHas = preChildrenMap.has(child.key);    const nextHas = nextChildrenMap.has(child.key);    const isExiting = preHas &amp;&amp; !preChildrenMap.get(child.key).props.in;    // 本次更新中被删除的元素    if (preHas &amp;&amp; !nextHas &amp;&amp; !isExiting) &#123;      childrenMap.set(        child.key,        React.cloneElement(child, &#123;          in: false,        &#125;)      );      // 新增的元素,包括正在退出中的元素    &#125; else if ((!preHas || isExiting) &amp;&amp; nextHas) &#123;      childrenMap.set(        child.key,        React.cloneElement(child, &#123;          onExited: () =&gt; handleExit(child),          in: true,          enter: getProp(child, &quot;enter&quot;, props),          exit: getProp(child, &quot;exit&quot;, props),        &#125;)      );      // 没有改变的元素    &#125; else if (preHas &amp;&amp; nextHas &amp;&amp; isValidElement(prevChild)) &#123;      childrenMap.set(        child.key,        React.cloneElement(child, &#123;          onExited: () =&gt; handleExit(child),          in: preChildrenMap.get(child.key).props.in,          enter: getProp(child, &quot;enter&quot;, props),          exit: getProp(child, &quot;exit&quot;, props),        &#125;)      );    &#125;  &#125;);  return childrenMap;&#125;;\n","categories":["React"],"tags":["React"]},{"title":"React Saga 解析","url":"/posts/d6763a23e0bd/","content":"项目启动时 saga 启动一个生成器函数，并提供对应的指令，可以利用 saga 的中间件控制指令的执行。\n最小化应用// app.jsimport &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;import createSagaMiddleware from &quot;redux-saga&quot;;import counterReducer from &quot;./reducers/counterSlice&quot;;import counterSaga from &quot;./sagas/counterSaga&quot;;import App from &quot;./App&quot;;const sagaMiddleware = createSagaMiddleware();const store = configureStore(&#123;  reducer: &#123;    counter: counterReducer, // Add counter slice reducer  &#125;,  middleware: (getDefaultMiddleware) =&gt;    getDefaultMiddleware().concat(sagaMiddleware), // Add saga middleware&#125;);sagaMiddleware.run(counterSaga);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(//...);\n\n// sagas/counterSaga.jsimport &#123; takeEvery, put, delay &#125; from &quot;redux-saga/effects&quot;;import &#123; increment, setLoading &#125; from &quot;../reducers/counterSlice&quot;;export const asyncIncrement = () =&gt; (&#123; type: &quot;counter/asyncIncrement&quot; &#125;);function* handleAsyncIncrement() &#123;  yield put(setLoading(true));  yield delay(1000);  yield put(increment());  yield put(setLoading(false));&#125;function* counterSaga() &#123;  yield takeEvery(&quot;counter/asyncIncrement&quot;, handleAsyncIncrement);&#125;export default counterSaga;\n\n指令saga 的生成器函数执行完成，中间件就执行结束，无法再响应 action.\n\ntake 监听某个 action,监听一次, yield 返回完整 action, 造成阻塞, 等待对应的 action 被触发。\n\nall 接受一个数组，数组中放入生成器，等待所有的生成器结束才会继续执行，可以用于拆分监听到不同的文件中，造成阻塞\n// rootSaga.jsimport &#123; takeEvery, put, delay, all &#125; from &quot;redux-saga/effects&quot;;import product from &quot;./product&quot;;import counterSaga from &quot;./counterSaga&quot;;export default function* () &#123;  yield all([counterSaga(), product()]);  // 下面的代码不会执行，直到所有的生成器直接结束&#125;\n\ntakeEvery 循环监听 action,不会阻塞,也就是这个生成器永远不会结束。\nexport default function* () &#123;  yield takeEvery(&quot;some action&quot;, function* () &#123;&#125;);  // 下面的代码会执行，不会阻塞&#125;\n\ndelay 延迟执行,阻塞\nexport default function* () &#123;  yield delay(1000);&#125;\n\nput 触发一个 action, 非阻塞\n\ncall 用于副作用的函数调用，是否阻塞取决与调用的函数是否异步\nfunction fetchData() &#123;  return new Promise((resolve) =&gt; setTimeout(resolve));&#125;function fetchDataReject() &#123;  return new Promise((resolve, reject) =&gt; setTimeout(reject));&#125;export default function* () &#123;  let data;  try &#123;    data = yield fetchDataReject();    // 如果报错，saga会通过生成器的throw抛出错误，    // 需要自己处理  &#125; catch &#123;&#125;  // 推荐使用 call 来处理异步  data = yield call(fetchData, &quot;调用参数&quot;);  data = yield call([&quot;this 的绑定对象&quot;，fetchData], &quot;自定义参数&quot;);  // 效果相同  data = yield call(&#123;context:this,fn:fetchData&#125;, &quot;自定义参数&quot;);&#125;\n\nselect 取出 store 中的数据\nexport default function* () &#123;  const state = yield select((store) =&gt; store);&#125;\n\ncps 用于调用采用回调方式的异步函数\nfunction asyncFn = (&#x27;调用参数&#x27;,fn) =&gt; &#123;  setTimeout(fn,3000)&#125;export default function* () &#123;  // 无需传入回调函数 saga 自动处理  const state = yield cps(asyncFn,&#x27;调用参数&#x27;);&#125;\n\nfork 启用一个新任务，不会阻塞，返回一个 Task 内部对象，可以配合 cancel 取消本次任务cancel 不传递参数取消当前任务线。\nfunction* nextTask() &#123;&#125;export default function* () &#123;  let task;  while (true) &#123;    if (task) &#123;      yield cancel(task);    &#125;    task = yield fork(nextTask);  &#125;&#125;\n\ncancelled 判断当前任务线是否被取消掉。\n\nrace 传递多个指令，其中一个结束就结束。\n\n\nsaga 简单实现export function createSagaMiddleware() &#123;  return function sagaMiddleware(store) &#123;    // 会使用到store中的数据，所以要写在里面    const env = &#123;      store,      channel: new Channel(),    &#125;;    sagaMiddleware.run = runSaga.bind(null, env);    return function (next) &#123;      return function (action) &#123;        const result = next(action);        // 触发 take 的订阅        env.channel.put(action.type);        return result;      &#125;;    &#125;;  &#125;;&#125;//function runSaga(env, generatorFn) &#123;  const iterator = generatorFn();  if (typeof generatorFn == &quot;function&quot;) &#123;    //如果是普通函数直接执行  &#125;  next();  // nextValue 是给将要执行下一次迭代传递的值  function next(nextValue, err, isOver) &#123;    let result;    if (err) &#123;      result = iterator.throw(err);    &#125; else if (isOver) &#123;      result = iterator.return();    &#125; else &#123;      result = iterator.next(nextValue);    &#125;    if (result.done) &#123;      return result;    &#125;    // 解析 Effect 对象    // &#123; @@redux-saga/IO :true，combinator：true，payload：[],type: ALL    solveResult(result.value);  &#125;  function solveResult(effect) &#123;    if (EffectType[effect.type]) &#123;      runEffect(env, effect, next);    &#125; else &#123;      // 可以是 Promise 或是一般值      if (effect instanceof Promise) &#123;        effect.then((res) =&gt; next(res)).catch((err) =&gt; next(void 0, err));      &#125; else &#123;        next(effect);      &#125;    &#125;  &#125;  // 用于取消任务  return new Task(next);&#125;// 所有的指令都是返回Effect对象，通过不同的处理函数，执行effect对象function createEffect(type, payload) &#123;  return &#123;    type,    payload,  &#125;;&#125;// 接受store对象，function runEffect(env, effect, next) &#123;  switch (effect.type) &#123;    case EffectType.CALL:      handleCall(effect, next);      break;    case EffectType.PUT:      handlePut(env, effect, next);      break;    case EffectType.TAKE:      handleTake(env, effect, next);      break;    case EffectType.FORK:      handleFork(env, effect, next);      break;    case EffectType.TAKE_EVERY:      handleTakeEvery(env, effect, next);      break;    default:      return;  &#125;&#125;export function call(fn, ...args) &#123;  return createEffect(EffectType.CALL, [fn, args]);&#125;function handleCall(effect, next) &#123;  const &#123;    payload: [fn, args],  &#125; = effect;  if (typeof fn === &quot;function&quot;) &#123;    const res = fn(...args);    if (res instanceof Promise) &#123;      res.then((res) =&gt; next(res));    &#125; else &#123;      next(res);    &#125;  &#125;&#125;// delay 就是用 call 实现的延迟方法export function delay(timer = 0) &#123;  return call(function () &#123;    return new Promise((resolve) =&gt; &#123;      setTimeout(resolve, timer);    &#125;);  &#125;);&#125;export function put(action) &#123;  return createEffect(EffectType.PUT, [action]);&#125;function handlePut(env, effect, next) &#123;  const &#123; dispatch &#125; = env.store;  const [action] = effect.payload;  const res = dispatch(action);  next(res);&#125;export function take(action) &#123;  return createEffect(EffectType.TAKE, [action]);&#125;// take 的阻塞行为意味着需要能监听dispatch被触发// 使用观察者模式监听take的订阅function handleTake(env, effect, next) &#123;  const &#123; channel &#125; = env;  const [action] = effect.payload;  channel.take(action.type, () =&gt; &#123;    next(action);  &#125;);&#125;export function fork(generatorFn) &#123;  return createEffect(EffectType.FORK, [generatorFn]);&#125;// 接受一个generatorfunction handleFork(env, effect, next) &#123;  const [generatorFn] = effect.payload;  const task = runSaga(env, generatorFn);  next(task);&#125;export function takeEvery(action, generatorFn) &#123;  return createEffect(EffectType.TAKE_EVERY, [action, generatorFn]);&#125;function handleTakeEvery(env, effect, next) &#123;  const [action, generatorFn] = effect.payload;  return fork(function* () &#123;    while (true) &#123;      yield take(action);      yield fork(generatorFn);    &#125;  &#125;);&#125;export function all(generators) &#123;  return createEffect(EffectType.TAKE_EVERY, [generators]);&#125;const EffectType = &#123;  ALL: &quot;ALL&quot;,  CALL: &quot;CALL&quot;,  PUT: &quot;PUT&quot;,  TAKE: &quot;TAKE&quot;,  FORK: &quot;FORK&quot;,  TAKE_EVERY: &quot;TAKE_EVERY&quot;,&#125;;export class Channel &#123;  listeners = &#123;&#125;;  take(prop, fn) &#123;    if (!this.listeners[prop]) this.listeners[prop] = [];    this.listeners[prop].push(fn);  &#125;  // 触发监听  put(prop, ...args) &#123;    if (!this.listeners[prop]) return;    const listeners = this.listeners[prop];    // 一定要先删除再运行，避免take中会再次添加新的监听    this.listeners[prop] = void 0;    listeners.forEach((fn) =&gt; &#123;      fn(...args);    &#125;);  &#125;&#125;class Task &#123;  constructor(next) &#123;    this.next = next;  &#125;  cancel() &#123;    this.next(null, null, true);  &#125;&#125;\n","categories":["React"],"tags":["React"]},{"title":"redux实现原理","url":"/posts/ac2ad072d0c9/","content":"现有状态管理工具\nredux mobx mobx-state-tree redoil vuex\nredux flux 是一个工具，每一层分的清楚但是麻烦\nstore -&gt; containercurrentState -&gt; _valueaction-&gt; fcurrentReducer -&gt;mapmiddleware- io functor 异步问题\nstore 是一个容器含有state 和reducer,reducer 是一个纯函数，他可以查看之前的状态，执行一个action并且返回一个新的状态\nmobx 强调的是轻量，去掉了Reducer.  只有action+state @observer(函数组件)\nmobx-state-lite &#x3D;&gt; provider  \n原理图\nActionAction 是store数据的唯一来源， store.dispatch() 将 action 传到 store。\n我们应该尽量减少在 action 中传递的数据。尽量传递数据标识或修改条件，如索引，过滤条件，而不是修改数据之后传入整个数据对象。\n通常Action是一个对象 \n&#123;  type: SET_VISIBILITY_FILTER,  filter: SHOW_COMPLETED&#125;\n\n可以用函数简单的包装\nconst addTodo  = (text) =&gt; (&#123;    type: ADD_TODO,    text&#125;)\n\n因为action最终回传递到dispatch中，可以通过一个函数来自动实现这一步，也就是actionCreater\nconst boundTode = (text) =&gt; dispatch(addTodo(text))\n\nReducerReducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。\nreducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。\n(previousState, action) =&gt; newState\n\n\n之所以将这样的函数称之为reducer，是因为这种函数与被传入 Array.prototype.reduce(reducer, ?initialValue) 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作：\n1.修改传入参数；2.执行有副作用的操作，如 API 请求和路由跳转；3.调用非纯函数，如 Date.now() 或 Math.random()。\n只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。\nfunction todoApp(state = initialState, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return Object.assign(&#123;&#125;, state, &#123;        visibilityFilter: action.filter      &#125;)    default:      return state  &#125;&#125;\n\n注意：\n\n不能直接修改state\n在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。\n\n拆分Reducer\nfunction todos(state = [], action) &#123;  switch (action.type) &#123;    case ADD_TODO:      return [        ...state,        &#123;          text: action.text,          completed: false        &#125;      ]    default:      return state  &#125;&#125;function visibilityFilter(state = SHOW_ALL, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return action.filter    default:      return state  &#125;&#125;function todoApp(state = &#123;&#125;, action) &#123;  return &#123;    visibilityFilter: visibilityFilter(state.visibilityFilter, action),    todos: todos(state.todos, action)  &#125;&#125;\n\nredux 提供了合并reducer的方法与上面的完全等价，会按照不同的key值，把reducer分组\nimport &#123; combineReducers &#125; from &#x27;redux&#x27;const todoApp = combineReducers(&#123;  visibilityFilter,  todos&#125;)\n\n\n\nStoreStore 就是把它们联系到一起的对象。\n维持应用的 state；提供 getState() 方法获取 state；提供 dispatch(action) 方法更新 state；通过 subscribe(listener) 注册监听器;通过 subscribe(listener) 返回的函数注销监听器。\n通过redux提供的createStore方法创建store\n.&#x2F;redux.js\n// 接受reducer 和 初始化状态返回store对象function createStore(reducer,initState)&#123;  let currentreducer = reducer;  let store = initState;  let currentListen = [];  // 直接返回store的引用  function getState()&#123;    return store;  &#125;  // 把事添加到监听队列中  function subscribe(listen)&#123;    currentListen.push(listen);  &#125;    //派发一个action,通过reducer处理，返回并保存新的state  function dispatch(action)&#123;    store = currentreducer(action,store);    // 发布通知    for(let i=0;i&lt;currentListen.length;i++)&#123;      currentListen[i]();    &#125;  &#125;  // 返回的store对象  return &#123;    getState,    dispatch,    subscribe  &#125;&#125;export &#123;  createStore,&#125;\n\n\ncombineReducerscombineReducers用于合并reducer,需要注意的是reducer和combineReducers都是函数所以combineReducers的实现是把，多个reducer循环执行并且按reducer拆分store\nfunction combineReducers(reducers)&#123;  // 缓存keys,避免重复执行  const keys = Object.keys(reducers);  return function(action,store)&#123;    // 初始化的store可能为undefined    store = store || &#123;&#125;;    for(let k of keys)&#123;      store[k] = reducers[k](action,store[k])    &#125;    return store;  &#125;&#125;\n\n因为第一次执行的时候,每个reducer如果有默认的state应该先合并一次\n需要在createrStore中自动执行一次dispatch(&#123;type:Symbol(&#39;&#39;)&#125;)\nMiddleware有时希望能在状态改变前和改变后处理\nfunction dispatchAndLog(store, action) &#123;  console.log(&#x27;dispatching&#x27;, action)  store.dispatch(action)  console.log(&#x27;next state&#x27;, store.getState())&#125;\n\n重写了dispatch函数，并保持了对老的dispatch的引用新的dispatch是对老的dispatch的封装，可以在中间添加逻辑处理\nfunction patchStoreToAddLogging(store) &#123;  let next = store.dispatch  store.dispatch = function dispatchAndLog(action) &#123;    console.log(&#x27;dispatching&#x27;, action)    let result = next(action)    console.log(&#x27;next state&#x27;, store.getState())    return result  &#125;&#125;\n\n由于不满足函数式编程的思想，这里通过直接返回一个函数来处理并把老的dispatch方法通过next参数传入传入的next需要在redux中实现\nconst logger = store =&gt; next =&gt; action =&gt; &#123;  console.log(&#x27;dispatching&#x27;, action)  let result = next(action)  console.log(&#x27;next state&#x27;, store.getState())  return result&#125;\n\napplyMiddleware\n返回一个新的store对象，并提供通过middleware包装过的dispatch方法\nfunction applyMiddleware(...middlewares)&#123;  return function(createStore)&#123;    // 新的createStore方法传入 reducers 和 initstate    return function(...args)&#123;    const store = createStore(...args);    // 保留dispatch的引用    const next = store.dispatch;      // 提供给middleware的第一个参数，如果直接调用dispatch回抛出错误      const middlewareApi = &#123;        getState:store.getState,        dispatch:()=&gt; new Error()      &#125;      //为每个middle提供getState方法      middlewares = middlewares.map(middleware=&gt;middleware(middlewareApi));      //重写dispatch方法，每一个middleware执行，都会触发传入的dispatch的引用      //a(next) 返回middleware中最有一个函数，需要传入一个action      //(action) =&gt;&#123;      //   console.log(&#x27;error state&#x27;,store.getState());      //   next(action);      //   console.log(&#x27;action&#x27;);      // &#125;      // b函数传入的就是这个返回函数      // 在最终调用的时候action回一级一级的被传下去      const dispatch = middlewares.reduce((a,b)=&gt;b(a(next)));      return &#123;        ...store,        dispatch      &#125;    &#125;  &#125;&#125;\n\n同时redux.js中需要修改 \nfunction createStore(reducer,initState,middleware)&#123;  if(middleware) &#123;    // 重写create函数,相当于在外层添加一个拦截器   return  middleware(createStore)(reducer,initState)  &#125;&#125;\n\ncompose\n把 reducer middlewares 的逻辑单独提取出来\nexport default function compose(...funcs) &#123;  if (funcs.length === 0) &#123;    return arg =&gt; arg  &#125;  if (funcs.length === 1) &#123;    return funcs[0]  &#125;  //注意最后返回的时候包裹了一个函数，传入外部参数，也就是上面的store.dispatch  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125;\n\n最终完整的代码\nconst applyMiddleware = function(...middlewares)&#123;  return (createStore)=&gt;(...args) =&gt;&#123;    const store = createStore(...args);    console.log(middlewares);    let dispatch = () =&gt; &#123;      throw new Error(        &#x27;Dispatching while constructing your middleware is not allowed. &#x27; +          &#x27;Other middleware would not be applied to this dispatch.&#x27;      )    &#125;    const middlewareAPI = &#123;      getState: store.getState,      dispatch: (...args) =&gt; dispatch(...args)    &#125;    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))    dispatch = compose(...chain)(store.dispatch)    return &#123;      ...store,      dispatch    &#125;  &#125;&#125;\n\nbindActionCreators我们希望可以创建一个action对象，直接调用上面的方法，而忽略dispatch的步骤\nconst actions1 =(payload)=&gt;(&#123;  type: &quot;A&quot;,  payload&#125;);const actions2 =(payload)=&gt;(&#123;  type: &quot;B&quot;,  payload&#125;)const actions3 =(payload)=&gt;(&#123;  type: &quot;C&quot;,  payload&#125;)const actions = bindActionCreators(&#123;  actions1,  actions2,  actions3,&#125;,store.dispatch)actions.actions1()actions.actions2(&#123;name: &#x27;wefwegwekfl&#x27;&#125;)actions.actions3(&#123;age: &#x27;30&#x27;&#125;)\n\n需要实现一个bindActionCreators方法\n惟一会使用到 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上\n却不想让这个组件觉察到 Redux 的存在，而且不希望把 dispatch 或 Redux store 传给它。\nconst bindActionCreator = function(actionCreator,dispatch)&#123;  return function()&#123;    return dispatch(actionCreator.apply(this,arguments))  &#125;&#125;// 接受的是一个action对象集合const bindActionCreators = function(actionCreators,dispatch)&#123;  const boundActionCreators = &#123;&#125;  for(let key in actionCreators)&#123;    if(typeof actionCreators[key]===&#x27;function&#x27;)&#123;      // 最终返回一个以每个action名字为key的对象      // 每个key对应的值为一个可以触发dispatch方法的函数      // 相当于为每个actio自动绑定了dispatch 方法      boundActionCreators[key] = bindActionCreator(actionCreators[key],dispatch)    &#125;  &#125;  return boundActionCreators;&#125;export default bindActionCreators","categories":["React"],"tags":["Redux"]},{"title":"React Lane 模型","url":"/posts/3e05dd1b5745/","content":"二进制操作常用于权限控制，在表示多种状态叠加(一对多)的场景更加方便。\n// 负数用补码来表示5 = 0b00000101-5 = 反码 + 1 = 0b11111010 + 1 = 0b11111011\n\n对 fiberNode 的操作也是用位运算来标记的。\n// 初始化一些 flagsconst NoFlags = 0b0000000000000000; // 0，表示没有任何标志const PerformedWork = 0b0000000000000001; // 1，表示执行过某项工作const Placement = 0b0000000000000010; // 2，表示需要放置某项内容const Update = 0b0000000000000100; // 4，表示需要更新// 一开始将 flag 变量初始化为 NoFlags，表示没有任何操作let flag = NoFlags;// 这里就是在组合多个状态flag = flag | PerformedWork | Update; // 按位或运算，将 PerformedWork 和 Update 结合进来// 要判断是否有某个 flag，直接通过 &amp; 来进行判断即可// 判断是否有 PerformedWork 类型的更新if (flag &amp; PerformedWork) &#123;  // 执行对应操作  console.log(&quot;执行 PerformedWork&quot;);&#125;// 判断是否有 Update 类型的更新if (flag &amp; Update) &#123;  // 执行对应操作  console.log(&quot;执行 Update&quot;);&#125;// 判断是否有 Placement 类型的更新if (flag &amp; Placement) &#123;  // 执行对应操作  console.log(&quot;执行 Placement&quot;);&#125;\n\n上下文react 中有许多上下文变量，使用位运算来标记,可以方便的表示进入或移出上下文\n// 未处理于 React 上下文export const NoContext = /* 0b000 */;// 处理于 batchedUpdates 上下文const BatchedContext = /* 0b001 */;// 处理于 render 阶段export const RenderContext = /* 0b010 */;// 处理于 commit 阶段export const CommitContext = /* 0b100 */;// 是否处于 RenderContext 上下文中，结果为 trueif ((executionContext &amp; RenderContext) !== NoContext) &#123;  // 在这里执行与 RenderContext 相关的逻辑&#125;// 是否处于 CommitContext 上下文中，结果为 falseif ((executionContext &amp; CommitContext) !== NoContext) &#123;  // 在这里执行与 CommitContext 相关的逻辑&#125;// 如果要移除某个上下文executionContext &amp;= ~RenderContext; // 从当前上下文中移除 RenderContext// 是否处于 RenderContext 上下文中，结果为 falseif ((executionContext &amp; RenderContext) !== NoContext) &#123;  // 在这里执行与 RenderContext 相关的逻辑&#125;\n\nLane 模型schedule 是一个单独的包定义了 5 种优先级。\nLane 是 react 内部的更细粒度的优先级管理，react 所有的更新都只能通过事件或异步任务触发， 所以 React 定义了自己的优先级：\n\ndiscreteEventPriority: 离散事件 input focus,blur,touchStart 等\ncontinuousEventPriority: 连续事件 drag mousemove, scroll 等；\nDefaultEventPriority: 默认优先级 通过计时器产生的任务\nidleEventPriority: 对应空闲情况的优先级\n\n每个优先级对应的值就是 Lane, 因此需要与 schedule 优先级相互转换。\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;export const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;//...\n\n\nreact 优先级转为 scheduler, 先将 lanes 转为 EventPriority\nexport function lanesToEventPriority(lanes: Lanes): EventPriority &#123;  const lane = getHighestPriorityLane(lanes);  if (!isHigherEventPriority(DiscreteEventPriority, lane)) &#123;    return DiscreteEventPriority;  &#125;  if (!isHigherEventPriority(ContinuousEventPriority, lane)) &#123;    return ContinuousEventPriority;  &#125;  if (includesNonIdleWork(lane)) &#123;    return DefaultEventPriority;  &#125;  return IdleEventPriority;&#125;\n\n再将 EventPriority 转为 schedule 优先级\nlet schedulerPriorityLevel;switch (lanesToEventPriority(nextLanes)) &#123;  case DiscreteEventPriority:    schedulerPriorityLevel = ImmediateSchedulerPriority;    break;  case ContinuousEventPriority:    schedulerPriorityLevel = UserBlockingSchedulerPriority;    break;  case DefaultEventPriority:    schedulerPriorityLevel = NormalSchedulerPriority;    break;  case IdleEventPriority:    schedulerPriorityLevel = IdleSchedulerPriority;    break;  default:    schedulerPriorityLevel = NormalSchedulerPriority;    break;&#125;\n\nscheduler 优先级转为 react 优先级\nconst schedulerPriority = getCurrentSchedulerPriorityLevel(); // 获取当前调度器优先级switch (schedulerPriority) &#123;  case ImmediateSchedulerPriority:    return DiscreteEventPriority;  case UserBlockingSchedulerPriority:    return ContinuousEventPriority;  case NormalSchedulerPriority:  case LowSchedulerPriority:    return DefaultEventPriority;  case IdleSchedulerPriority:    return IdleEventPriority;  default:    return DefaultEventPriority;&#125;\n\nexpiration Time 模型如果同一时间出发了多个更新，应该先去更新哪一个。\n早期 react 使用 expiration Time 模型,这一点和 scheduler 的设计是一致的。不同的优先级对应不同的 deadline, 每次 schedule 执行的时候，选出一个最高的优先级执行。\n但是这种模式无法表示批的概念，当优先级大于 priorityBunch 就会划分到同一批，但是无法将提交的不同更新种的某种类型的任务算作同一批。因此基于上面的原因引入了 lane 模型。\nlane 是如何灵活表达批的概念？\n// 要使用的批次let batch = 0;// laneA 和 laneB 是不相邻的优先级const laneA = 0b00000000000000001000000; // 代表某个优先级const laneB = 0b00000000000000000000001; // 代表另一个优先级// 将 laneA 纳入批中batch |= laneA; // 将 laneA 的优先级合并到 batch 中// 将 laneB 纳入批中batch |= laneB; // 将 laneB 的优先级合并到 batch 中\n\nupdateLane用于调度更新的优先级 通过 requestUpdateLane 创建\nexport function requestUpdateLane(fiber: Fiber): Lane &#123;  const mode = fiber.mode;  if ((mode &amp; BlockingMode) === NoMode) &#123;    // 初次加载时为SyncLane    return (SyncLane: Lane);  &#125; else if ((mode &amp; ConcurrentMode) === NoMode) &#123;    return getCurrentPriorityLevel() === ImmediateSchedulerPriority      ? (SyncLane: Lane)      : (SyncBatchedLane: Lane);  &#125; else if (    !deferRenderPhaseUpdateToNextBatch &amp;&amp;    (executionContext &amp; RenderContext) !== NoContext &amp;&amp;    workInProgressRootRenderLanes !== NoLanes  ) &#123;    // This is a render phase update. These are not officially supported. The    // 这是一个渲染阶段的更新，这些都没有得到官方的支持    // old behavior is to give this the same &quot;thread&quot; (expiration time) as    // 原来的方案是赋予它与当前渲染相同的过期时间    // whatever is currently rendering. So if you call `setState` on a component    // 如果你在一个组件上调用setState，他们会在相同的渲染中稍后生效，    // that happens later in the same render, it will flush. Ideally, we want to    // 会发生闪屏    // remove the special case and treat them as if they came from an    // 理想情况下，我们希望删除特例，并将它们视为来插入的事件    // interleaved event. Regardless, this pattern is not officially supported.    // 无论如何，这种模式并没有得到官方的支持。    // This behavior is only a fallback. The flag only exists until we can roll    // 这种行为值是一个回退机制，标识只存存在于我们可以离开setState警告之前    // out the setState warning, since existing code might accidentally rely on    // 因为现有代码可能意外地依赖于当前行为。    // the current behavior.    return pickArbitraryLane(workInProgressRootRenderLanes);  &#125;  // The algorithm for assigning an update to a lane should be stable for all  // updates at the same priority within the same event. To do this, the inputs  // 对于同一事件中具有相同优先级的所有更新，为车道分配更新的算法应该是稳定的（幂等的）。  // to the algorithm must be the same. For example, we use the `renderLanes`  // 为此，算法的输入必须相同。  // to avoid choosing a lane that is already in the middle of rendering.  // 我们使用“renderLanes”来避免选择已经在渲染过程中的车道。  // However, the &quot;included&quot; lanes could be mutated in between updates in the  // 然而 included 车道可能在两次相同事件中的更新被改变  // same event, like if you perform an update inside `flushSync`. Or any other  // 就像在“flushSync”中执行更新一样  // code path that might call `prepareFreshStack`.  // 或者任何其他可能调用“prepareFreshStack”的代码。  // The trick we use is to cache the first of each of these inputs within an  // 我们使用的技巧是在事件中缓存这些输入中的第一个  // event. Then reset the cached values once we can be sure the event is over.  // 然后在确定事件结束后重置缓存的值。  // Our heuristic for that is whenever we enter a concurrent work loop.  // 启发式方法是，每当我们进入一个并发工作循环时  // We&#x27;ll do the same for `currentEventPendingLanes` below.  if (currentEventWipLanes === NoLanes) &#123;    currentEventWipLanes = workInProgressRootIncludedLanes;  &#125;  const isTransition = requestCurrentTransition() !== NoTransition;  if (isTransition) &#123;    if (currentEventPendingLanes !== NoLanes) &#123;      currentEventPendingLanes =        mostRecentlyUpdatedRoot !== null          ? mostRecentlyUpdatedRoot.pendingLanes          : NoLanes;    &#125;    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);  &#125;  // TODO: Remove this dependency on the Scheduler priority.  // To do that, we&#x27;re replacing it with an update lane priority.  const schedulerPriority = getCurrentPriorityLevel();  // The old behavior was using the priority level of the Scheduler.  // This couples React to the Scheduler internals, so we&#x27;re replacing it  // with the currentUpdateLanePriority above. As an example of how this  // could be problematic, if we&#x27;re not inside `Scheduler.runWithPriority`,  // then we&#x27;ll get the priority of the current running Scheduler task,  // which is probably not what we want.  let lane;  if (    // TODO: Temporary. We&#x27;re removing the concept of discrete updates.    (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp;    schedulerPriority === UserBlockingSchedulerPriority  ) &#123;    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);  &#125; else &#123;    const schedulerLanePriority =      schedulerPriorityToLanePriority(schedulerPriority);    if (decoupleUpdatePriorityFromScheduler) &#123;      // In the new strategy, we will track the current update lane priority      // inside React and use that priority to select a lane for this update.      // For now, we&#x27;re just logging when they&#x27;re different so we can assess.      const currentUpdateLanePriority = getCurrentUpdateLanePriority();      if (        schedulerLanePriority !== currentUpdateLanePriority &amp;&amp;        currentUpdateLanePriority !== NoLanePriority      ) &#123;        if (__DEV__) &#123;          console.error(            &quot;Expected current scheduler lane priority %s to match current update lane priority %s&quot;,            schedulerLanePriority,            currentUpdateLanePriority          );        &#125;      &#125;    &#125;    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);  &#125;  return lane;&#125;\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑦ Diff 算法","url":"/posts/b28c7a3fb3e0/","content":"设计动机调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。\n将一棵树转换成另一棵树的最小操作次数,即使使用最优的算法，该算法的复杂程度仍为 ，其中 n 是树中元素的数量。\n如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套  的启发式算法：\n\n两个不同类型的元素会产生出不同的树；\n开发者可以通过设置 key 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变；\n\n换一种说法就是 :\n\n只对同级比较，跨层级的 dom 不会进行复用\n不同类型节点生成的 dom 树不同，此时会直接销毁老节点及子孙节点，并新建节点\n可以通过 key 来对元素 diff 的过程提供复用的条件\n\n单节点 Diff\nkey 和 type 相同表示可以复用节点\ntype 不同直接标记删除节点，然后新建节点\nkey 相同 type 不同，标记删除该节点和兄弟节点，然后新创建节点\n\n// eg1const A = &lt;span key=&quot;a&quot;&gt;0&lt;/span&gt;;const B = &lt;span kay=&quot;a&quot;&gt;1&lt;/span&gt;;// eg2const A = &lt;span key=&quot;a&quot;&gt;0&lt;/span&gt;;const B = &lt;span kay=&quot;b&quot;&gt;1&lt;/span&gt;;\n\n还记得 reconcileChildren 方法么, 它是双缓存 Fiber 构建时候调用的方法,因为新的节点是单节点,所以会进入 reconcileSingleElement\n//                              div Fiber    span 0 Fiber      span 1 JSXElementfunction reconcileSingleElement(  returnFiber,  currentFirstChild,  element,  lanes) &#123;  var key = element.key;  var child = currentFirstChild;  while (child !== null) &#123;    // TODO: If key === null and child.key === null, then this only applies to the first item in the list.    if (child.key === key) &#123;      switch (child.tag) &#123;        case Fragment: &#123;          if (element.type === REACT_FRAGMENT_TYPE) &#123;            deleteRemainingChildren(returnFiber, child.sibling);            var existing = useFiber(child, element.props.children);            existing.return = returnFiber;            return existing;          &#125;          break;        &#125;        case Block:        default: // key 相同 type 相同 eg1        &#123;          if (            child.elementType === element.type ||            // Keep this check inline so it only runs on the false path:            isCompatibleFamilyForHotReloading(child, element)          ) &#123;            // 因为新的节点是单节点,所以新的fiber节点不会再有兄弟节点            // 在重用之前兄弟节点标记为删除            deleteRemainingChildren(returnFiber, child.sibling);            // 通过 createWorkInProgress clone节点            // _existing3.sibling = null 因为上面的删除只是标记,而在链表中需要真正删除sibling属性            // 官方注释为: 在这里把 sibling 赋值为 null, 因为返回节点前很容易忘记赋值            var _existing3 = useFiber(child, element.props);            // ref 属性相关操作,重新为ref节点赋值            _existing3.ref = coerceRef(returnFiber, child, element);            _existing3.return = returnFiber;            // 返回 clone 的节点            return _existing3;          &#125;          break;        &#125;      &#125; // Didn&#x27;t match.      // key 相同 type 不同,节点本身和兄弟节点全部标记为删除, eg3      // ke 相同表示两个节点是对应的,所以兄弟节点无效标记为删除      // 但是type类型不同所以不能复用所以节点本身也需要标记为删除      deleteRemainingChildren(returnFiber, child);      break;    &#125; else &#123;      // 如果 key 不相同,直接将这个节点删掉 eg2      deleteChild(returnFiber, child);    &#125;    // 看兄弟节点是否可以通过 key 相同复用,例如    // current [a, p, span]    // new     p    // 兄弟节点中有一个 p 节点可以复用    child = child.sibling;  &#125;  // 如果没有节点可以复用, 就通过 JSXElement 创建一个新的 Fiber 节点  if (element.type === REACT_FRAGMENT_TYPE) &#123;    var created = createFiberFromFragment(      element.props.children,      returnFiber.mode,      lanes,      element.key    );    created.return = returnFiber;    return created;  &#125; else &#123;    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);    _created4.ref = coerceRef(returnFiber, currentFirstChild, element);    _created4.return = returnFiber;    return _created4;  &#125;&#125;\n\n多节点 diffreact 用 3 次循环实现了 react diff 算法, 下面是整个方法中的全局变量\n// Diff结果的第一个节点var resultingFirstChild = null;// 新的子元素数组的集合var knownKeys = new Set();// 上次可复用的位置var lastPlacedIndex = 0;// 当前对比的老的元素var oldFiber = currentFirstChild;// 保存老的节点中下一个需要对比的元素var nextOldFiber = null;// 计数器,记录新元素遍历到的位置var newIdx = 0;\n\n第一次循环\n\n用 newChildren[newIdx] 与 oldFiber 比较\n如果新元素是 reactElement\nkey 相同,type 相同, 则会使用 useFiber 复用节点\nkey 相同,type 不同, 通过 JSXElement 创建新的节点\nkey 不同, 直接跳出循环,可能存在移动,用下一个循环处理\n\n\n如果新元素是文本元素\n由于文本元素没有 key,所以老的节点如果有 key,那么元素类型一定不同,直接跳出循环,等待下一个循环处理\n如果老的节点没有 key, 是否 tag=HostText,如果是则 useFiber 复用节点,如果不是 createFiberFromText 创建节点\n\n\n如果新元素是数组\n老元素没有 key, 直接跳出循环\n老元素有 key 且 oldFiber.tag===Fragment, 通过 createFiberFromFragment 创建新的子元素\n老元素有 key 且 oldFiber.tag!==Fragment, useFiber 复用节点\n\n\n\n\n\n在复用或创建节点的同时也会传入新的 props 属性, 新的属性在 diffProperties 的时候会被解析,并添加到 updateQueue 中\n如果不需要跳出循环, 通过 newFiber.alternate === null 判断返回的节点是复用的还是新建的,因为新建的节点没有 alternate,如果是新建的节点, oldFiber 的服级节点上删除 oldFiber, 因为已经有了新节点,且老的节点也没有被使用\n下一步是给新的 Fiber 添加位置信息,调用 placeChild 方法, newFiber.index = newIndex, 并给 lastPlacedIndex 赋值如果是新建的节点,会被标记为插入, lastPlacedIndex 不变,因为这个位置不能复用,如果是复用节点的 index &lt; lastPlacedIndex,说明节点被移动了会打上移动的标记, 如果 index &gt;= lastPlacedIndex 节点位置不需要移动, 因为所有小于这个节点位置的元素都会被移动到后面.\n总结: 第一个循环主要处理属性的更新, key 不同则循环结束\n第二次循环\n如果 oldFiber 已经遍历到头, newChildren 还有剩余, 则会进入第二个循环, 将 newChildren 剩余的子元素,全部新建,并且标记为插入\n第三次循环\n如果第一次循环提前跳出, oldFiber, newChildren 都有剩余则会进入第三次循环\n首先把 oldFiber 转换成 map 格式,方便用 key 迅速查找对应的节点,如果新元素的 key 在 map 中存在则复用节点,如果不存在则新建节点\n调用第一次循环中的 placeChild , 为元素排序\n\nfunction reconcileChildrenArray(  returnFiber,  currentFirstChild,  newChildren,  lanes) &#123;  &#123;    // First, validate keys.    var knownKeys = null;    for (var i = 0; i &lt; newChildren.length; i++) &#123;      var child = newChildren[i];      knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);    &#125;  &#125;  var resultingFirstChild = null;  var previousNewFiber = null;  var oldFiber = currentFirstChild;  var lastPlacedIndex = 0;  var newIdx = 0;  var nextOldFiber = null;  for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;    if (oldFiber.index &gt; newIdx) &#123;      nextOldFiber = oldFiber;      oldFiber = null;    &#125; else &#123;      nextOldFiber = oldFiber.sibling;    &#125;    var newFiber = updateSlot(      returnFiber,      oldFiber,      newChildren[newIdx],      lanes    );    if (newFiber === null) &#123;      // TODO: This breaks on empty slots like null children. That&#x27;s      // unfortunate because it triggers the slow path all the time. We need      // a better way to communicate whether this was a miss or null,      // boolean, undefined, etc.      if (oldFiber === null) &#123;        oldFiber = nextOldFiber;      &#125;      break;    &#125;    if (shouldTrackSideEffects) &#123;      if (oldFiber &amp;&amp; newFiber.alternate === null) &#123;        // We matched the slot, but we didn&#x27;t reuse the existing fiber, so we        // need to delete the existing child.        deleteChild(returnFiber, oldFiber);      &#125;    &#125;    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);    if (previousNewFiber === null) &#123;      // TODO: Move out of the loop. This only happens for the first run.      resultingFirstChild = newFiber;    &#125; else &#123;      // TODO: Defer siblings if we&#x27;re not at the right index for this slot.      // I.e. if we had null values before, then we want to defer this      // for each null value. However, we also don&#x27;t want to call updateSlot      // with the previous one.      previousNewFiber.sibling = newFiber;    &#125;    previousNewFiber = newFiber;    oldFiber = nextOldFiber;  &#125;  if (newIdx === newChildren.length) &#123;    // We&#x27;ve reached the end of the new children. We can delete the rest.    deleteRemainingChildren(returnFiber, oldFiber);    return resultingFirstChild;  &#125;  if (oldFiber === null) &#123;    // If we don&#x27;t have any more existing children we can choose a fast path    // since the rest will all be insertions.    for (; newIdx &lt; newChildren.length; newIdx++) &#123;      var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);      if (_newFiber === null) &#123;        continue;      &#125;      lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);      if (previousNewFiber === null) &#123;        // TODO: Move out of the loop. This only happens for the first run.        resultingFirstChild = _newFiber;      &#125; else &#123;        previousNewFiber.sibling = _newFiber;      &#125;      previousNewFiber = _newFiber;    &#125;    return resultingFirstChild;  &#125; // Add all children to a key map for quick lookups.  var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.  for (; newIdx &lt; newChildren.length; newIdx++) &#123;    var _newFiber2 = updateFromMap(      existingChildren,      returnFiber,      newIdx,      newChildren[newIdx],      lanes    );    if (_newFiber2 !== null) &#123;      if (shouldTrackSideEffects) &#123;        if (_newFiber2.alternate !== null) &#123;          // The new fiber is a work in progress, but if there exists a          // current, that means that we reused the fiber. We need to delete          // it from the child list so that we don&#x27;t add it to the deletion          // list.          existingChildren.delete(            _newFiber2.key === null ? newIdx : _newFiber2.key          );        &#125;      &#125;      lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);      if (previousNewFiber === null) &#123;        resultingFirstChild = _newFiber2;      &#125; else &#123;        previousNewFiber.sibling = _newFiber2;      &#125;      previousNewFiber = _newFiber2;    &#125;  &#125;  if (shouldTrackSideEffects) &#123;    // Any existing children that weren&#x27;t consumed above were deleted. We need    // to add them to the deletion list.    existingChildren.forEach(function (child) &#123;      return deleteChild(returnFiber, child);    &#125;);  &#125;  return resultingFirstChild;&#125;\n\n属性 Difffunction diffProperties(  domElement,  tag,  lastRawProps,  nextRawProps,  rootContainerElement) &#123;  // lastRawProps &#123;children:&#x27;内容&#x27;&#125;  // nextRawProps &#123;children:&#x27;内容改变&#x27;&#125;  var updatePayload = null;  var lastProps;  var nextProps;  // 这些元素类型,会被添加上特有的元素默认属性  switch (tag) &#123;    case &quot;input&quot;:      lastProps = getHostProps(domElement, lastRawProps);      nextProps = getHostProps(domElement, nextRawProps);      updatePayload = [];      break;    case &quot;option&quot;:      lastProps = getHostProps$1(domElement, lastRawProps);      nextProps = getHostProps$1(domElement, nextRawProps);      updatePayload = [];      break;    case &quot;select&quot;:      lastProps = getHostProps$2(domElement, lastRawProps);      nextProps = getHostProps$2(domElement, nextRawProps);      updatePayload = [];      break;    case &quot;textarea&quot;:      lastProps = getHostProps$3(domElement, lastRawProps);      nextProps = getHostProps$3(domElement, nextRawProps);      updatePayload = [];      break;    default:      lastProps = lastRawProps;      nextProps = nextRawProps;      if (        typeof lastProps.onClick !== &quot;function&quot; &amp;&amp;        typeof nextProps.onClick === &quot;function&quot;      ) &#123;        // TODO: This cast may not be sound for SVG, MathML or custom elements.        trapClickOnNonInteractiveElement(domElement);      &#125;      break;  &#125;  // 验证一些特殊属性,是否合法 例如 dangerouslySetInnerHTML  assertValidProps(tag, nextProps);  var propKey;  var styleName;  var styleUpdates = null;  for (propKey in lastProps) &#123;    // 如果旧的属性没有,而新的属性有,那个就跳出直接分析新的属性    if (      nextProps.hasOwnProperty(propKey) ||      !lastProps.hasOwnProperty(propKey) ||      lastProps[propKey] == null    ) &#123;      continue;    &#125;    if (propKey === STYLE) &#123;      var lastStyle = lastProps[propKey];      // 如果是style属性,提取出属性的key      for (styleName in lastStyle) &#123;        if (lastStyle.hasOwnProperty(styleName)) &#123;          if (!styleUpdates) &#123;            styleUpdates = &#123;&#125;;          &#125;          styleUpdates[styleName] = &quot;&quot;;        &#125;      &#125;    &#125; else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN);    else if (      propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||      propKey === SUPPRESS_HYDRATION_WARNING    );    else if (propKey === AUTOFOCUS);    else if (registrationNameDependencies.hasOwnProperty(propKey)) &#123;      // This is a special case. If any listener updates we need to ensure      // that the &quot;current&quot; fiber pointer gets updated so we need a commit      // to update this element.      if (!updatePayload) &#123;        updatePayload = [];      &#125;    &#125; else &#123;      // For all other deleted properties we add it to the queue. We use      // the allowed property list in the commit phase instead.      (updatePayload = updatePayload || []).push(propKey, null);    &#125;  &#125;  for (propKey in nextProps) &#123;    var nextProp = nextProps[propKey];    var lastProp = lastProps != null ? lastProps[propKey] : undefined;    // 如果新的属性值为假,或者没有变化,就跳出循环    if (      !nextProps.hasOwnProperty(propKey) ||      nextProp === lastProp ||      (nextProp == null &amp;&amp; lastProp == null)    ) &#123;      continue;    &#125;    if (propKey === STYLE) &#123;      &#123;        if (nextProp) &#123;          // Freeze the next style object so that we can assume it won&#x27;t be          // mutated. We have already warned for this in the past.          Object.freeze(nextProp);        &#125;      &#125;      if (lastProp) &#123;        // Unset styles on `lastProp` but not on `nextProp`.        for (styleName in lastProp) &#123;          if (            lastProp.hasOwnProperty(styleName) &amp;&amp;            (!nextProp || !nextProp.hasOwnProperty(styleName))          ) &#123;            if (!styleUpdates) &#123;              styleUpdates = &#123;&#125;;            &#125;            styleUpdates[styleName] = &quot;&quot;;          &#125;        &#125; // Update styles that changed since `lastProp`.        for (styleName in nextProp) &#123;          if (            nextProp.hasOwnProperty(styleName) &amp;&amp;            lastProp[styleName] !== nextProp[styleName]          ) &#123;            if (!styleUpdates) &#123;              styleUpdates = &#123;&#125;;            &#125;            styleUpdates[styleName] = nextProp[styleName];          &#125;        &#125;      &#125; else &#123;        // Relies on `updateStylesByID` not mutating `styleUpdates`.        if (!styleUpdates) &#123;          if (!updatePayload) &#123;            updatePayload = [];          &#125;          updatePayload.push(propKey, styleUpdates);        &#125;        styleUpdates = nextProp;      &#125;    &#125; else if (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;      var lastHtml = lastProp ? lastProp[HTML$1] : undefined;      if (nextHtml != null) &#123;        if (lastHtml !== nextHtml) &#123;          (updatePayload = updatePayload || []).push(propKey, nextHtml);        &#125;      &#125;    &#125;    //  会以数组的形式,同时插入 key 和 value [&#x27;children&#x27;,&#x27;内容改变&#x27;]    else if (propKey === CHILDREN) &#123;      if (typeof nextProp === &quot;string&quot; || typeof nextProp === &quot;number&quot;) &#123;        (updatePayload = updatePayload || []).push(propKey, &quot;&quot; + nextProp);      &#125;    &#125; else if (      propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||      propKey === SUPPRESS_HYDRATION_WARNING    );    else if (registrationNameDependencies.hasOwnProperty(propKey)) &#123;      if (nextProp != null) &#123;        // We eagerly listen to this even though we haven&#x27;t committed yet.        if (typeof nextProp !== &quot;function&quot;) &#123;          warnForInvalidEventListener(propKey, nextProp);        &#125;        if (propKey === &quot;onScroll&quot;) &#123;          listenToNonDelegatedEvent(&quot;scroll&quot;, domElement);        &#125;      &#125;      if (!updatePayload &amp;&amp; lastProp !== nextProp) &#123;        // This is a special case. If any listener updates we need to ensure        // that the &quot;current&quot; props pointer gets updated so we need a commit        // to update this element.        updatePayload = [];      &#125;    &#125; else if (      typeof nextProp === &quot;object&quot; &amp;&amp;      nextProp !== null &amp;&amp;      nextProp.$$typeof === REACT_OPAQUE_ID_TYPE    ) &#123;      // If we encounter useOpaqueReference&#x27;s opaque object, this means we are hydrating.      // In this case, call the opaque object&#x27;s toString function which generates a new client      // ID so client and server IDs match and throws to rerender.      nextProp.toString();    &#125; else &#123;      // For any other property we always add it to the queue and then we      // filter it out using the allowed property list during the commit.      (updatePayload = updatePayload || []).push(propKey, nextProp);    &#125;  &#125;  if (styleUpdates) &#123;    &#123;      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);    &#125;    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);  &#125;  return updatePayload;&#125;\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑥ Fiber与Effects链表","url":"/posts/ed551cff73e5/","content":"const App: React.FC = () =&gt; &#123;  const [content, setContent] = useState(&quot;内容&quot;);  return (    &lt;&gt;      &lt;h1 onClick=&#123;() =&gt; setContent(&quot;内容改变&quot;)&#125; role=&quot;presentation&quot;&gt;        标题      &lt;/h1&gt;      &lt;p&gt;&#123;content&#125;&lt;/p&gt; 2020.01.01    &lt;/&gt;  );&#125;;\n\n回到 completeUnitOfWork 方法,看一下链表的创建过程\nfunction completeUnitOfWork(unitOfWork) &#123;  do &#123;    completeWork();    if ((completedWork.flags &amp; Incomplete) === NoFlags) &#123;      setCurrentFiber(completedWork);      if (        returnFiber !== null &amp;&amp;        // Do not append effects to parents if a sibling failed to complete        (returnFiber.flags &amp; Incomplete) === NoFlags      ) &#123;        // Append all the effects of the subtree and this fiber onto the effect        // list of the parent. The completion order of the children affects the        // side-effect order.        if (returnFiber.firstEffect === null) &#123;          returnFiber.firstEffect = completedWork.firstEffect;        &#125;        if (completedWork.lastEffect !== null) &#123;          if (returnFiber.lastEffect !== null) &#123;            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;          &#125;          returnFiber.lastEffect = completedWork.lastEffect;        &#125; // If this fiber had side-effects, we append it AFTER the children&#x27;s        // side-effects. We can perform certain side-effects earlier if needed,        // by doing multiple passes over the effect list. We don&#x27;t want to        // schedule our own side-effect on our own list because if end up        // reusing children we&#x27;ll schedule this effect onto itself since we&#x27;re        // at the end.        var flags = completedWork.flags;        // Skip both NoWork and PerformedWork tags when creating the effect        // list. PerformedWork effect is read by React DevTools but shouldn&#x27;t be        // committed.        // 创建Effect链表时跳过 tag 为 NoWork 和PerformedWork        // 他们只会被 DevTools 使用不应该提交        if (flags &gt; PerformedWork) &#123;          if (returnFiber.lastEffect !== null) &#123;            returnFiber.lastEffect.nextEffect = completedWork;          &#125; else &#123;            returnFiber.firstEffect = completedWork;          &#125;          returnFiber.lastEffect = completedWork;        &#125;      &#125;    &#125;    completedWork = returnFiber; // Update the next thing we&#x27;re working on in case something throws.    workInProgress = completedWork;  &#125; while (completedWork !== null); // We&#x27;ve reached the root.&#125;\n\n首先,分析一下挂载时的链表创建过程, 第一个结束 completeWork 的是 h1 元素, 它的 returnFiber 是 App, 由于 h1 的 flags 是 0, 因为首次渲染是没有标记副作用,所以 App 和 h1 并不会通过 Effect 指针相连, 同理 p 和 文本元素,也是一样处理\n下一个节点是 AppFiber, 它的 returnFiber 是 RootFiber, 由于 App 节点首次渲染的时候需要插入到挂载元素中, 所以它有 Placement 副作用,它的值大于 PerformedWork(标记节点处理过的副作用) ,首次挂载时的 Effect 链表如下\nreturnFiber.firstEffect = completedWork;returnFiber.lastEffect = completedWork;\n\n\n更新时, h1 绑定的函数是匿名函数,所以会携带副作用, 因为第一次执行的时候 h1 和它 returnFiber 的 firstEffect 和 lastEffect,都为 null,所以最先建立这两个节点的联系\n\n下一个节点是 p 节点, 它的副作用也需要添加到 Effect 链表上,所以通过 lastEffect 指针找到当前副作用链表的最后一个副作用,它的下一个副作用就是当前的 p 节点\n最后调整 returnFiber 的 lastEffect 指针,指向新的副作用 p 节点. 总结来说,如果下一级的子元素携带副作用, 通过 lastEffect 指针找到最后的副作用,并通过 nextEffect 延长 Effect 链表, 如果是上级元素携带副作用,则修改 firstEffect 指针延长 Effect 链表\n\n下面增加一点组件的复杂性\nconst Box: React.FC&lt;&#123; content: string &#125;&gt; = (props) =&gt; &#123;  const [number, setNumber] = useState(1);  return (    &lt;p onClick=&#123;() =&gt; setNumber((v) =&gt; v + 1)&#125;&gt;      &#123;props.content&#125;      &lt;span&gt;&#123;number&#125;&lt;/span&gt;    &lt;/p&gt;  );&#125;;const App: React.FC = () =&gt; &#123;  const [content, setContent] = useState(&quot;内容&quot;);  return (    &lt;&gt;      &lt;h1 onClick=&#123;() =&gt; setContent(&quot;内容改变&quot;)&#125; role=&quot;presentation&quot;&gt;        标题 &lt;p&gt;&#123;content&#125;&lt;/p&gt;      &lt;/h1&gt;      &lt;Box content=&#123;content&#125; /&gt;    &lt;/&gt;  );&#125;;\n\n这个组件最终形成的 Fiber 树如下\n\n当点击 h1 标签后\n第一个进入的是标题文本节点,但是文本节点不存在副作用,所以会跳过这个节点\n下一个节点是 P 节点, 内容改变携带了副作用,所以会最先添加到链表中和 returnFiber 也就是 h1 Fiber 相连\n\n下一个节点是 h1 会被拼接到 effectList 最后面, 这次 returnFiber 是 App, 它的 firstEffect 就是 h1 的 firstEffect, 换句话说也就是,上层节点会延长 effect 链表的头部, 会继承上一个节点 firstEffect\n\n下一个节点是 Box 中的文本节点, 会和他的上级节点形成 effect 链表\n\n下一个是 span 节点, 因为还没有点击 p 标签,所以 span 没有携带副作用,直接跳过\n下一个是 span 上级的 p 节点, returnFiber 是 Box 会成为新的头部\n\n下一个是个 Box 节点, returnFiber 是 App,相当于在末尾追加了 effect 链表, 所以修改了 App lastEffect 指针,并且延长了 h1 的 nextEffect\n\n最后遍历到根节点 rootFiber 相当于头部延长 effect 链表\n\n当点击 p 标签触发更新, 会重新构建整个 effect 链表, 最先进入 complete 的 span 节点, 所以会和他的父节点生成 effect 链表\n构建步骤与第一次更新时类似\n\n\n\n\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑤ Fiber与双缓存结构","url":"/posts/89ea5f49799f/","content":"fiber 是一种架构，一种数据类型，一个调用栈的帧。\n指向父节点使用 return 链接，指的是执行完 completeWork 返回的下一个 fiberNode,这里有一个返回的动作，所有用 return。\n双缓存类似于显卡的前缓冲区和后缓冲区，当新的图像写入后缓冲区之后，前后缓冲区交换。一个是真实的 UI 对应的 fiberTree,一个是即将更新的 UI 对应的 fiberTree，通过 alternate 关联。\n先创建一个组件,下面这个了例子在大部分的章节都会用到\nconst App: React.FC = () =&gt; &#123;  const [content, setContent] = useState(&quot;内容&quot;);  return (    &lt;&gt;      &lt;h1 onClick=&#123;() =&gt; setContent(&quot;内容改变&quot;)&#125; role=&quot;presentation&quot;&gt;        标题      &lt;/h1&gt;      &lt;p&gt;&#123;content&#125;&lt;/p&gt; 2020.01.01    &lt;/&gt;  );&#125;;\n\nmount 阶段准备 workInProgress 节点,此节点为 rootFiber 节点的一个副本,无论是更新还是挂载阶段都会先创建这个节点,然后从这个节点头部开始,递归处理每一个节点,最终形成一个 fiber 链表,对整个链表处理之后会交换两个 Fiber 树\ncreateWorkInProgress\nfunction prepareFreshStack(root, lanes) &#123;  workInProgressRoot = root;  // 传入rootFiber  workInProgressRoot = root;  workInProgress = createWorkInProgress(root.current, null);  workInProgressRootRenderLanes =    subtreeRenderLanes =    workInProgressRootIncludedLanes =      lanes;  workInProgressRootExitStatus = RootIncomplete;  workInProgressRootFatalError = null;  workInProgressRootSkippedLanes = NoLanes;  workInProgressRootUpdatedLanes = NoLanes;  workInProgressRootPingedLanes = NoLanes;&#125;function createWorkInProgress(current, pendingProps) &#123;  var workInProgress = current.alternate;  // workInProgress 不存在则创建新的节点  if (workInProgress === null) &#123;    // 我们使用了双缓冲池技术因为我们知道只需要最多两个版本的树    // 我们存放没有使用的节点以便复用,这是延时创建避免被从不会更新任务,占用额外的对象.    // 这也允许我们在需要的时候回收的内存.    // 克隆出新的rootFiber节点    workInProgress = createFiber(      current.tag,      pendingProps,      current.key,      current.mode    );    workInProgress.elementType = current.elementType;    workInProgress.type = current.type;    workInProgress.stateNode = current.stateNode;    // workInProgress 通过alternate属性链接原始的 FiberRoot 对象    workInProgress.alternate = current;    current.alternate = workInProgress;  &#125; else &#123;  &#125;  return workInProgress;&#125;\n\n到目前位置 Fiber 树的结构为\n\n递归处理的开始,在performUnitOfWork 中传入刚刚克隆出的 rootFiber 节点\nfunction workLoopSync() &#123;  // Already timed out, so perform work without checking if we need to yield.  while (workInProgress !== null) &#123;    performUnitOfWork(workInProgress);  &#125;&#125;function performUnitOfWork(unitOfWork) &#123;  // 当前正被处理的这个是Fiber的镜像,任何操作都不应该依赖于它  // 但在这里依赖它,意味在处理进程中不需要额外的字段  // 这个是原始的 rootFiber 节点  var current = unitOfWork.alternate;  // 一个全局current变量指向当前被处理的节点  setCurrentFiber(unitOfWork);  var next;  next = beginWork(current, unitOfWork, subtreeRenderLanes);  // 处理结束后清空current=null指针  resetCurrentFiber();  unitOfWork.memoizedProps = unitOfWork.pendingProps;  // complete 阶段  if (next === null) &#123;    completeUnitOfWork(unitOfWork);  &#125; else &#123;    workInProgress = next;  &#125;&#125;\n\nbeginWork 简单来说这个方法就是从根节点解析,如果节点不存在就创建对应的 fiber 节点,如果存在就判断是复用还是重新创建, 并通过 return, sibling 等指针链接各个 fiber 节点最终构建出一颗 Fiber 树, 而这个 Fiber 树与原始的 Fiber 树之间通过 alternate 指针相连. 注意 beginWork 处理的都是 js 对象, 对真正 DOM 元素的创建是在 completeWork 中进行的.\n第一个节点是 rootFiber 节点,因为它的镜像节点已经在克隆 rootFiber 节点的时候通过 alternate 指针与原始的 rootFiber 相关联,所以会进入 if(current!==null) 分支, 最终 didReceiveUpdate 标记为 false\n// current 为 alternate 节点,也就是原始的 Fiber 树中的镜像节点// workInProgress 为当前正在处理的节点// subtreeRenderLanes 为当前正处理的节点的优先级function beginWork(current, workInProgress, renderLanes) &#123;  if (current !== null) &#123;    var oldProps = current.memoizedProps;    var newProps = workInProgress.pendingProps;    // props改变    // 上下文对象改变    // Force a re-render if the implementation changed due to hot reload    // 这三个状态改变会被标记为 didReceiveUpdate 更新    if (oldProps !== newProps || hasContextChanged() || (     workInProgress.type !== current.type )) &#123;      // If props or context changed, mark the fiber as having performed work.      // This may be unset if the props are determined to be equal later (memo).      didReceiveUpdate = true;    &#125;    //    else if (!includesSomeLane(renderLanes, updateLanes)) &#123;      didReceiveUpdate = false;      // This fiber does not have any pending work. Bailout without entering      // the begin phase. There&#x27;s still some bookkeeping we that needs to be done      // in this optimized path, mostly pushing stuff onto the stack.      switch (workInProgress.tag) &#123;        case HostRoot:        // 不同的 fiber 类型用不同的函数处理        // 没有对 fiber 进行操作,只是处理上下文      &#125;      // 如果节点可以复用,会通过这个函数处理      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);    &#125; else &#123;     if ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;        // This is a special case that only exists for legacy mode.        // See https://github.com/facebook/react/pull/19216.        didReceiveUpdate = true;      &#125; else &#123;        // An update was scheduled on this fiber, but there are no new props        // nor legacy context. Set this to false. If an update queue or context        // consumer produces a changed value, it will set this to true. Otherwise,        // the component will assume the children have not changed and bail out.        didReceiveUpdate = false;      &#125;  &#125; else &#123;    didReceiveUpdate = false;  &#125;  switch (workInProgress.tag) &#123;    // updateHostRoot(...)    // updateHostComponent(...)  &#125;&#125;\n\n会跳出 if 条件,进入到下面的 switch 处理\nfunction updateHostRoot(current, workInProgress, renderLanes) &#123;  var updateQueue = workInProgress.updateQueue;  // 把一些原始rootFiber上的属性,复制到 workInProgress  cloneUpdateQueue(current, workInProgress);  // render方法调用时传入的App jsxElement,被添加到updateQueue  // 这个方法会将App从update对象中取出,放到memoizedState中  processUpdateQueue(workInProgress, nextProps, null, renderLanes);  var nextState = workInProgress.memoizedState;  // nextChildren 为render方法传入的 App 组件  var nextChildren = nextState.element;  // 如果和之前的组件相同,则复用该节点  if (nextChildren === prevChildren) &#123;    resetHydrationState();    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);  &#125;  // 进入协调子节点的方法  //           原始rootFiber, 当前处理的rootFiber, App节点  reconcileChildren(current, workInProgress, nextChildren, renderLanes);  return workInProgress.child;&#125;\n\nreconcileChildren\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) &#123;  if (current === null) &#123;    // If this is a fresh new component that hasn&#x27;t been rendered yet, we    // won&#x27;t update its child set by applying minimal side-effects. Instead,    // we will add them all to the child before it gets rendered. That means    // we can optimize this reconciliation pass by not tracking side-effects.    workInProgress.child = mountChildFibers(      workInProgress,      null,      nextChildren,      renderLanes    );  &#125; else &#123;    // If the current child is the same as the work in progress, it means that    // we haven&#x27;t yet started any work on these children. Therefore, we use    // the clone algorithm to create a copy of all the current children.    // If we had any progressed work already, that is invalid at this point so    // let&#x27;s throw it out.    workInProgress.child = reconcileChildFibers(      workInProgress,      current.child,      nextChildren,      renderLanes    );  &#125;&#125;\n\n这两个协调节点的处理函数都是通过一个函数生成的,区别就是 mountChildFibers 不会处理副作用,reconcileChildFibers 会在 fiber 节点上添加副作用的标识,标记删除或更新等操作\nvar reconcileChildFibers = ChildReconciler(true);var mountChildFibers = ChildReconciler(false);\n\n由于原始节点 current 存在, 会进入 reconcileChildFibers,根据不同的子元素类型使用不同的处理方法,Diff 算法也发生在这里\nreconcileChildFibers\nfunction reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) &#123;  // This function is not recursive.  // If the top level item is an array, we treat it as a set of children,  // not as a fragment. Nested arrays on the other hand will be treated as  // fragment nodes. Recursion happens at the normal flow.  // Handle top level unkeyed fragments as if they were arrays.  // This leads to an ambiguity between &lt;&gt;&#123;[...]&#125;&lt;/&gt; and &lt;&gt;...&lt;/&gt;.  // We treat the ambiguous cases above the same.  // 这个条件用于判断是否是Fragment,如果是顶层的Fragment会直接从props中取出,把他当作子元素  var isUnkeyedTopLevelFragment =    typeof newChild === &quot;object&quot; &amp;&amp;    newChild !== null &amp;&amp;    newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;    newChild.key === null;  if (isUnkeyedTopLevelFragment) &#123;    newChild = newChild.props.children;  &#125;  var isObject = typeof newChild === &quot;object&quot; &amp;&amp; newChild !== null;  if (isObject) &#123;    switch (newChild.$$typeof) &#123;      case REACT_ELEMENT_TYPE:        return placeSingleChild(          reconcileSingleElement(            returnFiber,            currentFirstChild,            newChild,            lanes          )        );      case REACT_PORTAL_TYPE:        return placeSingleChild(          reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes)        );    &#125;  &#125;  if (typeof newChild === &quot;string&quot; || typeof newChild === &quot;number&quot;) &#123;    return placeSingleChild(      reconcileSingleTextNode(        returnFiber,        currentFirstChild,        &quot;&quot; + newChild,        lanes      )    );  &#125;  if (isArray$1(newChild)) &#123;    return reconcileChildrenArray(      returnFiber,      currentFirstChild,      newChild,      lanes    );  &#125;  return deleteRemainingChildren(returnFiber, currentFirstChild);&#125;\n\n最终 reconcileSingleElement 会使用 App 生成新的 fiber 节点,并通过 return 指针与 rootFiber 相连\nfunction reconcileSingleElement(  returnFiber,  currentFirstChild,  element,  lanes) &#123;  /*    在这个函数中会判断组件的tag类型,需要注意的函数组件并不会一开始就被标记为FunctionComponent    因为函数可能没有继承React.Component 是用户自己的行为,所以会在处理这个节点的时候单独判断        type会按照以下顺序判断    type是否是一个函数,如果是原型链上有没有isReactComponent 如果有就是类组件    type是否是一个字符串, 如果是就是HTMLElement    type是不是内置的类型,例如 REACT_FRAGMENT_TYPE 等    如果都不是会被标记为 mountIndeterminateComponent=2 表示一个待定的组件  */  var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);  _created4.return = returnFiber;  return _created4;&#125;\n\nplaceSingleChild 会把节点的 flag 标记为 Placement 标识这是需要插入的元素\nnewFiber.flags = Placement;\n\n最后通过 return workInProgress.child 返回下一个 fiber , 也就是刚刚创建的 AppFiber, 现在链表的结构\n\n回到  performUnitOfWork 方法,next 现在为 App fiber,next!==null 表示还有 App Fiber 这个节点需要处理,所以并不会进入 complete 这个分支,下面经过 workLoopSync 再次进入 performUnitOfWork 方法\n由于 React.createElement 创建 virtualDOM 的是否并不会分析组件类型,只能简单区是否是 html 元素, 不能区分是函数组件还是类组件, 所以这里会进入 tag=2 的分支,用于处理一个不确定的组件\nswitch (workInProgress.tag) &#123;  case IndeterminateComponent: &#123;    return mountIndeterminateComponent(      current,      workInProgress,      workInProgress.type,      renderLanes    );  &#125;&#125;function mountIndeterminateComponent(  _current,  workInProgress,  Component,  renderLanes) &#123;  // 首先会尝试执行这个函数,拿到函数的返回值  var value = renderWithHooks(    null,    workInProgress,    Component,    props,    context,    renderLanes  );  // 判断是否具有类组件的行为,如果有则按类组件处理不,并重新标记tag  if (    typeof value === &quot;object&quot; &amp;&amp;    value !== null &amp;&amp;    typeof value.render === &quot;function&quot; &amp;&amp;    value.$$typeof === undefined  ) &#123;    //...    workInProgress.tag = ClassComponent;    //...  &#125; else &#123;    // 如果不是类组件才会标记为函数组件    workInProgress.tag = FunctionComponent;  &#125;  // 再次调用协调函数  reconcileChildren(null, workInProgress, value, renderLanes);&#125;\n\n和上次调用reconcileChildren的时候不同,这次传入的 current&#x3D;null, 也就是这个节点还没有镜像节点,所以会使用 mountChildFibers 处 理\n因为这两个方法只是区分是否是初次挂载,所以大致的流程相同,进入 reconcileChildFibers 会检查到这是一个 Fragment 节点,所以直接取出它的子元素,是一个由 h1,p,文本元素 三个 virtualDOM 组成的数组, 进入 reconcileChildrenArray 多节点的 Diff 算法就发生在这里\n最终这个方法会将三个子节点通过 sibling 指针相连,并返回头节点 h1, 作为下一个工作单元,现在链表的结构为\n\n再次处理的是 h1 节点, 因为初次挂载它的 alternate 也没有构建,所以直接进入对应的 case 处理\n在处理 h1 Fiber 的时候会检查是不是存在唯一的文本子节点,如果存在子元素为null\nfunction updateHostComponent(current, workInProgress, renderLanes) &#123;  if (isDirectTextChild) &#123;    // 我们把Host Node 唯一字节点当作一个特殊用例,这是一个常见的问题,不会当作一个子节点处理    // 在执行环境中会处理,依然可以获取这个props,这可以避免用另一个Fiber遍历处理    nextChildren = null;  &#125;  return workInProgress.child;&#125;\n\nh1 的 beginWork 结束之后会进入 completeWork, 因为 h1 有为文本子节点,并不会算作他的子元素,所以他的 child &#x3D; null\n需要注意的是,completeWork 并不一定在所有的节点的 beginWork 执行完成后才会执行,当一个节点没有子节点需要处理的时候,就会进入 completeWork,\ncomplete 阶段completeWork 最重要的目的之一就是对比新老节点,把 fiber 对应的真实 DOM 元素创建出来或添加更新属性, 并与 fiber 节点相关联,另一个目的是 构建 Effects 链表\n这个方法会遍历传入元素的 siblings 兄弟元素,如果没有会返回父级元素,一直递归到根节点\nfunction completeUnitOfWork(unitOfWork) &#123;  // Attempt to complete the current unit of work, then move to the next  // sibling. If there are no more siblings, return to the parent fiber.  var completedWork = unitOfWork;  do &#123;    next = completeWork(current, completedWork, subtreeRenderLanes);    // 结束执行后有一段处理 Effect 链表的逻辑    // ...    var siblingFiber = completedWork.sibling;    if (siblingFiber !== null) &#123;      // If there is more work to do in this returnFiber, do that next.      workInProgress = siblingFiber;      return;    &#125; // Otherwise, return to the parent    completedWork = returnFiber;    // Update the next thing we&#x27;re working on in case something throws.    workInProgress = completedWork;  &#125; while (completedWork !== null); // We&#x27;ve reached the root.&#125;\n\ncompleteWork 与 beginWork 方法设计类似,不同的 fiber 类型,会进入不同的 case 处理,但以下的节点类型会返回 null,这些类型的 Fiber 节点都没有真实的 DOM 元素与之对应\ncase IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:  return null;\n\n当 h1 元素首次进入, 会进入对应的 HostComponent 处理,这时的 alternate 节点还没有渲染,所以 current=null, 会进入 else 分支\ncase HostComponent:  &#123;    var type = workInProgress.type;    if (current !== null &amp;&amp; workInProgress.stateNode != null) &#123;      updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);    &#125;else&#123;      // 会直接调用原生的DOM方法创建元素      // domElement = ownerDocument.createElement(type);      var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);      // 如果元素还有其他子元素例如 &lt;h1&gt;&lt;span/&gt;&lt;span/&gt;&lt;/h1&gt;      // 会循环遍历子元素,将子元素的原生DOM,插入到 h1 的原生DOM中      appendAllChildren(instance, workInProgress, false, false);      // 重新赋值 stateNode 指针,指向原生DOM      workInProgress.stateNode = instance;      // Certain renderers require commit-time effects for initial mount.      // (eg DOM renderer supports auto-focus for certain elements).      // Make sure such renderers get scheduled for later work.      // 通过原生DOM方法将props中的属性添加在原生DOM上      // node.addAttribute(_attributeName);      // 如果是点击事件,则会加入到事件系统的队列中      if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;        // 添加更新的副作用 workInProgress.flags |= Update;        markUpdate(workInProgress);      &#125;    &#125;  &#125;  return null;&#125;\n\n跳出 complete 后,下一个节点是 p,与 h1 类似,还是会先进入 beginWork, 由于没有子节点,所以紧接着进入 completeWork, 当最后一个文本节点处理之后会执行 completedWork = returnFiber 也就是对 AppFiber 执行 completeWork, 所以直接返回 null,最终所有的节点都遍历之后形成的链表为\n\n\nupdate 阶段点击 h1 标签状态更新,依然会进入 createWorkInProgress 第一个节点是 RootFiber,alternate 已经存在,如果不存在则创建一个 FiberInWorkProgress 并用 alternate 相连\n与 render 阶段相同都会进入 beginWork , 第一个节点为 FiberRoot, 与首次渲染不同,这次的 renderLanes!==updateLanes 表示这个节点需要渲染,但是当前节点不需要更新,这也就意味这这个节点可以复用,会进入下面的复用的逻辑\n会直接克隆当前节点,并返回子节点 App\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) &#123;  //  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) &#123;    // The children don&#x27;t have any work either. We can skip them.    // TODO: Once we add back resuming, we should check if the children are    // a work-in-progress set. If so, we need to transfer their effects.    return null;  &#125; else &#123;    // 当前的节点不需要更新但是子节点需要更新,克隆子节点继续    // 会再次调用 createWorkInProgress 克隆当前节点的子节点,并通过 alternate 指针,与原节点相连    cloneChildFibers(current, workInProgress);    return workInProgress.child;  &#125;&#125;\n\n现在的 Fiber 树结构为\n\n下面进入的是 App 节点, 因为这个节点需要更新,但是又没有新的属性或上下文,所以会进入下面的分支,把是否收到更新标记为 false,并重新构建此节点\nif ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;  // This is a special case that only exists for legacy mode.  // See https://github.com/facebook/react/pull/19216.  didReceiveUpdate = true;&#125; else &#123;  // An update was scheduled on this fiber, but there are no new props  // nor legacy context. Set this to false. If an update queue or context  // consumer produces a changed value, it will set this to true. Otherwise,  // the component will assume the children have not changed and bail out.  // 这个Fiber上有一个更新被调度,但是没有新的属性或上下文,就设置为false  // 如果一个更新队列或上下文,消费了一个改变的值,会被设置为true  // 否则组件则会假定子元素没有改变并跳出  didReceiveUpdate = false;&#125;\n\n这一次的 App 节点已经不是 mount 时候无法确定的节点,而是一个 FunctionComponent,会进入对应的 case 处理\nfunction updateFunctionComponent(  current,  workInProgress,  Component,  nextProps,  renderLanes) &#123;  var context;  var nextChildren;  setIsRendering(true);  // 会在创建 virtualDOM 时检查是否更新,如果是 didReceiveUpdate 标记为true  nextChildren = renderWithHooks(    current,    workInProgress,    Component,    nextProps,    context,    renderLanes  );  // 如果节点不需要更新则会继续走复用节点的逻辑  if (current !== null &amp;&amp; !didReceiveUpdate) &#123;    bailoutHooks(current, workInProgress, renderLanes);    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);  &#125; // React DevTools reads this flag.  // 否则创建新的Fiber节点并返回  workInProgress.flags |= PerformedWork;  reconcileChildren(current, workInProgress, nextChildren, renderLanes);  return workInProgress.child;&#125;\n\nh1 更新阶段, 会进入 if 分支执行 updateHostComponent, 并且因为 props 发生改变,didReceiveUpdate 会被标记为 true. h1 的文本发生了改变,但由于这是它的唯一文本节点所以不需要额外处理,只当作节点更新即可.\n下面会紧接着进入 h1 的 completeWork, 进入对应的 case 进行处理, updateHostComponent$1 中会调用 diffProperties 进行属性的 Diff, 最终把 Diff 后的属性添加到 updateQueue 中\ncase HostComponent:  &#123;    var rootContainerInstance = getRootHostContainer();    var type = workInProgress.type;    if (current !== null &amp;&amp; workInProgress.stateNode != null) &#123;      // 执行属性Diff算法      // var updatePayload = diffProperties(domElement, type, oldProps, newProps);      // workInProgress.updateQueue = updatePayload;      updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);      if (current.ref !== workInProgress.ref) &#123;        markRef$1(workInProgress);      &#125;    &#125; else &#123;      var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);      appendAllChildren(instance, workInProgress, false, false);      workInProgress.stateNode = instance;      // Certain renderers require commit-time effects for initial mount.      // (eg DOM renderer supports auto-focus for certain elements).      // Make sure such renderers get scheduled for later work.    &#125;    return null;  &#125;\n\n以下一个进来的 p 节点为例, 新的文本是 内容改变, 旧的文本是 内容,与 h1 的处理过程类似,最后会执行 RootFiber 的 completeWork 会给 fiber 添加 snapshot 副作用标记\n// Schedule an effect to clear this container at the start of the next commit.// This handles the case of React rendering into a container with previous children.// It&#x27;s also safe to do for updates too, because current.child would only be null// if the previous render was null (so the the container would already be empty).workInProgress.flags |= Snapshot;\n\n最终依次处理所有节点之后,生成一个新的 Fiber 树\n\n双缓存结构在内存中构建并直接替换的技术叫做双缓存。\n当首次 update 结束,这时产生的两个 Fiber 树就是,Fiber 树的双缓存结构\n当 render 阶段执行结束之后会进入 commitRoot\nfunction performSyncWorkOnRoot(root) &#123;  // 原 rootFiber 的镜像节点,也就是 workInProgress  var finishedWork = root.current.alternate;  root.finishedWork = finishedWork;  root.finishedLanes = lanes;  // 提交阶段结束之后会重新复制current  // root.current = finishedWork;  // FiberRoot的 current 指针会指向最新构建的 Fiber 树  // 并将原有的 Fiber 树回收 workInProgress = null  commitRoot(root);&#125;\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑧ commit阶段","url":"/posts/ea3417396ca5/","content":"\n预备工作flushPassiveEffects 执行所有还没执行的副作用,因为执行的时候还可能产生额外的副作用,所以需要 while 判断. rootWithPendingPassiveEffect 表示是否有副作用标记\ndo &#123;  flushPassiveEffects();&#125; while (rootWithPendingPassiveEffects !== null);// 第一步执行所有的副作用销毁函数// 一定要保证在执行副作用函数前,所有的销毁函数已经执行完成,但也有例外的情况// 例如在兄弟组件中,一个组件的副作用销毁函数,是在兄弟组件的副作用创建函数中定义的// 并且被添加在Ref 属性上通过引用的方式使用.var unmountEffects = pendingPassiveHookEffectsUnmount;for (var i = 0; i &lt; unmountEffects.length; i += 2) &#123;  var destroy = _effect.destroy;  destroy();&#125;// 执行所有的副作用创建函数var mountEffects = pendingPassiveHookEffectsMount;for (var _i = 0; _i &lt; mountEffects.length; _i += 2) &#123;  var _effect2 = mountEffects[_i];  var create = effect.create;  effect.destroy = create();&#125;// 在副作用链表上 删除, 用于内存回收while (effect !== null) &#123;  var nextNextEffect = effect.nextEffect;  effect.nextEffect = null;  effect = nextNextEffect;&#125;// 如果与额外的副作产生则重新发起调度flushSyncCallbackQueue();\n\n将 rootFiber 添加到 effect 链表中, completeWork 中构建的 effect 链表只包涵它的子元素, 如果 rootFiber 有副作用需要把他添加到链表的最后. 最终的 effect 链表属于 rootFiber 的父元素\nif (finishedWork.flags &gt; PerformedWork) &#123;  if (finishedWork.lastEffect !== null) &#123;    finishedWork.lastEffect.nextEffect = finishedWork;    firstEffect = finishedWork.firstEffect;  &#125; else &#123;    firstEffect = finishedWork;  &#125;&#125; else &#123;  firstEffect = finishedWork.firstEffect;&#125;\n\ncommitBeforeMutationEffects尽可能早的去调度 mutation effect\nwhile (nextEffect !== null) &#123;  var current = nextEffect.alternate;  var flags = nextEffect.flags;  // getSnapshotBeforeUpdate 将会执行  if ((flags &amp; Snapshot) !== NoFlags) &#123;    commitBeforeMutationLifeCycles(current, nextEffect);  &#125;  if ((flags &amp; Passive) !== NoFlags) &#123;    if (!rootDoesHavePassiveEffects) &#123;      rootDoesHavePassiveEffects = true;      scheduleCallback(NormalPriority$1, function () &#123;        flushPassiveEffects();        return null;      &#125;);    &#125;  &#125;  nextEffect = nextEffect.nextEffect;&#125;\n\nscheduleCallback","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ③ concurrent 模式简介","url":"/posts/25575ed0111b/","content":"React 官方提供了三种模式可以选择:\n\nlegacy 模式： ReactDOM.render(, rootNode)。这是当前 React app 使用的方式。当前没有计划删除本模式，但是这个模式可能不支持这些新功能。\nblocking 模式： ReactDOM.createBlockingRoot(rootNode).render()。目前正在实验中。作为迁移到 concurrent 模式的第一个步骤。\nconcurrent 模式： ReactDOM.createRoot(rootNode).render()。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式。这个模式开启了所有的新功能。\n\n但即使对于最新版本的 React 也没有主动提供 createRoot 这个 api,需要安装 Alpha 版本, 效果仍然相当于 legacy 模式.\n版本演化React v15 的版本中用到了 Reconciler 和 Renderer 两个部分\n\n这样存在的问题就是对节点的更新是递归同步更新的，如果节点非常多,即使只有一次 state 变更，React 也需要进行复杂的递归更新，更新一旦开始，中途就无法中断，直到遍历完整颗树，才能释放主线程。\n而 React v16 添加了前两章提到的,Scheduler, Fiber 这些都为最终实现 concurrent 模式提供了支持\n\n但是在 React v16 版本中只是对能实现 concurrent 模式的这些模块进行了尝试. 最重要的还是在 v16.8 版本中发布了全新了 Hooks Api.\n在 v17.0 版本的时候又提出了全新的 lane 模型用于处理更新的优先级. 虽然在 v17.0 版本中没有重大的更新,但是 concurrent 模式已经可以与老的模式稳定共存.\n启动过程\n传入不同的 RootTag 用于标记不同的类型.这个变量会参与到初始化流程,优先级判断的逻辑中.\n更新入口legacy 模式\nunbatchedUpdates(() =&gt; &#123;  updateContainer(children, fiberRoot, parentComponent, callback);&#125;);\n\nconcurrent 模式\nReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render =  function (children: ReactNodeList): void &#123;    const root = this._internalRoot;    // 执行更新    updateContainer(children, root, null, null);  &#125;;\n\n异同点不同的模式,传入不同的 rootTag 类型,最终都调用了 updateContainer 函数串联了 react-dom 与 react-reconciler.\nlegacy 下的更新会先调用 unbatchedUpdates, 更改执行上下文为 LegacyUnbatchedContext, 之后调用 updateContainer 进行更新.\nconcurrent 和 blocking 不会更改执行上下文, 直接调用 updateContainer 进行更新.\n另外在 React 官方文档中可以找到:\nlegacy 模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非 React 事件想使用这个功能必须使用 unstable_batchedUpdates。在 blocking 模式和 concurrent 模式下，所有的 setState 在默认情况下都是批处理的,这也意味着 concurrent 模式下所有的更新都是异步的.\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑫ Hooks 原理","url":"/posts/9d345d748b95/","content":"针对 hooks 有三种策略，或者说三种类型的 dispatch\nHooksDispatcherOnMount 将函数组件初始化的信息挂载到 Fiber 上面\nconst HooksDispatcherOnMount: Dispatcher = &#123;  readContext,  useCallback: mountCallback,  useEffect: mountEffect,  useMemo: mountMemo,  useReducer: mountReducer,  useRef: mountRef,  useState: mountState,  // ...其他 Hooks&#125;;\n\nHooksDispatcherOnUpdate 函数执行更新的时候，会执行这个对象对应的方法，此时 fiber 上已经存储了函数组件的信息，这些 Hooks 会去维护或更新这些信息。\nconst HooksDispatcherOnUpdate: Dispatcher = &#123;    readContext,    useCallback: updateCallback,    useContext: readContext,    useEffect: updateEffect,    useMemo: updateMemo,    useReducer: updateReducer,   /    useRef: updateRef,    useState: updateState,    // ...其他 Hooks&#125;;\n\nContextOnlyDispatcher 防止开发者在函数组件外部调用 Hooks\nexport const ContextOnlyDispatcher: Dispatcher = &#123;  readContext, // 允许读取 Context  useCallback: throwInvalidHookError, // 抛出非法调用错误  useContext: throwInvalidHookError,  useEffect: throwInvalidHookError,  useMemo: throwInvalidHookError,  useReducer: throwInvalidHookError,  useRef: throwInvalidHookError,  useState: throwInvalidHookError,  // ...其他 Hooks 同理&#125;;\n\nrender 执行的时候会根据不同的上下文环境，给 hooks 赋值不同的方法。\nconst hook = &#123;  memoizedState: null, //当前 Hook 的缓存状态  baseState: null, // 基础状态（用于更新对比或重置）  baseQueue: null, // 基础更新队列（待处理的优先级较低更新）  queue: null, // 当前更新队列（高优先级更新）  next: null, // 指向下一个 Hook 节点的指针&#125;;\n\n当进入一个函数组件时， 会被 renderWithHooks\nexport function renderWithHooks(  current, // 当前 Fiber 节点（null 表示首次挂载）  workInProgress, // 正在处理的 Fiber 节点（本次渲染目标）  Component, // 用户编写的函数组件  props, // 组件接收的 props  secondary, // 次要参数（通常为 ref）  nextRenderLanes // 本次渲染的优先级车道（Lane 模型）) &#123;  // 设置全局渲染相关变量  renderLanes = nextRenderLanes;  currentlyRenderingFiber = workInProgress;  // 重置 Hook 链表和副作用队列  workInProgress.memoizedState = null; // 清空 Hooks 链表  workInProgress.updateQueue = null; // 清空 Effect List  // 动态切换 Hooks 分发器  ReactCurrentDispatcher.current =    current === null || current.memoizedState === null      ? HooksDispatcherOnMount // 挂载阶段分发器      : HooksDispatcherOnUpdate; // 更新阶段分发器  // 执行用户函数组件，触发 Hooks 调用  let children = Component(props, secondary);  // 渲染后清理工作  finishRenderingHooks(current, workInProgress);  return children;&#125;function finishRenderingHooks(current, workInProgress) &#123;  // 强制切换为错误分发器，防止外部调用 Hooks  ReactCurrentDispatcher.current = ContextOnlyDispatcher;  // ...其他清理逻辑&#125;\n\n执行 mountState 相关代码,会清空 WorkInProgress 的 memorizedState 以及 updateQueue, 接下来时派那段组件究竟时初始化还是更新，为 ReactCurrentDispatcher.current 赋予不同的上下文\nfunction mountState(initialState) &#123;  // 1. 创建 hook 对象  const hook = mountWorkInProgressHook(); // 初始化 hook 对象，关联当前正在渲染的组件  // 2. 判断 initialState 是否是一个函数，如果是则调用它并获得初始状态  if (typeof initialState === &quot;function&quot;) &#123;    initialState = initialState(); // 如果 initialState 是函数，调用该函数获取状态值  &#125;  // 2. 初始化 hook 的属性  // 2.1 设置 hook.memoizedState / hook.baseState  hook.memoizedState = hook.baseState = initialState;  // 定义 queue（队列），用于管理状态更新  const queue = &#123;    pending: null, // 队列中待处理的更新    lanes: NoLanes, // 当前更新所属的 lane，通常表示优先级    dispatch: null, // 状态更新函数    lastRenderedReducer: basicStateReducer, // 上一次渲染的状态更新函数    lastRenderedState: initialState, // 上一次渲染的状态  &#125;;  // 2.2 设置 hook.queue  hook.queue = queue; // 将队列分配给 hook 的 queue 属性  // 2.3 设置 hook.dispatch  // 将 dispatchSetState 绑定到当前组件的上下文中，并传入队列  const dispatch = (queue.dispatch = dispatchSetState.bind(    null,    currentlyRenderingFiber,    queue  ));  // 3. 返回当前状态和 dispatch 函数  return [hook.memoizedState, dispatch]; // 返回当前状态和状态更新函数&#125;function mountWorkInProgressHook() &#123;  const hook = &#123;    memoizedState: null, // Hook 自身维护的状态    baseState: null,    baseQueue: null,    queue: null, // Hook 自身维护的更新队列    next: null, // 指向下一个 Hook  &#125;;  // 如果当前组件的 Hook 链表为空，说明这是第一个 Hook  if (workInProgressHook === null) &#123;    // 这是链表的第一个节点（头结点）    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;  &#125; else &#123;    // 如果当前组件的 Hook 链表不为空，将新创建的 Hook 添加到链表的末尾（作为尾结点）    workInProgressHook = workInProgressHook.next = hook;  &#125;  return workInProgressHook;&#125;\n\n组件执行之后就会生成一个 hooks 链表，在更新过程中会移动指针依次指向每一个节点.\n这也是为什么不可以将 useHooks 放在条件中，因为他需要按照链表的顺序依次被引用。\nfunction updateWorkInProgressHook() &#123;  let nextCurrentHook;  // 获取当前 Fiber 的 alternate（用于双缓冲）  const current = currentlyRenderingFiber.alternate;  if (current !== null) &#123;    // 如果当前有 alternate（即已经存在旧的 Fiber）    nextCurrentHook = current.memoizedState;  &#125; else &#123;    nextCurrentHook = null;  &#125;  // 获取下一个 Hook  nextCurrentHook = currentHook.next;  // 更新 workInProgressHook 的指向  let nextWorkInProgressHook;  if (workInProgressHook === null) &#123;    // 当是第一个 Hook，直接从当前 Fiber 上获取第一个 hook    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;  &#125; else &#123;    // 获取链表的下一个 hook    nextWorkInProgressHook = workInProgressHook.next;  &#125;  // nextWorkInProgressHook 指向当前正在工作的 hook  if (nextWorkInProgressHook !== null) &#123;    // 如果已经有工作中的 hook，重用它    workInProgressHook = nextWorkInProgressHook;    nextWorkInProgressHook = workInProgressHook.next;    // 当前 hook 指向下一个 hook    currentHook = nextCurrentHook;  &#125; else &#123;    // 克隆当前 hook    if (nextCurrentHook === null) &#123;      const currentFiber = currentlyRenderingFiber.alternate;      if (currentFiber === null) &#123;        // 这是初始渲染，组件挂起、恢复时将渲染一个附加的 hook        const newHook = &#123;          memoizedState: null,          baseState: null,          baseQueue: null,          queue: null,          next: null,        &#125;;        nextCurrentHook = newHook; // 设置为当前 hook      &#125; else &#123;        // 如果是更新渲染，应该有一个有效的当前 hook        throw new Error(&quot;Rendered more hooks than during the previous render.&quot;);      &#125;    &#125;  &#125;  const newHook = &#123;    memoizedState: currentHook.memoizedState, // 当前 Hook 的状态值    baseState: currentHook.baseState, // 当前 Hook 的基础状态    baseQueue: currentHook.baseQueue, // 当前 Hook 的基础更新队列    queue: currentHook.queue, // 当前 Hook 的更新队列    next: null, // 指向下一个 Hook  &#125;;  // 如果 workInProgressHook 为 null，说明这是第一个 Hook  if (workInProgressHook === null) &#123;    // 设置当前渲染组件的 memoizedState 为新的 Hook    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;  &#125; else &#123;    // 否则，将新的 Hook 添加到链表的末尾    workInProgressHook = workInProgressHook.next = newHook;  &#125;  return workInProgressHook;&#125;\n\nuseEffect &#x2F; useLayoutEffect\nuseEffect：回调函数会在 commit 阶段完成后异步执行，所以它不会阻塞视觉渲染\n\nuseLayoutEffect：回调函数会在 commit 阶段的 Layout 子阶段同步执行，一般用于执行 DOM 相关的操作\n\nuseInsertionEffect：回调函数会在 commit 阶段的 Mutation 子阶段同步执行，与 useLayoutEffect 的区别在于执行时无法访问对 DOM 的引用。这个 Hook 是专门为 CSS-in-JS 库插入全局的 style 元素设计的。\n\n\n在内部共同使用一套数据结构, next 与当前的函数作用域内的其他 effect 函数，形成环状链表。\nconst effect = &#123;  // 用于区分 effect 类型 Passive | Layout | Insertion  tag, // effect 回调函数  create, // effect 创建函数  destroy, // 销毁函数  deps, // 依赖项  // 与当前 FC 的其他 effect 形成环状链表  next: null,&#125;;\n\n\n声明阶段\nmount子阶段 执行 mountEffectImpl, 生成 hook 对象拿到依赖，将当前的 effect 加入到环状链表\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) &#123;  // 生成 hook 对象  const hook = mountWorkInProgressHook();  // 保存依赖的数组  const nextDeps = deps === undefined ? null : deps;  // 修改当前 fiber 的 flag  currentlyRenderingFiber.flags |= fiberFlags;  // 将 pushEffect 返回的环形链表保存到 hook 对象的 memoizedState 中  hook.memoizedState = pushEffect(    HookHasEffect,    hookFlags,    create,    undefined,    nextDeps  );&#125;\n\nupdate子阶段执行 updateEffectImpl, 获取 hook 新旧值，进行依赖比较，打上响应的 tag,在 commit 阶段统一处理\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) &#123;  const hook = updateWorkInProgressHook();  const nextDeps = deps === undefined ? null : deps;  let destroy = undefined;  if (currentHook !== null) &#123;    const prevEffect = currentHook.memorizedState;    destroy = prevEffect.destroy;  &#125;  if (nextDeps !== null) &#123;    const prevDeps = prevEffect.deps;    // 浅比较依赖是否发生变化    if (areHookInputsEqual(nextDeps, prevDeps)) &#123;      hook.memorizedState = pushEffect(hookFlags, create, destroy, nextDeps);      return;    &#125;  &#125;  if (deps !== prevEffect.deps) &#123;    fiberFlags |= hookFlags;  &#125;  currentlyRenderingFiber.flags |= fiberFlags;  // pushEffect 的作用是将当前 effect 添加到 FiberNode 的 updateQueue 中，  // 然后返回当前 effect 保存在 Hook 节点的 memorizedState 属性中  hook.memorizedState = pushEffect(    HookHasEffect | hookFlags,    create,    destroy,    nextDeps  );&#125;\n\n调度阶段， useEffect 独有的，因为 useEffect 函数会在 commit 之后异步执行,\nif (  (finishedWork.subtreeFlags &amp; PassiveMask) !== NoFlags ||  (finishedWork.flags &amp; PassiveMask) !== NoFlags) &#123;  if (!rootDoesHavePassiveEffects) &#123;    rootDoesHavePassiveEffects = true;    pendingPassiveEffectsRemainingLanes = remainingLanes;    // scheduleCallback 来自于 Scheduler，用于以某一优先级调度回调函数    scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;      // 执行 effect 回调函数的具体方法      flushPassiveEffects();      return null;    &#125;);  &#125;&#125;\n\n为了保证下一次 commit 执行前，上一次的 commit 调用的 effect 已经全部执行，因此会在 commit 入口处也会执行 flushPassiveEffects\nfunction commitRootImpl(root, renderPriorityLevel) &#123;  do &#123;    flushPassiveEffects();  &#125; while (rootWithPendingPassiveEffects !== null);&#125;\n\n执行阶段\ncommitHookEffectListUnmount 遍历 Effect 链表依次执行 effect.destroy\nfunction commitHookEffectListUnmont(  flags: HookFlags,  finishedWork: Fiber,  nearestMountedAncestor: Fiber | null) &#123;  const updateQueue: FunctionComponentUpdateQueue | null =    finishedWork.updateQueue ? finishedWork.updateQueue : null;  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;  if (lastEffect !== null) &#123;    const firstEffect = lastEffect.next;    let effect = firstEffect;    do &#123;      if ((effect.tag &amp; flags) === flags) &#123;        // Unmount        // 从 effect 对象上拿到 destroy 函数        const destroy = effect.destroy;        effect.destroy = undefined;        // ...      &#125;      effect = effect.next;    &#125; while (effect !== firstEffect);  &#125;&#125;\n\ncommitHookEffectListMount 遍历 Effect 链表依次执行 effect.create,在声明阶段的时候已经打上了不同的 tag,这时会根据 tag 来执行\n// 类型为 useInsertionEffect 并且存在 HasEffect tag 的 effect 会执行回调commitHookEffectListMount(Insertion | HasEffect, fiber);// 类型为 useEffect 并且存在 HasEffect tag 的 effect 会执行回调commitHookEffectListMount(Passive | HasEffect, fiber);// 类型为 useLayoutEffect 并且存在 HasEffect tag 的 effect 会执行回调commitHookEffectListMount(Layout | HasEffect, fiber);\n\nuseCallback &#x2F; useMemo与其他的 hooks 类似，mount 阶段创建 hooks 对象，更行阶段对比依赖，计算结果\nfunction mountCallback(callback, deps) &#123;  // 首先还是创建一个 hook 对象  const hook = mountWorkInProgressHook();  // 依赖项  const nextDeps = deps === undefined ? null : deps;  // 把要缓存的函数和依赖数组存到 hook 对象上  hook.memoizedState = [callback, nextDeps];  // 向外部返回缓存函数  return callback;&#125;\n\nfunction updateCallback(callback, deps) &#123;  // 获取之前的 hook 对象  const hook = updateWorkInProgressHook();  // 新的依赖项  const nextDeps = deps === undefined ? null : deps;  // 之前的值，也就是 [callback, nextDeps]  const prevState = hook.memorizedState;  if (prevState !== null) &#123;    if (nextDeps !== null) &#123;      const prevDeps = prevState[1]; // 获取到之前的依赖项      // 对比依赖项是否相同      if (areHookInputsEqual(nextDeps, prevDeps)) &#123;        // 相同回 callback        return prevState[0];      &#125;    &#125;  &#125;  // 否则重新缓存  hook.memorizedState = [callback, nextDeps];  return callback;&#125;\n\nuseReffunction mountRef(initialValue) &#123;  // 创建 hook 对象  const hook = mountWorkInProgressHook();  const ref = &#123; current: initialValue &#125;;  // hook对象的 memorizedState 值 &#123; current: initialValue &#125;  hook.memorizedState = ref;  return ref;&#125;function updateRef(initialValue) &#123;  // 获取当前的 hook 对象  const hook = updateWorkInProgressHook();  return hook.memorizedState;&#125;\n\nref 创建之后会作为组件属性传递，在 react 的 render 阶段会标记 ref。\nfunction markRef(current, workInProgress) &#123;  const ref = workInProgress.ref;  if (    (current === null &amp;&amp; ref !== null) ||    (current !== null &amp;&amp; current.ref !== ref)  ) &#123;    // 标记 Reg tag    workInProgress.flags |= Ref;  &#125;&#125;\n\ncommit 的 mutation 子阶段删除旧的 ref\nfunction commitLayoutEffectOnFiber(  finishedRoot,  current,  finishedWork,  committedLanes) &#123;  // 省略代码  if (finishedWork.flags &amp; Ref) &#123;    commitAttachRef(finishedWork);  &#125;&#125;\n\ncommit 的 layout 子阶段会重新赋值新的 ref\nfunction commitAttachRef(finishedWork) &#123;  const ref = finishedWork.ref;  if (ref !== null) &#123;    const instance = finishedWork.stateNode;    let instanceToUse;    switch (finishedWork.tag) &#123;      case HostComponent:        // HostComponent 需要获取对应的 DOM 元素        instanceToUse = getPublicInstance(instance);        break;      default:        // ClassComponent 使用 FiberNode.stateNode 保存实例        instanceToUse = instance;    &#125;    if (typeof ref === &quot;function&quot;) &#123;      // 函数类型，执行函数并将实例传入      let retVal;      retVal = ref(instanceToUse);    &#125; else &#123;      // &#123; current: T &#125; 类型则更新 current 指向      ref.current = instanceToUse;    &#125;  &#125;&#125;\n\n通过 forwardRef 和 useImperativeHandle 操作元素, 尽量避手动绑定 ref，避免 ref 被修改。\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ④ render阶段执行流程","url":"/posts/00f2b5b49e55/","content":"\nrender传入 JSXElement 对象和挂载节点.\n何验证根节点是否合法,挂载节点为真,且必须是以下节点之一\nfunction isValidContainer(node) &#123;  return !!(    node &amp;&amp;    (node.nodeType === ELEMENT_NODE ||      node.nodeType === DOCUMENT_NODE ||      node.nodeType === DOCUMENT_FRAGMENT_NODE ||      (node.nodeType === COMMENT_NODE &amp;&amp;        node.nodeValue === &quot; react-mount-point-unstable &quot;))  );&#125;\n\n挂载节点必须是首次挂载,已经挂载过的节点不能再次执行 React.render(element,container),首次挂载之后会给元素打上一个标记 __reactContainer$xxx 是一个自定义字符串后面是随机数, 用这个标记来判断元素是否挂载过\n而且 internalContainerInstanceKey = FiberRoot 会被赋值为 FiberRoot\nlegacyRenderSubtreeIntoContainer(null, element, container, false, callback)首先尝试清空挂载节点中的内容,如果挂载节点中有其他的节点已经通过 render 渲染过,会提示错误\nwhile ((rootSibling = container.lastChild)) &#123;  container.removeChild(rootSibling);&#125;\n\n这里创建出 FiberFoot和RootFiber两个节点, 并且通过指针相互引用\n\ncontainer._reactRootContainer = new ReactDOMBlockingRoot() 挂载元素上会打上一个标记, 赋值为 RootFiber 构造函数的实例,而 render 方法 _reactRootContainer 中与__reactContainer$xxx 共同判断节点是否挂载过\n对于已经渲染过的节点会通过 _reactRootContainer 直接复用 FiberRoot, 并执行 updateContainer 批量更新, 如果是首次渲染则执行 unbatchedUpdates非批量更新,立即调用 updateContainer,同步执行尽快展示元素.\nupdateContainer(element, container, parentComponent, callback)在首次执行前会标记上下文环境,因为也可能是程序运行之后,人为调用非批量更新,所以这个方法可能重复执行\n// 保存之前的上下文var prevExecutionContext = executionContext;// 删除掉批量更新的标记executionContext &amp;= ~BatchedContext;// 添加非批量更新的标记executionContext |= LegacyUnbatchedContext;\n\n下面这里定义了几个比较关键的变量\nrequestUpdateLane 传入了 FiberRoot, 计算出更新优先级为 1 (SyncLane)\n// 计算一个时间戳var eventTime = requestEventTime();// 计算更新优先级var lane = requestUpdateLane(container.current);// 创建更新对象并添加到更新队列中var update = &#123;  eventTime: eventTime,  lane: lane,  tag: UpdateState,  // element 是 render 方法中传入的 JSXElement 对象  payload: &#123;element:element&#125;,  callback: null,  next: null&#125;;// updateQueue 是一个对象var updateQueue = &#123;  baseState:null  effects:null  firstBaseUpdate:null  lastBaseUpdate:null  shared:&#123;pending: null&#125;&#125;// 如果这是第一个更新,会被处理成循环链表if (updateQueue.pending === null) &#123;  update.next = update;&#125; else &#123;// 如果有了正在等待的更新,则链接到循环链表中  update.next = pending.next;  pending.next = update;&#125;updateQueue.share.pending = update;\n\nscheduleUpdateOnFiber(fiber, lane, eventTime)checkForNestedUpdates() 检查是否嵌套的更新过多\n拿到上 RootFiber 计算出的更新优先级, 与 fiber 上的优先级合并,如果当前节点不是根节点会一直递归到根节点. 首次执行时 fiber &#x3D; FiberRoot\nvar root = markUpdateLaneFromFiberToRoot(fiber, lane);\n\n在 FiberRoot 上更新 pendingLanes\nfunction markRootUpdated(root, updateLane, eventTime) &#123;  root.pendingLanes |= updateLane;  var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111  // 处于当前优先级左边的会通过&amp;被删除掉  // 其实就是删除了较低的优先级  root.suspendedLanes &amp;= higherPriorityLanes;  root.pingedLanes &amp;= higherPriorityLanes;  var eventTimes = root.eventTimes;  var index = laneToIndex(updateLane);  eventTimes[index] = eventTime;&#125;\n\n获取当前的执行优先级 var priorityLevel = getCurrentPriorityLevel() 这个优先级与 lane 是有区别的\n检查上下文环境,准备分析构建 Fiber 树\n// 如果传出的优先级是同步的if (lane === SyncLane) &#123;  if (    // 检查是非批量更新的状态    (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp;    // 检查还没有开始渲染    (executionContext &amp; (RenderContext | CommitContext)) === NoContext  ) &#123;    // Register pending interactions on the root to avoid losing traced interaction data.    schedulePendingInteractions(root, lane);    // This is a legacy edge case. The initial mount of a ReactDOM.render-ed    // root inside of batchedUpdates should be synchronous, but layout updates    // should be deferred until the end of the batch.    performSyncWorkOnRoot(root);  &#125; else &#123;    ensureRootIsScheduled(root, eventTime);    schedulePendingInteractions(root, lane);    if (executionContext === NoContext) &#123;      // Flush the synchronous work now, unless we&#x27;re already working or inside      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of      // scheduleCallbackForFiber to preserve the ability to schedule a callback      // without immediately flushing it. We only do this for user-initiated      // updates, to preserve historical behavior of legacy mode.      resetRenderTimer();      flushSyncCallbackQueue();    &#125;  &#125;&#125; else &#123;  // Schedule a discrete update but only if it&#x27;s not Sync.  if (    (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; // Only updates at user-blocking priority or greater are considered    // discrete, even inside a discrete event.    (priorityLevel === UserBlockingPriority$2 ||      priorityLevel === ImmediatePriority$1)  ) &#123;    // This is the result of a discrete event. Track the lowest priority    // discrete update per root so we can flush them early, if needed.    if (rootsWithPendingDiscreteUpdates === null) &#123;      rootsWithPendingDiscreteUpdates = new Set([root]);    &#125; else &#123;      rootsWithPendingDiscreteUpdates.add(root);    &#125;  &#125; // Schedule other updates after in case the callback is sync.  ensureRootIsScheduled(root, eventTime);  schedulePendingInteractions(root, lane);&#125;\n\nperformSyncWorkOnRoot(fiberRoot)执行 renderRootSync(root, lanes)\n执行结束后,赋值 finishWork 为最新的 Fiber 树,并进入提交节点,渲染元素\nvar finishedWork = root.current.alternate;root.finishedWork = finishedWork;root.finishedLanes = lanes;commitRoot(root);\n\nrenderRootSync(root, lanes)这个方法可以算是构建 Fiber 树的起点\nfunction renderRootSync(root, lanes) &#123;  // 缓存执行环境  var prevExecutionContext = executionContext;  // 执行环境标记为渲染环境  executionContext |= RenderContext;  // 调用 createWorkInProgress 创建新的 RootFiber 作为 WorkInProgress  prepareFreshStack(root, lanes);  do &#123;    try &#123;      workLoopSync();      break;    &#125; catch (thrownValue) &#123;      handleError(root, thrownValue);    &#125;  &#125; while (true);  workInProgressRoot = null;  workInProgressRootRenderLanes = NoLanes;  return workInProgressRootExitStatus;&#125;\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑩ 事件系统","url":"/posts/fe1542994b88/","content":"合成事件先看一个案例\nexport default class App extends React.Component &#123;  state = &#123;    show: false,  &#125;;  ref = React.createRef();  componentDidMount() &#123;    const that = this;    document.addEventListener(&quot;click&quot;, () =&gt; &#123;      that.setState(&#123; show: false &#125;);      console.log(&quot;document&quot;);    &#125;);    this.ref.current.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;ref&quot;);    &#125;);  &#125;  render() &#123;    return (      &lt;div        ref=&#123;this.ref&#125;        onClick=&#123;() =&gt; this.setState(&#123; show: true &#125;, console.log(&quot;dom&quot;))&#125;      &gt;        点击 &#123;this.state.show ? &quot;show&quot; : &quot;null&quot;&#125;      &lt;/div&gt;    );  &#125;&#125;\n\n当点击事件触发的时候会发现点击事件无效, 先打印出 ref,再打印 dom,后打印出 document,先分析一个打印顺序的问题\n如果事件是绑定在原生上的,那么 render 的执行会早于 componentDidMount,所以按理来说打印 dom 的事件应该先执行,在执行打印 ref 的事件,但显然结果不是这样.\n其实这就是 React 合成事件(SyntheticEvent),在项目初始化的时候, 在 react v16 版本会把所有的事件绑定在 document 元素上, v17 版本把元素修改为 root 元素,用官方的话讲就是:不需要使用 addEventListener 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。\n因为这个原因,在冒泡阶段最先执行的是 div 的原生事件,又因为 div 上的合成事件虽然绑定在 document 上,但绑定时机在项目初始化的时候, 而 document 上原生的绑定事件是在 componentDidMount 生命周期中,所以按照原生事件的行为,先绑定的先执行,会先打印 dom 后打印 document,看一个复杂的例子:\nimport React from &quot;react&quot;;export default class App extends React.Component &#123;  parentRef = React.createRef();  childRef = React.createRef();  componentDidMount() &#123;    this.parentRef.current.addEventListener(      &quot;click&quot;,      () =&gt; &#123;        console.log(&quot;父元素原生事件捕获&quot;);      &#125;,      true    );    this.parentRef.current.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;父元素原生事件冒泡&quot;);    &#125;);    this.childRef.current.addEventListener(      &quot;click&quot;,      () =&gt; &#123;        console.log(&quot;子元素原生事件捕获&quot;);      &#125;,      true    );    this.childRef.current.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;子元素原生事件冒泡&quot;);    &#125;);    document.addEventListener(      &quot;click&quot;,      () =&gt; &#123;        console.log(&quot;document 捕获&quot;);      &#125;,      true    );    document.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;document 冒泡&quot;);    &#125;);  &#125;  parentBubble = () =&gt; &#123;    console.log(&quot;父组件React事件冒泡&quot;);  &#125;;  parenteCapture = () =&gt; &#123;    console.log(&quot;父组件React事件捕获&quot;);  &#125;;  childBubble = () =&gt; &#123;    console.log(&quot;子组件React事件冒泡&quot;);  &#125;;  childeCapture = () =&gt; &#123;    console.log(&quot;子组件React事件捕获&quot;);  &#125;;  render() &#123;    return (      &lt;div        ref=&#123;this.parentRef&#125;        onClick=&#123;this.parentBubble&#125;        onClickCapture=&#123;this.parenteCapture&#125;      &gt;        &lt;p          ref=&#123;this.childRef&#125;          onClick=&#123;this.childBubble&#125;          onClickCapture=&#123;this.childeCapture&#125;        &gt;          事件        &lt;/p&gt;      &lt;/div&gt;    );  &#125;&#125;\n\nv16 版本\ndocument 捕获父元素原生事件捕获子元素原生事件捕获子元素原生事件冒泡父元素原生事件冒泡父组件React事件捕获子组件React事件捕获子组件React事件冒泡父组件React事件冒泡document 冒泡\n\n虽然合成事件绑定在 document 元素上但只能在冒泡阶段触发, 因为合成事件绑定在冒包阶段而不是捕获阶段, 因此会先执行所有原生事件的捕获阶段, 捕获阶段结束之后由于合成事件在 document 仍然不会执行, 紧接着执行原生的冒泡事件.直到冒泡到 document 元素由于合成事件绑定的早,所有一次性的执行了合成事件的捕获和冒泡阶段,最后才是 document 冒泡事件\nv17 版本\ndocument 捕获父组件React事件捕获子组件React事件捕获父元素原生事件捕获子元素原生事件捕获子元素原生事件冒泡父元素原生事件冒泡子组件React事件冒泡父组件React事件冒泡document 冒泡\n\n由于在 v17 版本中事件是绑定在 root 上的,所以在捕获阶段可以执行合成事件的 冒泡阶段.\n简单实现&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;div id=&quot;parent&quot;&gt;      &lt;p id=&quot;child&quot;&gt;事件&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script&gt;  let root = document.getElementById(&quot;root&quot;);  let parent = document.getElementById(&quot;parent&quot;);  let child = document.getElementById(&quot;child&quot;);  parent.addEventListener(    &quot;click&quot;,    () =&gt; &#123;      console.log(&quot;父元素原生事件捕获&quot;);    &#125;,    true  );  parent.addEventListener(&quot;click&quot;, () =&gt; &#123;    console.log(&quot;父元素原生事件冒泡&quot;);  &#125;);  child.addEventListener(    &quot;click&quot;,    () =&gt; &#123;      console.log(&quot;子元素原生事件捕获&quot;);    &#125;,    true  );  child.addEventListener(&quot;click&quot;, () =&gt; &#123;    console.log(&quot;子元素原生事件冒泡&quot;);  &#125;);  document.addEventListener(    &quot;click&quot;,    function () &#123;      console.log(&quot;document 捕获&quot;);    &#125;,    true  );  document.addEventListener(&quot;click&quot;, function () &#123;    console.log(&quot;document 冒泡&quot;);  &#125;);  parent.onClick = function () &#123;    console.log(&quot;父组件React事件冒泡&quot;);  &#125;;  parent.onClickCapture = () =&gt; &#123;    console.log(&quot;父组件React事件捕获&quot;);  &#125;;  child.onClick = function () &#123;    console.log(&quot;子组件React事件冒泡&quot;);  &#125;;  child.onClickCapture = () =&gt; &#123;    console.log(&quot;子组件React事件捕获&quot;);  &#125;;&lt;/script&gt;\n\nv16 版本\ndocument.addEventListener(&quot;click&quot;, dispatchEvent);function dispatchEvent(event) &#123;  let paths = [];  let current = event.target;  while (current) &#123;    paths.push(current);    current = current.parentNode;  &#125;  for (let i = paths.length - 1; i &gt;= 0; i--) &#123;    let handle = paths[i].onClickCapture;    handle &amp;&amp; handle();  &#125;  for (let i = 0; i &lt; paths.length; i++) &#123;    let handle = paths[i].onClick;    handle &amp;&amp; handle();  &#125;&#125;\n\nv17 版本\nfunction dispatchEvent(event, useCapture) &#123;  let paths = [];  let current = event.target;  while (current) &#123;    paths.push(current);    current = current.parentNode;  &#125;  if (useCapture) &#123;    for (let i = paths.length - 1; i &gt;= 0; i--) &#123;      let handle = paths[i].onClickCapture;      handle &amp;&amp; handle();    &#125;  &#125; else &#123;    for (let i = 0; i &lt; paths.length; i++) &#123;      let handle = paths[i].onClick;      handle &amp;&amp; handle();    &#125;  &#125;&#125;root.addEventListener(&quot;click&quot;, (e) =&gt; dispatchEvent(e, true), true);root.addEventListener(&quot;click&quot;, (e) =&gt; dispatchEvent(e, false));\n\n事件注册\n这一过程是在全局执行的\nSimpleEventPlugin.registerEvents();EnterLeaveEventPlugin.registerEvents();ChangeEventPlugin.registerEvents();SelectEventPlugin.registerEvents();BeforeInputEventPlugin.registerEvents();\n\n先把所有的事件分为以下 5 种类型\n\nsimpleEvents\nfor (var i = 0; i &lt; simpleEventPluginEvents.length; i++) &#123;  var eventName = simpleEventPluginEvents[i];  var domEventName = eventName.toLowerCase();  var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);  // 把事件转换成 onEvent 的格式  registerSimpleEvent(domEventName, &quot;on&quot; + capitalizedEvent);&#125;registerSimpleEvent(ANIMATION_END, &quot;onAnimationEnd&quot;);registerSimpleEvent(ANIMATION_ITERATION, &quot;onAnimationIteration&quot;);registerSimpleEvent(ANIMATION_START, &quot;onAnimationStart&quot;);registerSimpleEvent(&quot;dblclick&quot;, &quot;onDoubleClick&quot;);registerSimpleEvent(&quot;focusin&quot;, &quot;onFocus&quot;);registerSimpleEvent(&quot;focusout&quot;, &quot;onBlur&quot;);registerSimpleEvent(TRANSITION_END, &quot;onTransitionEnd&quot;);\n\nenterLeaveEvents\nregisterDirectEvent(&quot;onMouseEnter&quot;, [&quot;mouseout&quot;, &quot;mouseover&quot;]);registerDirectEvent(&quot;onMouseLeave&quot;, [&quot;mouseout&quot;, &quot;mouseover&quot;]);registerDirectEvent(&quot;onPointerEnter&quot;, [&quot;pointerout&quot;, &quot;pointerover&quot;]);registerDirectEvent(&quot;onPointerLeave&quot;, [&quot;pointerout&quot;, &quot;pointerover&quot;]);\nchangeEvents\nregisterTwoPhaseEvent(&quot;onChange&quot;, [  &quot;change&quot;,  &quot;click&quot;,  &quot;focusin&quot;,  &quot;focusout&quot;,  &quot;input&quot;,  &quot;keydown&quot;,  &quot;keyup&quot;,  &quot;selectionchange&quot;,]);\n\nselectEvent\nregisterTwoPhaseEvent(&quot;onSelect&quot;, [  &quot;focusout&quot;,  &quot;contextmenu&quot;,  &quot;dragend&quot;,  &quot;focusin&quot;,  &quot;keydown&quot;,  &quot;keyup&quot;,  &quot;mousedown&quot;,  &quot;mouseup&quot;,  &quot;selectionchange&quot;,]);\n\nbeforeInputEvents\nfunction registerEvents() &#123;  registerTwoPhaseEvent(&quot;onBeforeInput&quot;, [    &quot;compositionend&quot;,    &quot;keypress&quot;,    &quot;textInput&quot;,    &quot;paste&quot;,  ]);  registerTwoPhaseEvent(&quot;onCompositionEnd&quot;, [    &quot;compositionend&quot;,    &quot;focusout&quot;,    &quot;keydown&quot;,    &quot;keypress&quot;,    &quot;keyup&quot;,    &quot;mousedown&quot;,  ]);  registerTwoPhaseEvent(&quot;onCompositionStart&quot;, [    &quot;compositionstart&quot;,    &quot;focusout&quot;,    &quot;keydown&quot;,    &quot;keypress&quot;,    &quot;keyup&quot;,    &quot;mousedown&quot;,  ]);  registerTwoPhaseEvent(&quot;onCompositionUpdate&quot;, [    &quot;compositionupdate&quot;,    &quot;focusout&quot;,    &quot;keydown&quot;,    &quot;keypress&quot;,    &quot;keyup&quot;,    &quot;mousedown&quot;,  ]);&#125;\n\nregisterSimpleEvent 是为了保存原生事件和合成事件名称之间的对应关系,并且调用 registerTwoPhaseEvent\nvar topLevelEventsToReactNames = new Map();//                              click       onClickfunction registerSimpleEvent(domEventName, reactName) &#123;  topLevelEventsToReactNames.set(domEventName, reactName);  registerTwoPhaseEvent(reactName, [domEventName]);&#125;\n\nregisterTwoPhaseEvent 会调用 registerDirectEvent 用于绑定合成事件名称和其对应的真正事件,一个合成事件对应多个原生事件,也就是 JSX 中绑定的事件,可能会触发多个原生事件\nfunction registerTwoPhaseEvent(registrationName, dependencies) &#123;  registerDirectEvent(registrationName, dependencies);  registerDirectEvent(registrationName + &quot;Capture&quot;, dependencies);&#125;function registerDirectEvent(registrationName, dependencies) &#123;  // 合成事件和原生事件的对应关系 &#123;onAbort:[&#x27;abort&#x27;]&#125;  registrationNameDependencies[registrationName] = dependencies;  &#123;    var lowerCasedName = registrationName.toLowerCase();    // 内部用于验证事件的对象,保存的是驼峰命名和非驼峰命名之间的关系  &#123;onclick:onClick&#125;    possibleRegistrationNames[lowerCasedName] = registrationName;    if (registrationName === &quot;onDoubleClick&quot;) &#123;      possibleRegistrationNames.ondblclick = registrationName;    &#125;  &#125;  //所有原生事件名称的 set 集合 set([click,cancel])  for (var i = 0; i &lt; dependencies.length; i++) &#123;    allNativeEvents.add(dependencies[i]);  &#125;&#125;\n\n注册过程就是通过几个全局变量完整的保存了,原生事件名称(click),原生事件绑定名称(onClick),合成事件名称 中的对应关系\n事件绑定\n绑定事件发生在 render 或 createRoot 方法中, 在创建了 root 节点之后会调用 listenToAllSupportedEvents, 会对所有的原生事件调用绑定函数\nfunction listenToAllSupportedEvents(rootContainerElement) &#123;  allNativeEvents.forEach(function (domEventName) &#123;    // 特殊处理,这个方法只会在 document 上    if (domEventName !== &quot;selectionchange&quot;) &#123;      // 排除那些没有冒泡阶段的事件      if (!nonDelegatedEvents.has(domEventName)) &#123;        listenToNativeEvent(domEventName, false, rootContainerElement);      &#125;      listenToNativeEvent(domEventName, true, rootContainerElement);    &#125;  &#125;);  ownerDocument[listeningMarker] = true;  listenToNativeEvent(&quot;selectionchange&quot;, false, ownerDocument);&#125;function listenToNativeEvent(domEventName, isCapturePhaseListener, target) &#123;  var eventSystemFlags = 0;  // 添加捕获阶段的标识  if (isCapturePhaseListener) &#123;    eventSystemFlags |= IS_CAPTURE_PHASE;  &#125;  addTrappedEventListener(    target,    domEventName,    eventSystemFlags,    isCapturePhaseListener  );&#125;function addTrappedEventListener(  targetContainer,  domEventName,  eventSystemFlags,  isCapturePhaseListener,  isDeferredListenerForLegacyFBSupport) &#123;  // 创建事件回调函数  var listener = createEventListenerWrapperWithPriority(    targetContainer,    domEventName,    eventSystemFlags  );  var isPassiveListener = undefined;  // 是否支持 passive 参数  // addEventListener 第三个参数可以写为一个对象 &#123; capture: false, once: true,passive:true &#125;  // capture 表示冒泡阶段执行还是捕获阶段执行  // once 标识绑定事件只会执行一次就被移除  // passive 是否执行默认事件,有些默认事件和浏览器行为绑定比如移动端 touchstart 会触发浏览器滚动  // 如果使用 event.preventDefault() 会调用函数后才会停止默认行为, 可以使用 passive:false 直接阻止默认行为  if (passiveBrowserEventsSupported) &#123;    if (      domEventName === &quot;touchstart&quot; ||      domEventName === &quot;touchmove&quot; ||      domEventName === &quot;wheel&quot;    ) &#123;      isPassiveListener = true;    &#125;  &#125;  targetContainer = targetContainer;  var unsubscribeListener;  // 利用 addEventListener 绑定事件监听函数  if (isCapturePhaseListener) &#123;    if (isPassiveListener !== undefined) &#123;      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(        targetContainer,        domEventName,        listener,        isPassiveListener      );    &#125; else &#123;      unsubscribeListener = addEventCaptureListener(        targetContainer,        domEventName,        listener      );    &#125;  &#125; else &#123;    if (isPassiveListener !== undefined) &#123;      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(        targetContainer,        domEventName,        listener,        isPassiveListener      );    &#125; else &#123;      unsubscribeListener = addEventBubbleListener(        targetContainer,        domEventName,        listener      );    &#125;  &#125;&#125;\n\ncreateEventListenerWrapperWithPriority 会调用 getEventPriority 按事件名称为事件定义不同的优先级,不同的优先级对应不同的事件处理函数\nfunction getEventPriority(domEventName) &#123;  switch (domEventName) &#123;    // Used by SimpleEventPlugin:    case &quot;cancel&quot;:    case &quot;click&quot;:    case &quot;close&quot;:    case &quot;contextmenu&quot;:    case &quot;copy&quot;:    case &quot;cut&quot;:    case &quot;auxclick&quot;:    case &quot;dblclick&quot;:    case &quot;dragend&quot;:    case &quot;dragstart&quot;:    case &quot;drop&quot;:    case &quot;focusin&quot;:    case &quot;focusout&quot;:    case &quot;input&quot;:    case &quot;invalid&quot;:    case &quot;keydown&quot;:    case &quot;keypress&quot;:    case &quot;keyup&quot;:    case &quot;mousedown&quot;:    case &quot;mouseup&quot;:    case &quot;paste&quot;:    case &quot;pause&quot;:    case &quot;play&quot;:    case &quot;pointercancel&quot;:    case &quot;pointerdown&quot;:    case &quot;pointerup&quot;:    case &quot;ratechange&quot;:    case &quot;reset&quot;:    case &quot;resize&quot;:    case &quot;seeked&quot;:    case &quot;submit&quot;:    case &quot;touchcancel&quot;:    case &quot;touchend&quot;:    case &quot;touchstart&quot;:    case &quot;volumechange&quot;: // Used by polyfills:    // eslint-disable-next-line no-fallthrough    case &quot;change&quot;:    case &quot;selectionchange&quot;:    case &quot;textInput&quot;:    case &quot;compositionstart&quot;:    case &quot;compositionend&quot;:    case &quot;compositionupdate&quot;: // Only enableCreateEventHandleAPI:    // eslint-disable-next-line no-fallthrough    case &quot;beforeblur&quot;:    case &quot;afterblur&quot;: // Not used by React but could be by user code:    // eslint-disable-next-line no-fallthrough    case &quot;beforeinput&quot;:    case &quot;blur&quot;:    case &quot;fullscreenchange&quot;:    case &quot;focus&quot;:    case &quot;hashchange&quot;:    case &quot;popstate&quot;:    case &quot;select&quot;:    case &quot;selectstart&quot;:      return DiscreteEventPriority;    case &quot;drag&quot;:    case &quot;dragenter&quot;:    case &quot;dragexit&quot;:    case &quot;dragleave&quot;:    case &quot;dragover&quot;:    case &quot;mousemove&quot;:    case &quot;mouseout&quot;:    case &quot;mouseover&quot;:    case &quot;pointermove&quot;:    case &quot;pointerout&quot;:    case &quot;pointerover&quot;:    case &quot;scroll&quot;:    case &quot;toggle&quot;:    case &quot;touchmove&quot;:    case &quot;wheel&quot;: // Not used by React but could be by user code:    // eslint-disable-next-line no-fallthrough    case &quot;mouseenter&quot;:    case &quot;mouseleave&quot;:    case &quot;pointerenter&quot;:    case &quot;pointerleave&quot;:      return ContinuousEventPriority;    case &quot;message&quot;: &#123;      // We might be in the Scheduler callback.      // Eventually this mechanism will be replaced by a check      // of the current priority on the native scheduler.      var schedulerPriority = getCurrentPriorityLevel();      switch (schedulerPriority) &#123;        case ImmediatePriority:          return DiscreteEventPriority;        case UserBlockingPriority:          return ContinuousEventPriority;        case NormalPriority:        case LowPriority:          // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.          return DefaultEventPriority;        case IdlePriority:          return IdleEventPriority;        default:          return DefaultEventPriority;      &#125;    &#125;    default:      return DefaultEventPriority;  &#125;&#125;function createEventListenerWrapperWithPriority(  targetContainer,  domEventName,  eventSystemFlags) &#123;  var eventPriority = getEventPriority(domEventName);  var listenerWrapper;  switch (eventPriority) &#123;    case DiscreteEventPriority:      listenerWrapper = dispatchDiscreteEvent;      break;    case ContinuousEventPriority:      listenerWrapper = dispatchContinuousEvent;      break;    case DefaultEventPriority:    default:      listenerWrapper = dispatchEvent;      break;  &#125;  return listenerWrapper.bind(    null,    domEventName,    eventSystemFlags,    targetContainer  );&#125;\n\n事件执行\n当一个事件触发时, 会调用事件绑定时创建的回调函数,这个函数会以批处理的形式调用事件处理方法 dispatchEventsForPlugins\nbatchedUpdates(function () &#123;  return dispatchEventsForPlugins(    domEventName, // 事件名称    eventSystemFlags, // 捕获阶段标识    nativeEvent, // 原生事件对象    ancestorInst  );&#125;);\n\ndispatchEventsForPlugins 首先获取触发事件的元素调用 extractEvents 方法,从原生 DOM 上的 stateNode 获取到 FiberNode,并且尝试获取当前元素的绑定事件,在根据不同的事件优先级,包装成不同的合成事件对象\nfunction dispatchEventsForPlugins(  domEventName,  eventSystemFlags,  nativeEvent,  targetInst,  targetContainer) &#123;  var nativeEventTarget = getEventTarget(nativeEvent);  var dispatchQueue = [];    //  内部调用不同的处理函数,用于处理没有原生事件对应的 React 事件,例如 onBeforeInput    // if (shouldProcessPolyfillPlugins) &#123;    //     extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);    //     extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);    //     extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);    //     extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);    // &#125;  extractEvents(    dispatchQueue,    domEventName,    targetInst,    nativeEvent,    nativeEventTarget,    eventSystemFlags  );  processDispatchQueue(dispatchQueue, eventSystemFlags);&#125;function extractEvents(  dispatchQueue,  domEventName,  targetInst,  nativeEvent,  nativeEventTarget,  eventSystemFlags,  targetContainer) &#123;  // 不同的事件类型,对应不同的合成事件构造函数  // 内部实现 preventDefault stopPropagation  switch (domEventName) &#123;    case &quot;click&quot;:      SyntheticEventCtor = SyntheticMouseEvent;    case &quot;drag&quot;:      SyntheticEventCtor = SyntheticDragEvent;  &#125;  // 从当前节点循环遍历到根节点, 收集所有上级节点中绑定当前方法的节点和它的绑定函数  var _listeners = accumulateSinglePhaseListeners(    targetInst,    reactName,    nativeEvent.type,    inCapturePhase,    accumulateTargetOnly  );  if (_listeners.length &gt; 0) &#123;    // Intentionally create event lazily.    var _event = new SyntheticEventCtor(      reactName,      reactEventType,      null,      nativeEvent,      nativeEventTarget    );    dispatchQueue.push(&#123;      event: _event,      listeners: _listeners,    &#125;);  &#125;&#125;function processDispatchQueue(dispatchQueue, eventSystemFlags) &#123;  var inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== 0;  // 循环事件队列,依次触发合成事件  for (let i = 0; i &lt; dispatchQueue.length; i++) &#123;    const &#123;event, listeners&#125; = dispatchQueue[i];    var previousInstance;    (function processDispatchQueueItemsInOrder(      event: ReactSyntheticEvent,      dispatchListeners: Array&lt;DispatchListener&gt;,      inCapturePhase: boolean    ): void &#123;      let previousInstance;      if (inCapturePhase) &#123;        // 反响遍历模拟捕获阶段        for (let i = dispatchListeners.length - 1; i &gt;= 0; i--) &#123;          const &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];          if (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;            return;          &#125;          executeDispatch(event, listener, currentTarget);          previousInstance = instance;        &#125;      &#125; else &#123;        // 正向循环模拟冒泡阶段        for (let i = 0; i &lt; dispatchListeners.length; i++) &#123;          const &#123; instance, currentTarget, listener &#125; = dispatchListeners[i];          if (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;            return;          &#125;          executeDispatch(event, listener, currentTarget);          previousInstance = instance;        &#125;      &#125;    &#125;  &#125;)()  rethrowCaughtError();&#125;\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑬ 性能优化相关","url":"/posts/13b92a7a082c/","content":"对于以下代码\nfunction Child() &#123;  console.log(&quot;child&quot;);  return &lt;div&gt;2&lt;/div&gt;;&#125;function App() &#123;  const [state, setState] = useState(1);  console.log(&quot;parent&quot;);  return (    &lt;div&gt;      &lt;div onClick=&#123;() =&gt; setState(2)&#125;&gt;click&lt;/div&gt;      &lt;Child&gt;&lt;/Child&gt;    &lt;/div&gt;  );&#125;\n\n首次挂载打印 parent &#x3D;&gt; child;第一次点击 click 打印 parent&#x3D;&gt;child第二次点击 click 打印 parent第三次点击 click，不打印任何内容\n第二次点击的时候没有打印 child 实际上是命中了 bailout 策略，命中该策略的子组件会跳过 reconcile 过程，因此不会进入 render 阶段。\n第三次点击没有任何打印，说明父组件和子组件都没有进入 render 阶段，实际上是命中了 eagerState 策略，这是一种发生于触发状态更新时的优化策略，如果命中了该策略不会进入 schedule 阶段，更不会进入 render 阶段。\neagerState如果某个状态更新前后没有变化就可以跳过更新流程。\nstate 是基于 update 计算出来的，计算过程发生在 render 的 beginWork, 而 eagerState 则是将计算过程提到了 schedule 之前执行。\n前提条件是该 fiberNode 不存在等待执行的更新，如果不存在更新那么就可以作为第一个更新。\nif (  fiber.lanes === NoLanes &amp;&amp;  (alternate === null || alternate.lanes === NoLanes)) &#123;  // 如果新状态与当前状态相同，我们可以完全摆脱副作用  const lastRenderedReducer = queue.lastRenderedReducer;  if (lastRenderedReducer !== null) &#123;    let prevDispatcher;    try &#123;      const currentState = queue.lastRenderedState; // 就是 memoizedState      const eagerState = lastRenderedReducer(currentState, action); // 基于 action 提前计算 state      // 如果在我们进入渲染阶段时 reducer 没有改变，那我们可以使用 eager 状态而无需再次调用 reducer。      update.hasEagerState = lastRenderedReducer; // 标记该 update 存在 eagerState      update.eagerState = eagerState; // 存储 eagerState 的值      if (is(eagerState, currentState)) &#123;        return;      &#125;    &#125; catch (error) &#123;      // ...    &#125; finally &#123;      // ...    &#125;  &#125;&#125;\n\n上面的代码中通过 lastRenderedReducer 提前计算 State,如果前后状态没有变化就会命中 eagerState 策略，如果没有命中但是当前更新是 fiberNode 的第一个更新，也可以作为后续更新的 baseState。\n为什么第二次点击的时候，父组件还是要渲染一次，因为进入 eagerState 的条件是\nfiber.lanes === NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes);\n\ncurrent.lanes 和 workInProcess.lanes 都需要 NoLanes, 第一次点击时 beginWork 执行结束后 workInProcess.lanes 会被设置为 NoLanes 但此时还没有交换 fiberTree 需要等到 commit 之后执行，因此第一次点击之后，只有 current 被设置为了 NoLanes。虽然没有命令 eagerState 但是会命中 bailout 这时会被设置为 NoLanes。\nfunction bailoutHooks(current: Fiber, workInProgress: Fiber, lanes: Lanes) &#123;  workInProgress.updateQueue = current.updateQueue;  // ...  current.lanes = removeLanes(current.lanes, lanes);&#125;\n\n\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑪ 更新流程","url":"/posts/c9c96aab2070/","content":"useState 与 setState 更新流程大致相同,只是入口函数不同。\nreact 更新是有优先级的,高优先级的任务可能会打断低优先级任务的，低优先级任务会在高优先级更新后的状态上进行更新。\n不同组件用不同的处理函数：\n\nReactDOM.createRoot 对应 HostRoot\nthis.setState 对应 ClassComponent\nthis.forceUpdate 对应 ClassComponent\nuseState dispatcher 对应 FunctionComponent\nuseReducer dispatcher 对应 FunctionComponent\n\nHostRoot,ClassComponent 对应如下的结构,tag 字段区分不同的更新触发场景：\n\nReplaceState: 代表在 ClassComponent 生命周期函数中直接改变 this.state\nUpdateState: 默认情况，通过 ReactDOM.createRoot 或者 this.setState 触发更新\nCaptureUpdate: 代表发生错误的情况下在 ClassComponent 或 HostRoot 中触发更新（比如通过 getDerivedStateFromError 方法）\nForceUpdate: 代表通过 this.forceUpdate 触发更新\n\nfunction createUpdate(eventTime, lane) &#123;  const update = &#123;    eventTime,    lane,    // 区分触发更新的场景    tag: UpdateState,    payload: null,    // UI 渲染后触发的回调函数    callback: null,    next: null,  &#125;;  return update;&#125;\n\n函数组件触发更新时的 update 对象结构：\nconst update = &#123;  lane,  action,  // 优化策略相关  hasEagerState: false,  eagerState: null,  next: null,&#125;;\n\n\n承载更新内容的字段不同，类组件是 payload 字段\n更新的紧急程度是 lane 字段表示的\n更新之间的顺序，通过 next 字段指向下一个 update,从而形成一个链表\n\nupdateQueue 是一个 update 对象组成的链表\n\nbaseState: 参与计算的初始 state, update 基于该 state 计算新的 state, 可以类比为心智模型中的 master 分支。\nfirstBaseUpdate 与 lastBaseUpdate: 表示更新前该 FiberNode 中已保存的 update, 以链表的形式串联起来。链表头部为 firstBaseUpdate，链表尾部为 lastBaseUpdate。\nshared.pending: 触发更新后，产生的 update 会保存在 shared.pending 中形成单向环状链表。计算 state 时，该环状链表会被拆分并接在 lastBaseUpdate 后面。\n\nconst updateQueue = &#123;  baseState: null,  firstBaseUpdate: null,  lastBaseUpdate: null,  shared: &#123;    pending: null,  &#125;,&#125;;\n\n一轮跟新后如果有两个低优先级更新没有处理，那么这两个更新会放在 baseState 上，如果有另外两个更新进来会放在 shared.pending 上并且形成一个环状链表，下一次 commit 时 shared.pending 会被拼接到 baseState 后面，循环处理哪些符合优先级的更新，基于符合条件的更新，来计算最终的state.\n在类组件上会挂载 setState 方法, 在调用的时候会把状态添加到队列中\nfunction Component(props, context, updater) &#123;  this.updater = updater || ReactNoopUpdateQueue;&#125;Component.prototype.setState = function (partialState, callback) &#123;  this.updater.enqueueSetState(this, partialState, callback, &quot;setState&quot;);&#125;;\n\n在 render 阶段的 beginWork 中会调用类组件对应的方法创建 Fiber 节点, 类组件会在这时实例化,实例化完成后立即执行 adoptClassInstance 方法, 为实例提供用于更新的 this.updater 对象\nfunction constructClassInstance() &#123;  var instance = new ctor(props, context);  adoptClassInstance(workInProgress, instance);&#125;function adoptClassInstance(workInProgress, instance) &#123;  instance.updater = classComponentUpdater;  workInProgress.stateNode = instance;  set(instance, workInProgress);&#125;\n\n当事件被触发之后会调用 updater.enqueueSetState, 与首次 render 阶段时为 FiberRoot 创建更新队列相似\n在首次渲染时已经通过 initializeUpdateQueue 为节点初始化了更新队列,现在需要把 update 对象添加到队列中\nvar classComponentUpdater = &#123;  isMounted: isMounted,  enqueueSetState: function (inst, payload, callback) &#123;    var fiber = get(inst);    var eventTime = requestEventTime();    var lane = requestUpdateLane(fiber);    var update = createUpdate(eventTime, lane);    update.payload = payload;    if (callback !== undefined &amp;&amp; callback !== null) &#123;      update.callback = callback;    &#125;    enqueueUpdate(fiber, update);    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);    if (root !== null) &#123;      entangleTransitions(root, fiber, lane);    &#125;  &#125;,  enqueueReplaceState: function (inst, payload, callback) &#123;    var fiber = get(inst);    var eventTime = requestEventTime();    var lane = requestUpdateLane(fiber);    var update = createUpdate(eventTime, lane);    update.tag = ReplaceState;    update.payload = payload;    if (callback !== undefined &amp;&amp; callback !== null) &#123;      update.callback = callback;    &#125;    enqueueUpdate(fiber, update);    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);    if (root !== null) &#123;      entangleTransitions(root, fiber, lane);    &#125;  &#125;,  enqueueForceUpdate: function (inst, callback) &#123;    var fiber = get(inst);    var eventTime = requestEventTime();    var lane = requestUpdateLane(fiber);    var update = createUpdate(eventTime, lane);    update.tag = ForceUpdate;    if (callback !== undefined &amp;&amp; callback !== null) &#123;      update.callback = callback;    &#125;    enqueueUpdate(fiber, update);    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);    if (root !== null) &#123;      entangleTransitions(root, fiber, lane);    &#125;  &#125;,&#125;;\n\nupdate 对象会被添加到 updateQueue.shared.pending 中,并且形成循环链表,如果有新的更新会成为新的头节点\n\nfunction enqueueUpdate(fiber, update, lane) &#123;  var updateQueue = fiber.updateQueue;  if (updateQueue === null) &#123;    // Only occurs if the fiber has been unmounted.    return;  &#125;  var sharedQueue = updateQueue.shared;  if (isInterleavedUpdate(fiber)) &#123;    var interleaved = sharedQueue.interleaved;    if (interleaved === null) &#123;      // This is the first update. Create a circular list.      update.next = update;      // At the end of the current render, this queue&#x27;s interleaved updates will      // be transferred to the pending queue.      pushInterleavedQueue(sharedQueue);    &#125; else &#123;      update.next = interleaved.next;      interleaved.next = update;    &#125;    sharedQueue.interleaved = update;  &#125; else &#123;    var pending = sharedQueue.pending;    if (pending === null) &#123;      // This is the first update. Create a circular list.      update.next = update;    &#125; else &#123;      update.next = pending.next;      pending.next = update;    &#125;    sharedQueue.pending = update;  &#125;&#125;\n\n接着触发事件的 Fiber 节点会被传入 scheduleUpdateOnFiber 进行调度, 其中会执行 markUpdateLaneFromFiberToRoot 将每一个 Fiber 节点的 lanes 都合并到父级节点上,这样在 rootFiber 节点上就包含了所有子节点的更新优先级信息\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, lane) &#123;  // Update the source fiber&#x27;s lanes  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);  var alternate = sourceFiber.alternate;  if (alternate !== null) &#123;    alternate.lanes = mergeLanes(alternate.lanes, lane);  &#125;  &#123;    if (      alternate === null &amp;&amp;      (sourceFiber.flags &amp; (Placement | Hydrating)) !== NoFlags    ) &#123;      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);    &#125;  &#125;  var node = sourceFiber;  var parent = sourceFiber.return;  while (parent !== null) &#123;    parent.childLanes = mergeLanes(parent.childLanes, lane);    alternate = parent.alternate;    if (alternate !== null) &#123;      alternate.childLanes = mergeLanes(alternate.childLanes, lane);    &#125; else &#123;      &#123;        if ((parent.flags &amp; (Placement | Hydrating)) !== NoFlags) &#123;          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);        &#125;      &#125;    &#125;    node = parent;    parent = parent.return;  &#125;  if (node.tag === HostRoot) &#123;    var root = node.stateNode;    return root;  &#125; else &#123;    return null;  &#125;&#125;\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ⑨ 组件生命周期","url":"/posts/fbcba5f47351/","content":"\n从横向的结构分析, 生命周期包括 Render phase Pre-commit phase Commit phase 这些生命周期是与代码逻辑相符的,很容易找到类型名称的函数调用\n纵向的 Mounting Updating Unmounting 是从 DOM 的表现层面划分的,真正对 DOM 的处理分散在上面的不同阶段之中\n下面以横向的结构划分,也就是以代码的执行逻辑分析不同阶段的生命周期方法\nRenderRender 阶段也就是 Fiber 树 构建的阶段, 对于首次渲染的节点会创建新的 FiberNode, 对于更新的节点会检查是需要新建还是复用\n在构建 Fiber 树的过程中,会在每个节点处理之前调用 createWorkInProgress,当发现此节点还没有创建,会调用 createFiber 创建对应的 FiberNode\n将 FiberNode 传入 beginWork 按 Fiber 的 tag 类型,调用不同的方法处理, 如果 Fiber 的类型是 class component 会调用 constructClassInstance 实例化\n紧接着会执行 getDerivedStateFromProps 或 componentWillMount, 因此这两个生命周期在挂载阶段和更新阶段是都会执行的\nfunction constructClassInstance(workInProgress, ctor, props) &#123;  var instance = new ctor(props, context);  if (typeof getDerivedStateFromProps === &quot;function&quot;) &#123;    getDerivedStateFromProps(nextProps, prevState);  &#125;  if (typeof instance.componentWillMount === &quot;function&quot;) &#123;    instance.componentWillMount();  &#125;&#125;\n\n如果是函数组件则会直接执行\nvar children = Component(props, secondArg);\n\n实例化类组件之后会执行 finishClassComponent, 在这里会执行类组件的 render 方法\nfunction finishClassComponent() &#123;  instance.render();&#125;\n\n如果节点已经挂载过, 类组件会进入更新的逻辑,这里会执行 shouldComponentUpdate 并返回一个 boolean, 用作是否执行 componentWillUpdate() render() componentDidUpdate() 的依据\nfunction updateClassInstance() &#123;  var shouldUpdate = instance.shouldComponentUpdate(    newProps,    newState,    nextContext  );  if (shouldUpdate) &#123;    if (typeof instance.componentWillUpdate === &quot;function&quot;) &#123;      instance.componentWillUpdate(newProps, newState, nextContext);    &#125;    if (typeof instance.componentDidUpdate === &quot;function&quot;) &#123;      workInProgress.flags |= Update;    &#125;    if (typeof instance.getSnapshotBeforeUpdate === &quot;function&quot;) &#123;      workInProgress.flags |= Snapshot;    &#125;  &#125;&#125;\n\nPre-commitPre-commit 阶段实际就是 commit 阶段 前半部分\n其中 getSnapshotBeforeUpdate 将会被执行\nCommit指的就是 commit 阶段 后半部分\n在这个阶段会真实的操作 DOM,并且重新绑定 Ref\n可以看到 componentDidMount componentDidUpdate 会在这个阶段执行\n其中 commitMutationEffects 阶段会对标记删除的节点执行 commitDeletion, componentWillUnmount 会在这个函数中执行\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ① 从入口开始认识React","url":"/posts/78be9aaa5f2c/","content":"render 方法当我们打开 React 的官方文档看到的第一个例子便是 Hello World：\nReactDOM.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&quot;root&quot;));\n\nrender函数将h1标签和Hello World文本渲染在了页面的root元素中，但很显然这段代码没有看到的那么简单，js并不会认识html元素，这个标签最终会被转换成 js 对象，然后通过render方法后面的一系列函数调用，最终被插入到页面中。\nJSX刚才看到的 h1 标签，严格说来并不是html,因为他写在 js 语法中，可以把它叫做标签语法，也就是 JSX。\n为什么 JSX 的出现好像又让页面开发回到了刀耕火种的jquery时代，js与html混合在一起，UI(视图)与逻辑耦合。\n但实际上 React 认为，渲染逻辑与 UI 的逻辑是耦合的，比如需要在 UI 中绑定事件，数据改变时通知 UI 发生改变，而 React 并没有将这两点分离到不同的文件中，而是通过组件的概念，实现关注点分离，也就是设计原则的分离，每一部分都有自己的关注点。\n我们可以在Babel中，看一下 JSX 最终变成了什么。\nconst CompA = (  &lt;div&gt;    &lt;p&gt;p&lt;/p&gt;div  &lt;/div&gt;);const CompB = () =&gt; &lt;a&gt;a&lt;/a&gt;;const App = () =&gt; &#123;  return (    &lt;&gt;      &lt;CompA /&gt;      &lt;CompB /&gt;    &lt;/&gt;  );&#125;;\n\n转化为\n&quot;use strict&quot;;const CompA = /*#__PURE__*/ React.createElement(  &quot;div&quot;,  null,  /*#__PURE__*/ React.createElement(&quot;p&quot;, null, &quot;p&quot;),  &quot;div&quot;);const CompB = () =&gt; /*#__PURE__*/ React.createElement(&quot;a&quot;, null, &quot;a&quot;);const App = () =&gt; &#123;  return /*#__PURE__*/ React.createElement(    React.Fragment,    null,    /*#__PURE__*/ React.createElement(CompA, null),    /*#__PURE__*/ React.createElement(CompB, null)  );&#125;;\n\n可以注意到组件被转化为React.createElement方法的第一个参数，这也是为什么组件的第一个字母需要大写的原因，Babel 会通过大小写来区分原生组件和 React 组件\n而正因为 JSX 语法被转换成了React.createElement的函数调用，因此在写 JSX 的时候必须要import React from react\n而 React 17-RC 以及之后的版本将采用新的 JSX 转换，从而无需在引入 React\nVirtual DOM通过 React.createElement 处理的节点，会被转换成 Virtual DOM 也可以称为虚拟 DOM\nVirtual DOM 是一种编程概念,它与真是的 DOM 一一对应，而且他是保存在内存中的，当 DOM 的属性发生改变的时候，React 会在内存中把改变映射成 Virtual DOM,在把最终状态渲染在页面中，从而保证最小的 DOM 操作\n实际上 React 中的 Fiber,也是属于 Virtual DOM 概念的一部分，在 React.createElement 创建的对象上添加了，更多的属性，例如优先级，副作用，更新队列等。\n\nReact.createElement &#x2F;react&#x2F;packages&#x2F;react&#x2F;src&#x2F;React.js 在源码中非常简单 \n\nexport function createElement(type, config, children) &#123;  let propName;  // 用于提取保留字段  const props = &#123;&#125;;  let key = null;  let ref = null;  let self = null;  let source = null;  if (config != null) &#123;    if (hasValidRef(config)) &#123;      ref = config.ref;    &#125;    if (hasValidKey(config)) &#123;      // 转换为字符串      key = &quot;&quot; + config.key;    &#125;    self = config.__self === undefined ? null : config.__self;    source = config.__source === undefined ? null : config.__source;        // 拷贝外部传入的props属性(这里的形参是config)到props对象上    for (propName in config) &#123;      if (        hasOwnProperty.call(config, propName) &amp;&amp;        !RESERVED_PROPS.hasOwnProperty(propName)      ) &#123;        props[propName] = config[propName];      &#125;    &#125;  &#125;  // 子元素的个数  const childrenLength = arguments.length - 2;  // 如果只有一个子元素直接赋值  if (childrenLength === 1) &#123;    props.children = children;  &#125; else if (childrenLength &gt; 1) &#123;    const childArray = Array(childrenLength);    for (let i = 0; i &lt; childrenLength; i++) &#123;      childArray[i] = arguments[i + 2];    &#125;    // 如果大于一个则插入到一个数组中    props.children = childArray;  &#125;  // 如果定义了默认属性，则用默认属性覆盖掉，  if (type &amp;&amp; type.defaultProps) &#123;    const defaultProps = type.defaultProps;    for (propName in defaultProps) &#123;      if (props[propName] === undefined) &#123;        props[propName] = defaultProps[propName];      &#125;    &#125;  &#125;  return ReactElement(    type,                     // 组件类型 可能是元素标签，也可能是类组件或函数组件的引用    key,                      // 字符串key    ref,                      // ref对象     self,                     // 内部属性初始化null    source,                   // 内部属性初始化null    ReactCurrentOwner.current,// 用于跟踪拥有当前正在被构建组件的组件    props                     // 属性集合  );&#125;                         const ReactElement = function(type, key, ref, self, source, owner, props) &#123;  const element = &#123;    $$typeof: REACT_ELEMENT_TYPE,    type: type,    key: key,    ref: ref,    props: props,    _owner: owner,  &#125;;  return element;&#125;;\n\n当type是一个react组件的时候，他会被赋值到type属性上，最终被实例化。现在看一下，这个组件被定义时的样子\nclass App extends React.Component &#123;&#125;\n\n\nReact.Component  &#x2F;react&#x2F;packages&#x2F;react&#x2F;src&#x2F;ReactBaseClasses.js\n\n// 基本类，用于帮助更新组件的状态function Component(props, context, updater) &#123;  this.props = props;  this.context = context;  // 如果refs是一个已经过时的string类型，晚一点的时候会重新分配一个不同的对象  this.refs = emptyObject;  // 初始化一个默认updater对象，但真实的对象会在渲染的时候被插入  this.updater = updater || ReactNoopUpdateQueue;&#125;Component.prototype.isReactComponent = &#123;&#125;;/** * 设置一个状态的子集，必须使用这个方法，你应该确保&#x27;this.state&#x27;是不可变的，也就是不能修改，每次修改必须返回一个新的传入一个新的state *  * setState没有确保立即更新，所以在调用这个方法后使用数据可能是旧的。也没有确保setState会立即执行，实际上最终可能会一起执行 * 你可以提供一个回调函数，他将在setState真正完成后执行。 *  * 当setState传入一个函数，他将在未来的某一时间执行，并不是同步，它将使用最新的组件参数（state, props, context）被调用 * 这些参数与this对象上的可以是不同的，因为他可能在receiveProps之后但在shouldComponentUpdate之前，这些新的state, props, and context还没来得及合并到this对象 */Component.prototype.setState = function(partialState, callback) &#123;  if (    typeof partialState !== &#x27;object&#x27; &amp;&amp;    typeof partialState !== &#x27;function&#x27; &amp;&amp;    partialState != null  ) &#123;    throw new Error(      &#x27;setState(...): takes an object of state variables to update or a &#x27; +        &#x27;function which returns an object of state variables.&#x27;,    );  &#125;  // 更新会被添加到队列，在未来的某一时间更新  this.updater.enqueueSetState(this, partialState, callback, &#x27;setState&#x27;);&#125;;/** * 强制更新，它应该只当明确知道我们不在一个DOM事务中才被使用，你可能会想，当你知道一些深层组件的状态已经改变但是setState没有调用的时候去调用它。 * 它将不会触发shouldComponentUpdate，但会触发 `componentWillUpdate` 和 `componentDidUpdate` */Component.prototype.forceUpdate = function(callback) &#123;  this.updater.enqueueForceUpdate(this, callback, &#x27;forceUpdate&#x27;);&#125;;\n\n执行流程现在已经知道了render执行时的大部分必要信息，那render背后的逻辑又是怎样的，这显然是一个复杂的调用过程，但是我们可以通过浏览器的性能分析去查看render函数的调用那个过程\n现在你只需要大概了解调用了哪些方法，这些方法会组成后面的调用流程图，后面会详细的描述\n\n初始化事件相关对象\n\nregisterSimpleEvents 创建对象相关对象\n\n\n\n\n变量名称\n变量对象\n说明\n\n\n\nallNativeEvents\nSet 集合\n保存所有原生事件的名称 例如 0:&quot;cancel&quot;\n\n\neventPriorities\nMap 集\n保存事件名称和事件优先级对应关系 例如 click=&gt;0 \n\n\ntopLevelEventsToReactNames\nMap 集\n保存原始事件名称和 React 事件的对应关系 例如 &quot;cancel&quot; =&gt; &quot;onCancel&quot; \n\n\nregistrationNameDependencies\nObject\n保存 React 事件和原生事件的对应关系 例如 onClick:(1) [&#39;click&#39;] 每个 React 事件对应一个数组用于保存合成事件对应关系\n\n\npossibleRegistrationNames\nObject\n保存小写的 React 事件名称和正确的驼峰命名事件的对应关系，用于校验用户输入 例如 onclick:onClick\n\n\n入口\nrender : ReactDom.render()createRootImpl : 创建 FiberRootNode 根节点listenToAllSupportedEvents : 绑定所有原生事件在 root 节点上\nrender 阶段\nunbatchedUpdates : 非批量更新，让用户尽早看见页面内容，如果是 batchedUpdates 会以异步执行scheduleUpdateOnFiber : 调度 Fiber 节点更新优先级performUnitOfWork : 以 Fiber 节点为单位，深度优先递归遍历每一个节点reconcileChildren ： 创建对比 Fiber 节点，标记有副作用的节点 （添加，删除，移动，更新）completeUnitOfWork ： 从下至上遍历节点，创建相应的 DOM 节点，并创建 Effects 链表，交给 commit 阶段使用\ncommit 阶段\ncommitBeforeMutationEffects: 操作真实节点前执行，会执行getSnapshotBeforeUpdatecommitMutationEffects: 执行节点操作commitLayoutEffects： 执行副作用函数，包括 componentDidUpdate 或 effect回调函数\n如此复杂的调用栈，是为了解决哪些问题。下一章，让我们感受一下react的设计理念\n","categories":["React"],"tags":["React"]},{"title":"React v16 源码分析 ② 设计理念","url":"/posts/1c503c842746/","content":"状态渲染 UIUI = react(state);\n\nReact 程序设计哲学\n\n将设计好的 UI 划分为组件层级\n确定 UI state 的最小（且完整）表示\n确定 state 放置的位置\n添加反向数据流，低层层级组件更新高层级组件状态\n\n使用组合而不是继承Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。\n如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。\nFiberFiber 其实就是 Virtual DOM 的一种实现，相比于通过 React.createElement 创建的 Virtual DOM，Fiber 在此基础上添加了更多的属性，例如 return, current 等指针，用于将 Fiber 对象链接为链表。最终形成一颗树状结构，也就是 Fiber 树，他对应着真实 DOM 树的结构。\n而 Fiber 对象上的属性还不止这些，还有像 updateQueue 更新队列等属性，但到目前位置知道 Fiber 是对 DOM 树的一种描述，已经足够了。而让 React 设计 Fiber 的原因，则是因为下面的协调过程。\n协调 reconciler这一概念应该是当我们对 React 执行过程深入思考的时候最容易想到的一部分，通过 JSX 创建的 Virtual DOM 如何与真实的 DOM 同步，真实 DOM 属性改变的时候，又如何被记录到 Virtual DOM 上，这个过程就叫做协调。\nreconciler 模块，用于处理协调相关的事务。Diff 算法也在这个期间发生。\nReact15 之前的协调过程是同步的，也叫 stack reconciler。\nJS 的执行是单线程的,由于浏览器器触发的事件（用户交互触发的事件回调）是一个宏任务，所以会等待同步任务执行完成，在更新比较耗时的任务时，会阻塞用户的交互。\n也许会考虑将耗时任务放到异步任务中执行，但最终还是会回到主线程中执行，所以比较好的解决办法就是任务分割，当其他优先级比较高的任务到来时，将正在执行的任务打断让出执行权。之后再从中断的部分开始异步执行剩下的计算。\n为了将老的同步更新的架构变为异步可中断更新，所以需要一套数据结构让它既能对应真实的 dom 又能作为分隔的单元，这就是 Fiber。\nScheduler有了 Fiber，就需要用浏览器的时间片异步执行这些 Fiber 的工作单元，浏览器有一个 api 叫做 requestIdleCallback，它可以在浏览器空闲的时候执行一些任务，我们用这个 api 执行 react 的更新，让高优先级的任务优先响应不就可以了吗，但事实是 requestIdleCallback 存在着浏览器的兼容性和触发不稳定的问题，所以我们需要用 js 实现一套时间片运行的机制，在 react 中这部分叫做 scheduler。\n下面用伪代码理解一下 分割，异步执行，让出执行权\nlet firstFiber; // 代表Fiber树的头节点let nextFiber = firstFiber; // 用于遍历子节点function performUnitOfWork() &#123;  // 处理节点相关逻辑  return nextFiber.next; // 返回下一个节点&#125;function workLoop(deadline) &#123;  while (nextFiber &amp;&amp; !shouldYield) &#123;    nextFiber = performUnitOfWork();    // 如果没有剩余时间处理下一个节点    // 则暂停执行，让出主线程，给优先级更高的任务    shouldYield = deadline &lt; 1;  &#125;  requestIdleCallback(workLoop);&#125;requestIdleCallback(workLoop);\n\n为什么不使用统的异步控制：\n\nsetTimeout setTimeout 在嵌套超过 5 层之后有默认 4ms 的延时\nrequestFrameAnimation 执行时机不确定，chrome 和 firefox 是在渲染前执行，safari 是在渲染之后执行。\npromise 微任务会在主进程执行结束后释放掉有所得微任务，不能控制什么时候需要执行。\n\nLane有了异步调度，我们还需要细粒度的管理各个任务的优先级，让高优先级的任务优先执行，各个 Fiber 工作单元还能比较优先级，相同优先级的任务可以一起更新。\n代数效应（algebraic effects） 可能翻译成 可以当做参数传递的副作用 更容易理解。 它是函数式编程中的一个概念，用于将副作用从函数调用中分离。\n从实用的角度上举例，假如我们有这样一段代码，其主要目的是进行一大段精妙的运算：\nasync function biz(id) &#123;  const infoId = /* do some calc */ id; // 这里可以理解为是一大段计算逻辑  const info = await getInfo(infoId); // 副作用，与 server 通信  const dataId = /* do some calc */ info.dataId; // 这里可以理解为是一大段计算逻辑  const data = getData(dataId); // 副作用，非幂等操作  return /* do some calc */ data.finalCalcData; // 这里可以理解为是一大段计算逻辑&#125;\n\n尽管运算逻辑很优美，但美中不足的是有两段副作用，导致它不能成为一个干净的纯函数被单元测试。而且这里会导致严重的逻辑耦合：『做什么』与『怎么做』没有拆的很干净：你的一大段计算逻辑是在处理做什么；两个副作用更关心怎么做：比如线上是接口调用，单测里是 mock 数据；但是由于这两块副作用代码，导致整个糅杂的逻辑都无法复用。直接把两个副作用传进来不就行了？\nasync function biz(id, getInfo, getData) &#123;  const infoId = /* do some calc */ id; // 这里可以理解为是一大段计算逻辑  const info = await getInfo(infoId); // 副作用，与 server 通信  const dataId = /* do some calc */ info.dataId; // 这里可以理解为是一大段计算逻辑  const data = getData(dataId); // 副作用，非幂等操作  return /* do some calc */ data.finalCalcData; // 这里可以理解为是一大段计算逻辑&#125;\n\n是的，这样确实可以复用，但还有一个叫函数染色的问题没有解决：明明是一大段干净的同步运算逻辑，因为 getInfo 是异步的，导致整个函数都得加个 async。而且很有可能在我单元测试里，这个 getInfo 是直接同步取内存数据，还得因此弄个 Promise……这时候如果 JS 里有这样一种语法就好了：\n当函数执行到perform的时候，会被暂停，并被handle捕获，当异步执行的结果被返回，函数在继续执行\nfunction biz(id) &#123;  const infoId = /* do some calc */ id; // 这里可以理解为是一大段计算逻辑  const info = perform &#123; type: &#x27;getInfo&#x27;, payload: infoId &#125;;  const dataId = /* do some calc */ info.dataId; // 这里可以理解为是一大段计算逻辑  const data = perform &#123; type: &#x27;getData&#x27;, payload: dataId &#125;;  return /* do some calc */ data.finalCalcData;  // 这里可以理解为是一大段计算逻辑&#125;// 正常业务逻辑async function runBiz() &#123;  try &#123;    biz();  &#125; handle(effect) &#123;    if (effect.type === &#x27;getInfo&#x27;) &#123;      resume await getInfo(effect.payload);    &#125; else if (effect.type === &#x27;getData&#x27;) &#123;      resume await getData(effect.payload)    &#125;  &#125;&#125;// 单元测试逻辑function testBiz() &#123;  try &#123;    biz();  &#125; handle(effect) &#123;    if (effect.type === &#x27;getInfo&#x27;) &#123;      resume testInfo;    &#125; else if (effect.type === &#x27;getData&#x27;) &#123;      resume testData;    &#125;  &#125;&#125;\n\n分离副作用在函数编程中非常常见，redux-saga也会将副作用分离出来，只负责发起请求\nfunction* fetchUser(action) &#123;  try &#123;    const user = yield call(Api.fetchUser, action.payload);    yield put(&#123; type: &quot;SUCCESS&quot;, user: user &#125;);  &#125; catch (err) &#123;    yield put(&#123; type: &quot;ERROR&quot; &#125;);  &#125;&#125;\n\n这样业务逻辑代码即摆脱了副作用，完成了做什么与怎么做的解耦；又完全不必担心异步副作用带来的染色问题，可以愉快的单测和复用了。Suspense 也是这种概念的延伸:\nconst ProductResource = createResource(fetchProduct);const Product = (props) =&gt; &#123;  const p = ProductResource.read(    // 用同步的方式来编写异步代码!    props.id  );  return &lt;h3&gt;&#123;p.price&#125;&lt;/h3&gt;;&#125;;function App() &#123;  return (    &lt;div&gt;      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;        &lt;Product id=&#123;123&#125; /&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  );&#125;\n\n可以看到 ProductResource.read 完全是同步的写法，把获取数据的部分完全分离出了 Product 组件之外。在源码中， ProductResource.read 会在获取数据之前会 throw 一个特殊的 Promise， 由于 scheduler 的存在， scheduler 可以捕获这个 promise，暂停更新等数据获取之后交还执行权。ProductResource 可以是 localStorage 甚至是 redis 、 mysql 等数据库，也就是组件即服务，可能以后会有 server Component 的出现。\n","categories":["React"],"tags":["React"]},{"title":"React 18 新特性","url":"/posts/0dfb128a2887/","content":"兼容性V18 已不再支持 IE11,计划时间是 2022 年 6 月 15 日, 因为用到的一些现代浏览器新特性如 micro-tasks,在 IE 中无法充分 polyfill .\n并发V18 版本在 V17 的基础上又做了一些调整。在过去的 V17 版本中,传统模式和并发模式是共存的， 通过 createRoot API 就可以启用并发模式。React 为向并发模式迁移的最初策略是设计三种模式。\n\nLegacy 模式： V17 中默认使用的模式。默认开启严格模式。默认同步更新。Legacy Suspense semantics。\nBlocking 模式： Legacy 和 Concurrent 混合模式。默认开启严格模式。默认同步更新。开放一些新特性。\nConcurrent 模式：V18 使用的模式。默认开启严格模式。默认并发更新。开发所有的新特性。\n\nReact 最初的计划是用户可以从 Legacy 切换到 Blocking 模式，并不需要修改任何语法，配合严格模式（StrictMode）修改其中的报错，当所有错误被解决之后，可以直接切换到的 Concurrent 模式。\n但在实际的场景 React 思考了以下几个问题:\n\n项目中会有成百上千个文件，开启严格模式，会有大量的错误信息，虽然不影响程序运行，但是会干扰开发并且不能快速的一次性解决。\n启用并发模式的好处不言而喻，可能会在未来默认启用。提供 startTransition Suspense 等 API 在内部实现并发特性。用户可以增量的选择性的使用这些 API 从而获得并发的特性。\n如果按照上述的思路，那么 Concurrent 模式和 Blocking 模式的唯一区别就只有是否提示错误信息。那么如果默认不启用并发模式，就可以不开启严格模式，用于提示错误信息。\n\n基于上面的思考，V18 的策略是不会默认启用并发的特性，即使用 createRoot 启用并发模式并不能体验并发的特性，如果想体验并发的特性，需要使用例如 startTransition 等支持并发特性的 API. 所以官方描述为 没有并发模式，只有并发特性\nAPI\nstartTransition\n\n这个 API 可以防止渲染任务立即执行，允许将应用程序中的某些更新标记为非紧急更新，因此它们会暂停，同时优先考虑更紧急的更新。这可以在一个复杂的更新中相应用户输入。\nfunction aaaaaaaaaaaaaaa() &#123;  for (let i = 0; i &lt; 100000000; i += 1) &#123;    const a = 1;  &#125;&#125;const [num, setNum] = useState&lt;string&gt;(&quot;&quot;);const [list, setList] = useState&lt;any[]&gt;([]);useEffect(() =&gt; &#123;  setList(new Array(20000).fill(null));  setTimeout(() =&gt; &#123;    const event = document.createEvent(&quot;MouseEvents&quot;);    event.initEvent(&quot;click&quot;, true, true);    document.getElementById(&quot;button&quot;)!.dispatchEvent(event);  &#125;, 500);&#125;, []);return (  &lt;&gt;    &lt;button      id=&quot;button&quot;      type=&quot;button&quot;      onClick=&#123;() =&gt; &#123;        setNum(() =&gt; &#123;          aaaaaaaaaaaaaaa();          return &quot;123&quot;;        &#125;);      &#125;&#125;    &gt;      点击    &lt;/button&gt;    &lt;p&gt;&#123;num&#125;&lt;/p&gt;    &#123;list.map((_, i) =&gt; (      &lt;div key=&#123;Math.random()&#125;&gt;&#123;i&#125;&lt;/div&gt;    ))&#125;  &lt;/&gt;);\n\n在没有使用并发特性的时候，列表的渲染是一个同步任务，不会相应模拟的用户事件\n\n当开启了并发特性之后，会被拆分成小任务异步执行\nstartTransition(() =&gt; &#123;  setList(new Array(20000).fill(null));&#125;);\n\n\n\nuseDeferredValue\n\n会创建一个数据的副本，如果当前更新是一个紧急更新，useDeferredValue 会返回之前的状态，从而优先响应紧急更新。当紧急更新渲染完成后，才会去执行的当前更新。底层实现与 useDeferredValue 类似。\n使用 useDeferredValue 也可以实现相同的效果\nconst [list, setList] = useState&lt;any[]&gt;([]);const dList = useDeferredValue(list);\n\n\nuseId\n\n生成一个唯一 ID, 在服务端与客户端生成的相同，防止 ID 不匹配\n\nuseSyncExternalStore\n\nuseSyncExternalStore  是一个新的 api，经历了一次修改，由  useMutableSource  改变而来，主要用来解决外部数据撕裂问题。\nuseSyncExternalStore 能够通过强制同步更新数据让 React 组件在 CM 下安全地有效地读取外接数据源。 在 Concurrent Mode 下，React 一次渲染会分片执行（以 fiber 为单位），中间可能穿插优先级更高的更新。假如在高优先级的更新中改变了公共数据（比如 redux 中的数据），那之前低优先的渲染必须要重新开始执行，否则就会出现前后状态不一致的情况。\nuseSyncExternalStore 一般是三方状态管理库使用，我们在日常业务中不需要关注。因为 React 自身的 useState 已经原生的解决的并发特性下的 tear（撕裂）问题。useSyncExternalStore 主要对于框架开发者，比如 redux，它在控制状态时可能并非直接使用的 React 的 state，而是自己在外部维护了一个 store 对象，用发布订阅模式实现了数据更新，脱离了 React 的管理，也就无法依靠 React 自动解决撕裂问题。因此 React 对外提供了这样一个 API。\n目前 React-Redux 8.0 已经基于 useSyncExternalStore 实现。\n\nuseInsertionEffect\n\n这个 Hooks 只建议  css-in-js 库来使用。 这个 Hooks 执行时机在 DOM 生成之后，useLayoutEffect 之前，它的工作原理大致和  useLayoutEffect  相同，只是此时无法访问  DOM  节点的引用，一般用于提前注入  &lt;style&gt;  脚本。\n\nSuspense\n\n官方对 空的 fallback 属性的处理方式做了改变：不再跳过 缺失值 或 值为 null 的 fallback 的 Suspense。如果没有指定 fallback 将会把 fallback 呈现为 null。\n批处理在 18 之前，只有在 react 事件处理函数中，才会自动执行批处理，其它情况会多次更新\n在 18 之后，任何情况都会自动执行批处理，多次更新始终合并为一次\n如果想要跳出批处理使用 flushSync\n关于卸载组件时的更新状态警告有的时候会遇到如下的错误\n\n这个错误表示：无法对未挂载（已卸载）的组件执行状态更新。这是一个无效操作，并且表明我们的代码中存在内存泄漏。\n实际上，这个错误并不多见，在以往的版本中，这个警告被广泛误解，并且有些误导。\n这个错误的初衷，原本旨在针对一些特殊场景，譬如 你在 useEffect 里面设置了定时器，或者订阅了某个事件，从而在组件内部产生了副作用，而且忘记 return 一个函数清除副作用，则会发生内存泄漏…… 之类的场景\n但是在实际开发中，更多的场景是，我们在 useEffect 里面发送了一个异步请求，在异步函数还没有被 resolve 或者被 reject 的时候，我们就卸载了组件。 在这种场景中，警告同样会触发。但是，在这种情况下，组件内部并没有内存泄漏，因为这个异步函数已经被垃圾回收了，此时，警告具有误导性。\n综上所述原因，在 React 18 中，官方删除了这个报错。\n返回值类型在 React 18 中，不再检查因返回 undefined 而导致崩溃。既能返回 null，也能返回 undefined。但需要修改相应的 dts 文件。\nStrict Mode严格模式会打印两次日志，可以在 React DevTools 中关闭。\n在 React 17 中，取消了其中一次渲染的控制台日志，以便让日志更容易阅读。\n在 React 18 中，官方取消了这个限制。如果你安装了 React DevTools，第二次渲染的日志信息将显示为灰色，以柔和的方式显式在控制台。\n","categories":["React"],"tags":["React"]},{"title":"① ReactSSR 渲染一个简单组件","url":"/posts/2874c8836f69/","content":"客户端渲染 vs 服务端渲染SSR：服务端渲染（Server side render）\n优点：① 利于 SEO ②TTFP 首屏渲染时间比较快\n缺点：① 复杂度增加 ② 服务器消耗资源增大，需要处理 IO 和执行 JavaScript\n&amp;nbsp;\nCSR：客户端渲染（Client side render）\n优点：① 前后端分离，加快开发效率\n缺点：①TTFP 首屏渲染时间比较长 ② 不能 SEO\n\n\n由服务端返回页面万事开头难，现实服务器返回静态页面。\n使用 Koa 搭建一个 Node 服务器，并在访问根路径的时候返回静态页面。\n\nsrc&#x2F;server.js\n\nimport Koa from &quot;koa&quot;;import Router from &quot;@koa/router&quot;;const router = new Router();const app = new Koa();router.get(&quot;/&quot;, async (ctx, next) =&gt; &#123;  ctx.body = `    &lt;!DOCTYPE html&gt;      &lt;html lang=&quot;en&quot;&gt;      &lt;head&gt;          &lt;meta charset=&quot;UTF-8&quot;&gt;          &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;           &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;          &lt;title&gt;Document&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;          Hello      &lt;/body&gt;    &lt;/html&gt;`;&#125;);app.use(router.routes()).use(router.allowedMethods());app.listen(conf.PORT, () =&gt; &#123;  `server is running in port 3000`;&#125;);\n\n使用 ES6 语法你也可能注意到这里使用了 ES6 的语法，因此需要添加@babel&#x2F;register这个工具，帮助我们在执行 ES6 的 Node 文件时即时编译。\n\n添加 src&#x2F;start.js 入口文件\n\nrequire(&quot;@babel/register&quot;);module.exports = require(&quot;./server&quot;);\n\n\n添加.babelrc 配置文件\n\n需要添加下面几个依赖，注意区分依赖环境\nyarn add @babel/runtimeyarn add core-js@3# 用于定义一些编译后的依赖函数yarn add -D @babel/plugin-transform-runtime\n\n&#123;  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      &#123;        &quot;useBuiltIns&quot;: &quot;entry&quot;,        &quot;corejs&quot;: &quot;3&quot;      &#125;    ]  ],  &quot;plugins&quot;: [&quot;@babel/plugin-transform-runtime&quot;]&#125;\n\n最后使用 node src/start.js 执行入口文件\n使用 TS\n添加 tsconfig.json 配置文件\n\n&#123;  &quot;compilerOptions&quot;: &#123;    /* TypeScript文件编译后生成的javascript文件里的语法应该遵循哪个JavaScript的版本 &quot;ES5&quot;， &quot;ES6&quot;/ &quot;ES2015&quot;， &quot;ES2016&quot;， &quot;ES2017&quot;或 &quot;ESNext&quot;*/    &quot;target&quot;: &quot;es6&quot;,    &quot;jsx&quot;: &quot;react&quot;,    /* 编译后生成的javascript文件中的module，采用何种方式实现，可选项为：&quot;None&quot;， &quot;CommonJS&quot;， &quot;AMD&quot;， &quot;System&quot;， &quot;UMD&quot;， &quot;ES6&quot;或 &quot;ES2015&quot;。 */    &quot;module&quot;: &quot;commonjs&quot;,    /*采用何种方式解析（也就是查找）TypeScript文件中依赖的模块的位置*/    &quot;moduleResolution&quot;: &quot;node&quot; /* Specify how TypeScript looks up a file from a given module specifier. */,    &quot;sourceMap&quot;: true /* Create source map files for emitted JavaScript files. */,    &quot;outDir&quot;: &quot;dist&quot; /* Specify an output folder for all emitted files. */,    &quot;allowSyntheticDefaultImports&quot;: true /* Allow &#x27;import x from y&#x27; when a module doesn&#x27;t have a default export. */,    &quot;esModuleInterop&quot;: true /* Emit additional JavaScript to ease support for importing CommonJS modules. This */,    &quot;forceConsistentCasingInFileNames&quot;: true /* Ensure that casing is correct in imports. */,    &quot;strict&quot;: true /* Enable all strict type-checking options. */,    &quot;noImplicitAny&quot;: true  &#125;,  &quot;include&quot;: [&quot;src/**/*&quot;, &quot;global.d.ts&quot;],  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;**/*.spec.ts&quot;]&#125;\n\n添加 React 组件我们想把 Hello 换成 React 组件试一试，新建 components 文件创建&lt;Hello/&gt;组件并导出\nimport Hello from &quot;react&quot;;const Home: React.FC = () =&gt; &#123;  return &lt;div&gt;Hello&lt;/div&gt;;&#125;;export default Hello;\n\nimport Koa from &quot;koa&quot;;import Home from &quot;../components/home&quot;;const router = new Router();router.get(&quot;/&quot;, async (ctx, next) =&gt; &#123;  ctx.body = &lt;Home /&gt;;&#125;);\n\n再一次运行的时候遇到了问题\n\n因为现在并不能编译 JSX 语法需要添加一些配置。\n如果使用的babel-register,安装依赖后，可以修改.babelrc 文件添加对 react 的支持\n&#123;  &quot;presets&quot;: [&quot;@babel/preset-react&quot;]&#125;\n\n如果使用的是 TS，添加在tsconfig.json中添加 jsx 支持\n&quot;jsx&quot;: &quot;react&quot;,\n\n现在服务器可以正常启动了，但是我们的组件还不能正常加载\n\n这是因为我们的组件只被解析为 React.Element 而不是字符串，所以我们需要使用 ReactDOM 提供的服务端渲染的方法，将 React.Element 转换为字符串\nimport ReactDOMServer from &#x27;react-dom/server&#x27;;router.get(&#x27;/&#x27;,async (ctx,next)=&gt;&#123;    ctx.body= ReactDOMServer.renderToString(&lt;Home /&gt;;&#125;)\n\n现在一个最简单的组件就通过服务端渲染并返回给浏览器。\n","categories":["React"],"tags":["React","SSR"]},{"title":"② ReactSSR 最简单的同构","url":"/posts/6192ec0d02ae/","content":"什么是同构简单说同构就是前后端公用一套代码。\n首先需要明确的是同构是SSR的一种实现方式，同构也是通过服务端渲染，将生成的HTML返回给浏览器展示，但是在React组件中绑定的事件会丢失，因为同构只返回了HTML字符串，并没有返回JavaScript文件。\n所以可以把组件打包成JavaScript文件浏览器中在执行一次，用于绑定交互事件。真实的场景中还会有路由，和数据状态管理工具（redux等）的同步。\n打包的组件也用于在服务端生成HTML字符串，它们公用一套代码这也是同构的本质。\n打包组件把组件打包成一个单独的文件，放在static静态资源目录下面，当浏览器访问的时候会从静态资源文件夹读取文件\n\nwebpack.config.ts\n\nimport * as path from &#x27;path&#x27;;import * as webpack from &#x27;webpack&#x27;;const config: webpack.Configuration = &#123;    entry:&#x27;./src/components/hello.tsx&#x27;,    output:&#123;        filename:&#x27;index.js&#x27;,        path:path.resolve(__dirname,&#x27;static&#x27;)    &#125;,    module:&#123;        rules:[            &#123;                test:/\\.tsx?$/,                use:[&#x27;babel-loader&#x27;]            &#125;        ]    &#125;,    resolve: &#123;        extensions: [&#x27;.tsx&#x27;, &#x27;.ts&#x27;, &#x27;.js&#x27;],    &#125;,    mode:&#x27;development&#x27;,&#125;export default config;\n\n静态资源访问koa提供了一个中间件 koa-static 用于静态资源访问\n注意路径是否正确，如果是在打包好的文件夹中执行，可以通过PWD获取Node进程执行时候的位置\nstatic 用于指定静态资源文件夹的名称，如果想访问static中的文件不需要在路径中添加static, 例如静态资源路径为 static/js/index.js,script 标签中的src路径为 /js/index.js\n最后在返回的HTML中添加打包好的JS文件\n\nsrc&#x2F;server.ts\n\nimport koaStatic from &#x27;koa-static&#x27;;router.get(&#x27;/&#x27;,async (ctx,next)=&gt;&#123;    ctx.body=`        &lt;html lang=&quot;en&quot;&gt;            &lt;body&gt;                $&#123;ReactDOMServer.renderToString(&lt;Home /&gt;)&#125;                &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt;            &lt;/body&gt;        &lt;/html&gt;    `&#125;)app.use(koaStatic(path.join((process.env as any).PWD,&#x27;./static&#x27;))).use(router.routes()).use(router.allowedMethods())app.listen(conf.PORT,()=&gt;&#123;    `server is running in port 3000`&#125;);\n\n点击无效？ 请把组件放在root中按照上面的步骤已经可以在页面中加载 index.js 的文件，但是点击事件并没有生效,这是因为还没有将组件插入到root节点中\n虽然服务端通过HTML直接返回给浏览器可以展示组件，但是在浏览器中执行React打包好的文件的时候需要将节点挂载在元素上，通常为 &lt;div id=&#39;root&#39;&gt;&lt;/div&gt;\n所以尝试添加这样的逻辑\n\nsrc&#x2F;components&#x2F;hello.ts\n\nimport React from &#x27;react&#x27;;const Hello:React.FC = () =&gt;&#123;    return &lt;div onClick=&#123;()=&gt;&#123;alert(&quot;hello&quot;)&#125;&#125;&gt;Hello&lt;/div&gt;&#125;ReactDom.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;));export default Hello;\n\n很不幸会提示一个错误，document没有定义，因为这个组件用于生成HTML字符串，当他被执行的时候node环境中并没有document 这个全局变量\n所以我们把他放到一个新的文件中\n\nsrc&#x2F;component&#x2F;index.ts\n\nimport ReactDom from &#x27;react-dom&#x27;;import React from &#x27;react&#x27;;import Home from &#x27;./home&#x27;ReactDom.render(&lt;Home/&gt;, document.getElementById(&#x27;root&#x27;));\n\n这时没有再报错，但是收到了一个警告 \n\nWarning: render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v18. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML\n\n需要把ReactDOM.render() 替换为 ReactDOM.hydrate()\nReactDom.hydrate(&lt;Home/&gt;, document.getElementById(&#x27;root&#x27;));","categories":["React"],"tags":["React","SSR"]},{"title":"React原理 执行流程与架构","url":"/posts/94ab7cddc99f/","content":"在 react v15 之前成为 stack 架构，从 v16 开始重构了整个架构，新的架构叫做 fiber 架构，最大的改变就是可以进行时间切片。\n\ncpu 瓶颈如果主进程存在大量的计算任务，会阻塞后续的任务,同样也会影响浏览器的绘制任务,从而造成掉帧，用户交互无响应。在 v15 的版本当嵌套组件过多时，虚拟 DOM 会递归执行，导致执行时间过长。\n\nio 瓶颈，对前端来讲 io 瓶颈主要来自于网络，对于 React 所有的更新都来自于内部状态的变化，所以 react 将触发状态变化的事件分为不同的优先级，统一调度这些任务，挡在更新过程中有更高优先级的任务产生，需要中断当前任务，处理更高优先级的任务。\n\n\n因此需要 React 实现任务调度算法，可以中断的 dom 更新，任务分级的机制, 以下是 React 升级的关键设计思想：\n\n在 UI 中，不需要每次更新都立即应用；事实上，这样做可能会造成浪费，导致帧丢失并降低用户体验。\n不同类型的更新有不同的优先级——动画更新需要比数据存储更新更快地完成。\nreact 使用的拉的模式，他会自己安排更新工作，而不需要让程序员推送任务执行的方式。\n\nfiber 相当于代替了之前版本的调用栈信息， 一个 fiber 相当于一个调用栈帧，生命周期比调用栈长，可以保存在内存中，在需要的时候调用。\n为什么在 fiber 架构之前无法中断更新，假设一个列表有 4 个 div 每个 div 中的文字是 2，现在触发一个事件需要将列表中的每个文字更新为 4， stack reconciler 递归的执行每个更新，在更新到第三个元素的时候，如果想要中断了更新那么会让出主进程允许浏览器更新 UI，这就会造成只有三个元素显示了正确的 UI, 造成 UI 和状态不一致。\nfiber 架构的第一个阶段是 render&#x2F;reconciliation, 他会解析当前 fiber 链接起来的树，弄清楚哪些需要更新，这个过程是可以中断的,react 从根节点向下递归，标记那些已经被删除或是更新的节点，并在每个节点处理过后检查是否还剩余处理时间，如果时间不足会中断当前处理让出主线程，当主线程任务结束后会从中断的位置继续处理剩余的节点，所有节点处理完成后，会递归向上回到根节点，将所有需要更新和修改的节点作为一个副作用链表一直连接到 root fiber。\n第二个阶段是提交 commit 阶段，它会将识别到的更改应用到元素上，这一过程是不可以中断的。\n优先级：\n\nSynchronous 同步相当于 stack reconciler\ntask 在下一次事件循环前\nanimation 在下一次渲染之前\nHigh 即使处理\nLow 网络请求等\nOffscreen\n\n整体执行流程\n初始化事件相关对象\n\nregisterSimpleEvents 创建对象相关对象\n\n\n\n\n变量名称\n变量对象\n说明\n\n\n\nallNativeEvents\nSet 集合\n保存所有原生事件的名称 例如 0:&quot;cancel&quot;\n\n\neventPriorities\nMap 集\n保存事件名称和事件优先级对应关系 例如 click=&gt;0 \n\n\ntopLevelEventsToReactNames\nMap 集\n保存原始事件名称和 React 事件的对应关系 例如 &quot;cancel&quot; =&gt; &quot;onCancel&quot; \n\n\nregistrationNameDependencies\nObject\n保存 React 事件和原生事件的对应关系 例如 onClick:(1) [&#39;click&#39;] 每个 React 事件对应一个数组用于保存合成事件对应关系\n\n\npossibleRegistrationNames\nObject\n保存小写的 React 事件名称和正确的驼峰命名事件的对应关系，用于校验用户输入 例如 onclick:onClick\n\n\n入口\nrender : ReactDom.render()createRootImpl : 创建 FiberRootNode 根节点listenToAllSupportedEvents : 绑定所有原生事件在 root 节点上\nrender 阶段\nunbatchedUpdates : 非批量更新，让用户尽早看见页面内容，如果是 batchedUpdates 会以异步执行scheduleUpdateOnFiber : 调度 Fiber 节点更新优先级performUnitOfWork : 以 Fiber 节点为单位，深度优先递归遍历每一个节点reconcileChildren ： 创建对比 Fiber 节点，标记有副作用的节点 （添加，删除，移动，更新）completeUnitOfWork ： 从下至上遍历节点，创建相应的 DOM 节点，并创建 Effects 链表，交给 commit 阶段使用\ncommit 阶段\ncommitBeforeMutationEffects: 操作真实节点前执行，会执行getSnapshotBeforeUpdatecommitMutationEffects: 执行节点操作commitLayoutEffects： 执行副作用函数，包括 componentDidUpdate 或 effect回调函数\nJSXjsx 是 js 语言的扩展，react 通过 babel 词法解析，将 jsx 转换成 React.createElement，React.createElement 方法返回 virtual-dom 对象（内存中用来描述 dom 阶段的对象），所有 jsx 本质上就是 React.createElement 的语法糖，它能声明式的编写我们想要组件呈现出什么样的 ui 效果.\nFiber 双缓存Fiber 对象上面保存了包括这个节点的属性、类型、dom 等，Fiber 通过 child、sibling、return（指向父节点）来形成 Fiber 树，还保存了更新状态时用于计算 state 的 updateQueue，updateQueue 是一种链表结构，上面可能存在多个未计算的 update，update 也是一种数据结构，上面包含了更新的数据、优先级等，除了这些之外，上面还有和副作用有关的信息。\n双缓存是指存在两颗 Fiber 树，current Fiber 树描述了当前呈现的 dom 树，workInProgress Fiber 是正在更新的 Fiber 树，这两颗 Fiber 树都是在内存中运行的，在 workInProgress Fiber 构建完成之后会将它作为 current Fiber 应用到 dom 上\n在 mount 时（首次渲染），会根据 jsx 对象（Class Component 或的 render 函数者 Function Component 的返回值），构建 Fiber 对象，形成 Fiber 树，然后这颗 Fiber 树会作为 current Fiber 应用到真实 dom 上，在 update（状态更新时如 setState）的时候，会根据状态变更后的 jsx 对象和 current Fiber 做对比形成新的 workInProgress Fiber，然后 workInProgress Fiber 切换成 current Fiber 应用到真实 dom 就达到了更新的目的，而这一切都是在内存中发生的，从而减少了对 dom 好性能的操作。\n\nLane 模型react 之前的版本用 expirationTime 属性代表优先级，该优先级和 IO 不能很好的搭配工作（io 的优先级高于 cpu 的优先级），现在有了更加细粒度的优先级表示方法 Lane，Lane 用二进制位表示优先级，二进制中的 1 表示位置，同一个二进制数可以有多个相同优先级的位，这就可以表示‘批’的概念，而且二进制方便计算。\n这好比赛车比赛，在比赛开始的时候会分配一个赛道，比赛开始之后大家都会抢内圈的赛道（react 中就是抢优先级高的 Lane），比赛的尾声，最后一名赛车如果落后了很多，它也会跑到内圈的赛道，最后到达目的地（对应 react 中就是饥饿问题，低优先级的任务如果被高优先级的任务一直打断，到了它的过期时间，它也会变成高优先级）\nLane 的二进制位如下，1 的 bits 越多，优先级越低\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;export const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;\n\nSchedulerScheduler 的作用是调度任务，react15 没有 Scheduler 这部分，所以所有任务没有优先级，也不能中断，只能同步执行。\n我们知道了要实现异步可中断的更新，需要浏览器指定一个时间，如果没有时间剩余了就需要暂停任务，requestIdleCallback 貌似是个不错的选择，但是它存在兼容和触发不稳定的原因，react17 中采用 MessageChannel 来实现。\n在 Scheduler 中的每的每个任务的优先级使用过期时间表示的，如果一个任务的过期时间离现在很近，说明它马上就要过期了，优先级很高，如果过期时间很长，那它的优先级就低，没有过期的任务存放在 timerQueue 中，过期的任务存放在 taskQueue 中，timerQueue 和 timerQueue 都是小顶堆，所以 peek 取出来的都是离现在时间最近也就是优先级最高的那个任务，然后优先执行它。\nreconcilerReconciler 发生在 render 阶段，render 阶段会分别为节点执行 beginWork 和 completeWork，或者计算 state，对比节点的差异，为节点赋值相应的 effectFlags（对应 dom 节点的增删改）。\n协调器是在 render 阶段工作的，简单一句话概括就是 Reconciler 会创建或者更新 Fiber 节点。在 mount 的时候会根据 jsx 生成 Fiber 对象，在 update 的时候会根据最新的 state 形成的 jsx 对象和 current Fiber 树对比构建 workInProgress Fiber 树，这个对比的过程就是 diff 算法。\ndiff 算法发生在 render 阶段的 reconcileChildFibers 函数中，diff 算法分为单节点的 diff 和多节点的 diff（例如一个节点中包含多个子节点就属于多节点的 diff），单节点会根据节点的 key 和 type，props 等来判断节点是复用还是直接新创建节点，多节点 diff 会涉及节点的增删和节点位置的变化。\nreconcile 时会在这些 Fiber 上打上 Flags 标签，在 commit 阶段把这些标签应用到真实 dom 上，这些标签代表节点的增删改，如\nexport const Placement = /*             */ 0b0000000000010;export const Update = /*                */ 0b0000000000100;\n\nrender 阶段遍历 Fiber 树类似 dfs 的过程，处理发生在 beginWork 函数中，该函数做的主要工作是创建 Fiber 节点，计算 state 和 diff 算法，‘冒泡’阶段发生在 completeWork 中，该函数主要是做一些收尾工作，例如处理节点的 props、和形成一条 effectList 的链表，该链表是被标记了更新的节点形成的链表。\nfunction App() &#123;  const [count, setCount] = useState(0);  return (    &lt;&gt;      &lt;h1        onClick=&#123;() =&gt; &#123;          setCount(() =&gt; count + 1);        &#125;&#125;      &gt;        &lt;p title=&#123;count&#125;&gt;&#123;count&#125;&lt;/p&gt; hello      &lt;/h1&gt;    &lt;/&gt;  );&#125;\n\n如果 p 和 h1 节点更新了则 effectList 如下，从 rootFiber-&gt;h1-&gt;p,，顺便说下 fiberRoot 是整个项目的根节点，只存在一个，rootFiber 是应用的根节点，可能存在多个。\n","categories":["React"],"tags":["React"]},{"title":"React原理 组件","url":"/posts/209c6f803ab9/","content":"class类组件\n类组件继承了React.Component &#x2F;react&#x2F;src&#x2F;ReactBaseClasses.js\n\n类组件的updater对象在实例化的时候在被绑定\nfunction Component(props, context, updater) &#123;  this.props = props;      //绑定props  this.context = context;  //绑定context  this.refs = emptyObject; //绑定ref  this.updater = updater || ReactNoopUpdateQueue; //上面所属的updater 对象&#125;/* 绑定setState 方法 */Component.prototype.setState = function(partialState, callback) &#123;  this.updater.enqueueSetState(this, partialState, callback, &#x27;setState&#x27;);&#125;/* 绑定forceUpdate 方法 */Component.prototype.forceUpdate = function(callback) &#123;  this.updater.enqueueForceUpdate(this, callback, &#x27;forceUpdate&#x27;);&#125;\n\n根据上面的源码，可以知道为什么类组件一定要在super函数中传入props\nconstructor(props)&#123;    super(props)    console.log(this.props) // 如果不传，打印 undefined 为什么?&#125;\n\n执行super相当于执行Component函数如果没有传入props,Component函数不能绑定props类属性，在后面的子类中则取不到props\n函数组件\n注意：不要尝试给函数组件 prototype 绑定属性或方法，即使绑定了也没有任何作用，因为通过上面源码中 React 对函数组件的调用，是采用直接执行函数的方式，而不是通过new的方式\n\n对于类组件来说，底层只需要实例化一次，实例中保存了组件的 state 等状态。对于每一次更新只需要调用 render 方法以及对应的生命周期就可以了。但是在函数组件中，每一次更新都是一次新的函数执行，一次函数组件的更新，里面的变量会重新声明。\n为了能让函数组件可以保存一些状态，执行一些副作用钩子，React Hooks 应运而生，它可以帮助记录 React 中组件的状态，处理一些额外的副作用。\n组件常用的通信方式\nprops 和 callback 方式\n\n子组件可以调用父组件传递下来的方法，改变父组件的状态\n\nref 方式。\nReact-redux 或 React-mobx 状态管理方式。\ncontext 上下文方式。\nevent bus 事件总线。\n\nevent bus的本质是观察者模式.\n组件的强化方式\n类组件继承\n\nclass BaseComponent extends React.Component&#123;  constructor(props)&#123;      super(props)      this.state = &#123;        name:&quot;BaseComponent&quot;      &#125;  &#125;  // 内部属性  interFunc ()&#123;    console.log(&#x27;interFunc&#x27;)  &#125;  render()&#123;    return &lt;div&gt;      基础组件 &#123;this.state.name&#125;    &lt;/div&gt;  &#125;&#125;class ExtendsComponent extends BaseComponent &#123;  // 重写父组件方法   interFunc()&#123;    console.log(&#x27;over write interFunc&#x27;)  &#125;  render()&#123;    return &lt;div&gt;      &#123;super.render()&#125;      &lt;p&gt;ExtendsComponent&lt;/p&gt;    &lt;/div&gt;  &#125;&#125;\n\n组件的本质组件的本质就是类和函数，只不过在函数和类上添加了渲染视图（render）或更新视图（setState&#x2F;useState）的逻辑\nreact会像正常实例化类或执行函数一样处理组件\n\n对于类组件的执行，是在react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js中：\n\nfunction constructClassInstance(    workInProgress, // 当前正在工作的 fiber 对象    ctor,           // 我们的类组件    props           // props )&#123;     /* 实例化组件，得到组件实例 instance */     const instance = new ctor(props, context)&#125;\n\n\n对于函数组件的执行，是在react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js中\n\nfunction renderWithHooks(  current,          // 当前函数组件对应的 `fiber`， 初始化  workInProgress,   // 当前正在工作的 fiber 对象  Component,        // 我们函数组件  props,            // 函数组件第一个参数 props  secondArg,        // 函数组件其他参数  nextRenderExpirationTime, //下次渲染过期时间)&#123;     /* 执行我们的函数组件，得到 return 返回的 React.element对象 */     let children = Component(props, secondArg);&#125;\n\n\n初始化的时候会执行组件的函数  &#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.new.js\n\n会按照不同的组件类型，调用不同组件声明的函数来初始化组件\nfunction beginWork(current, workInProgress, renderLanes) &#123;  switch (workInProgress.tag) &#123;    case IndeterminateComponent:      &#123;        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);      &#125;  &#125;&#125;\n\n","categories":["React"],"tags":["React"]},{"title":"React原理 state深入","url":"/posts/9bd2ea4bc399/","content":"同步还是异步batchUpdate批量更新可能并不准确，React 是有多种模式的，基本平时用的都是 legacy 模式下的 React，除了legacy 模式，还有 blocking 模式和 concurrent 模式， blocking 可以视为 concurrent 的优雅降级版本和过渡版本，React 未来将以 concurrent 模式作为默认版本，这个模式下会开启一些新功能。\n对于 concurrent 模式下，会采用不同 State 更新逻辑。前不久透露出未来的React v18 版本，concurrent 将作为一个稳定的功能出现。\nsetState时候发生了什么\n首先，setState 会产生当前更新的优先级（老版本用 expirationTime ，新版本用 lane ）。\n\n接下来 React 会从 fiber Root 根部 root fiber 向下调和子节点，调和阶段将对比发生更新的地方，更新对比 expirationTime ，找到发生更新的组件，合并 state，然后触发 render 函数，得到新的 UI 视图层，完成 render 阶段。\n\n接下来到 commit 阶段，commit 阶段，替换真实 DOM ，完成此次更新流程。\n\n接下来会执行 setState 中 callback 函数,如上的()&#x3D;&gt;{ console.log(this.state.number) }，到此为止完成了一次 setState 全过程。\n\n\n对更新的限制① pureComponent 可以对 state 和 props 进行浅比较，如果没有发生变化，那么组件不更新。\n② shouldComponentUpdate 生命周期可以通过判断前后 state 变化来决定组件需不需要更新，需要更新返回true，否则返回false。\n实现原理setState实际上调用了Component上的updater对象的类方法\n\n&#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.new.js\n\nfunction adoptClassInstance(workInProgress: Fiber, instance: any): void &#123;  instance.updater = classComponentUpdater;  workInProgress.stateNode = instance;&#125;\n\nconst classComponentUpdater = &#123;  enqueueSetState(inst, payload, callback) &#123;    // 获取当前fiber节点    const fiber = getInstance(inst);    // 获取当前更新时间    const eventTime = requestEventTime();    // 获取更新优先级    const lane = requestUpdateLane(fiber);    // 每一次调用`setState`，react 都会创建一个 update     const update = createUpdate(eventTime, lane);    update.payload = payload;    // 保存更新之后的会掉函数    if (callback !== undefined &amp;&amp; callback !== null) &#123;      update.callback = callback;    &#125;    /* enqueueUpdate 把当前的update 传入当前fiber，待更新队列中 */    enqueueUpdate(fiber, update, lane);    // 开始调度更新    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);  &#125;&#125;\n\n批量更新在何时处理？ \n大部分的更新都是由UI交互产生，或异步的方法和函数，例如setTimeout或xhr,批量更新和事件系统息息相关\n事件系统的函数调用过程为：\n\n&#x2F;react-dom&#x2F;src&#x2F;client&#x2F;ReactDOMRoot.js\n\nexport function hydrateRoot(  container: Container,  initialChildren: ReactNodeList,  options?: HydrateRootOptions,): RootType &#123;  // 在root元素上监听所有的时间  listenToAllSupportedEvents(container);&#125;\n\nexport function listenToAllSupportedEvents(rootContainerElement: EventTarget) &#123;    // 循环所有的事件名称，绑定事件    allNativeEvents.forEach(domEventName =&gt; &#123;        listenToNativeEvent(domEventName, true, rootContainerElement);    &#125;);&#125;\n\nfunction listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) &#123;    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);&#125;\n\nfunction addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) &#123;  var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the&#125;\n\nfunction createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) &#123;  var eventPriority = getEventPriorityForPluginSystem(domEventName);  var listenerWrapper;  switch (eventPriority) &#123;    case DiscreteEvent:      listenerWrapper = dispatchDiscreteEvent;      break;    case UserBlockingEvent:      listenerWrapper = dispatchUserBlockingUpdate;      break;    case ContinuousEvent:    default:      listenerWrapper = dispatchEvent;      break;  &#125;  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);&#125;\n\nfunction dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) &#123;  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);&#125; // Attempt dispatching an event. Returns a SuspenseInstance or Container if it&#x27;s blocked.\n\n// 在`legacy`模式下，所有的事件都将经过此函数同一处理 function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) &#123;  batchedEventUpdates(function () &#123;    return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);  &#125;);&#125;\n\nfunction batchedEventUpdates(fn, a, b) &#123;  // 标记为批量更新  // scheduleUpdateOnFiber中会根据这个变量判断是否批量更新  isBatchingEventUpdates = true;  try &#123;    return batchedEventUpdatesImpl(fn, a, b);  &#125; finally &#123;    // try 不会影响finally执行，执行结束后标记为false    isBatchingEventUpdates = false;    finishEventHandler();  &#125;&#125;\n\n\n更新调用栈export default class index extends React.Component&#123;    state = &#123; number:0 &#125;    handleClick= () =&gt; &#123;          this.setState(&#123; number:this.state.number + 1 &#125;,()=&gt;&#123;   console.log( &#x27;callback1&#x27;, this.state.number)  &#125;)          console.log(this.state.number)          this.setState(&#123; number:this.state.number + 1 &#125;,()=&gt;&#123;   console.log( &#x27;callback2&#x27;, this.state.number)  &#125;)          console.log(this.state.number)          this.setState(&#123; number:this.state.number + 1 &#125;,()=&gt;&#123;   console.log( &#x27;callback3&#x27;, this.state.number)  &#125;)          console.log(this.state.number)    &#125;    render()&#123;        return &lt;div&gt;            &#123; this.state.number &#125;            &lt;button onClick=&#123; this.handleClick &#125;  &gt;number++&lt;/button&gt;        &lt;/div&gt;    &#125;&#125; \n\n最终打印的结果是 0,0,0,callback1 ,1,callback2 ,1,callback3 ,1, \n\n如果是异步执行，调用栈会被改变\nsetTimeout(()=&gt;&#123;  this.setState(&#123; number:this.state.number + 1 &#125;,()=&gt;&#123;   console.log( &#x27;callback1&#x27;, this.state.number)  &#125;)  console.log(this.state.number)  this.setState(&#123; number:this.state.number + 1 &#125;,()=&gt;&#123;    console.log( &#x27;callback2&#x27;, this.state.number)  &#125;)  console.log(this.state.number)  this.setState(&#123; number:this.state.number + 1 &#125;,()=&gt;&#123;   console.log( &#x27;callback3&#x27;, this.state.number)  &#125;)  console.log(this.state.number)&#125;)\n\n\n在异步环境批量更新\nimport ReactDOM from &#x27;react-dom&#x27;const &#123; unstable_batchedUpdates &#125; = ReactDOMsetTimeout(()=&gt;&#123;    unstable_batchedUpdates(()=&gt;&#123;        this.setState(&#123; number:this.state.number + 1 &#125;)        console.log(this.state.number)        this.setState(&#123; number:this.state.number + 1&#125;)        console.log(this.state.number)        this.setState(&#123; number:this.state.number + 1 &#125;)        console.log(this.state.number)    &#125;)&#125;)\n\n那么如何提升更新优先级呢？\nReact-dom 提供了 flushSync ，flushSync 可以将回调函数中的更新任务，放在一个较高的优先级中。React 设定了很多不同优先级的更新任务。如果一次更新任务在 flushSync 回调函数内部，那么将获得一个较高优先级的更新。\nhanderClick=()=&gt;&#123;  setTimeout(()=&gt;&#123;      this.setState(&#123; number: 1  &#125;)  &#125;)  this.setState(&#123; number: 2  &#125;)  ReactDOM.flushSync(()=&gt;&#123;      this.setState(&#123; number: 3  &#125;)  &#125;)  this.setState(&#123; number: 4  &#125;)&#125;render()&#123;   console.log(this.state.number)   return ...&#125;\n\n最终结果打印 3,4,1\nflushSync补充说明：flushSync 在同步条件下，会合并之前的 setState | useState，可以理解成，如果发现了 flushSync ，就会先执行更新，如果之前有未更新的 setState ｜ useState ，就会一起合并了，所以就解释了如上，2 和 3 被批量更新到 3 ，所以 3 先被打印。\n综上所述， React 同一级别更新优先级关系是:\nflushSync 中的 setState &gt; 正常执行上下文中 setState &gt; setTimeout ，Promise 中的 setState。\nhooks中的state行为与类中的相似, 需要注意的是，在一个方法中的执行上下文中，是获取不到最新的state\nexport default function Index(props)&#123;  const [ number , setNumber ] = React.useState(0)  /* 监听 number 变化 */  React.useEffect(()=&gt;&#123;      console.log(&#x27;监听number变化，此时的number是:  &#x27; + number )  &#125;,[ number ])  const handerClick = ()=&gt;&#123;      // 遇到下面高优先级更新被合并更新      setNumber(5)       // 和handerClick方法中下面的几个打印函数一样      // 打印值都为0,每次触发更新之后，Index函数都会被重新执行      // number值已经与当前环境绑定      console.log(number);      /** 高优先级更新 **/      ReactDOM.flushSync(()=&gt;&#123;          setNumber(3)       &#125;)      // 批量更新，只会触发一次更新      setNumber(1)       setNumber(2)       console.log(number);      // 滞后更新 ，批量更新规则被打破      setTimeout(()=&gt;&#123;          setNumber(4)           console.log(number);      &#125;)       &#125;;  // 每次函数被重新执行的时候，打印最新的state值  console.log(number)  return &lt;div&gt;      &lt;span&gt; &#123; number &#125;&lt;/span&gt;      &lt;button onClick=&#123; handerClick &#125;  &gt;number++&lt;/button&gt;  &lt;/div&gt;&#125;\n\n\n相同与不同相同： \n首先从原理角度出发，setState和 useState 更新视图，底层都调用了 scheduleUpdateOnFiber 方法，而且事件驱动情况下都有批量更新规则。\n不同: \n在不是 pureComponent 组件模式下， setState 不会浅比较两次 state 的值，只要调用 setState，在没有其他优化手段的前提下，就会执行更新。但是 useState 中的 dispatchAction 会默认比较两次 state 是否相同，然后决定是否更新组件。\nsetState 有专门监听 state 变化的回调函数 callback，可以获取最新state；但是在函数组件中，只能通过 useEffect 来执行 state 变化引起的副作用。\nsetState 在底层处理逻辑上主要是和老 state 进行合并处理，而 useState 更倾向于重新赋值。\n","categories":["React"],"tags":["React"]},{"title":"③ ReactSSR 实现路由","url":"/posts/31dff1f45ed2/","content":"整理文件结构最后的文件结构会变为下面的结构，有一些文件需要我们去继续完善\nsrc/├── app koa服务器相关文件│   ├── errorHandle.ts│   └── index.ts├── components 组件文件夹│   ├── header│   │   ├── header.tsx (新增)│   │   └── index.tsx (新增)│   ├── hello│   │   ├── hello.tsx│   │   └── index.tsx│   ├── index.tsx 组件的入口│   ├── login│   │   ├── index.tsx│   │   └── login.tsx│   ├── router.tsx 客户端路由 (新增)│   └── routes.tsx 路由子项，可以和服务端渲染公用 (新增)├── config│   └── default.config.ts├── router│   ├── index.tsx koa的路由配置│   └── router.tsx 服务端路由 (新增)├── server.ts koa服务器入口文件└── util    └── errorTypes.ts\n\n客户端添加路由添加一个简单的&lt;Header/&gt;组件，使用&lt;Link/&gt;组件添加路由跳转\nimport React from &quot;react&quot;;import &#123;  Link&#125; from &quot;react-router-dom&quot;;const Header:React.FC = () =&gt;&#123;    return &lt;div&gt;       &lt;Link to=&quot;/&quot;&gt;hello&lt;/Link&gt;       &lt;Link to=&quot;/login&quot;&gt;login&lt;/Link&gt;    &lt;/div&gt;&#125;export default Header;\n\n\n添加 src&#x2F;routes.ts 提取路由公用部分\n\nimport React from &quot;react&quot;;import &#123;    Switch,    Route,  &#125; from &quot;react-router-dom&quot;;  import Hello  from &quot;./hello&quot;;import Login  from &quot;./login&quot;;const Routes = () =&gt; &#123;  return (    &lt;Switch&gt;        &lt;Route path=&quot;/hello&quot;&gt;            &lt;Hello /&gt;        &lt;/Route&gt;        &lt;Route path=&quot;/login&quot;&gt;            &lt;Login /&gt;        &lt;/Route&gt;        &lt;Route path=&quot;/&quot;&gt;            &lt;Hello /&gt;        &lt;/Route&gt;    &lt;/Switch&gt;  )&#125;export default Routes;\n\n\n添加 src&#x2F;router.ts 客户端路由\n\nimport React from &quot;react&quot;;import Koa from &#x27;koa&#x27;;import &#123;  BrowserRouter,&#125; from &quot;react-router-dom&quot;;import Routes from &#x27;./routes&#x27;const Router:React.FC&lt;unknown&gt; = () =&gt;&#123;    return (        &lt;BrowserRouter&gt;            &lt;Routes /&gt;        &lt;/BrowserRouter&gt;    )&#125;export default Router;\n\n\nsrc&#x2F;index.ts 最终导出App\n\nimport ReactDom from &#x27;react-dom&#x27;;import React from &#x27;react&#x27;;import Router from &#x27;./router&#x27;;const App = () =&gt; &#123;        return &lt;Router /&gt;&#125;ReactDom.hydrate(&lt;App/&gt;, document.getElementById(&#x27;root&#x27;));\n\n服务端路由\n添加 router&#x2F;touter.ts\n\n因为服务端并不能感知到路由的变化，所以需要手动传递路由\n当客户端渲染了一个 &lt;Redirect&gt; 浏览器历史改变并显示了新的屏幕，在服务端不能改变App的状态，所以使用context拿到渲染的结果，如果可以拿到context.url,就可以知道重定向的结果。可以让我们在服务中发起重定向.\nimport React from &quot;react&quot;;import Koa from &#x27;koa&#x27;;import &#123;    StaticRouter,&#125; from &quot;react-router-dom&quot;;import Routes from &#x27;../components/routes&#x27;const context=&#123;&#125;;const Router:React.FC&lt;unknown&gt; = (&#123;ctx&#125;) =&gt;&#123;    return (        &lt;StaticRouter location=&#123;ctx.url&#125; context=&#123;context&#125;&gt;            &lt;Routes /&gt;        &lt;/StaticRouter&gt;    )&#125;export default Router;\n\n\nrouter&#x2F;index.tsx\n\n需要添加root元素，并匹配所有路径\nimport Router from &#x27;@koa/router&#x27;;import ReactDOMServer from &#x27;react-dom/server&#x27;;import React from &#x27;react&#x27;;import App from &#x27;./router&#x27;;const router = new Router();router.get(&quot;/(.*)&quot;,async (ctx,next)=&gt;&#123;    console.log(ctx);    ctx.body=`    &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;            &lt;title&gt;Document&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;            &lt;div id=&#x27;root&#x27;&gt;$&#123;ReactDOMServer.renderToString(&lt;App &#123;...&#123;ctx&#125;&#125;/&gt;)&#125;&lt;/div&gt;            &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt;        &lt;/body&gt;        &lt;/html&gt;    `&#125;)export default router;","categories":["React"],"tags":["React","SSR"]},{"title":"React原理 JSX基础","url":"/posts/1833ee36d2f0/","content":"JSX是什么JSX是一种JavaScript的语法扩展，运用于React架构中，其格式比较像是模版语言，但事实上完全是在JavaScript内部实现的。元素是构成React应用的最小单位，JSX就是用来声明React当中的元素，React使用JSX来描述用户界面。\nconst A = ()=&gt;&#123;  return &lt;div id=&#x27;root&#x27;&gt;&lt;/div&gt;&#125;\n\n最后JSX变成什么显然JSX并不是标准的JS语法，需要转换成标准的JS语法浏览器才能识别 \nfunction() &#123;  React.createElement(&quot;div&quot;, &#123;      style: &#123;          height: 200      &#125;  &#125;, React.createElement(&quot;div&quot;, &#123;      onClick: function(e) &#123;          return console.log(e)      &#125;  &#125;), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].map((function(t) &#123;      return React.createElement(&quot;span&quot;, &#123;          key: t      &#125;, t)  &#125;  )))&#125;\n\n所有的JSX代码最终都会变成 React.createElement的函数调用\nReact.createElement(&#123;  // 组件类型 div等字符串  type,  // 一个对象，对应dom中的标签属性  [props],  // 子元素按原有顺序排列  [...children]&#125;)\n\n在老版本中由于编译后的代码会变成React.createElement的函数调用，所以必须在文件中引入React,17版以后\ncreateElement 做了如下几件事\n\n处理config，把除了保留属性外的其他config赋值给props\n把children处理后赋值给props.children\n处理defaultProps\n调用ReactElement返回一个jsx对象(virtual-dom)\n\njsx对象上没有优先级、状态、effectTag等标记，这些标记在Fiber对象上，在mount时Fiber根据jsx对象来构建，在update时根据最新状态的jsx和current Fiber对比，形成新的workInProgress Fiber，最后workInProgress Fiber切换成current Fiber。\n下面描述了JSX被转换之后，以及生成的type类型\n&lt;div style=&#123;&#123;height:200&#125;&#125;&gt;  &lt;React.Fragment&gt;&lt;/React.Fragment&gt; &#123;/*Fragment组件*/&#125;  string children                   &#123;/*string类型子元素*/&#125;  &lt;FunctionComponent/&gt;              &#123;/*函数式组件*/&#125;  &lt;ClassComponent/&gt;                 &#123;/*类组件组件*/&#125;  &#123;/*绑定属性*/&#125;  &lt;div onClick = &#123;(e)=&gt; console.log(e)&#125;&gt;&lt;/div&gt;  &#123;/*数组类型子元素*/&#125;  &#123;[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;].map(item=&gt; &lt;span key=&#123;item&#125;&gt;&#123;item&#125;&lt;/span&gt;)&#125;&lt;/div&gt;\n\n\n\n\n\njsx元素类型\n通过createElement转换\ntype属性\n\n\n\n原生标签\nreact element类型\ntagname 例如span div\n\n\nfragment类型\nreact element类型\nsymbol react.fragment类型\n\n\n文本类型\n直接返回字符串\n无\n\n\n数组类型\n返回数组，数组中的元素按上述规则转换\n无\n\n\n类组件\nreact element类型\n类组件引用\n\n\n函数组件\nreact element类型\n函数组件引用\n\n\n三元表达式\n执行运算后的结果按上述规则匹配\n无\n\n\n函数调用\n执行运算后的结果按上述规则匹配\n无\n\n\nReact针对不同React element元素会产生不通的tag（种类），也就是不同的fiber对象， 在ReactWorkTags.js定义了tag种类\nexport const FunctionComponent = 0;              // 函数组件export const ClassComponent = 1;                 // 类组建export const IndeterminateComponent = 2;         // 在不知道是函数组件还是类组件的时候export const HostRoot = 3;                       // Root Fiber 必须呗包含在另一个节点中export const HostPortal = 4;                     // 通过createPortal创建的fiber子树，可能是另一个渲染的入口export const HostComponent = 5;export const HostText = 6;export const Fragment = 7;export const Mode = 8;                           // &lt;React.StrictMode&gt;export const ContextConsumer = 9;export const ContextProvider = 10;export const ForwardRef = 11;export const Profiler = 12;                      // &lt;Profiler /&gt;export const SuspenseComponent = 13;export const MemoComponent = 14;export const SimpleMemoComponent = 15;export const LazyComponent = 16;export const IncompleteClassComponent = 17;export const DehydratedFragment = 18;export const SuspenseListComponent = 19;export const ScopeComponent = 21;export const OffscreenComponent = 22;export const LegacyHiddenComponent = 23;export const CacheComponent = 24;\n\n最终JSX会变成由Fiber节点组成的链表\n数组结构中的子节点会作为Fragment的子节点\nfunction FiberNode(  tag: WorkTag,  pendingProps: mixed,  key: null | string,  mode: TypeOfMode,) &#123;  // Instance  this.tag = tag;  this.key = key;  this.elementType = null;  this.type = null;  this.stateNode = null;  // Fiber  this.return = null;  // 指向父级fiber节点  this.child = null;   // 指向子级fiber节点  this.sibling = null; // 指向兄弟fiber节点  this.index = 0;  this.ref = null;  this.pendingProps = pendingProps;  this.memoizedProps = null;  this.updateQueue = null;  this.memoizedState = null;  this.dependencies = null;  this.mode = mode;  // Effects  this.flags = NoFlags;  this.subtreeFlags = NoFlags;  this.deletions = null;  this.lanes = NoLanes;  this.childLanes = NoLanes;  this.alternate = null;&#125;\n\n\n对元素进行操作\nReact.Children.toArray 拍平子元素\n\nconst Element = (  &lt;div style=&#123;&#123;height:200&#125;&#125;&gt;    &lt;React.Fragment&gt;&lt;/React.Fragment&gt;    string children    &lt;FunctionComponent/&gt;    &lt;ClassComponent/&gt;    &lt;div onClick = &#123;(e)=&gt; console.log(e)&#125;&gt;&lt;/div&gt;    &#123;[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;].map(item=&gt; &lt;span key=&#123;item&#125;&gt;&#123;item&#125;&lt;/span&gt;)&#125;  &lt;/div&gt;)React.Children.toArray(Element.props.children)\n\n\n\n遍历子节点 React.Children.forEach React.Children.map\n\n在 children 里的每个直接子节点上调用一个函数，并将 this 设置为 thisArg。如果 children 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 null 或是 undefined，则此方法将返回 null 或是 undefined，而不会返回数组。\n如果 children 是一个 Fragment 对象，它将被视为单一子节点的情况处理，而不会被遍历。\nReact.Children.map(children, function[(thisArg)])\n\n\nReact.Children.only\n\n验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。\nReact.Children.only(children)\n\n\nReact.cloneElement 克隆元素\n\n以 element 元素为样板克隆并返回新的 React 元素。config 中应包含新的 props，key 或 ref。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。新的子元素将取代现有的子元素，如果在 config 中未出现 key 或 ref，那么原始元素的 key 和 ref 将被保留。\nReact.cloneElement(  element,  [config],  [...children])\n\nReact.cloneElement() 几乎等同于：\n&lt;element.type &#123;...element.props&#125; &#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt;\n\n但是，这也保留了组件的 ref。这意味着当通过 ref 获取子节点时，你将不会意外地从你祖先节点上窃取它。相同的 ref 将添加到克隆后的新元素中。如果存在新的 ref 或 key 将覆盖之前的。\n","categories":["React"],"tags":["React","JSX"]},{"title":"React原理 props深入","url":"/posts/8d49fda41a82/","content":"props的几种用法① props 作为一个子组件渲染数据源。② props 作为一个通知父组件的回调函数。③ props 作为一个单纯的组件传递。④ props 作为渲染函数。⑤ render props ， 和④的区别是放在了 children 属性上。⑥ render component 插槽组件。\n/* children 组件 */function ChidrenComponent()&#123;    return &lt;div&gt; In this chapter, let&#x27;s learn about react props ! &lt;/div&gt;&#125;/* props 接受处理 */class PropsComponent extends React.Component&#123;    componentDidMount()&#123;        console.log(this,&#x27;_this&#x27;)    &#125;    render()&#123;        const &#123;  children , mes , renderName , say ,Component &#125; = this.props        const renderFunction = children[0]        const renderComponent = children[1]        /* 对于子组件，不同的props是怎么被处理 */        return &lt;div&gt;            &#123; renderFunction() &#125;            &#123; mes &#125;            &#123; renderName() &#125;            &#123; renderComponent &#125;            &lt;Component /&gt;            &lt;button onClick=&#123; () =&gt; say() &#125; &gt; change content &lt;/button&gt;        &lt;/div&gt;    &#125;&#125;/* props 定义绑定 */class Index extends React.Component&#123;    state=&#123;          mes: &quot;hello,React&quot;    &#125;    node = null    say= () =&gt;  this.setState(&#123; mes:&#x27;let us learn React!&#x27; &#125;)    render()&#123;        return &lt;div&gt;            &lt;PropsComponent                 mes=&#123;this.state.mes&#125;  // ① props 作为一个渲染数据源               say=&#123; this.say  &#125;     // ② props 作为一个回调函数 callback               Component=&#123; ChidrenComponent &#125; // ③ props 作为一个组件               renderName=&#123; ()=&gt;&lt;div&gt; my name is alien &lt;/div&gt; &#125; // ④ props 作为渲染函数            &gt;                &#123; ()=&gt; &lt;div&gt;hello,world&lt;/div&gt;  &#125; &#123; /* ⑤render props */ &#125;                &lt;ChidrenComponent /&gt;             &#123; /* ⑥render component */ &#125;            &lt;/PropsComponent&gt;        &lt;/div&gt;    &#125;&#125;\n\n监听props改变类组件\ngetDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。\n函数组件\n函数组件中同理可以用 useEffect 来作为 props 改变后的监听函数。\nprops+children 最佳实践增强子组件\n通过 props.children 属性访问到 Chidren 组件，为 React element 对象。\n\n可以根据需要控制 Chidren 是否渲染。\n\nContainer 可以用 React.cloneElement 强化 props (混入新的 props )，或者修改 Chidren 的子元素。\n\n\n&lt;Container&gt;    &lt;Children&gt;&lt;/Container&gt;\n\n\n函数式子组件\n\n根据需要控制 Chidren 渲染与否。\n可以将需要传给 Children 的 props 直接通过函数参数的方式传递给执行函数 children 。\n\n&lt;Container&gt;   &#123; (ContainerProps)=&gt; &lt;Children &#123;...ContainerProps&#125;  /&gt; &#125;&lt;/Container&gt;\n\n像下面这种情况下 children 是不能直接渲染的，直接渲染会报错。\nfunction  Container(props) &#123;    const  ContainerProps = &#123;        name: &#x27;alien&#x27;,        mes:&#x27;let us learn react&#x27;    &#125;    return  props.children(ContainerProps)&#125;\n\n混合使用\n&lt;Container&gt;    &lt;Children /&gt;    &#123; (ContainerProps)=&gt; &lt;Children &#123;...ContainerProps&#125; name=&#123;&#x27;haha&#x27;&#125;  /&gt;  &#125;&lt;/Container&gt;\n\nconst Children = (props)=&gt; (&lt;div&gt;    &lt;div&gt;hello, my name is &#123;  props.name &#125; &lt;/div&gt;    &lt;div&gt; &#123; props.mes &#125; &lt;/div&gt;&lt;/div&gt;)function  Container(props) &#123;    const ContainerProps = &#123;        name: &#x27;alien&#x27;,        mes:&#x27;let us learn react&#x27;    &#125;     return props.children.map(item=&gt;&#123;        if(React.isValidElement(item))&#123; // 判断是 react elment  混入 props            return React.cloneElement(item,&#123; ...ContainerProps &#125;,item.props.children)        &#125;else if(typeof item === &#x27;function&#x27;)&#123;            return item(ContainerProps)        &#125;else return null     &#125;)&#125;const Index = ()=&gt;&#123;    return &lt;Container&gt;        &lt;Children /&gt;        &#123; (ContainerProps)=&gt; &lt;Children &#123;...ContainerProps&#125; name=&#123;&#x27;haha&#x27;&#125;  /&gt;  &#125;    &lt;/Container&gt;&#125;\n\nprops的意义层级间数据传递\n父组件 props 可以把数据层传递给子组件去渲染消费。另一方面子组件可以通过 props 中的 callback ，来向父组件传递信息。还有一种可以将视图容器作为 props 进行渲染。\nReact 可以把组件的闭合标签里的插槽，转化成 children 属性，一会将详细介绍这个模式。\n用于更新判断\n在 React 中，props 在组件更新中充当了重要的角色，在 fiber 调和阶段中，diff 可以说是 React 更新的驱动器，熟悉 vue 的同学都知道 vue 中基于响应式，数据的变化，就会颗粒化到组件层级，通知其更新，但是在 React 中，无法直接检测出数据更新波及到的范围，props 可以作为组件是否更新的重要准则，变化即更新，于是有了 PureComponent ，memo 等性能优化方案。\n使用技巧使用剩余参数过滤props\nfunction Father(props)&#123;    const &#123; age,...fatherProps  &#125; = props    return &lt;Son  &#123; ...fatherProps &#125;  /&gt;&#125;\n\n混合props\nfunction Father(prop)&#123;    return React.cloneElement(prop.children,&#123;  mes:&#x27;let us learn React !&#x27; &#125;)&#125;\n\n","categories":["React"],"tags":["React"]},{"title":"④ ReactSSR 接入redux","url":"/posts/a8dd4b44a192/","content":"创建Action\n&#x2F;src&#x2F;components&#x2F;hello&#x2F;action.ts\n\nimport &#123; Dispatch, ActionCreator &#125; from &quot;redux&quot;;import axios, &#123; AxiosResponse &#125; from &#x27;axios&#x27;export const LOAD_DATA = &#x27;LOAD_DATA&#x27;;export type LOAD_DATA_TYPE = typeof LOAD_DATA;interface FetchDataInterface &#123;    (match?: any): Promise&lt;AxiosResponse&gt;&#125;const fetchData: FetchDataInterface = (match) =&gt; axios(&#x27;https://fakestoreapi.com/products&#x27;);interface ServerLoadDataInterface &#123;    (match: any): Promise&lt;any&gt;&#125;export const serverLoadData: ServerLoadDataInterface = (match) =&gt; fetchData().then((&#123; data &#125;) =&gt; (&#123; hello: &#123; shopData: data &#125; &#125;));const loadDataAction: ActionCreator&lt;&#123; type: LOAD_DATA_TYPE &#125;&gt; = (payload) =&gt; (&#123;    type: LOAD_DATA,    payload,&#125;)export type ActionTypes = LOAD_DATA_TYPE;export const loadData = () =&gt; (dispatch: Dispatch) =&gt; fetchData().then((&#123; data &#125;) =&gt; dispatch(loadDataAction(data)));\n\n创建reducer\n&#x2F;src&#x2F;components&#x2F;hello&#x2F;reducer.ts\n\nimport &#123;AnyAction,Reducer&#125; from &#x27;redux&#x27;;import &#123;    LOAD_DATA,&#125; from &#x27;./action&#x27;;import &#123; StoreType &#125; from &#x27;.&#x27;;const initStore = &#123;    shopData:[]&#125;const hello:Reducer&lt;StoreType,AnyAction&gt; = (state=initStore, action) =&gt; &#123;    switch (action.type) &#123;        case LOAD_DATA:            return (&#123;...state,shopData:action.payload&#125;)        default:            return state;    &#125;&#125;export default hello;\n\n\nconnect Hello组件\n&#x2F;src&#x2F;components&#x2F;hello&#x2F;hello.ts\n\nimport React from &#x27;react&#x27;;import &#123; bindActionCreators,Dispatch &#125; from &#x27;redux&#x27;;import &#123;connect&#125; from &#x27;react-redux&#x27;;import &#123; StoreType &#125; from &#x27;../../store&#x27;;import Header from &#x27;../header&#x27;;import &#123;loadData&#125; from &#x27;./action&#x27;;type HelloComponentProps = &#123;    loadData:()=&gt;void,    shopData:Array&lt;any&gt;,&#125;;const Hello:React.FC&lt;HelloComponentProps&gt; = (props) =&gt;&#123;    const &#123;        loadData,        shopData    &#125; = props;        React.useEffect(()=&gt;&#123;        loadData();    &#125;,[])    return &lt;div&gt;        &lt;Header/&gt;        &#123;            shopData.map(item=&gt; &lt;h6 onClick=&#123;()=&gt;&#123;alert(&quot;hello&quot;)&#125;&#125; key=&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;/h6&gt;)        &#125;    &lt;/div&gt;&#125;const mapStateToProps = (state:StoreType) =&gt; &#123;    return &#123;        shopData:state.hello.shopData    &#125;  &#125;    const mapDispatchToProps = (dispatch:Dispatch) =&gt; &#123;    return &#123;        loadData: bindActionCreators(loadData,dispatch)    &#125;  &#125;export default connect(mapStateToProps,mapDispatchToProps)(Hello) ;\n\n修改 Hello 组件入口文件 index.ts\n暴露服务端渲染时需要的数据请求方法\n\n添加store类型，暴露到外部的 store&#x2F;index.js 统一描述store类型\n\n\nimport Hello from &quot;./hello&quot;;import &#123;serverLoadData&#125; from &#x27;./action&#x27;;export interface StoreType &#123;    shopData:Array&lt;any&gt;&#125;export &#123;    serverLoadData&#125;;export default Hello;\n\n创建全局的store\nsrc&#x2F;store&#x2F;index.ts\n\n用于生成store对象\nimport &#123; Provider &#125; from &#x27;react-redux&#x27;import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import thunk from &#x27;redux-thunk&#x27;import reducers from &#x27;./reducers&#x27;;import &#123; StoreType as HelloStoreType &#125; from &#x27;../components/hello&#x27;;const browserStore = ()=&gt; createStore(reducers, (window as any).__HYDRATE_DATA__, applyMiddleware(thunk));const serverStores = (__HYDRATE_DATA__: any) =&gt; createStore(reducers, __HYDRATE_DATA__, applyMiddleware(thunk));export type StoreType = &#123;    hello: HelloStoreType&#125;export &#123;    Provider,    browserStore,    serverStores&#125;\n\n\nsrc&#x2F;store&#x2F;reducers.ts\n\n合并所有组件中的reducer\nimport &#123; combineReducers &#125; from &#x27;redux&#x27;;import hello from &#x27;../components/hello/reducer&#x27;;export default combineReducers(&#123;    hello&#125;)\n\n服务端预加载数据，改造routers之前的routers是一个JSX元素，现在想调用组件暴露出的服务端请求数据的方法，并在拿到结果重新渲染组件，生成html字符串，并返回给浏览器\n所以第一步：改造routers让我们可以拿到数据请求的方法\n\nsrc&#x2F;components&#x2F;routes.tsx\n\nimport Hello, &#123; serverLoadData as helloServerLoadData &#125; from &quot;./hello&quot;;import Login from &quot;./login&quot;;const routes = [    &#123;        path: &quot;/hello&quot;,        exact: true,        component: Hello,        loadData: (match:any) =&gt; helloServerLoadData(match)    &#125;,    &#123;        path: &quot;/login&quot;,        exact: true,        component: Login,    &#125;,    &#123;        path: &quot;/&quot;,        component: Hello,        exact: true,        loadData: (match:any) =&gt; helloServerLoadData(match)    &#125;,];export default routes;\n\n\nsrc&#x2F;components&#x2F;router.tsx\n\n循环生成路由组件\nimport React from &quot;react&quot;;import Koa from &#x27;koa&#x27;;import &#123;    BrowserRouter,    Switch,    Route&#125; from &quot;react-router-dom&quot;;import routes from &#x27;./routes&#x27;interface RouterProps &#123;    ctx?: Koa.BaseContext&#125;const Router: React.FC&lt;RouterProps&gt; = () =&gt; &#123;    return (        &lt;BrowserRouter&gt;            &lt;Switch&gt;                &#123;routes.map(route =&gt; (                    &lt;Route &#123;...route&#125; key=&#123;route.path&#125; /&gt;                ))&#125;            &lt;/Switch&gt;        &lt;/BrowserRouter&gt;    )&#125;export default Router;\n\n匹配路由对应的组件react-router-config 用于匹配包括子路由在内的所有路由配置对应的组件\n在拿到所有的匹配项之后，循环调用所有组件的数据请求方法，并把返回的promise对象放到一个数组中\n当所有的返回值拿到之后，组合所有的state,初始化React组件，并渲染成字符串返回给浏览器\nimport Router from &#x27;@koa/router&#x27;;import ReactDOMServer from &#x27;react-dom/server&#x27;;import React from &#x27;react&#x27;;import App from &#x27;./router&#x27;;import routes from &#x27;../components/routes&#x27;import &#123; matchRoutes &#125; from &quot;react-router-config&quot;;const router = new Router();router.get(&quot;/(.*)&quot;,async (ctx,next)=&gt;&#123;    const promises:Array&lt;any&gt; = matchRoutes(routes,ctx.request.path).map((&#123;route,match&#125;)=&gt; route.loadData?route.loadData(match):Promise.resolve());    const preloadData = await Promise.all(promises);    const __HYDRATE_DATA__ = preloadData.reduce((res,data)=&gt;Object.assign(&#123;&#125;,res,data) ,&#123;&#125;);    ctx.body=`    &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;                &lt;title&gt;Document&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                &lt;div id=&#x27;root&#x27;&gt;$&#123;ReactDOMServer.renderToString(&lt;App &#123;...&#123;ctx,__HYDRATE_DATA__&#125;&#125;/&gt;)&#125;&lt;/div&gt;                &lt;script&gt;                    window.__HYDRATE_DATA__ = $&#123;JSON.stringify(__HYDRATE_DATA__)&#125;                &lt;/script&gt;                &lt;script src=&#x27;/index.js&#x27;&gt;&lt;/script&gt;            &lt;/body&gt;        &lt;/html&gt;    `&#125;)export default router;\n\n\n数据脱水和注水\n服务端渲染的时候需要把整合之后的store传入到初始化函数中，用于渲染Html字符串\n\n客户端渲染的时候，由于第一次渲染是并没有数据，会覆盖掉服务端渲染的结构，并重新请求后在渲染，这中间的过程就会白屏所以会在服务端直接把数据以字符串的方式插入到html界面中，在客户端解析的时候会变成window下的一个store对象，这个过程就叫做数据注水\n\n当客户端初始化时，会尝试查找window下有没有服务端插入的数据，如果有就用这个数据作为初始化数据，从而防止两边状态不统一造成的白屏，这一过程也叫做数据脱水\n\n\n","categories":["React"],"tags":["React","SSR"]},{"title":"React原理 生命周期","url":"/posts/afa1cc89da08/","content":"预备React 有两个重要阶段，render 阶段和 commit 阶段，React 在调和( render )阶段会深度遍历 React fiber 树，目的就是发现不同( diff )，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了commit 阶段，commit 阶段会创建修改真实的 DOM 节点。\n\n类组件的处理逻辑在beginWork中被调用，react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js\n\n① instance 类组件对应实例。② workInProgress 树，当前正在调和的 fiber 树 ，一次更新中，React 会自上而下深度遍历子代 fiber ，如果遍历到一个 fiber ，会把当前 fiber 指向 workInProgress。③ current 树，在初始化更新中，current &#x3D; null ，在第一次 fiber 调和之后，会将 workInProgress 树赋值给 current 树。React 来用workInProgress 和 current 来确保一次更新中，快速构建，并且状态不丢失。④ Component 就是项目中的 class 组件。⑤ nextProps 作为组件在一次更新中新的 props 。⑥ renderLanes 作为下一次渲染的优先级。\n在组件实例上可以通过 _reactInternals 属性来访问组件对应的 fiber 对象。在 fiber 对象上，可以通过 stateNode 来访问当前 fiber 对应的组件实例。\nclass Instance . _reactInternals &#x3D;&gt; class Fiber\nclass Fiber . stateNode &#x3D;&gt; class Instance\nfunction updateClassComponent(  current: Fiber | null,  workInProgress: Fiber,  Component: any,  nextProps: any,  renderLanes: Lanes,) &#123;  // stateNode 是 fiber 指向 类组件实例的指针。  const instance = workInProgress.stateNode;  let shouldUpdate;  // instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程  if (instance === null) &#123;    // 在这个方法中组件通过new被实例化    constructClassInstance(workInProgress, Component, nextProps);    // 初始化挂载组件流程    mountClassInstance(workInProgress, Component, nextProps, renderLanes);    // shouldUpdate 标识用来证明 组件是否需要更新。    shouldUpdate = true;  &#125; else if (current === null) &#123;    // 已经存在了一个实例可以被复用    shouldUpdate = resumeMountClassInstance(      workInProgress,      Component,      nextProps,      renderLanes,    );  &#125; else &#123;    // 更新组件流程    shouldUpdate = updateClassInstance(      current,      workInProgress,      Component,      nextProps,      renderLanes,    );  &#125;  const nextUnitOfWork = finishClassComponent(    current,    workInProgress,    Component,    shouldUpdate,    hasContext,    renderLanes,  );  return nextUnitOfWork;&#125;\n\nfunction finishClassComponent(  current: Fiber | null,  workInProgress: Fiber,  Component: any,  shouldUpdate: boolean,  hasContext: boolean,  renderLanes: Lanes,) &#123;  // 即使 shouldComponentUpdate 返回了 false,Refs也应该被更新  markRef(current, workInProgress);  const instance = workInProgress.stateNode;  // Rerender  ReactCurrentOwner.current = workInProgress;  // 获取子节点  let nextChildren = instance.render();  // 调和子节点  reconcileChildren(current, workInProgress, nextChildren, renderLanes);  // Memoize state using the values we just used to render.  // TODO: Restructure so we never read values from the instance.  workInProgress.memoizedState = instance.state;  // The context might have changed so we need to recalculate it.  if (hasContext) &#123;    invalidateContextProvider(workInProgress, Component, true);  &#125;  return workInProgress.child;&#125;\n\n\n初始化阶段constructClassInstance构建了组件的实例，在实例化组件之后，会调用 mountClassInstance 组件初始化。\n\nreact-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js\n\n// 在从没有渲染过的实例上执行挂载生命周期function mountClassInstance(  workInProgress: Fiber,  ctor: any,  newProps: any,  renderLanes: Lanes,): void &#123;  // 组件实例  const instance = workInProgress.stateNode;  instance.props = newProps;  instance.state = workInProgress.memoizedState;  instance.refs = emptyRefsObject;  initializeUpdateQueue(workInProgress);    // 拿到类组件构造函数的静态方法  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;    if (typeof getDerivedStateFromProps === &#x27;function&#x27;) &#123;        var prevState = workInProgress.memoizedState;        // 返回更新之后的state        var partialState = getDerivedStateFromProps(nextProps, prevState);        // 如果返回的state不合法，使用原有状态，否则合并两个状态生成一个新的state对象        var memoizedState = partialState === null || partialState === undefined ? prevState : _assign(&#123;&#125;, prevState, partialState);        workInProgress.memoizedState = memoizedState;                 // Once the update queue is empty, persist the derived state onto the        // base state.        if (workInProgress.lanes === NoLanes) &#123;            // Queue is always non-null for classes            var updateQueue = workInProgress.updateQueue;            updateQueue.baseState = memoizedState;        &#125;        instance.state = workInProgress.memoizedState;    &#125;  if (typeof instance.componentDidMount === &#x27;function&#x27;) &#123;    workInProgress.flags |= fiberFlags;  &#125;&#125;\n\nrender 函数执行\n到此为止 mountClassInstance 函数完成，但是上面 updateClassComponent 函数， 在执行完 mountClassInstance 后，执行了 render 渲染函数，形成了 children ， 接下来 React 调用 reconcileChildren 方法深度调和 children 。\ncomponentDidMount函数执行\n上述提及的几生命周期都是在 render 阶段执行的。一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 componentDidMount 生命周期。\nfunction commitRootImpl(root, renderPriorityLevel)&#123;    const finishedWork = root.finishedWork;    commitLayoutEffects(finishedWork, root, lanes);&#125;\n\n17.0.2\nfunction commitLifeCycles(finishedRoot,current,finishedWork)&#123;     switch (finishedWork.tag)&#123;                             /* fiber tag 在第一节讲了不同fiber类型 */        case ClassComponent: &#123;                              /* 如果是 类组件 类型 */             const instance = finishedWork.stateNode        /* 类实例 */             if(current === null)&#123;                          /* 类组件第一次调和渲染 */                instance.componentDidMount()              &#125;else&#123;                                         /* 类组件更新 */                instance.componentDidUpdate(prevProps,prevState，instance.__reactInternalSnapshotBeforeUpdate);              &#125;        &#125;     &#125;&#125;\n\n17.0.3\nfunction commitLayoutEffectOnFiber(  finishedRoot: FiberRoot,  current: Fiber | null,  finishedWork: Fiber,  committedLanes: Lanes,): void &#123;    switch (finishedWork.tag) &#123;        case ClassComponent: &#123;            const instance = finishedWork.stateNode;            if (!offscreenSubtreeWasHidden) &#123;                if (                    enableProfilerTimer &amp;&amp;                    enableProfilerCommitHooks &amp;&amp;                    finishedWork.mode &amp; ProfileMode                ) &#123;                    try &#123;                    startLayoutEffectTimer();                    instance.componentDidMount();                    &#125; finally &#123;                    recordLayoutEffectDuration(finishedWork);                    &#125;                &#125; else &#123;                    instance.componentDidMount();                &#125;                           commitUpdateQueue(finishedWork, updateQueue, instance);            &#125;            break;        &#125;    &#125;&#125;\n\n更新阶段回到了最开始 updateClassComponent 函数了，当发现 current 不为 null 的情况时，说明该类组件被挂载过，那么直接按照更新逻辑来处理。\n\nreact-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js\n\nfunction updateClassInstance(current,workInProgress,ctor,newProps,renderExpirationTime)&#123;    // 类组件实例    const instance = workInProgress.stateNode;    // 判断是否具有 getDerivedStateFromProps 生命周期    const hasNewLifecycles =  typeof ctor.getDerivedStateFromProps === &#x27;function&#x27;    if(!hasNewLifecycles &amp;&amp; typeof instance.componentWillReceiveProps === &#x27;function&#x27; )&#123;        // 浅比较 props 不相等         if (oldProps !== newProps || oldContext !== nextContext) &#123;            // 执行生命周期 componentWillReceiveProps            instance.componentWillReceiveProps(newProps, nextContext);         &#125;    &#125;    let newState = (instance.state = oldState);    if (typeof getDerivedStateFromProps === &#x27;function&#x27;) &#123;        /* 执行生命周期getDerivedStateFromProps  ，逻辑和mounted类似 ，合并state  */        ctor.getDerivedStateFromProps(nextProps,prevState)          newState = workInProgress.memoizedState;    &#125;    let shouldUpdate = true    /* 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点 */    if(typeof instance.shouldComponentUpdate === &#x27;function&#x27; )&#123;         shouldUpdate = instance.shouldComponentUpdate(newProps,newState,nextContext,);    &#125;    if(shouldUpdate)&#123;        if (typeof instance.componentWillUpdate === &#x27;function&#x27;) &#123;            /* 执行生命周期 componentWillUpdate  */            instance.componentWillUpdate();     &#125;    return shouldUpdate&#125;\n\ngetSnapshotBeforeUpdate 的执行也是在 commit 阶段，commit 阶段细分为 before Mutation( DOM 修改前)，Mutation ( DOM 修改)，Layout( DOM 修改后) 三个阶段，getSnapshotBeforeUpdate 发生在before Mutation 阶段\n销毁阶段在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签 ，然后在 commit 阶段就会调用 componentWillUnmount 生命周期，接下来统一卸载组件以及 DOM 元素。\nvar callComponentWillUnmountWithTimer = function (current, instance) &#123;  instance.props = current.memoizedProps;  instance.state = current.memoizedState;  &#123;    instance.componentWillUnmount();  &#125;&#125;;\n\n\n各生命周期最佳实践constructorconstructor(props)&#123;    super(props)        // 执行 super ，别忘了传递props,才能在接下来的上下文中，获取到props。    this.state=&#123;       //① 可以用来初始化state，比如可以用来获取路由中的        name:&#x27;alien&#x27;    &#125;    this.handleClick = this.handleClick.bind(this) /* ② 绑定 this */    this.handleInputChange = debounce(this.handleInputChange , 500) /* ③ 绑定防抖函数，防抖 500 毫秒 */    const _render = this.render    this.render = function()&#123;        return _render.bind(this)  /* ④ 劫持修改类组件上的一些生命周期 */    &#125;&#125;\n\nUNSAFE_componentWillMount在新版本的react（v16.3）中componentWillMount已经变更为UNSAFE_componentWillMount,而且不在推荐使用，其中很大一部分原因是经常被滥用\n\n初始化状态\n\nclass ExampleComponent extends React.Component &#123;  constructor(props)&#123;    this.state = &#123;      color: &quot;red&quot;    &#125;;  &#125;  state = &#123;    color: &quot;red&quot;  &#125;;  componentWillMount() &#123;    // 应该将初始化状态放到构造函数或属性的初始化状态中    // this.setState(&#123;    //   color: &quot;red&quot;    // &#125;);  &#125;&#125;\n\n\n获取异步的外部数据\n\n// Beforeclass ExampleComponent extends React.Component &#123;  state = &#123;    externalData: null,  &#125;;  componentWillMount() &#123;    this._asyncRequest = loadMyAsyncData().then(      externalData =&gt; &#123;        this._asyncRequest = null;        this.setState(&#123;externalData&#125;);      &#125;    );  &#125;  componentWillUnmount() &#123;    if (this._asyncRequest) &#123;      this._asyncRequest.cancel();    &#125;  &#125;  render() &#123;    if (this.state.externalData === null) &#123;      // 渲染加载状态 ...    &#125; else &#123;      // 渲染真实 UI ...    &#125;  &#125;&#125;\n\n上述代码对于服务器渲染（异步的请求数据不会被放到state中）和即将推出的异步渲染模式（可能执行多次）都存在问题。通常会把上面的操作放到 componentDidMount \n另一个问题是，componentWillMount的名字比较反直觉，听起来觉得在这个生命周期中获取数据，可以避免第一次render的时候进行一次空渲染，单实际上 componentWillMount执行后 render方法会立即执行，如果componentWillMount 没有获取到可用数据，render方法中同样获取不到数据。\n如果想稍微提前一点请求，从而适应低性能的设备可以使用下面的方法\n// This is an advanced example! It is not intended for use in application code.// Libraries like Relay may make use of this technique to save some time on low-end mobile devices.// Most components should just initiate async requests in componentDidMount.class ExampleComponent extends React.Component &#123;  _hasUnmounted = false;  state = &#123;    externalData: null,  &#125;;  constructor(props) &#123;    super(props);    // Prime an external cache as early as possible.    // Async requests are unlikely to complete before render anyway,    // So we aren&#x27;t missing out by not providing a callback here.    asyncLoadData(this.props.someId);  &#125;  componentDidMount() &#123;    // Now that this component has mounted,    // Wait for earlier pre-fetch to complete and update its state.    // (This assumes some kind of external cache to avoid duplicate requests.)    asyncLoadData(this.props.someId).then(externalData =&gt; &#123;      if (!this._hasUnmounted) &#123;        this.setState(&#123; externalData &#125;);      &#125;    &#125;);  &#125;  componentWillUnmount() &#123;    this._hasUnmounted = true;  &#125;  render() &#123;    if (this.state.externalData === null) &#123;      // Render loading state ...    &#125; else &#123;      // Render real UI ...    &#125;  &#125;&#125;\n\n\n事件监听\n\n// Beforeclass ExampleComponent extends React.Component &#123;  componentWillMount() &#123;    this.setState(&#123;      subscribedValue: this.props.dataSource.value,    &#125;);    // 这是不安全的，它会导致内存泄漏！    this.props.dataSource.subscribe(      this.handleSubscriptionChange    );  &#125;  componentWillUnmount() &#123;    this.props.dataSource.unsubscribe(      this.handleSubscriptionChange    );  &#125;  handleSubscriptionChange = dataSource =&gt; &#123;    this.setState(&#123;      subscribedValue: dataSource.value,    &#125;);  &#125;;&#125;\n\n上面的代码在服务端可能永远不会调用 componentWillUnmount, 或者在渲染完成之前可能被中断，导致不调用 componentWillUnmount,这两种场景都可能导致内存泄露，推荐的做法是移到componentDidMount \n订阅的触发，导致属性和状态的改变，Redux 或 MobX 会帮助我们实现，对于应用开发场景可以使用 create-subscription, 在这里可以看到源码分析。\nUNSAFE_componentWillReceiveProps getDerivedStateFromProps首先明确一下这个两个方法在使用时，最常见的错误\n\n直接复制 props 到 state 上\n如果 props 和 state 不一致就更新 state\n经常被误解只有props改变时这两个方法才会调用，实际上只要父组件重新渲染这两个方法就会被调用\n\n想说清楚造成这两个错误的原因，需要先了解一个概念叫做 受控\n受控和非受控通常用来指代表单的 inputs,但是也可以用来描述数据频繁更新的组件。如果组件完全依赖于外部传入的props,可以认为是受控状态，因为组件完全被父组件的props控制。如果组件的状态只保存在组件（state）内部，可以认为是非受控的，因为组件有自己的状态，不受父组件的控制。\n而组件中一旦将两种模式混为一谈（同时包含props和state）就会造成问题\n直接复制 props 到 state 上造成的问题\nclass EmailInput extends Component &#123;  state = &#123; email: this.props.email &#125;;  render() &#123;    return &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;;  &#125;  handleChange = event =&gt; &#123;    this.setState(&#123; email: event.target.value &#125;);  &#125;;  componentWillReceiveProps(nextProps) &#123;    // 这会覆盖所有组件内的 state 更新！    this.setState(&#123; email: nextProps.email &#125;);  &#125;&#125;\n\n初看还觉得可以，但是问题很严重，当通过input的输入改变了组件的状态，这时如果父组件更新就会触发componentWillReceiveProps方法，会将state.email状态重写，覆盖了刚才通过input输入更新的状态，导致状态丢失，这是两种模式混用最明显的错误。在实际的使用中会有多个props属性，任意一个属性的更新都会导致内部状态可能被覆盖。\n既然这样，可以很容易想到，能不能只用props来更新组件，不让组件有自己的内部状态\nclass EmailInput extends Component &#123;  state = &#123;    email: this.props.email  &#125;;  componentWillReceiveProps(nextProps) &#123;    // 只要 props.email 改变，就改变 state    if (nextProps.email !== this.props.email) &#123;      this.setState(&#123;        email: nextProps.email      &#125;);    &#125;  &#125;&#125; \n\n但是仍然有个问题。想象一下，如果这是一个密码输入组件，拥有同样 email 的两个账户(假设一个邮箱可以注册多个账户)进行切换时，这个输入框不会重置（用来让用户重新登录）。因为父组件传来的 prop 值没有变化！这会让用户非常惊讶，因为这看起来像是帮助一个用户分享了另外一个用户的密码\n最佳实践:完全可控的组件\n从组件里面删除state,完全让外部的props的接管组件的状态\n最佳实践：有 key 的非可控组件\n让组件自己存储临时的 email state。在这种情况下，组件仍然可以从 prop 接收“初始值”，但是更改之后的值就和 prop 没关系了\nclass EmailInput extends Component &#123;  state = &#123; email: this.props.defaultEmail &#125;;  handleChange = event =&gt; &#123;    this.setState(&#123; email: event.target.value &#125;);  &#125;;  render() &#123;    return &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;;  &#125;&#125;\n\n我们可以使用 key 这个特殊的 React 属性。当 key 变化时， React 会创建一个新的而不是更新一个既有的组件。 Keys 一般用来渲染动态列表，但是这里也可以使用。在这个示例里，当用户输入时，我们使用 user ID 当作 key 重新创建一个新的 email input 组件\n不用为每次输入都添加 key，在整个表单上添加 key 更有位合理。每次 key 变化，表单里的所有组件都会用新的初始值重新创建。\n&lt;EmailInput  defaultEmail=&#123;this.props.user.email&#125;  key=&#123;this.props.user.id&#125;/&gt;\n\n\n这听起来很慢，但是这点的性能是可以忽略的。如果在组件树的更新上有很重的逻辑，这样反而会更快，因为省略了子组件 diff。\n\n备选：用 prop 的 ID 重置非受控组件\n如果某些情况下 key 不起作用（可能是组件初始化的开销太大），一个麻烦但是可行的方案是在 getDerivedStateFromProps 观察 userID 的变化：、\nclass EmailInput extends Component &#123;  state = &#123;    email: this.props.defaultEmail,    prevPropsUserID: this.props.userID  &#125;;  static getDerivedStateFromProps(props, state) &#123;    // 只要当前 user 变化，    // 重置所有跟 user 相关的状态。    // 这个例子中，只有 email 和 user 相关。    if (props.userID !== state.prevPropsUserID) &#123;      return &#123;        prevPropsUserID: props.userID,        email: props.defaultEmail      &#125;;    &#125;    return null;  &#125;&#125;\n\ngetDerivedStateFromProps 的存在只有一个目的：让组件在 props 变化时更新 state。 代替了原来的componentWillReceiveProps\nnextProps 父组件新传递的 props ;\n你可能想知道为什么我们不将上一个 props 作为参数传递给 getDerivedStateFromProps。我们在设计 API 时考虑过这个方案，但最终决定不采用它，原因有两个：\n\nprevProps 参数在第一次调用 getDerivedStateFromProps（实例化之后）时为 null，需要在每次访问 prevProps 时添加 if-not-null 检查。\n\n在 React 的未来版本中，不传递上一个 props 给这个方法是为了释放内存。（如果 React 无需传递上一个 props 给生命周期，那么它就无需保存上一个 props 对象在内存中。）\n\n\nprevState 组件在此次更新前的 state 。\n需要注意每次组件更新时getDerivedStateFromProps都会执行，无论是以哪那种方式更新\n通常用于吧props混入state作为初始状态，合并后的state可以作为 shouldComponentUpdate 第二个参数 newState ，可以判断是否渲染组件。\ngetDerivedStateFromProps(nextProps,prevState)\n\n总结\n最重要的是确定组件是受控组件还是非受控组件。不要直接复制（mirror） props 的值到 state 中，而是去实现一个受控的组件，然后在父组件里合并两个值。\n对于不受控的组件，当你想在 prop 变化（通常是 ID ）时重置 state 的话，可以选择以下几种方式：\n建议: 重置内部所有的初始 state，使用 key 属性选项一：仅更改某些字段，观察特殊属性的变化（比如 props.userID）。\nUNSAFE_componentWillUpdate getSnapshotBeforeUpdate当组件收到新的 props 或 state 时，会在渲染之前调用 UNSAFE_componentWillUpdate()。 有时人们使用 componentWillUpdate 是出于一种反直觉，当 componentDidUpdate 触发时，更新其他组件的 state 已经”太晚”了。事实并非如此。在UI渲染之前，componentWillUpdate和componentDidUpdate中的state改变都将被记录。\ngetSnapshotBeforeUpdate(prevProps, prevState)\n\ncomponentWillUpdate常见的错误是在生命周期中使用异步获取数据的方法，因为任何state的更新和父组件的重新渲染会触发componentWillUpdate重新执行，所有获取数据的方法可能被执行多次。相反，应该使用 componentDidUpdate 生命周期，因为它保证每次更新只调用一次。\nclass ExampleComponent extends React.Component &#123;  componentDidUpdate(prevProps, prevState) &#123;    if (      this.state.someStatefulValue !==      prevState.someStatefulValue    ) &#123;      this.props.onChange(this.state.someStatefulValue);    &#125;  &#125;&#125;\n\n更新前读取 DOM 属性\nclass ListBox extends React.Component &#123;  ref = React.createRef();  previousScrollOffset=0;  // 在列表更新的时候，读取DOM属性  componentWillUpdate(nextProps, nextState) &#123;    // 当列列表个数被改变的时候计算偏移量    if (this.props.list.length &lt; nextProps.list.length) &#123;      this.previousScrollOffset =        this.ref.current.scrollHeight - this.ref.current.scrollTop;    &#125;  &#125;  // 在列表被挂载的时候修改DOM属性  componentDidUpdate()&#123;    // previousScrollOffset ！== 容器高度时(2px是边框高度)，表示滚动条没有滚动到底部，可能在查看历史记录的状态    if(this.previousScrollOffset!== this.ref.current.offsetHeight-2) return;    // newScrollHeight - oldScrollHeight + lastScrollTop    // 相当于在上一次的scrollTop上加上ScrollHeight的增量    this.ref.current.scrollTop =  (this.ref.current.scrollHeight -　this.previousScrollOffset　)    this.previousScrollOffset = 0;  &#125;  render() &#123;    return (&lt;div style=&#123;&#123; width: 300, height: 200, overflow: &#x27;auto&#x27;, border: &#x27;1px solid&#x27; &#125;&#125; ref=&#123;this.ref&#125;&gt;      &#123;this.props.list.map(item =&gt; &lt;div style=&#123;&#123; height: 20 &#125;&#125;&gt;&#123;item.val&#125;&lt;/div&gt;)&#125;    &lt;/div&gt;)  &#125;&#125;\n\n在上面的示例中，componentWillUpdate 用于读取 DOM 属性。但是，对于异步渲染，“渲染”阶段的生命周期（如 componentWillUpdate 和 render）和”提交”阶段的生命周期（如 componentDidUpdate）之间可能存在延迟。如果用户在这段时间内调整窗口大小，那么从 componentWillUpdate 读取的 scrollHeight 值将过时。\n这个问题的解决方案是使用新的“提交”阶段生命周期 getSnapshotBeforeUpdate。这个方法在发生变化 前立即 被调用（例如在更新 DOM 之前）。它可以返回一个 React 的值作为参数传递给 componentDidUpdate 方法，该方法在发生变化 后立即 被调用。\nclass ListBox extends React.Component &#123;  ref = React.createRef();  getSnapshotBeforeUpdate(prevProps, nextState) &#123;    if (this.props.list.length &gt; prevProps.list.length) &#123;      return this.ref.current.scrollHeight - this.ref.current.scrollTop;    &#125;  &#125;  componentDidUpdate(prevProps, prevState, snapshot)&#123;    if(snapshot&gt;this.ref.current.offsetHeight) return;    this.ref.current.scrollTop =  (this.ref.current.scrollHeight -　snapshot　)    console.log(this.ref.current.scrollTop);  &#125;  render() &#123;    return (&lt;div style=&#123;&#123; width: 300, height: 200, overflow: &#x27;auto&#x27;, border: &#x27;1px solid&#x27; &#125;&#125; ref=&#123;this.ref&#125;&gt;      &#123;this.props.list.map(item =&gt; &lt;div style=&#123;&#123; height: 20 &#125;&#125;&gt;&#123;item.val&#125;&lt;/div&gt;)&#125;    &lt;/div&gt;)  &#125;&#125;\n\n\ncomponentDidMountcomponentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。\n这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅\n你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理\nuseEffect 和 useLayoutEffect对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会像 setTimeout回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。\nuseLayoutEffect 和 useEffect 不同的地方是采用了同步执行\n首先 useLayoutEffect 是在 DOM 绘制之前，这样可以方便修改 DOM ，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。useLayoutEffect callback 中代码执行会阻塞浏览器绘制。\nuseEffect 对 React 执行栈来看是异步执行的，而 componentDidMount &#x2F; componentDidUpdate 是同步执行的，useEffect代码不会阻塞浏览器绘制。在时机上 ，componentDidMount &#x2F; componentDidUpdate 和 useLayoutEffect 更类似。\n","categories":["React"],"tags":["React"]},{"title":"⑤ ReactSSR node中间层代理请求","url":"/posts/70ef756f1afd/","content":"代理请求由于客户端和服务端公用一套请求的接口，所以需要接口同时适应客户端和移动端，这里可以选用 cross-fetch 或 axios\n当在异步 action 中请求数据时，我们希望请求的是同域的服务\nexport const loadData =  () =&gt; (dispatch: Dispatch, getState: any, request: AxiosInstance) =&gt;    axios(&quot;/api/products&quot;).then((&#123; data &#125;) =&gt; dispatch(loadDataAction(data)));\n\n而不是直接请求后端服务器。所以需要将 api 开头的请求转发到后端服务器请求。用到了一个 koa 的中间件 koa-proxies\nimport Koa from &#x27;koa&#x27;;import koaBody from &#x27;koa-body&#x27;;import koaStatic from &#x27;koa-static&#x27;;import proxy from &#x27;koa-proxies&#x27;;import path from &#x27;path&#x27;;import router from &#x27;../router&#x27;import errorHandle from &#x27;./errorHandle&#x27;const app = new Koa();app.use(async (ctx:any, next:()=&gt;Promise&lt;any&gt;) =&gt; &#123;  try &#123;    await next();  &#125; catch (err) &#123;    ctx.app.emit(&#x27;error&#x27;, err, ctx);  &#125;&#125;).use(proxy(&#x27;/api&#x27;,&#123;    target:  &#x27;https://fakestoreapi.com&#x27;,    changeOrigin: true,    rewrite: path =&gt; path.replace(/^\\/api/,&#x27;&#x27;),  &#125;)).use(koaStatic(path.join((process.env as any).PWD,&#x27;./static&#x27;))).use(koaBody()).use(router.routes()).use(router.allowedMethods())app.on(&#x27;error&#x27;, errorHandle);export default app;\n\n处理请求现在客户端正常访问是可以的，但是服务端会报出错误，因为当刷新页面的时候服务端会做服务端渲染，这时直接调用了组件中获取数据的方法。\n由于组件中的路径是以 /api 开头的绝对路径，所以会尝试在服务器中查找根路径下api文件夹，因为找不到报错错误。\n一个思路是，区分服务端的请求和客户端的请求，分别为其创建不同的 axios 实例用于请求，但是为了避免像上一章中，每个请求分两种写，可以考虑在项目初始化的时候创建不同的 axios 实例，并通过参数传递到请求方法中，从而避免业务逻辑太多冗余。\n\nsrc&#x2F;util&#x2F;request.ts\n\n定义一个请求方法，为服务端和客户端创建不同实例\n由于后端服务并不是api开头的接口，所以后端访问时，需要为其重写url路径.\nimport axios from &quot;axios&quot;;const serverInstance = axios.create(&#123;  baseURL: &quot;https://fakestoreapi.com&quot;,  adapter: function (config) &#123;    /* ... */    config.url = config.url?.replace(/^\\/api/, &quot;&quot;);    delete config.adapter;    return new Promise((resolve) =&gt; &#123;      resolve(axios(config));    &#125;);  &#125;,&#125;);const clientInstance = axios.create(&#123;  baseURL: &quot;/&quot;,&#125;);export &#123; serverInstance, clientInstance &#125;;\n\n在初始化 store 的时候，通过中间件把 axios 实例传入，让所用的异步 action 在请求前可以通过第三个参数拿到 axios 实例\n\nsrc&#x2F;store&#x2F;index.ts\n\nimport &#123; Provider &#125; from &#x27;react-redux&#x27;import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import thunk from &#x27;redux-thunk&#x27;import reducers from &#x27;./reducers&#x27;;import &#123; StoreType as HelloStoreType &#125; from &#x27;../components/hello&#x27;;import &#123;clientInstance,serverInstance&#125; from &#x27;../util/request&#x27;const browserStore = ()=&gt; createStore(reducers, (window as any).__HYDRATE_DATA__, applyMiddleware(thunk.withExtraArgument(clientInstance)));const serverStore = () =&gt; createStore(reducers, applyMiddleware(thunk.withExtraArgument(serverInstance)));export type StoreType = &#123;    hello: HelloStoreType&#125;export &#123;    Provider,    browserStore,    serverStore&#125;\n\n\nsrc&#x2F;components&#x2F;hello&#x2F;action.ts\n\n修改 action 方法，通过 axios 实例请求\nimport &#123; Dispatch, ActionCreator &#125; from &quot;redux&quot;;import &#123; AxiosInstance &#125; from &quot;axios&quot;;import &#123;&#125; from &quot;redux&quot;;export const LOAD_DATA = &quot;LOAD_DATA&quot;;export type LOAD_DATA_TYPE = typeof LOAD_DATA;const loadDataAction: ActionCreator&lt;&#123; type: LOAD_DATA_TYPE &#125;&gt; = (payload) =&gt; (&#123;  type: LOAD_DATA,  payload,&#125;);export type ActionTypes = LOAD_DATA_TYPE;export const loadData =  () =&gt; (dispatch: Dispatch, getState: any, request: AxiosInstance) =&gt;    request(&quot;/api/products&quot;).then((&#123; data &#125;) =&gt; dispatch(loadDataAction(data)));export const serverLoadData = loadData;\n\n最后一步，由于我们统一了调用方法，现在服务端也会通过异步 action 方法调用接口\n所以需要让服务端调用方法的时候，也像客户端一样通过bindActionCreators传入dispatch方法\n通过服务端创建的store传入了dispatch方法，并且让中间件的参数生效。这时也不需要再组合不同接口返回的state,通过异步action方法，在拿到返回值之后，dispatch会触发并更新store\n当所有的组件异步数据请求之后，在通过getState获取最新的store渲染页面\n\nsrc&#x2F;router&#x2F;index.tsx\n\nconst router = new Router();router.get(&quot;/(.*)&quot;, async (ctx) =&gt; &#123;  const store = serverStore();  const promises: Array&lt;any&gt; = matchRoutes(routes, ctx.request.path).map(    (&#123; route, match &#125;) =&gt; &#123;      return route.loadData        ? bindActionCreators(route.loadData, store.dispatch)()        : Promise.resolve();    &#125;  );  await Promise.all(promises);  ctx.body = `    &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;            &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;                &lt;title&gt;Document&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                &lt;div id=&#x27;root&#x27;&gt;$&#123;ReactDOMServer.renderToString(                  &lt;App &#123;...&#123; ctx, store &#125;&#125; /&gt;                )&#125;&lt;/div&gt;                &lt;script&gt;                    window.__HYDRATE_DATA__ = $&#123;JSON.stringify(                      store.getState()                    )&#125;                &lt;/script&gt;                &lt;script src=&#x27;/index.js&#x27; defer&gt;&lt;/script&gt;            &lt;/body&gt;        &lt;/html&gt;    `;&#125;);export default router;\n","categories":["React"],"tags":["React","SSR"]},{"title":"React原理 Ref深入","url":"/posts/05d3d2e460ac/","content":"Ref相关的问题\nRef是如何通过 createRef 或 useRef 创建对象的\n\nReact 对标签上的 ref 属性是如何处理的\n\nReact 内部处理Ref的逻辑是怎样的，如何做 Ref 转发的\n\n\n创建Ref对象\nReact.create 源码 react&#x2F;src&#x2F;ReactCreateRef.js\n\nexport function createRef(): RefObject &#123;  const refObject = &#123;    current: null,  &#125;;  return refObject;&#125;\n\n\nReact.useRef &#x2F;react&#x2F;src&#x2F;ReactHooks.js\n\nconst ReactCurrentDispatcher = &#123;  /**   * @internal   * @type &#123;ReactComponent&#125;   */  current: (null: null | Dispatcher),&#125;;function resolveDispatcher() &#123;  const dispatcher = ReactCurrentDispatcher.current;  return ((dispatcher: any): Dispatcher);&#125;export function useRef&lt;T&gt;(initialValue: T): &#123;|current: T|&#125; &#123;  const dispatcher = resolveDispatcher();  return dispatcher.useRef(initialValue);&#125;\n\nuseRef的初始化逻辑藏的比较深，当引入useRef的是否，dispatcher.current===null 并没有挂载方法。\n而是通过 exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals; 挂载在 ReactSharedInternals对象上并导出给 react-reconciler 中初始化（最后打包的时候react-reconciler会打包在react-dom中）。\n\n&#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberHooks.new.js\n\nfunction renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) &#123;    if (current !== null &amp;&amp; current.memoizedState !== null) &#123;        ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;    &#125; else if (hookTypesDev !== null) &#123;        // This dispatcher handles an edge case where a component is updating,        // but no stateful hooks have been used.        // We want to match the production code behavior (which will use HooksDispatcherOnMount),        // but with the extra DEV validation to ensure hooks ordering hasn&#x27;t changed.        // This dispatcher does that.        ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;    &#125; else &#123;        ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;    &#125;&#125;\n\n简单来说 Ref 就是一个对象，其中的current属性用于保存DOM元素，或组件实例。useRef 底层逻辑是和 createRef 差不多，就是 ref 保存位置不相同，类组件有一个实例 instance 能够维护像 ref 这种信息，但是由于函数组件每次更新都是一次新的开始，所有变量重新声明，所以 useRef 不能像 createRef 把 ref 对象直接暴露出去，如果这样每一次函数组件执行就会重新声明 Ref，此时 ref 就会随着函数组件执行被重置，这就解释了在函数组件中为什么不能用 createRef 的原因。\n为了解决这个问题，hooks 和函数组件对应的 fiber 对象建立起关联，将 useRef 产生的 ref 对象挂到函数组件对应的 fiber 上，函数组件每次执行，只要组件不被销毁，函数组件对应的 fiber 对象一直存在，所以 ref 等信息就会被保存下来。对于 hooks 原理，后续章节会有对应的介绍。\nRef的几种用法String 类型Ref在老的React版本中使用，新版本中已经不推荐使用，可以用 React.createRef 或回调形式的 Ref 来代替。v17版本中使用refs获取对象时，只会返回一个空对象，String类型的Ref会导致很多问题：\n\nReact必须跟踪当前渲染的组件，因为它不知道this指向谁，这会导致React变慢\n\n下面例子中，string类型的refs写法会让ref被放置在DataTable组件中，而不是MyComponent中。\n\n\nclass MyComponent extends Component &#123;  renderRow = (index) =&gt; &#123;    // This won&#x27;t work. Ref will get attached to DataTable rather than MyComponent:    return &lt;input ref=&#123;&#x27;input-&#x27; + index&#125; /&gt;;    // This would work though! Callback refs are awesome.    return &lt;input ref=&#123;input =&gt; this[&#x27;input-&#x27; + index] = input&#125; /&gt;;  &#125;   render() &#123;    return &lt;DataTable data=&#123;this.props.data&#125; renderRow=&#123;this.renderRow&#125; /&gt;  &#125;&#125;\n\n\n如果一个库在传递的子组件（子元素）上放置了一个ref，那用户就无法在它上面再放一个ref了。但函数式可以实现这种组合。\n\n函数类型Refexport default class Index extends React.Component&#123;    render=()=&gt; &lt;div&gt;        &lt;div ref=&#123;(node)=&gt; this.currentDom = node &#125; &gt;hello word&lt;/div&gt;        &lt;Children ref=&#123;(node) =&gt; this.currentComponentInstance = node  &#125;  /&gt;    &lt;/div&gt;&#125;\n\n当用一个函数来标记 Ref 的时候，将作为 callback 形式，等到真实 DOM 创建阶段，执行 callback ，获取的 DOM 元素或组件实例，将以回调函数第一个参数形式传入，所以可以像上述代码片段中，用组件实例下的属性 currentDom和 currentComponentInstance 来接收真实 DOM 和组件实例。\nRef对象export default class Index extends React.Component&#123;    currentDom = React.createRef(null)    currentComponentInstance = React.createRef(null)     render=()=&gt; &lt;div&gt;         &lt;div ref=&#123; this.currentDom &#125; &gt;hello word&lt;/div&gt;        &lt;Children ref=&#123; this.currentComponentInstance &#125;  /&gt;   &lt;/div&gt;&#125;\n\nRef高级用法Ref转发初衷是用来实现将一个ref分发到一个组件的子组件中，这在写一些库的时候非常有用。\n你可能会注意到，即使不通过refApi仅仅通过props的传递也可以获取，子组件的DOM。像下面的例子：\nclass Level1 extends React.Component&#123;    render()&#123;        return &lt;Level2 topRef=&#123;this.props.topRef&#125;/&gt;    &#125;&#125;class Level2 extends React.Component&#123;    render()&#123;        return &lt;input name=&#x27;level2&#x27; ref=&#123;this.props.topRef&#125;/&gt;    &#125;&#125;class TopLevel extends React.Component&#123;    topRef = React.createRef();    componentDidMount()&#123;        console.log(this.topRef.current)    &#125;    render()&#123;        return &lt;Level1 topRef=&#123;this.topRef&#125;/&gt;     &#125;&#125;\n\n这与Ref转发的本意不符，对于高可复用“叶”组件来说是不方便的。这些组件倾向于在整个应用中以一种类似常规 DOM button 和 input 的方式被使用，并且访问其 DOM 节点对管理焦点，选中或动画来说是不可避免的。也可以理解成是对原声DOM的封装，而且还能方便的获取到原声DOM的引用\n下面的例子，通过Ref转发获取到了 &lt;FancyButton/&gt;组件的子组件\nconst FancyButton = React.forwardRef((props, ref) =&gt; (  &lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt;    &#123;props.children&#125;  &lt;/button&gt;));class Level1 extends React.Component&#123;    render()&#123;        return &lt;Level2 topRef=&#123;this.props.topRef&#125;/&gt;    &#125;&#125;const Level1Ref = React.forwardRef((props,ref)=&gt; &lt;Level1 &#123;...props&#125; topRef=&#123;ref&#125;/&gt;)class Level2 extends React.Component&#123;    render()&#123;        return &lt;input name=&#x27;level2&#x27; ref=&#123;this.props.topRef&#125;/&gt;    &#125;&#125;class TopLevel extends React.Component&#123;    topRef = React.createRef();    componentDidMount()&#123;        console.log(this.topRef.current)    &#125;    render()&#123;        return &lt;Level1Ref ref=&#123;this.topRef&#125;/&gt;     &#125;&#125;export default TopLevel;// 你可以直接获取 DOM button 的 ref：const ref = React.createRef();&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;\n\n\n我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。\n我们通过指定 ref 为 JSX 属性，将其向下传递给 。\nReact 传递 ref 给 forwardRef 内函数 (props, ref) &#x3D;&gt; …，作为其第二个参数。\n我们向下转发该 ref 参数到 ，将其指定为 JSX 属性。\n当 ref 挂载完成，ref.current 将指向  DOM 节点。\n\n所以在最开的错误案例中，可以通过ref转发让叶组件获取ref,再通过props在将其在组件内部传递到需要的位置\nclass Level1 extends React.Component&#123;    render()&#123;        return &lt;Level2 topRef=&#123;this.props.topRef&#125;/&gt;    &#125;&#125;const Level1Ref = React.forwardRef((props,ref)=&gt; &lt;Level1 &#123;...props&#125; topRef=&#123;ref&#125;/&gt;)class Level2 extends React.Component&#123;    render()&#123;        return &lt;input name=&#x27;level2&#x27; ref=&#123;this.props.topRef&#125;/&gt;    &#125;&#125;class TopLevel extends React.Component&#123;    topRef = React.createRef();    componentDidMount()&#123;        console.log(this.topRef.current)    &#125;    render()&#123;        return &lt;Level1Ref ref=&#123;this.topRef&#125;/&gt;     &#125;&#125;\n\n合并Ref转发理解了上面通过 forwardRef 和 props 共同传递ref,供给子组件消费，就很容易理解合并Ref转发\nforwardRef 让 ref 可以通过 props 传递，那么如果用 ref 对象标记的 ref ，那么 ref 对象就可以通过 props 的形式，提供给子孙组件消费，当然子孙组件也可以改变 ref 对象里面的属性，或者像如上代码中赋予新的属性，这种 forwardref + ref 模式一定程度上打破了 React 单向数据流动的原则。当然绑定在 ref 对象上的属性，不限于组件实例或者 DOM 元素，也可以是属性值或方法。\n// 表单组件class Form extends React.Component&#123;    render()&#123;       return &lt;div&gt;&#123;...&#125;&lt;/div&gt;    &#125;&#125;// index 组件class Index extends React.Component&#123;     componentDidMount()&#123;        const &#123; forwardRef &#125; = this.props        forwardRef.current=&#123;            form:this.form,      // 给form组件实例 ，绑定给 ref form属性             index:this,          // 给index组件实例 ，绑定给 ref index属性             button:this.button,  // 给button dom 元素，绑定给 ref button属性         &#125;    &#125;    form = null    button = null    render()&#123;        return &lt;div   &gt;           &lt;button ref=&#123;(button)=&gt; this.button = button &#125;  &gt;点击&lt;/button&gt;          &lt;Form  ref=&#123;(form) =&gt; this.form = form &#125;  /&gt;        &lt;/div&gt;    &#125;&#125;const ForwardRefIndex = React.forwardRef(( props,ref )=&gt;&lt;Index  &#123;...props&#125; forwardRef=&#123;ref&#125;  /&gt;)// home 组件export default function Home()&#123;    const ref = useRef(null)     useEffect(()=&gt;&#123;         console.log(ref.current)     &#125;,[])    return &lt;ForwardRefIndex ref=&#123;ref&#125; /&gt;&#125;\n\n在高阶组件中转发Ref高阶组件中，属性是可以透传的，但是ref不可以，ref是特殊属性，这就导致使用高阶组件的时候，仅仅通过ref不能传递到基础组件\nfunction logProps(WrappedComponent) &#123;    class LogProps extends React.Component &#123;        render() &#123;            return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;        &#125;    &#125;    return LogProps;&#125;class FancyButton extends React.Component &#123;    focus() &#123;        console.log(&#x27;focus&#x27;)    &#125;    render()&#123;        return &lt;div&gt;wefwef&lt;/div&gt;    &#125;&#125;const HOCFancyButton = logProps(FancyButton);class MyComponent extends React.Component &#123;    ref = React.createRef();    componentDidMount()&#123;        console.log(this.ref.current)    &#125;    render()&#123;        // 使用高阶组件的时候 ref指向的是LogProps，而不是FancyButton        return &lt;HOCFancyButton ref=&#123;this.ref&#125;/&gt;    &#125;&#125;\n\n可以使用forwardRef在高阶组件中做Ref转发\nfunction logProps(WrappedComponent) &#123;    class LogProps extends React.Component &#123;        render() &#123;            const &#123; forwardedRef, ...rest &#125; = this.props;            return &lt;WrappedComponent &#123;...rest&#125; ref=&#123;forwardedRef&#125; /&gt;;        &#125;    &#125;    return React.forwardRef((props, ref) =&gt; &lt;LogProps &#123;...props&#125; forwardRef=&#123;ref&#125; /&gt;);&#125;class FancyButton extends React.Component &#123;    focus() &#123;        console.log(&#x27;focus&#x27;)    &#125;    render() &#123;        return &lt;div&gt;wefwef&lt;/div&gt;    &#125;&#125;const HOCFancyButton = logProps(FancyButton);class MyComponent extends React.Component &#123;    ref = React.createRef();    componentDidMount() &#123;        console.log(this.ref.current)    &#125;    render() &#123;        return &lt;HOCFancyButton ref=&#123;this.ref&#125; /&gt;    &#125;&#125;\n\n类组件通过Ref通信有一种类似表单（Form）的场景，不希望表单元素的更新是通过父组件（Form）更新触发render并传递props到子组件来更新。而是希望不用触发父组件的render，直接子组件，子组件有自己的状态，这时就需要父组件能获取到子组件的实例。调用子组件实例方法，更新子组件内部状态。\nclass Child extends React.Component&#123;    receiveMessageFromParent = (msg)=&gt;&#123;        console.log(msg)    &#125;    render()&#123;        return &lt;&gt;            &lt;button onClick=&#123;()=&gt;this.receiveMessageFromParent(&#x27;MessageFromChild&#x27;)&#125;&gt;发消息给父组件&lt;/button&gt;            &lt;div&gt;child&lt;/div&gt;        &lt;/&gt;     &#125;&#125;class Parent extends React.Component &#123;    childRef = React.createRef();    sendMessageToChild = ()=&gt;&#123;        this.childRef.current.receiveMessageFromParent(&#x27;MessageFromParent&#x27;)    &#125;    receiveMessageFromChild = (msg)=&gt;&#123;        console.log(msg);    &#125;    render()&#123;        return &lt;&gt;            &lt;button type=&#x27;button&#x27; onClick=&#123;this.sendMessageToChild&#125;&gt;发消息给子组件&lt;/button&gt;            &lt;Child ref=&#123;this.childRef&#125; receiveMessageFromChild=&#123;this.receiveMessageFromChild&#125;/&gt;        &lt;/&gt;     &#125;&#125;\n\n函数组件通信useImperativeHandle可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用：\nfunction FancyInput(props, ref) &#123;  const inputRef = useRef();  useImperativeHandle(ref, () =&gt; (&#123;    focus: () =&gt; &#123;      inputRef.current.focus();    &#125;  &#125;));  return &lt;input ref=&#123;inputRef&#125; /&gt;;&#125;FancyInput = forwardRef(FancyInput);\n\n\n上面的例子在函数式组件中可以改写为：\nfunction Child(props, ref) &#123;    const inputRef = React.useRef();    const sayChild = useCallback(()=&gt;&#123;        console.log(&#x27;child&#x27;)    &#125;,[])    React.useImperativeHandle(ref, () =&gt; (&#123;        focus: () =&gt; &#123;            inputRef.current.focus();        &#125;,        sayChild    &#125;));    return &lt;&gt;        &lt;button onClick=&#123;()=&gt; props.receiveMessageFromChild(&#x27;MessageFromChild&#x27;)&#125;&gt;发消息给父组件&lt;/button&gt;        &lt;input ref=&#123;ref&#125;/&gt;    &lt;/&gt;&#125;Child = React.forwardRef(Child)const Parent = () =&gt; &#123;    const ref = React.useRef();    React.useEffect(()=&gt;&#123;        // 可以拿到子组件定义的方法,或者操作子组件的DOM元素        console.log(ref.current)    &#125;,[ref])    const receiveMessageFromChild =useCallback((msg)=&gt;&#123;        console.log(msg);    &#125;,[])    return &lt;&gt;        &lt;Child ref=&#123;ref&#125; receiveMessageFromChild=&#123;receiveMessageFromChild&#125;/&gt;    &lt;/&gt;&#125;\n\nRef的原理对于整个 Ref 的处理，都是在 commit 阶段发生的。因为在 commit 阶段才会对真正的 Dom 进行操作，这是用 ref 保存真正的 DOM 节点，或组件实例。\n对Ref的更新会调用两个方法 commitDetachRef 和 commitAttachRef 一个发生在 commit 之前，一个发生在 commit 之后\n\nreact-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js\n\n// 在 commit 的 mutation 阶段会清空Reffunction commitDetachRef(current: Fiber) &#123;  const currentRef = current.ref;  if (currentRef !== null) &#123;    if (typeof currentRef === &#x27;function&#x27;) &#123;      currentRef(null);     &#125; else &#123;      currentRef.current = null;    &#125;  &#125;&#125;\n\n清空之后会进入DOM更新，根据不同的effect标签，操作真实的dom\n最后 Layout 阶段会会更新Ref\nfunction commitAttachRef(finishedWork: Fiber) &#123;  const ref = finishedWork.ref;  if (ref !== null) &#123;    const instance = finishedWork.stateNode;    let instanceToUse;    switch (finishedWork.tag) &#123;      case HostComponent: //元素节点 获取元素        instanceToUse = getPublicInstance(instance);        break;      default:  // 类组件直接使用实例        instanceToUse = instance;    &#125;    if (typeof ref === &#x27;function&#x27;) &#123;      ref(instanceToUse);  //* function 和 字符串获取方式。 */    &#125; else &#123;      ref.current = instanceToUse; /* ref对象方式 */    &#125;  &#125;&#125;\n\n字符串形式的ref,最后被包装成一个函数，以函数的形式执行\nfunction coerceRef(returnFiber, current, element) &#123;    // 会用_stringRef给函数做标记，如果相同则直接返回原来的函数引用    if (current !== null &amp;&amp; current.ref !== null &amp;&amp; typeof current.ref === &#x27;function&#x27; &amp;&amp; current.ref._stringRef === stringRef) &#123;        return current.ref;    &#125;    var ref = function (value) &#123;        var refs = inst.refs;        if (refs === emptyRefsObject) &#123;            // This is a lazy pooled frozen object, so we need to initialize.            refs = inst.refs = &#123;&#125;;        &#125;        if (value === null) &#123;            delete refs[stringRef];        &#125; else &#123;            refs[stringRef] = value;        &#125;    &#125;;    ref._stringRef = stringRef;    return ref;&#125;\n\n事实上并不是每次创建或更新这两个函数都会执行\n\nreact-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js\n\ncommitDetachRef 执行位置\n每次都设为null,是防止内存泄漏 如果 ref 每次绑定一个全新的 对象（Ref.current，callback）上，而不清理对旧的 dom节点 或者 类实例 的引用，则可能会产生内存泄漏。\nfunction commitMutationEffects()&#123;     if (effectTag &amp; Ref) &#123;      const current = nextEffect.alternate;      if (current !== null) &#123;        commitDetachRef(current);      &#125;    &#125;&#125;\n\ncommitAttachRef 执行位置\nfunction commitLayoutEffects()&#123;     if (effectTag &amp; Ref) &#123;      commitAttachRef(nextEffect);    &#125;&#125;\n\n想要挂载Ref，是必须要打上effectTag的标签,所以只有在Ref改变的时候才会更新\n\nreact-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js\n\nfunction markRef(current, workInProgress) &#123;  var ref = workInProgress.ref;  if (      // fiber初始化的时候，且定义了ref属性      current === null &amp;&amp; ref !== null      // fiber更新的时候，ref对象的引用已经改变      || current !== null &amp;&amp; current.ref !== ref    ) &#123;    // Schedule a Ref effect    workInProgress.flags |= Ref;  &#125;&#125;\n\n所以绑定匿名函数的写法，会导致函数每次都执行，因为函数的引用不一样\n// 可以把函数定义为类的方法&lt;div ref=&#123;(node)=&gt;&#123;    this.node = node    console.log(&#x27;此时的参数是什么：&#x27;, this.node )&#125;&#125;  &gt;ref元素节点&lt;/div&gt;\n\n\n被卸载的 fiber 会被打成 Deletion effect tag ，然后在 commit 阶段会进行 commitDeletion 流程。对于有 ref 标记的 ClassComponent （类组件） 和 HostComponent （元素），会统一走 safelyDetachRef 流程，这个方法就是用来卸载 ref。\n\nreact-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js\n\nfunction safelyDetachRef(current) &#123;  const ref = current.ref;  if (ref !== null) &#123;    if (typeof ref === &#x27;function&#x27;) &#123;  // 函数式 ｜ 字符串        ref(null)    &#125; else &#123;      ref.current = null;  // ref 对象    &#125;  &#125;&#125;\n\n","categories":["React"],"tags":["React"]},{"title":"React原理 context深入","url":"/posts/5d39b4cbab35/","content":"context三中用法定义context\nconst ThemeContext = React.createContext(null) //const ThemeProvider = ThemeContext.Provider  //提供者const ThemeConsumer = ThemeContext.Consumer // 订阅消费者\n\n使用方法\nclass ConsumerDemo extends React.Component&#123;    render()&#123;        const &#123; color,background &#125; = this.context        return &lt;div style=&#123;&#123; color,background &#125; &#125; &gt;消费者&lt;/div&gt;     &#125; &#125; ConsumerDemo.contextType = ThemeContextfunction ProviderDemo()&#123;    const [ contextValue , setContextValue ] = React.useState(&#123;  color:&#x27;#ccc&#x27;, background:&#x27;pink&#x27; &#125;)    return &lt;div&gt;        &lt;ThemeProvider value=&#123; contextValue &#125; &gt;             &lt;ConsumerDemo /&gt;        &lt;/ThemeProvider&gt;    &lt;/div&gt;&#125;\n\nclass ConsumerDemo extends React.Component &#123;    render() &#123;        return &lt;ThemeConsumer&gt;            &#123;(&#123; color, background &#125;) =&gt; &lt;div style=&#123;&#123; color, background &#125;&#125; &gt;消费者&lt;/div&gt;&#125;        &lt;/ThemeConsumer&gt;    &#125;&#125;function ProviderDemo() &#123;    const [contextValue, setContextValue] = React.useState(&#123; color: &#x27;#ccc&#x27;, background: &#x27;pink&#x27; &#125;)    return &lt;div&gt;        &lt;ThemeProvider value=&#123;contextValue&#125; &gt;            &lt;ConsumerDemo /&gt;        &lt;/ThemeProvider&gt;    &lt;/div&gt;&#125;\n\nfunction ConsumerDemo() &#123;    const &#123; color, background &#125; = React.useContext(ThemeContext);    return &lt;div style=&#123;&#123; color, background &#125;&#125; &gt;消费者&lt;/div&gt;&#125;function ProviderDemo() &#123;    const [contextValue, setContextValue] = React.useState(&#123; color: &#x27;#ccc&#x27;, background: &#x27;pink&#x27; &#125;)    return &lt;div&gt;        &lt;ThemeProvider value=&#123;contextValue&#125; &gt;            &lt;ConsumerDemo /&gt;        &lt;/ThemeProvider&gt;    &lt;/div&gt;&#125;\n\ndisplayNamecontext 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。\nconst MyContext = React.createContext(/* 初始化内容 */);MyContext.displayName = &#x27;MyDisplayName&#x27;;&lt;MyContext.Provider&gt; // &quot;MyDisplayName.Provider&quot; 在 DevTools 中&lt;MyContext.Consumer&gt; // &quot;MyDisplayName.Consumer&quot; 在 DevTools 中\n\n源码createContext 创建了一个包含， Provider 和 Consumer 组件的对象,通过_context属性形成相互引用的循环链表结构\nfunction createContext(defaultValue, calculateChangedBits) &#123;  var context = &#123;    $$typeof: REACT_CONTEXT_TYPE,    _currentValue: defaultValue,    _currentValue2: defaultValue,    Provider: null,    Consumer: null  &#125;;  context.Provider = &#123;    $$typeof: REACT_PROVIDER_TYPE,    _context: context  &#125;;  &#123;    var Consumer = &#123;      $$typeof: REACT_CONTEXT_TYPE,      _context: context,    &#125;;     Object.defineProperties(Consumer, &#123;      // 添加getter 和 setter    &#125;);    context.Consumer = Consumer;  &#125;  return context;&#125;\n\n\n如果当前类型的 fiber 不需要更新，那么会 FinishedWork 中止当前节点和子节点的更新。\n如果当前类型 fiber 需要更新，那么会调用不同类型 fiber 的处理方法。当然 ContextProvider 也有特有的 fiber 更新方法 —— updateContextProvider\nfunction updateContextProvider(current, workInProgress, renderLanes) &#123;  // 通过type属性获取Provider组件  var providerType = workInProgress.type;  // 拿到createContext定义的上下文  var context = providerType._context;    // 获取传递到Provider组件的属性  var newProps = workInProgress.pendingProps;  var oldProps = workInProgress.memoizedProps;  var newValue = newProps.value;  // 方法内部通过context._currentValue = nextValue 给context赋值  pushProvider(workInProgress, newValue);    // 上一次props有值得时候需要判断是否进行子元素的调度  if (oldProps !== null) &#123;    var oldValue = oldProps.value;    // 1.判断引用是否相同    // 2.尝试使用自定义函数判断是否相同 changedBits &amp; MAX_SIGNED_31_BIT_INT) !== changedBits 如果不是有效数字则报错    // 3 通过 |0 操作将非法结果强制转换成0；    var changedBits = calculateChangedBits(context, newValue, oldValue);    if (changedBits === 0) &#123;      // context没有变化，且子节点没有变化，legacy context没改变，则退出更新      // No change. Bailout early if children are the same.      if (oldProps.children === newProps.children &amp;&amp; !hasContextChanged()) &#123;        // 子元素引用没有变化则停止调度        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);      &#125;    &#125; else &#123;      // The context value changed. Search for matching consumers and schedule      // them to update.      propagateContextChange(workInProgress, context, changedBits, renderLanes);    &#125;  &#125;  // 获取到子节点并继续在子节点上调度  var newChildren = newProps.children;  reconcileChildren(current, workInProgress, newChildren, renderLanes);  return workInProgress.child;&#125;\n\n\n\nfunction updateContextConsumer(current, workInProgress, renderLanes) &#123;  var context = workInProgress.type;  var newProps = workInProgress.pendingProps;  var render = newProps.children;  // 如果子元素不是一个函数则抛出错误  &#123;    if (typeof render !== &#x27;function&#x27;) &#123;      error(&#x27;A context consumer was rendered with multiple children, or a child &#x27; + &quot;that isn&#x27;t a function. A context consumer expects a single child &quot; + &#x27;that is a function. If you did pass a function, make sure there &#x27; + &#x27;is no trailing or leading whitespace around it.&#x27;);    &#125;  &#125;    prepareToReadContext(workInProgress, renderLanes);  // 获取最新的值  var newValue = readContext(context, newProps.unstable_observedBits);  var newChildren;  // 执行函数获取下一个节点  &#123;    ReactCurrentOwner$1.current = workInProgress;    setIsRendering(true);    newChildren = render(newValue);    setIsRendering(false);  &#125; // React DevTools reads this flag.  //继续在下一个节点上调度  workInProgress.flags |= PerformedWork;  reconcileChildren(current, workInProgress, newChildren, renderLanes);  return workInProgress.child;&#125;\n\n\n","categories":["React"],"tags":["React"]},{"title":"React原理 HOC高阶组件","url":"/posts/fc16ed74f067/","content":"属性代理属性代理，就是用组件包裹一层代理组件，在代理组件上，可以做一些，对源组件的强化操作。这里注意属性代理返回的是一个新组件，被包裹的原始组件，将在新的组件里被挂载。\nfunction HOC(WrapComponent)&#123;    return class Advance extends React.Component&#123;       state=&#123;           name:&#x27;alien&#x27;       &#125;       render()&#123;           return &lt;WrapComponent  &#123; ...this.props &#125; &#123; ...this.state &#125;  /&gt;       &#125;    &#125;&#125;\n\n优点：\n① 属性代理可以和业务组件低耦合，零耦合，对于条件渲染和 props 属性增强，只负责控制子组件渲染和传递额外的 props 就可以了，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的 HOC ，目前开源的 HOC 基本都是通过这个模式实现的。② 同样适用于类组件和函数组件。③ 可以完全隔离业务组件的渲染，因为属性代理说白了是一个新的组件，相比反向继承，可以完全控制业务组件是否渲染。④ 可以嵌套使用，多个 HOC 是可以嵌套使用的，而且一般不会限制包装 HOC 的先后顺序。\n缺点：\n① 一般无法直接获取原始组件的状态，如果想要获取，需要 ref 获取组件实例。② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。③ 因为本质上是产生了一个新组件，所以需要配合 forwardRef 来转发 ref。\n反向继承反向继承和属性代理有一定的区别，在于包装后的组件继承了原始组件本身，所以此时无须再去挂载业务组件。\nclass Index extends React.Component&#123;  render()&#123;    return &lt;div&gt; hello,world  &lt;/div&gt;  &#125;&#125;function HOC(Component)&#123;    return class wrapComponent extends Component&#123; /* 直接继承需要包装的组件 */            &#125;&#125;export default HOC(Index) \n\n优点：\n① 方便获取组件内部状态，比如 state ，props ，生命周期，绑定的事件函数等。② es6继承可以良好继承静态属性。所以无须对静态属性和方法进行额外的处理。\n缺点：\n① 函数组件无法使用。② 和被包装的组件耦合度高，需要知道被包装的原始组件的内部状态，具体做了些什么？③ 如果多个反向继承 HOC 嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个 componentDidMount ，当前 componentDidMount 会覆盖上一个 componentDidMount 。这样副作用串联起来，影响很大。\nHOC的几种场景强化props强化 props 就是在原始组件的 props 基础上，加入一些其他的 props ，强化原始组件功能。举个例子，为了让组件也可以获取到路由对象，进行路由跳转等操作，所以 React Router 提供了类似 withRouter 的 HOC 。\nfunction withRouter(Component) &#123;  const displayName = `withRouter($&#123;Component.displayName || Component.name&#125;)`;  const C = props =&gt; &#123;      /*  获取 */    const &#123; wrappedComponentRef, ...remainingProps &#125; = props;    return (      &lt;RouterContext.Consumer&gt;        &#123;context =&gt; &#123;          return (            &lt;Component              &#123;...remainingProps&#125; // 组件原始的props               &#123;...context&#125;        // 存在路由对象的上下文，history  location 等               ref=&#123;wrappedComponentRef&#125;            /&gt;          );        &#125;&#125;      &lt;/RouterContext.Consumer&gt;    );  &#125;;  C.displayName = displayName;  C.WrappedComponent = Component;  /* 继承静态属性 */  return hoistStatics(C, Component);&#125;export default withRouter\n\n分离出 props 中 wrappedComponentRef 和 remainingProps ， remainingProps 是原始组件真正的 props， wrappedComponentRef 用于转发 ref。用 Context.Consumer 上下文模式获取保存的路由信息。（ React Router 中路由状态是通过 context 上下文保存传递的）将路由对象和原始 props 传递给原始组件，所以可以在原始组件中获取 history ，location 等信息。\n控制渲染HOC 反向继承模式，可以通过 super.render() 得到 render 之后的内容，利用这一点，可以做渲染劫持 ，更有甚者可以修改 render 之后的 React element 对象。\nconst HOC = (WrapComponent) =&gt;  class Index  extends WrapComponent &#123;    render() &#123;      if (this.props.visible) &#123;        return super.render()      &#125; else &#123;        return &lt;div&gt;暂无数据&lt;/div&gt;      &#125;    &#125;  &#125;\n\n\nclass Index extends React.Component&#123;  render()&#123;    return &lt;div&gt;       &lt;ul&gt;         &lt;li&gt;react&lt;/li&gt;         &lt;li&gt;vue&lt;/li&gt;         &lt;li&gt;Angular&lt;/li&gt;       &lt;/ul&gt;    &lt;/div&gt;  &#125;&#125;function HOC (Component)&#123;  return class Advance extends Component &#123;    render() &#123;      const element = super.render()      const otherProps = &#123;        name:&#x27;alien&#x27;      &#125;      /* 替换 Angular 元素节点 */      const appendElement = React.createElement(&#x27;li&#x27; ,&#123;&#125; , `hello ,world , my name  is $&#123; otherProps.name &#125;` )      const newchild =  React.Children.map(element.props.children.props.children,(child,index)=&gt;&#123;           if(index === 2) return appendElement           return  child      &#125;)       return  React.cloneElement(element, element.props, newchild)    &#125;  &#125;&#125;export  default HOC(Index)\n\n\n动态加载dva 中 dynamic 就是配合 import ，实现组件的动态加载的，而且每次切换路由，都会有 Loading 效果，接下来看看大致的实现思路。\nexport default function dynamicHoc(loadRouter) &#123;  return class Content extends React.Component &#123;    state = &#123;Component: null&#125;    componentDidMount() &#123;      if (this.state.Component) return      loadRouter()        .then(module =&gt; module.default) // 动态加载 component 组件        .then(Component =&gt; this.setState(&#123;Component&#125;,         ))    &#125;    render() &#123;      const &#123;Component&#125; = this.state      return Component ? &lt;Component &#123;      ...this.props      &#125;      /&gt; : &lt;Loading /&gt;    &#125;  &#125;&#125;\n\n\n组件赋能ref获取实例 \n对于属性代理虽然不能直接获取组件内的状态，但是可以通过 ref 获取组件实例，获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是：类组件才存在实例，函数组件不存在实例。\nfunction Hoc(Component)&#123;  return class WrapComponent extends React.Component&#123;      constructor()&#123;        super()        this.node = null /* 获取实例，可以做一些其他的操作。 */      &#125;      render()&#123;        return &lt;Component &#123;...this.props&#125;  ref=&#123;(node) =&gt; this.node = node &#125;  /&gt;      &#125;  &#125;&#125;\n\n事件监控\nHOC 不一定非要对组件本身做些什么？也可以单纯增加一些事件监听，错误监控。接下来，接下来做一个 HOC ，只对组件内的点击事件做一个监听效果。\nfunction ClickHoc (Component)&#123;  return  function Wrap(props)&#123;    const dom = useRef(null)    useEffect(()=&gt;&#123;       const handerClick = () =&gt; console.log(&#x27;发生点击事件&#x27;)        dom.current.addEventListener(&#x27;click&#x27;,handerClick)     return () =&gt; dom.current.removeEventListener(&#x27;click&#x27;,handerClick)    &#125;,[])    return  &lt;div ref=&#123;dom&#125;  &gt;&lt;Component  &#123;...props&#125; /&gt;&lt;/div&gt;  &#125;&#125;@ClickHocclass Index extends React.Component&#123;   render()&#123;     return &lt;div className=&#x27;index&#x27;  &gt;       &lt;p&gt;hello，world&lt;/p&gt;       &lt;button&gt;组件内部点击&lt;/button&gt;    &lt;/div&gt;   &#125;&#125;export default ()=&gt;&#123;  return &lt;div className=&#x27;box&#x27;  &gt;     &lt;Index /&gt;     &lt;button&gt;组件外部点击&lt;/button&gt;  &lt;/div&gt;&#125;\n\n\n总结下面对 HOC 具体能实现那些功能，和如何编写做一下总结：\n\n强化 props ，可以通过 HOC ，向原始组件混入一些状态。\n\n渲染劫持，可以利用 HOC ，动态挂载原始组件，还可以先获取原始组件的渲染树，进行可控性修改。\n\n可以配合 import 等 api ，实现动态加载组件，实现代码分割，加入 loading 效果。\n\n可以通过 ref 来获取原始组件实例，操作实例下的属性和方法。\n\n可以对原始组件做一些事件监听，错误监控等。\n\n\n注意事项谨慎修改原型链\n如上 HOC 作用仅仅是修改了原来组件原型链上的 componentDidMount 生命周期。但是这样有一个弊端就是如果再用另外一个 HOC 修改原型链上的 componentDidMount ，那么这个HOC的功能即将失效。\nfunction HOC (Component)&#123;  const proDidMount = Component.prototype.componentDidMount   Component.prototype.componentDidMount = function()&#123;     console.log(&#x27;劫持生命周期：componentDidMount&#x27;)     proDidMount.call(this)  &#125;  return  Component&#125;\n\n不要在函数组件内部或类组件render函数中使用HOC\n由于属性的引用不同，每次都会重新渲染\nref的处理\n高阶组件的约定是将所有 props 传递给被包装组件，但这对于 ref 并不适用。那是因为 ref 实际上并不是一个 prop ， 就像 key 一样，对于 ref 属性它是由 React 专门处理的。那么如何通过 ref 正常获取到原始组件的实例呢？在 ref 章节已经讲到，可以用 forwardRef做 ref 的转发处理。\n修饰器的嵌套顺序\n静态属性需要处理\n","categories":["React"],"tags":["React"]},{"title":"React原理 diff算法","url":"/posts/5d71f8c31805/","content":"随机树差异查找两个随机树之间的最小差异是一个 O(n^3)问题。\n如你所想，这么高复杂度的算法是无法满足我们的需求的。React 使用了一种更为简单且直观的算法使得算法复杂度优化至 O(n)。\nReact 只会逐层对比两颗随机树。这大大降低了 diff 算法的复杂度。并且在 web 组件中很少会将节点移动到不同的层级，经常只会在同一层级中移动。\n\ndiff 策略\nWeb UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。\n\n拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。\n\n对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。\n\n\ntree diff基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。\n既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。\n如下图，A 节点（包括其子节点）整个被移动到 D 节点下，由于 React 只会简单的考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，React diff 的执行情况：create A -&gt; create B -&gt; create C -&gt; delete A。\n\n由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。\ncomponent diff\nReact 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。\n\n如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。\n\n如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。\n\n对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。\n\n\n如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。\n\ndiff 过程\n判断新的子元素中是否有重复的 key，如果有则抛出警告。方法是通过创建一个 Set 对象，判断 key 时候已经存在。\n\nfor (var i = 0; i &lt; newChildren.length; i++) &#123;  var child = newChildren[i];  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);&#125;\n\n\n利用循环新的子元素数组，遍历老的子元素 Fiber然后通过调用 updateSlot ，updateSlot 内部会判断当前的 tag 和 key 是否匹配，如果匹配复用老 fiber 形成新的 fiber ，如果不匹配，返回 null ，此时 newFiber 等于 null 。跳出循环。如果是处于更新流程，找到与新节点对应的老 fiber ，但是不能复用 alternate &#x3D;&#x3D;&#x3D; null ，那么会删除老 fiber 。\n\n for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;    if (oldFiber.index &gt; newIdx) &#123;        nextOldFiber = oldFiber;        oldFiber = null;    &#125; else &#123;        nextOldFiber = oldFiber.sibling;    &#125;    const newFiber = updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime,);    if (newFiber === null) &#123; break &#125;    // ..一些其他逻辑    &#125;    if (shouldTrackSideEffects) &#123;  // shouldTrackSideEffects 为更新流程。        if (oldFiber &amp;&amp; newFiber.alternate === null) &#123;            /* 找到了与新节点对应的fiber，但是不能复用，那么直接删除老节点 */            deleteChild(returnFiber, oldFiber);        &#125;    &#125;&#125;\n\n\n当第一步结束完 newIdx &#x3D;&#x3D;&#x3D; newChildren.length 此时证明所有 newChild 已经全部被遍历完，那么剩下没有遍历 oldFiber 也就没有用了，那么调用 deleteRemainingChildren 统一删除剩余 oldFiber 。\n\nif (newIdx === newChildren.length) &#123;  // We&#x27;ve reached the end of the new children. We can delete the rest.  deleteRemainingChildren(returnFiber, oldFiber);  return resultingFirstChild;&#125;\n\n\n当经历过第一步，oldFiber 为 null ， 证明 oldFiber 复用完毕，那么如果还有新的 children ，说明都是新的元素，只需要调用 createChild 创建新的 fiber 。\n\nif (oldFiber === null) &#123;  for (; newIdx &lt; newChildren.length; newIdx++) &#123;    const newFiber = createChild(      returnFiber,      newChildren[newIdx],      expirationTime    );    // ...  &#125;&#125;\n\n\n针对移动元素的场景\n\nmapRemainingChildren 返回一个 map ，map 里存放剩余的老的 fiber 和对应的 key (或 index )的映射关系。\n接下来遍历剩下没有处理的 Children ，通过 updateFromMap ，判断 mapRemainingChildren 中有没有可以复用 oldFiber ，如果有，那么复用，如果没有，新创建一个 newFiber 。\n复用的 oldFiber 会从 mapRemainingChildren 删掉。\nconst existingChildren = mapRemainingChildren(returnFiber, oldFiber);if (_newFiber2 !== null) &#123;    if (shouldTrackSideEffects) &#123;        if (_newFiber2.alternate !== null) &#123;        // The new fiber is a work in progress, but if there exists a        // current, that means that we reused the fiber. We need to delete        // it from the child list so that we don&#x27;t add it to the deletion        // list.        existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);        &#125;    &#125;    lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);    if (previousNewFiber === null) &#123;        resultingFirstChild = _newFiber2;    &#125; else &#123;        previousNewFiber.sibling = _newFiber2;    &#125;    previousNewFiber = _newFiber2;    &#125;&#125;if (shouldTrackSideEffects) &#123;    // Any existing children that weren&#x27;t consumed above were deleted. We need    // to add them to the deletion list.    existingChildren.forEach(function (child) &#123;    return deleteChild(returnFiber, child);    &#125;);&#125;\n\n位置交换 lastPlacedIndex初始化为 0，如果一个新元素的索引大于lastPlacedIndex表示他从后面一动到前面，那么位置保持不变，如果新元素的索引小于lastPlacedIndex表示需要移动到后面，会被打上移动的 flag,最后通过previousNewFiber(他保存着上一次的最后节点)和sibling将 Fiber 链表链接\nfunction placeChild(newFiber, lastPlacedIndex, newIndex) &#123;    newFiber.index = newIndex;    if (!shouldTrackSideEffects) &#123;      // Noop.      return lastPlacedIndex;    &#125;    var current = newFiber.alternate;    if (current !== null) &#123;      var oldIndex = current.index;      if (oldIndex &lt; lastPlacedIndex) &#123;        // This is a move.        newFiber.flags = Placement;        return lastPlacedIndex;      &#125; else &#123;        // This item can stay in place.        return oldIndex;      &#125;    &#125; else &#123;      // This is an insertion.      newFiber.flags = Placement;      return lastPlacedIndex;    &#125;  &#125;&#125;\n","categories":["React"],"tags":["React"]},{"title":"React原理 海量数据处理","url":"/posts/21a6cf64a57d/","content":"requestIdleCallback\n图中是浏览器每一帧的生命周期，requestIdleCallback则会在某一帧结束后的空闲时间或者用户处于不活跃状态时，处理我们的工作。\n靠自己人工的安排不必要的工作是很困难的。比如，要弄清楚一帧剩余的时间，这显然是不可能的，因为当requestAnimationFrame的回调完成后，还要进行样式的计算，布局，渲染以及浏览器内部的工作等等。为了确保用户不以某种方式进行交互，你需要为各种交互行为添加监听事件（scroll、touch、click），即使你并不需要这些功能，只有这样才能绝对确保用户没有进行交互。另一方面，浏览器能够确切地知道在一帧的结束时有多少的可用时间，如果用户正在交互，通过使用requestIdleCallback这个API，允许我们尽可能高效地利用任何的空闲时间。\n当 myNonEssentialWork 被调用，会返回一个 deadline 对象，这个对象包含一个方法，该方法会返回一个数字表示你的工作还能执行多长时间：\nrequestIdleCallback(function myNonEssentialWork (deadline) &#123;  while (deadline.timeRemaining() &gt; 0)    doWorkIfNeeded();&#125;)\n\n 调用 timeRemaining 这个方法能获得最后的剩余时间，当 timeRemaining() 返回0，如果你仍有其他任务需要执行，可以在下一次空闲时间继续执行\nfunction myNonEssentialWork (deadline) &#123;  while (deadline.timeRemaining() &gt; 0 &amp;&amp; tasks.length &gt; 0)    doWorkIfNeeded();  if (tasks.length &gt; 0)    requestIdleCallback(myNonEssentialWork);&#125;\n\n如果任务耗时太长，可能回调函数永远不能执行，requestIdleCallback有一个可选的第二个参数：含有timeout属性的对象。如果设置了timeout这个值，回调函数还没被调用的话，则浏览器必须在设置的这个毫秒数时，去强制调用对应的回调函数。\n如果你的回调函数是因为设置的这个timeout而触发的，你会注意到：\ntimeRemaining()会返回0deadline对象的didTimeout属性值是true\n注意事项\n对非高优先级的任务使用空闲回调。 已经创建了多少回调，用户系统的繁忙程度，你的回调多久会执行一次（除非你指定了 timeout），这些都是未知的。不能保证每次事件循环（甚至每次屏幕更新）后都能执行空闲回调；如果事件循环用尽了所有可用时间，那可能你的任务永远不能执行。在你需要的时候要用 timeout，但记得只在需要的时候才用。 使用 timeout可以保证你的代码按时执行，但是在剩余时间不足以强制执行你的代码的同时保证浏览器的性能表现的情况下，timeout就会造成延迟或者动画不流畅。设置了timeout，如果回调中的任务也是个长时间任务，可能会导致影响用户交互。最好的办是确认任务足够小。\n\n空闲回调应尽可能不超支分配到的时间。尽管即使你超出了规定的时间上限，通常来说浏览器、代码、网页也能继续正常运行，这里的时间限制是用来保证系统能留有足够的时间去完成当前的事件循环然后进入下一个循环，而不会导致其他代码卡顿或动画效果延迟。目前，timeRemaining() 有一个50 ms 的上限时间，但实际上你能用的时间比这个少，因为在复杂的页面中事件循环可能已经花费了其中的一部分，浏览器的扩展插件也需要处理时间，等等。\n\n避免在空闲回调中改变 DOM。 空闲回调执行的时候，当前帧已经结束绘制了，所有布局的更新和计算也已经完成。如果你做的改变影响了布局， 你可能会强制停止浏览器并重新计算，而从另一方面来看，这是不必要的。 如果你的回调需要改变DOM，它应该使用Window.requestAnimationFrame()来调度它。\n\n避免运行时间无法预测的任务。 你的空闲回调必须避免做任何占用时间不可预测的事情。比如说，应该避免做任何会影响页面布局的事情。你也必须避免 执行Promise (en-US) 的resolve和reject，因为这会在你的回调函数返回后立即引用Promise对象对resolve和reject的处理程序。可能导致任务阻塞。\n\n\n回退兼容window.requestIdleCallback = window.requestIdleCallback || function(handler) &#123;  let startTime = Date.now();  return setTimeout(function() &#123;    handler(&#123;      didTimeout: false,      timeRemaining: function() &#123;        return Math.max(0, 50.0 - (Date.now() - startTime));      &#125;    &#125;);  &#125;, 1);&#125;window.cancelIdleCallback = window.cancelIdleCallback || function(id) &#123;  clearTimeout(id);&#125;\n\n上报数据有时我们希望，避免在用户交互行为发生的时候立即上报数据，思路就是将上报信息添加到队列中，在空闲的时间处理\nvar eventsToSend = [];function onNavOpenClick () &#123;  eventsToSend.push(    &#123;      category: &#x27;button&#x27;,      action: &#x27;click&#x27;,      label: &#x27;nav&#x27;,      value: &#x27;open&#x27;    &#125;);  schedulePendingEvents();&#125;function schedulePendingEvents() &#123;  // 如果已经在调度中则返回  if (isRequestIdleCallbackScheduled)    return;  isRequestIdleCallbackScheduled = true;  if (&#x27;requestIdleCallback&#x27; in window) &#123;    // 最晚两秒之后上报数据    requestIdleCallback(processPendingAnalyticsEvents, &#123; timeout: 2000 &#125;);  &#125; else &#123;    processPendingAnalyticsEvents();  &#125;&#125;function processPendingAnalyticsEvents (deadline) &#123;  // 重置状态  isRequestIdleCallbackScheduled = false;  // 针对没有实现 requestIdleCallback 的环境  if (typeof deadline === &#x27;undefined&#x27;)    deadline = &#123; timeRemaining: function () &#123; return Number.MAX_VALUE &#125; &#125;;  while (deadline.timeRemaining() &gt; 0 &amp;&amp; eventsToSend.length &gt; 0) &#123;    var evt = eventsToSend.pop();    ga(&#x27;send&#x27;, &#x27;event&#x27;,        evt.category,        evt.action,        evt.label,        evt.value);  &#125;  // 如果还有任务在下次空闲时发送  if (eventsToSend.length &gt; 0)    schedulePendingEvents();&#125;\n\n渲染分片对于大量数据渲染，可以考虑利用浏览器空闲时间分片处理\nconst generateColor = () =&gt; &#123;    const r = Math.floor(Math.random()*255);    const g = Math.floor(Math.random()*255);    const b = Math.floor(Math.random()*255);    return &#x27;rgba(&#x27;+ r +&#x27;,&#x27;+ g +&#x27;,&#x27;+ b +&#x27;,0.8)&#x27;;&#125;const getRandomPos = (width,height,distance = 0) =&gt; (&#123;    x: distance/2 + (width - distance/2) * Math.random(),    y: distance/2 + (height - distance/2) * Math.random(),&#125;)const Circle = (&#123;position,color&#125;) =&gt;&#123;    return &lt;div style=&#123;&#123;        width:10,        height:10,        borderRadius:&quot;50%&quot;,        backgroundColor:color,        position:&#x27;absolute&#x27;,        left:position.x,        top:position.y    &#125;&#125;&gt;&lt;/div&gt;&#125; const getKey =()=&gt; Math.random().toString(36).substring(2,8)const renderCircle = (count,width,height)=&gt;  new Array(count).fill(&#x27;circle&#x27;).map(()=&gt;(    &lt;Circle position=&#123;getRandomPos(width,height)&#125; key=&#123;getKey()&#125; color=&#123;generateColor()&#125;/&gt;))const calcRenderCount = (count,perRenderCount,times) =&gt; &#123;    if(perRenderCount *　times &gt; count) return count % perRenderCount;    return perRenderCount;&#125;export default function Magnanimity()&#123;    const [list,setList] = useState([]);    const total = useRef(20000);    const throttleCount= useRef(500);    const timeSpliceRender = useCallback((renderTimes,currentTime,width,height)=&gt;&#123;        if(currentTime &gt; renderTimes) return;        const task = () =&gt; &#123;            const renderCount = calcRenderCount(total.current,throttleCount.current,currentTime);            setList(list=&gt; list.concat(renderCircle(renderCount,width,height)))            currentTime++;        &#125;        requestIdleCallback((deadline)=&gt;&#123;            while (deadline.timeRemaining()&gt;0) &#123;                task();            &#125;            timeSpliceRender(renderTimes,currentTime,width,height);        &#125;)    &#125;,[setList,        total,        throttleCount    ])    useEffect(()=&gt;&#123;         const currentTime = 1;        const renderTimes = Math.ceil(total.current/throttleCount.current);        const width = document.documentElement.clientWidth;        const height = document.documentElement.clientHeight;        timeSpliceRender(renderTimes,currentTime,width,height)    &#125;,[        timeSpliceRender,        total,        throttleCount    ])    return  &lt;div         onClick=&#123;()=&gt;console.log(&quot;click&quot;)&#125;    style=&#123;&#123;        width:document.documentElement.clientWidth,        height:document.documentElement.clientHeight,    &#125;&#125;&gt;&#123;list&#125;&lt;/div&gt;&#125;\n\n\n长列表渲染比较容易想到的思路是：\n\n计算出列表能容纳的个数。\n\n计算需要渲染列表的高度\n\n筛选能显示在列表中的元素，为了保证用户体验，靠近列表头部和尾部的元素也可以渲染出来。\n\n为每个列表元素设置偏移量\n\n当滚动列表时，重新筛选显示元素并设置偏移量\n\n\nfunction List(&#123;data&#125;)&#123;    const [height,setHeight] = useState(0);    const [filterData,setFilterData] = useState([]);    const [scrollTop,setScrollTop] = useState(0);    const wrapperRef = useRef(null)    useEffect(()=&gt;&#123;        setHeight(()=&gt; data.length * 40)    &#125;,[        data,        setHeight    ])    useEffect(()=&gt;&#123;        const arr = [];        const boxHeight = wrapperRef.current.offsetHeight;        // 如果离列表头尾超过三个元素则不在显示        data.forEach((item,index) =&gt; &#123;            if(index * 40 - 1 - scrollTop &lt;= -80) return             if(index * 40 - 1 - boxHeight - scrollTop &gt;= 80) return             console.log(item)            arr.push(&#123;                ...item,                top: index * 40            &#125;)        &#125;);        setFilterData(arr);            &#125;,[        scrollTop,        data,        height,        setFilterData,        wrapperRef    ])    const scroll = useCallback((e)=&gt;&#123;        // 滚动时重新筛选元素        setScrollTop(e.target.scrollTop)    &#125;,[setScrollTop])    if(!data ||　!Array.isArray(data)) return null;    return (        &lt;div style=&#123;&#123;            height:&#x27;100%&#x27;,            width:&#x27;100%&#x27;,            overflow:&#x27;auto&#x27;        &#125;&#125;        ref=&#123;wrapperRef&#125;        onScroll=&#123;scroll&#125;        &gt;            &lt;ul                style=&#123;&#123;height,position:&#x27;relative&#x27;&#125;&#125;            &gt;                &#123;filterData.map(item =&gt; (                    &lt;li                         key=&#123;item.key&#125;                        style=&#123;&#123;                            padding:&#x27;5px 4px&#x27;,                            position:&#x27;absolute&#x27;,                            left:0,                            right:0,                            top:item.top                        &#125;&#125;                    &gt;                           &lt;div                          style=&#123;&#123;                            background:&#x27;pink&#x27;,                            lineHeight:&#x27;30px&#x27;,                            height:&#x27;30px&#x27;                          &#125;&#125;                           &gt;                            &#123;item.value&#125;                        &lt;/div&gt;                    &lt;/li&gt;)                )&#125;            &lt;/ul&gt;        &lt;/div&gt;    )&#125;export default function Comp()&#123;    const [data, setData] = useState(new Array(10).fill(1).map((item,index)=&gt;(&#123;key:index,value:index&#125;)))    return &lt;div style=&#123;&#123;width:300,height:600,border:&#x27;1px solid #000&#x27;&#125;&#125;&gt;        &lt;List data=&#123;data&#125;&gt;&lt;/List&gt;    &lt;/div&gt;&#125;\n\n上面的实现存在几个问题：\n\n常量没有抽离，不能灵活配置\n\n每次滚动触发，需要遍历数据，性能损耗大\n\n\n所以，可以优化为根据滚动高度计算出需要展示数据的区间，用transform变换待定绝对定位\nfunction List(&#123;data=[]&#125;)&#123;    const wrapperRef = useRef(null)    // 元素容器    const containerRef = useRef(null);    const [range,setRange] = useState([0,0])    const info = useRef(&#123;        // 屏幕外预渲染的个数        preRenderCount:2,        // 元素高度        itemHeight:40            &#125;)    useEffect(()=&gt;&#123;        const boxHeight = wrapperRef.current.offsetHeight;        const &#123;itemHeight,preRenderCount&#125; = info.current;        // 不需要关心data长度，如果截取的长度溢出，仍然会包含data中所有元素        const end = Math.ceil(boxHeight/itemHeight) + preRenderCount;        setRange([0,end]);            &#125;,[        info,        wrapperRef,        setRange    ])    const scroll = useCallback((e)=&gt;&#123;        const scrollTop = e.target.scrollTop;        const boxHeight = wrapperRef.current.offsetHeight;        const &#123;itemHeight,preRenderCount&#125; = info.current;        // 顶部有两个缓冲元素，滚动高度还在这两个元素高度范围内，则前两个元素会被保留        const start = Math.floor(Math.max(0, scrollTop - preRenderCount * itemHeight) / itemHeight);                // 不需要关心data长度，如果截取的长度溢出，仍然会包含data中所有元素        const end =  Math.ceil((scrollTop + boxHeight)/itemHeight)　+　preRenderCount;        // 计算内容区域偏移量 移动距离大于元素高度，重置视图框的位置        const offset =  scrollTop - preRenderCount * itemHeight &gt; 0 ? scrollTop - (scrollTop % itemHeight) - preRenderCount * itemHeight : 0;        containerRef.current.style.transform= `translate3D(0,$&#123;offset&#125;px,0)`        setRange([start,end])    &#125;,[1        setRange,        wrapperRef,        containerRef    ])    const &#123;itemHeight&#125; =  info.current;    const height = useMemo(()=&gt;data.length * itemHeight,[data,itemHeight]);    if(!data ||　!Array.isArray(data)) return null;    return (        &lt;div style=&#123;&#123;            height:&#x27;100%&#x27;,            width:&#x27;100%&#x27;,            overflow:&#x27;auto&#x27;,            position:&#x27;relative&#x27;        &#125;&#125;        ref=&#123;wrapperRef&#125;        onScroll=&#123;scroll&#125;        &gt;               &lt;div style=&#123;&#123;height&#125;&#125;&gt;&lt;/div&gt;            &#123;/* 注意：对ul列表的操作可能会触发上层滚动条的事件，所以仍然让他脱离文档流 */&#125;            &lt;ul                ref=&#123;containerRef&#125;                style=&#123;&#123;                    position:&#x27;absolute&#x27;,                    top:0,                    left:0,                    right:0                &#125;&#125;            &gt;                &#123;data.slice(...range).map(item =&gt; (                    &lt;li                         key=&#123;item.key&#125;                        style=&#123;&#123;                            height:itemHeight,                            overflow:&#x27;hidden&#x27;                        &#125;&#125;                    &gt;                           &lt;div                        style=&#123;&#123;                            background:&#x27;pink&#x27;,                            lineHeight:&#x27;30px&#x27;,                            height:&#x27;30px&#x27;,                            margin:&#x27;5px 4px&#x27;                        &#125;&#125;                           &gt;                            &#123;item.value&#125;                        &lt;/div&gt;                    &lt;/li&gt;)                )&#125;            &lt;/ul&gt;        &lt;/div&gt;    )&#125;export default function Comp()&#123;    const [data, setData] = useState(new Array(100).fill(1).map((item,index)=&gt;(&#123;key:index,value:index&#125;)))    return &lt;div style=&#123;&#123;width:300,height:600,border:&#x27;1px solid #000&#x27;&#125;&#125;&gt;        &lt;List data=&#123;data&#125;&gt;&lt;/List&gt;    &lt;/div&gt;&#125;","categories":["React"],"tags":["React"]},{"title":"React原理 Suspense lazy","url":"/posts/69ea5c974b5e/","content":"lazy\n&#x2F;react&#x2F;packages&#x2F;react&#x2F;src&#x2F;ReactLazy.js\n\nlazy的本质是返回一个包含thenable的对象\nfunction lazyInitializer&lt;T&gt;(payload: Payload&lt;T&gt;): T &#123;  if (payload._status === Uninitialized) &#123;    const ctor = payload._result;    const thenable = ctor();    // Transition to the next state.    // This might throw either because it&#x27;s missing or throws. If so, we treat it    // as still uninitialized and try again next time. Which is the same as what    // happens if the ctor or any wrappers processing the ctor throws. This might    // end up fixing it if the resolution was a concurrency bug.    thenable.then(      moduleObject =&gt; &#123;        if (payload._status === Pending || payload._status === Uninitialized) &#123;          // Transition to the next state.          const resolved: ResolvedPayload&lt;T&gt; = (payload: any);          resolved._status = Resolved;          resolved._result = moduleObject;        &#125;      &#125;,      error =&gt; &#123;        if (payload._status === Pending || payload._status === Uninitialized) &#123;          // Transition to the next state.          const rejected: RejectedPayload = (payload: any);          rejected._status = Rejected;          rejected._result = error;        &#125;      &#125;,    );    if (payload._status === Uninitialized) &#123;      // In case, we&#x27;re still uninitialized, then we&#x27;re waiting for the thenable      // to resolve. Set it as pending in the meantime.      const pending: PendingPayload = (payload: any);      pending._status = Pending;      pending._result = thenable;    &#125;  &#125;  if (payload._status === Resolved) &#123;    const moduleObject = payload._result;       return moduleObject.default;  &#125; else &#123;    throw payload._result;  &#125;&#125;export function lazy&lt;T&gt;(  ctor: () =&gt; Thenable&lt;&#123;default: T, ...&#125;&gt;,): LazyComponent&lt;T, Payload&lt;T&gt;&gt; &#123;  const payload: Payload&lt;T&gt; = &#123;    // We use these fields to store the result.    _status: -1,    _result: ctor,  &#125;;  const lazyType: LazyComponent&lt;T, Payload&lt;T&gt;&gt; = &#123;    $$typeof: REACT_LAZY_TYPE,    _payload: payload,    _init: lazyInitializer,  &#125;;    return lazyType;&#125;\n\nRender阶段在beginWork中遇到LazyComponent类型组件，会调用mountLazyComponent 方法处理\nfunction mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes) &#123;  if (_current !== null) &#123;    // A lazy component only mounts if it suspended inside a non-    // concurrent tree, in an inconsistent state. We want to treat it like    // a new mount, even though an empty version of it already committed.    // Disconnect the alternate pointers.    _current.alternate = null;    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect    workInProgress.flags |= Placement;  &#125;  var props = workInProgress.pendingProps;  var lazyComponent = elementType;  var payload = lazyComponent._payload;  var init = lazyComponent._init;  // 第一次挂载组件时，因为promise状态不是完成状态，会抛出错误被上层的try catch捕获  var Component = init(payload);  workInProgress.type = Component;  // 如果已经加载成功，分析出异步组件的类型  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);  // 合并异步组件的props和通过lazy创建组件时传入的props  var resolvedProps = resolveDefaultProps(Component, props);  var child;  // 根据不同的组件类型处理，如果没有则抛出错误  switch (resolvedTag) &#123;      //...  &#125;  &#123;    throw Error( &quot;Element type is invalid. Received a promise that resolves to: &quot; + Component + &quot;. Lazy element type must resolve to a class or function.&quot; + hint );  &#125;&#125;\n\n下面是Suspense如何被创建并影响lazy创建的异步组件\nReact并没有直接创建Suspense组件，最开始的时候Suspense组件只是一个标识用于导出 REACT_SUSPENSE_TYPE as Suspense\n节点类型的创建，在初始只会创建出根节点的 fiber，后续的创建在 beginWork 入口，进入 reconcile 过程，会判断节点可复用性，然后不能复用的就通过 createFiberFromTypeAndProps 创建新节点。\nfunction createFiberFromSuspense(pendingProps, mode, lanes, key) &#123;  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn&#x27;t have a type. It has a tag.  // This needs to be fixed in getComponentName so that it relies on the tag  // instead.  fiber.type = REACT_SUSPENSE_TYPE;  fiber.elementType = REACT_SUSPENSE_TYPE;  fiber.lanes = lanes;  return fiber;&#125;\n\nbeginWork中发现是Suspense类型会执行 updateSuspenseComponent\n第一次执行创建子节点 workInProgress.child = mountChildFibers \n第二次执行，建立节点间联系\nfallbackChildFragment.return = workInProgress;primaryChildFragment.sibling = fallbackChildFragment;workInProgress.child = primaryChildFragment;return fallbackChildFragment\n\n由于第一次执行的时候lazy组件抛出错误，会被renderRootSync捕获\nfunction renderRootSync(root, lanes) &#123;  do &#123;    try &#123;      workLoopSync();      break;    &#125; catch (thrownValue) &#123;      handleError(root, thrownValue);    &#125;  &#125; while (true);&#125;\n\nfunction handleError(root, thrownValue) &#123;  do &#123;    try &#123;      ...      // 继续执行      throwException(...);      // 这里完成时   会将wip设置为自己的父节点  也就是 suspense 节点      workInProgress = completeUnitOfWork(workInProgress);    &#125; catch (yetAnotherThrownValue) &#123;      ...      continue    &#125;    // Return to the normal work loop.    return;  &#125; while (true);&#125;\n\n继续执行 throwException，这里会将抛出的 promise 放入子组件的 updateQueue\nfunction throwException(  root: FiberRoot,  returnFiber: Fiber,  sourceFiber: Fiber,  value: mixed,  renderExpirationTime: ExpirationTime,) &#123;  ...  if (    value !== null &amp;&amp;    typeof value === &#x27;object&#x27; &amp;&amp;    typeof value.then === &#x27;function&#x27;  ) &#123;    // This is a thenable.    const thenable: Thenable = (value: any);    ...    do &#123;      if (        workInProgress.tag === SuspenseComponent &amp;&amp;        shouldCaptureSuspense(workInProgress, hasInvisibleParentBoundary)      ) &#123;        // 一个 set 结构存储在 updateQueue        const thenables: Set&lt;Thenable&gt; = (workInProgress.updateQueue: any);        if (thenables === null) &#123;          const updateQueue = (new Set(): any);          updateQueue.add(thenable);          // 第一次新增          workInProgress.updateQueue = updateQueue;        &#125; else &#123;          // 追加          thenables.add(thenable);        &#125;           ...          // 同步设置          sourceFiber.expirationTime = Sync;          return;        &#125;        ...      workInProgress = workInProgress.return;    &#125; while (workInProgress !== null);      &#125;  ...&#125;\ncommit阶段commitWork 中会处理队列中的Promise\n会对之前渲染的 fallback 组件标记删除，对新的渲染数据标记更新。\nfunction attachSuspenseRetryListeners(finishedWork) &#123;  // If this boundary just timed out, then it will have a set of wakeables.  // For each wakeable, attach a listener so that when it resolves, React  // attempts to re-render the boundary in the primary (pre-timeout) state.  var wakeables = finishedWork.updateQueue;  if (wakeables !== null) &#123;    finishedWork.updateQueue = null;    var retryCache = finishedWork.stateNode;    if (retryCache === null) &#123;      retryCache = finishedWork.stateNode = new PossiblyWeakSet();    &#125;    wakeables.forEach(function (wakeable) &#123;      // Memoize using the boundary fiber to prevent redundant listeners.      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);      if (!retryCache.has(wakeable)) &#123;        &#123;          if (wakeable.__reactDoNotTraceInteractions !== true) &#123;            retry = tracing.unstable_wrap(retry);          &#125;        &#125;        retryCache.add(wakeable);        // 通过then方法在resolve之后执行        wakeable.then(retry, retry);      &#125;    &#125;);  &#125;&#125;\n\n实现一个异步组件/** *  * @param &#123;*&#125; Component  需要异步数据的component  * @param &#123;*&#125; api        请求数据接口,返回Promise，可以再then中获取与后端交互的数据 * @returns  */function AysncComponent(Component,api)&#123;    const AysncComponentPromise = () =&gt; new Promise(async (resolve)=&gt;&#123;          const data = await api()          resolve(&#123;              default: (props) =&gt; &lt;Component rdata=&#123;data&#125; &#123; ...props&#125;  /&gt;          &#125;)    &#125;)    return React.lazy(AysncComponentPromise)&#125;\n\n\n用 AysncComponent 作为一个 HOC 包装组件，接受两个参数，第一个参数为当前组件，第二个参数为请求数据的 api 。\n声明一个函数给 React.lazy 作为回调函数，React.lazy 要求这个函数必须是返回一个 Promise 。在 Promise 里面通过调用 api 请求数据，然后根据返回来的数据 rdata 渲染组件，别忘了接受并传递 props 。\n\n/* 数据模拟 */const getData=()=&gt;&#123;    return new Promise((resolve)=&gt;&#123;        //模拟异步        setTimeout(() =&gt; &#123;             resolve(&#123;                 name:&#x27;alien&#x27;,                 say:&#x27;let us learn React!&#x27;             &#125;)        &#125;, 1000)    &#125;)&#125;/* 测试异步组件 */function Test(&#123; rdata  , age&#125;)&#123;    const &#123; name , say &#125; = rdata    console.log(&#x27;组件渲染&#x27;)    return &lt;div&gt;        &lt;div&gt; hello , my name is &#123; name &#125; &lt;/div&gt;        &lt;div&gt;age : &#123; age &#125; &lt;/div&gt;        &lt;div&gt; i want to say &#123; say &#125; &lt;/div&gt;    &lt;/div&gt;&#125;/* 父组件 */export default class Index extends React.Component&#123;    LazyTest = AysncComponent(Test,getData)     /* 需要每一次在组件内部声明，保证每次父组件挂载，都会重新请求数据 ，防止内存泄漏。 */    render()&#123;        const &#123; LazyTest &#125; = this        return &lt;div&gt;           &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125; &gt;              &lt;LazyTest age=&#123;18&#125;  /&gt;          &lt;/Suspense&gt;        &lt;/div&gt;    &#125;&#125;","categories":["React"],"tags":["React"]},{"title":"React原理 事件系统","url":"/posts/f95bd5c5972e/","content":"创建事件集合React会在初始化的时候生成事件系统所需要的事件对象集合。\n\n把系统事件按照优先级分为三大类，每种事件对应着一个优先级\n\n\n\n\n事件类别\n变量名称\n说明\n优先级\n举例\n\n\n\n独立事件\ndiscreteEventPairsForSimpleEventPlugin\n\nDiscreteEvent&#x3D;0\n例如: click\n\n\n用户阻塞事件\nuserBlockingPairsForSimpleEventPlugin\n因为事件持触发，所以如果某段逻辑执行之间过长，会影响用户的交互\nUserBlockingEvent&#x3D;1\n例如：drag\n\n\n连续事件\ncontinuousPairsForSimpleEventPlugin\n需要系统一直监听是否触发的事件\nContinuousEvent&#x3D;2\n例如: animationEnd\n\n\n\n通过循环每种事件对应的数组，将事件保存在一下几种事件对象中\n\n\n\n\n变量名称\n变量对象\n说明\n\n\n\nallNativeEvents\nSet集合\n保存所有原生事件的名称 例如 0:&quot;cancel&quot;\n\n\neventPriorities\nMap集\n保存事件名称和事件优先级对应关系 例如 click=&gt;0 \n\n\ntopLevelEventsToReactNames\nMap集\n保存原始事件名称和 React事件的对应关系 例如 &quot;cancel&quot; =&gt; &quot;onCancel&quot; \n\n\nregistrationNameDependencies\nObject\n保存React事件和原生事件的对应关系 例如 onClick:(1) [&#39;click&#39;] 每个React事件对应一个数组用于保存合成事件对应关系\n\n\npossibleRegistrationNames\nObject\n保存小写的React事件名称和正确的驼峰命名事件的对应关系，用于校验用户输入 例如 onclick:onClick\n\n\n\n注册合成事件\n\n合成事件： 某些React事件会对应多个原生事件 例如：\n&#x27;onChange&#x27; =&gt; [&#x27;change&#x27;, &#x27;click&#x27;, &#x27;focusin&#x27;, &#x27;focusout&#x27;, &#x27;input&#x27;, &#x27;keydown&#x27;, &#x27;keyup&#x27;, &#x27;selectionchange&#x27;]\n\n合成事件会维护在registrationNameDependencies变量中，例如 onChange事件最终会变为 &#96;&#96;\n创建事件对象事件对象用于不用的事件类型，当React事件触发时，将会传入对应的事件对象，而不是原生的事件对象\nfunction createSyntheticEvent(Interface) &#123;  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) &#123;    this._reactName = reactName;    this._targetInst = targetInst;    this.type = reactEventType;    this.nativeEvent = nativeEvent;    this.target = nativeEventTarget;    this.currentTarget = null;  _assign(SyntheticBaseEvent.prototype, &#123;    preventDefault: function () &#123;&#125;,    stopPropagation: function () &#123;this.isPropagationStopped = functionThatReturnsTrue;&#125;,    persist: function () &#123;&#125;,    isPersistent: functionThatReturnsTrue  &#125;);  return SyntheticBaseEvent;&#125;var UIEventInterface = _assign(&#123;&#125;, EventInterface, &#123;  view: 0,  detail: 0&#125;);var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);\n\n事件绑定React 创建 FiberRoot 根节点阶段, 会循环所有的原声事件，将事件绑定在 root 元素上。\nfunction listenToAllSupportedEvents(rootContainerElement) &#123;  &#123;    var listeningMarker = &#x27;_reactListening&#x27; + Math.random().toString(36).slice(2);    rootContainerElement[listeningMarker] = true;    allNativeEvents.forEach(function (domEventName) &#123;      // 没有事件委托的事件，也就是不能冒泡到document的事件      if (!nonDelegatedEvents.has(domEventName)) &#123;        listenToNativeEvent(domEventName, false, rootContainerElement, null);      &#125;      listenToNativeEvent(domEventName, true, rootContainerElement, null);    &#125;);  &#125;&#125;\n\n根据事件的优先级不同，事件类型不同，绑定的事件处理函数也会不同。\nfunction createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) &#123;  var eventPriority = getEventPriorityForPluginSystem(domEventName);  var listenerWrapper;  switch (eventPriority) &#123;    case DiscreteEvent:      listenerWrapper = dispatchDiscreteEvent;      break;    case UserBlockingEvent:      listenerWrapper = dispatchUserBlockingUpdate;      break;    case ContinuousEvent:    default:      listenerWrapper = dispatchEvent;      break;  &#125;  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);&#125;\n\n\n对于独立事件，如果更新时存在副作用，会在下一个事件前立即执行\n\nfunction flushDiscreteUpdates() &#123;  flushPendingDiscreteUpdates();  flushPassiveEffects();&#125;\n\n对于用户阻塞事件，通过原生事件的target 或 srcElement 获取到触发事件的元素，再通过定义在原生DOM上的属性 internalInstanceKey 找到DOM对应的Fiber节点\nvar targetInst = targetNode[internalInstanceKey];\n\n通过 batchedEventUpdates 标记批处理\nfunction batchedEventUpdates(fn, a, b) &#123;  if (isBatchingEventUpdates) &#123;    // If we are currently inside another batch, we need to wait until it    // fully completes before restoring state.    return fn(a, b);  &#125;  isBatchingEventUpdates = true;  try &#123;    return batchedEventUpdatesImpl(fn, a, b);  &#125; finally &#123;    isBatchingEventUpdates = false;    finishEventHandler();  &#125;&#125;\n\n为不同的事件类型选择不同的事件对象，通过FiberNode上的props属性获取到事件，加入事件队列，用队列来模拟冒泡事件和捕获事件\nswitch (domEventName) &#123;  case &#x27;click&#x27;:    // Firefox creates a click event on right mouse clicks. This removes the    // unwanted click events.    if (nativeEvent.button === 2) &#123;      return;    &#125;  case &#x27;auxclick&#x27;:  case &#x27;dblclick&#x27;:  case &#x27;mousedown&#x27;:  case &#x27;mousemove&#x27;:  case &#x27;mouseup&#x27;: // TODO: Disabled elements should not respond to mouse events  /* falls through */  case &#x27;mouseout&#x27;:  case &#x27;mouseover&#x27;:  case &#x27;contextmenu&#x27;:    SyntheticEventCtor = SyntheticMouseEvent;    break;&#125;while (instance !== null) &#123;  var _instance2 = instance,      stateNode = _instance2.stateNode,      tag = _instance2.tag; // Handle listeners that are on HostComponents (i.e. &lt;div&gt;)    if (reactEventName !== null) &#123;      var props = getFiberCurrentPropsFromNode(stateNode);      var listener = props[registrationName];     if (captureListener != null) &#123;        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));      &#125;      var bubbleListener = getListener(instance, reactName);      if (bubbleListener != null) &#123;        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));      &#125;    &#125;  instance = instance.return;&#125;dispatchQueue.push(&#123;  event: _event,  listeners: _listeners&#125;);\n\n循环事件队列，如果执行过stopPropagation 直接跳出循环，方法定义在上面的事件对象中\nfunction processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) &#123;gfdg  var previousInstance;  for (var i = dispatchListeners.length - 1; i &gt;= 0; i--) &#123;    var _dispatchListeners$i = dispatchListeners[i],        instance = _dispatchListeners$i.instance,        currentTarget = _dispatchListeners$i.currentTarget,        listener = _dispatchListeners$i.listener;    if (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;      return;    &#125;    executeDispatch(event, listener, currentTarget);    previousInstance = instance;  &#125;&#125;\n\nFAQ\nReact 为什么有自己的事件系统？\n\n为了抹平浏览器间差异，封装了事件对象，模拟了事件冒泡和捕获。\n\n什么是事件合成？\n\n一个React可能是一个事件，也可能是多个原生事件。而且事件对象也是封装过的对象。\n\n如何实现的批量更新？\n\n通过 isBatchingEventUpdates 标记批处理开始， 一次用户阻塞事件中的所有相同类型事件，都会合并成一次更新\n\n事件系统如何模拟冒泡和捕获阶段？\n\n通过队列，冒泡事件插入在队列尾部，捕获事件插入队列的头部\n\n如何通过 dom 元素找到与之匹配的fiber？\n\n通过原生事件对象获取触发事件的DOM元素，通过DOM元素上的内置属性，获取fiber节点\n\n阻止默认行为 ？\n\n原生事件： e.preventDefault() 和 return false 可以用来阻止事件默认行为，由于在 React 中给元素的事件并不是真正的事件处理函数。所以导致 return false 方法在 React 应用中完全失去了作用。\nReact事件 在React应用中，可以用 e.preventDefault() 阻止事件默认行为，这个方法并非是原生事件的 preventDefault ，由于 React 事件源 e 也是独立组建的，所以 preventDefault 也是单独处理的。\n\n事件是绑定在真实的dom上吗？如何不是绑定在哪里？\n\n绑定在root节点上\n","categories":["React"],"tags":["React","JSX"]},{"title":"React源码分析 $1 全局对象或变量","url":"/posts/b1a1478f3615/","content":"FiberRootfunction FiberRootNode(containerInfo, tag, hydrate) &#123;  this.tag = tag;  this.containerInfo = containerInfo;  this.pendingChildren = null;  this.current = null;  this.pingCache = null;  this.finishedWork = null;  this.timeoutHandle = noTimeout;  this.context = null;  this.pendingContext = null;  this.hydrate = hydrate;  this.callbackNode = null;  this.callbackPriority = NoLanePriority;  this.eventTimes = createLaneMap(NoLanes);  this.expirationTimes = createLaneMap(NoTimestamp);  this.pendingLanes = NoLanes;  this.suspendedLanes = NoLanes;  this.pingedLanes = NoLanes;  this.expiredLanes = NoLanes;  this.mutableReadLanes = NoLanes;  this.finishedLanes = NoLanes;  this.entangledLanes = NoLanes;  this.entanglements = createLaneMap(NoLanes);\n\nFiberreact15 在 render 阶段的 reconcile 是不可打断的，这会在进行大量节点的 reconcile 时可能产生卡顿，因为浏览器所有的时间都交给了 js 执行，并且 js 的执行时单线程。为此 react16 之后就有了 scheduler 进行时间片的调度，给每个 task（工作单元）一定的时间，如果在这个时间内没执行完，也要交出执行权给浏览器进行绘制和重排，所以异步可中断的更新需要一定的数据结构在内存中来保存工作单元的信息，这个数据结构就是 Fiber。\n\n工作单元：Fiber 最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成 Fiber 树\n增量渲染：通过 jsx 对象和 current Fiber 的对比，生成最小的差异补丁，应用到真实节点上\n根据优先级暂停、继续、排列优先级：Fiber 节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense 提供了基础\n保存状态： : 因为 Fiber 能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是 hooks\n\nfunction FiberNode(  tag: WorkTag,  pendingProps: mixed,  key: null | string,  mode: TypeOfMode) &#123;  //作为静态的数据结构 保存节点的信息  this.tag = tag; //对应组件的类型  this.key = key; //key属性  this.elementType = null; //元素类型  this.type = null; //func或者class  this.stateNode = null; //真实dom节点  //作为fiber数架构 连接成fiber树  this.return = null; //指向父节点  this.child = null; //指向child  this.sibling = null; //指向兄弟节点  this.index = 0;  this.ref = null;  //用作为工作单元 来计算state  this.pendingProps = pendingProps;  this.memoizedProps = null;  this.updateQueue = null;  this.memoizedState = null;  this.dependencies = null;  this.mode = mode;  //effect相关  this.effectTag = NoEffect;  this.nextEffect = null;  this.firstEffect = null;  this.lastEffect = null;  //优先级相关的属性  this.lanes = NoLanes;  this.childLanes = NoLanes;  //current和workInProgress的指针  this.alternate = null;&#125;\n\nupdateQueue另外 updateQueue 属性在节点创建的时候添加 Fiber 对象上\nfunction initializeUpdateQueue(fiber) &#123;  var queue = &#123;    baseState: fiber.memoizedState,    firstBaseUpdate: null,    lastBaseUpdate: null,    shared: &#123;      pending: null,    &#125;,    effects: null,  &#125;;  fiber.updateQueue = queue;&#125;\n\n优先级export const NoPriority = 0;export const ImmediatePriority = 1;export const UserBlockingPriority = 2;export const NormalPriority = 3;export const LowPriority = 4;export const IdlePriority = 5;\n\nFlags// Don&#x27;t change these two values. They&#x27;re used by React Dev Tools.export const NoFlags = /*                      */ 0b00000000000000000000000000;export const PerformedWork = /*                */ 0b00000000000000000000000001;// You can change the rest (and add more).export const Placement = /*                    */ 0b00000000000000000000000010;export const Update = /*                       */ 0b00000000000000000000000100;export const PlacementAndUpdate = /*           */ Placement | Update;export const Deletion = /*                     */ 0b00000000000000000000001000;export const ChildDeletion = /*                */ 0b00000000000000000000010000;export const ContentReset = /*                 */ 0b00000000000000000000100000;export const Callback = /*                     */ 0b00000000000000000001000000;export const DidCapture = /*                   */ 0b00000000000000000010000000;export const ForceClientRender = /*            */ 0b00000000000000000100000000;export const Ref = /*                          */ 0b00000000000000001000000000;export const Snapshot = /*                     */ 0b00000000000000010000000000;export const Passive = /*                      */ 0b00000000000000100000000000;export const Hydrating = /*                    */ 0b00000000000001000000000000;export const HydratingAndUpdate = /*           */ Hydrating | Update;export const Visibility = /*                   */ 0b00000000000010000000000000;export const StoreConsistency = /*             */ 0b00000000000100000000000000;export const LifecycleEffectMask =  Passive | Update | Callback | Ref | Snapshot | StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)export const HostEffectMask = /*               */ 0b00000000000111111111111111;// These are not really side effects, but we still reuse this field.export const Incomplete = /*                   */ 0b00000000001000000000000000;export const ShouldCapture = /*                */ 0b00000000010000000000000000;export const ForceUpdateForLegacySuspense = /* */ 0b00000000100000000000000000;export const DidPropagateContext = /*          */ 0b00000001000000000000000000;export const NeedsPropagation = /*             */ 0b00000010000000000000000000;export const Forked = /*                       */ 0b00000100000000000000000000;// Static tags describe aspects of a fiber that are not specific to a render,// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).// This enables us to defer more work in the unmount case,// since we can defer traversing the tree during layout to look for Passive effects,// and instead rely on the static flag as a signal that there may be cleanup work.export const RefStatic = /*                    */ 0b00001000000000000000000000;export const LayoutStatic = /*                 */ 0b00010000000000000000000000;export const PassiveStatic = /*                */ 0b00100000000000000000000000;// These flags allow us to traverse to fibers that have effects on mount// without traversing the entire tree after every commit for// double invokingexport const MountLayoutDev = /*               */ 0b01000000000000000000000000;export const MountPassiveDev = /*              */ 0b10000000000000000000000000;// Groups of flags that are used in the commit phase to skip over trees that// don&#x27;t contain effects, by checking subtreeFlags.export const BeforeMutationMask =  // TODO: Remove Update flag from before mutation phase by re-landing Visibility  // flag logic (see #20043)  Update |  Snapshot |  (enableCreateEventHandleAPI    ? // createEventHandle needs to visit deleted and hidden trees to      // fire beforeblur      // TODO: Only need to visit Deletions during BeforeMutation phase if an      // element is focused.      ChildDeletion | Visibility    : 0);export const MutationMask =  Placement |  Update |  ChildDeletion |  ContentReset |  Ref |  Hydrating |  Visibility;export const LayoutMask = Update | Callback | Ref | Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMaskexport const PassiveMask = Passive | ChildDeletion;// Union of tags that don&#x27;t get reset on clones.// This allows certain concepts to persist without recalculating them,// e.g. whether a subtree contains passive effects or portals.export const StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n\nRootTagexport type RootTag = 0 | 1;export const LegacyRoot = 0;export const ConcurrentRoot = 1;\n\nsimpleEventPluginEventsconst simpleEventPluginEvents = [  &quot;abort&quot;,  &quot;auxClick&quot;,  &quot;cancel&quot;,  &quot;canPlay&quot;,  &quot;canPlayThrough&quot;,  &quot;click&quot;,  &quot;close&quot;,  &quot;contextMenu&quot;,  &quot;copy&quot;,  &quot;cut&quot;,  &quot;drag&quot;,  &quot;dragEnd&quot;,  &quot;dragEnter&quot;,  &quot;dragExit&quot;,  &quot;dragLeave&quot;,  &quot;dragOver&quot;,  &quot;dragStart&quot;,  &quot;drop&quot;,  &quot;durationChange&quot;,  &quot;emptied&quot;,  &quot;encrypted&quot;,  &quot;ended&quot;,  &quot;error&quot;,  &quot;gotPointerCapture&quot;,  &quot;input&quot;,  &quot;invalid&quot;,  &quot;keyDown&quot;,  &quot;keyPress&quot;,  &quot;keyUp&quot;,  &quot;load&quot;,  &quot;loadedData&quot;,  &quot;loadedMetadata&quot;,  &quot;loadStart&quot;,  &quot;lostPointerCapture&quot;,  &quot;mouseDown&quot;,  &quot;mouseMove&quot;,  &quot;mouseOut&quot;,  &quot;mouseOver&quot;,  &quot;mouseUp&quot;,  &quot;paste&quot;,  &quot;pause&quot;,  &quot;play&quot;,  &quot;playing&quot;,  &quot;pointerCancel&quot;,  &quot;pointerDown&quot;,  &quot;pointerMove&quot;,  &quot;pointerOut&quot;,  &quot;pointerOver&quot;,  &quot;pointerUp&quot;,  &quot;progress&quot;,  &quot;rateChange&quot;,  &quot;reset&quot;,  &quot;resize&quot;,  &quot;seeked&quot;,  &quot;seeking&quot;,  &quot;stalled&quot;,  &quot;submit&quot;,  &quot;suspend&quot;,  &quot;timeUpdate&quot;,  &quot;touchCancel&quot;,  &quot;touchEnd&quot;,  &quot;touchStart&quot;,  &quot;volumeChange&quot;,  &quot;scroll&quot;,  &quot;toggle&quot;,  &quot;touchMove&quot;,  &quot;waiting&quot;,  &quot;wheel&quot;,];\n","categories":["React"],"tags":["React"]},{"title":"React+TS 实战文档","url":"/posts/737e9484764d/","content":"Function ComponentsReact.FunctionComponent 或 React.FC 与普通函数有什么不同?\nReact.FC 是隐式的返回值类型, 不同函数是显示的返回值类型\nReact.FC 提供了一些静态属性类型检查 displayName,propTypes, defaultProps\nReact.FC 隐式的定义了 children 子元素类型, 但某些场景自定义这个类型会更好\n第二点中,当在 React.FC 中使用 defaultProps 的时候可能会造成错误\ninterface Props &#123;  text: string;&#125;const BackButton: React.FC&lt;Props&gt; = (props) =&gt; &#123;  return &lt;div /&gt;;&#125;;BackButton.defaultProps = &#123;  text: &quot;Go Back&quot;,&#125;;let a = &lt;BackButton /&gt;; // error: text is missing in type &#123;&#125;\n\n这个问题有很多种方法可以解决, 可以使用普通函数来定义,而不是使用函数类型\ninterface Props &#123;  text: string;&#125;function BackButton(props: Props) &#123;  return &lt;div /&gt;;&#125;BackButton.defaultProps = &#123;  text: &quot;Go Back&quot;,&#125;;let a = &lt;BackButton /&gt;; // it&#x27;s OK\n\n或者显示的声明 defaultProps\ninterface Props &#123;  text: string;&#125;const BackButton: React.FC&lt;Props&gt; &amp; &#123;  defaultProps: &#123;    text: string;  &#125;;&#125; = (props) =&gt; &#123;  return &lt;div /&gt;;&#125;;BackButton.defaultProps = &#123;  text: &quot;Go Back&quot;,&#125;;let a = &lt;BackButton /&gt;; // it&#x27;s OK\n\n另一个问题是 children 类型的问题, 有时组件返回的 children 类型并不是 React.FC 默认的 children 类型\n// Type &#x27;string&#x27; is not assignable to type &#x27;ReactElement&lt;any, any&gt;&#x27;.const Title: React.FC = () =&gt; &quot;123&quot;;\n\n你可以选择者重新为返回值赋类型,这个处理方法同样适用于条件语句中的子元素,或者通过数组或对象生成的子元素\nconst Title: React.FC = () =&gt; &quot;123&quot; as unknown as React.ReactElement;\n\n正因为有这种问题, @type&#x2F;react@^18.0.0 将不再把 children 作为默认的属性,而是需要显示声明\ntype T1 = &#123; name: string &#125;;type T2 = &#123; age: number &#125;;// 返回值逆变 因此返回的是联合类型type UnionToIntersection&lt;T&gt; = T extends &#123;  a: (x: T1) =&gt; infer U;  b: (x: T2) =&gt; infer U;&#125;  ? U  : never;type T3 = UnionToIntersection&lt;&#123; a: (x: T1) =&gt; string; b: (x: T2) =&gt; void &#125;&gt;; // string|void\n\n类型模块查找过程\n检查 package.json 的 exports 字段\n&#123;  &quot;exports&quot;: &#123;    &quot;./es&quot;: &#123;      &quot;types&quot;: &quot;./es/index.d.ts&quot;,      &quot;import&quot;: &quot;./es/index.js&quot;    &#125;  &#125;&#125;\n\n但是不支持动态路径映射，必须是指定路径下的文件, 也就是说类型文件必须存在于 &#x2F;es 目录下\n&#123;  &quot;exports&quot;: &#123;    &quot;./es&quot;: &#123;      // 使用方会提示找不到对应的类型文件      &quot;types&quot;: &quot;./index.d.ts&quot;,      &quot;import&quot;: &quot;./es/index.js&quot;    &#125;  &#125;&#125;\n\n检查 package.json 的 types\n&#123;  &quot;name&quot;: &quot;lodash&quot;,  &quot;types&quot;: &quot;index.d.ts&quot;&#125;\n\n如果导入了 lodash&#x2F;es 类似的二级路径，但 types 只指向 index.d.ts，TypeScript 不会自动识别子路径，类型文件必须存在于 &#x2F;es 目录下，或者使用 tsconfig 文件明确指明路径\n&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;lodash/es&quot;: [&quot;node_modules/@types/lodash/index.d.ts&quot;]    &#125;  &#125;&#125;\n\n直接检查文件路径尝试直接从导入路径中解析类型文件\n\n在 node_modules&#x2F;@types 中查找类型同样不支持动态路径映射，必须指定路径\n\n\n映射类型\n边界情况,映射类型在遇到非对象类型（例如 undefined 或 null）时,直接保留原始类型。\ntype NonNullableFlat&lt;O&gt; = &#123;  [K in keyof O]: NonNullable&lt;O[K]&gt;;&#125; &amp; &#123;&#125;;type c = NonNullableFlat&lt;undefined&gt;; // undefinedtype d = NonNullableFlat&lt;null&gt;; // null\n\n条件类型\n条件类型会引入局部作用域。\ntype z = [1, 2, 3, 4, 5];// B 的定义仅在 true 分支中存在。type V = z extends [any, ...infer B] ? 1 : B;\n\n","categories":["TypeScript"],"tags":["TypeScript","React"]},{"title":"TypeScript 体操","url":"/posts/d2311fb3cd62/","content":"","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"TypeScript 相关概念","url":"/posts/e40dc38116f7/","content":"interface vs type\ninterface 可以使用 扩展（extends）来继承其他接口，并且支持 声明合并（Declaration Merging）type 不能像接口那样直接进行声明合并，但它可以通过 交叉类型（&amp;）来合并类型。一般称作类型别名\n\ninterface 更多地用于定义对象的结构，也可以用来定义类的形状（即类实现的接口）。type 是更通用的类型别名，可以用于任何类型，包括基本类型、联合类型、交叉类型、元组等。\n\n鼠标放在 interface 上会显示接口名称，但是放在 type 上显示的是对应的类型，因此 type 并不定义新的类型。\n\n\nconst vs readonly不在同一个维度，一个是类型，一个是变量，如果描述一个类型不可变使用 readonly, 如果是变量不可变使用 const。\n数字类型索引数字类型索引的类型必须是字符串索引的子类型。\nclass Animal &#123;&#125;class Dog extends Animal &#123;&#125;const a: &#123;  [k: number]: Dog;  [k: string]: Animal;&#125; = &#123;  1: new Dog(),&#125;;\n\nclass interfaceclass 具有静态部分类型，和实例类型。 不要用构造器签名去给类实现接口使用。\ninterface IA &#123;  todo(): void;&#125;interface IACons &#123;  new (): IA;&#125;class A implements IA &#123;  todo() &#123;&#125;&#125;function create(cons: IACons): IA &#123;  return new cons();&#125;\n\n受保护的构造方法可以考虑用抽象类代替\nclass A &#123;  protected constructor() &#123;&#125;&#125;\n\n类型断言const a: object | any[] = [];(a as any[]).push(1);(&lt;any[]&gt;a).push(1);\n\n类型保护\n使用类型谓词\ninterface Fish &#123;  swim: () =&gt; void;  name: () =&gt; void;&#125;interface Bird &#123;  fly: () =&gt; void;  name: () =&gt; void;&#125;function isFish(obj: Fish | Bird): obj is Fish &#123;  // 返回一个boolean  return (obj as Fish).swim !== undefined;&#125;function fn(obj: Fish | Bird) &#123;  if (isFish(obj)) obj.swim();  else obj.fly();&#125;\n\ntypeof\nfunction fn(obj: string | number) &#123;  if (typeof obj === &quot;string&quot;) obj.substring;  else obj.toFixed;&#125;\n\n! 操作符\n// 在嵌套函数中无法正确推断数据类型function fn(name: string | null | undefined) &#123;  return function () &#123;    name!.substring;  &#125;;&#125;\n\n类型约束\nunknown 是 TypeScript 中的一个特殊类型，它表示任何类型。与 any 不同，unknown 类型的值不能直接操作，必须先进行某种类型的检查。\n\ntype of = [1, 2, 3] extends unknown ? 1 : 2; // 1\n\n元组转为普通对象会移除,number 索引签名,所有数组方法, length 属性,所有可能的数字字符串索引\n保留元组特有的具体数字属性映射\ntype ObjFromTuple = Omit&lt;Tuple, keyof any[]&gt;;\n\n逆变 协变\n协变通常表示同向，例如 A 是 B 的子类型，那么 Container 也是 Container 的子类型，类型会随着内部类型的变化而同向变化。\n\n逆变通常表示逆向，例如 A 是 B 的子类型，那么 Container 是 Container 的子类型，类型会随着内部类型的变化而逆向变化。\n\n换一种简单说法就是要永远保证类型的安全\n\n\nclass Animal &#123;&#125;class Cat extends Animal &#123;  Cat() &#123;&#125;&#125;class Dog extends Animal &#123;  Dog() &#123;&#125;&#125;class SmallDog extends Dog &#123;  public name = 1;&#125;// 错误  参数类型不安全，定义的类型应该是参数类型的父类型，参数可以多出不使用，但是不能少const fn: (v: Dog) =&gt; Dog = (v: SmallDog) =&gt; new SmallDog();// 错误const fn1: (v: Dog) =&gt; Dog = (v: SmallDog) =&gt; new Animal();const fn2: (v: Dog) =&gt; Dog = (v: Animal) =&gt; new SmallDog();// 错误  返回值类型不安全，定义的类型应该是返回值类型的子类型，返回值可以返回当前有的类型，但是不能多返回const fn3: (v: Dog) =&gt; Dog = (v: Animal) =&gt; new Animal();\n\ntype T1 = &#123; name: string &#125;;type T2 = &#123; age: number &#125;;// 参数协变，因此返回的是交叉类型type UnionToIntersection&lt;T&gt; = T extends &#123;  a: (x: infer U) =&gt; void;  b: (x: infer U) =&gt; void;&#125;  ? U  : never;type T3 = UnionToIntersection&lt;&#123; a: (x: T1) =&gt; void; b: (x: T2) =&gt; void &#125;&gt;; // T1 &amp; T2\n","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"B端产品设计流程和规范","url":"/posts/d5eef4de5048/","content":"B端产品和C端产品理解B端和C端\nB端（Business) :面向商业和企业，是为帮助企业集团等实现商业目的而设计的软件、工具或者平台。\nC端（Consumer） :表示为消费者、个人用户或终端用户设计，直接面向普通用户提供服务来帮助他们实现个人需求。\nC端产品后台产品线（BtoC） :比如淘宝卖家平台、饿了么商家版等。除此之外，还有面向商家、企业、业务部门提供的企业级服务产品，以及面对企业或者个人提供的平台级工具产品等。\n\nC端的产品核心功能突出，主要为了实现较单一的功能，比如: 购物，听音乐，上网，12306购票，附加功能可以增加用户体验，但如果缺失并不会影响产品的核心功能。\n作为C端用户很少会接触到B端的产品，接触的平台类产品，也可以叫做C段产品的后端产品线,即（BtoC）。\nB端产品包含多个主要功能，用于链接C端和B端。\nB端和C端产品的区别\n用户角度\n\n\n\n\nB端\nC端\n\n\n\nB端产品追求的是效率和效益的提升。解决需求，上手缓慢\n上手较快、用户体验，流量\n\n\n\n开发角度\n\n\n\n\nB端\nC端\n\n\n\n用户量少\n用户量多\n\n\n端周期长\n周期短\n\n\n竞品较少\n竞品较多\n\n\n逻辑复杂\n逻辑简单\n\n\nPC 端\n移动端\n\n\n解决问题驱动\n户体验驱动\n\n\n决策权则在客户手中\n使用决策权在用户手中\n\n\nB端产品的实用性大于美观性，能切实解决问题配置资源的 B 端产品才是一个好的 B 端产品.产品经理要具有更强的逻辑思维能力\nC端产品除了产品的体验以外，也要让产品更美观，让活动更有趣，让用户更舒服，产品经理有很强的同理心。\n\n\n后台产品常见分类\nC 端产品的后台产品线，如淘宝商家版，饿了么商家版，对订单和用户进行管理，支持 C 端产品的业务进展。\n平台级工具产品，如微信公众平台，对文章和读者的数据统计和管理；各大互联网公司的开放平台，如微博开放平台等。\n企业级服务产品，虚拟主机系统（VMware），云主机管理系统（深信服、xensystem、腾讯云）以及各种云SaaS。\n企业的业务处理平台，对内有考勤、报销等 OA办公系统，对外有 CRM 客户管理系统，ERP 资源及供应链管理系统。\n\n后台产品设计思路问题所在\n竞品较少，难以参考\n深入行业，对行业有自己的理解\n权限众多，关系复杂\n需要多和产品经理沟通，加深对产品的思考和探索\n\n后台UI设计工作流程\n需求分析\n\n对行业和产品有基本的认知\n要了解产品的基本情况，比如产品目标、用户人群、产品定位、需求分析、功能模块、主要竞品和产品特色。\n解决什么问题？想实现什么目标？使用这个系统的用户有哪些？不同角色的用户有哪些具体的权限？是否需要对每一个用户的行为都生成操作日志？产品有哪些主要的功能模块？产品的业务流程是怎样的？有哪些同类型的产品？和他们相比我们的产品有什么特色和特点？\n\n\n设计执行阶段\n\n参照 PM 给出的功能清单做原型和流程的梳理，需要关注的有当前版本规划、功能模块、功能类型、功能描述、任务优先级、完成时间等，交互原型则伴随着功能描述、规则判定条件、触发条件等内容。\n原型设计完成，开始做 UI 视觉方面的设计，而这时后端同步构思需求的实现方案。UI 设计师向前端了解实现框架，方便交接和沟通。\n当界面实现，UI 设计师应该是最早进行测试的，力求视觉设计和代码实现无误差。在完成设计执行后，从信息层级、文字、图标、图片等方面进行设计走查，进行多次设计验证与测试。\n\n\n数据分析数据分析是产品优化迭代的重要依据。进行多番测试和评审后交付客户（或内部）使用，根据产生的具体问题进行不断迭代，且观察产品能否通过准确的数据反映问题、体现能力，应虚心接纳使用者的使用建议并严谨思考其合理性，用户的使用和反馈是优化产品的重要途径。只有达到了管理和运营的指标，后台产品才是真正产生了价值。\n\n\n制定设计规范的作用\n对产品：在项目完成第一版较为稳定的版本时，着手制定设计标准，统一公司视觉设计规范及某些特定交互设计规范。同一个项目会有多个设计师的参与，规范化的设计语言，避免因设计控件混乱而影响设计输出。\n对自己：组件化同类元素，提高工作效率，建立公司产品的组件库，以便不同项目的复用及设计延展。在同一个项目中也能更好的把控该项目的视觉规范，提高效率。\n对团队：设计规范的制定，规范了设计团队的输出，同时方便了与开发团队的交接和协作。通过设计规范的制定，前端实现也能拥有一套可供复用和扩展的组件库，助力上下游交接及团队协作。\n对客户：制定设计规范的同时需要考虑设计延展性，为不同客户的定制化需求提供更高效的输出。同时在进行产品迭代时，设计规范的组件化调整也大大提高了工作效率。\n\n后台产品设计规范页面布局统一尺寸据统计，目前 PC 端用户屏幕分辨率占比排名前三的是 19201080、1366768、1440*900，以 1440 来设计的话，向上适配或者向下适配误差会比较小。\n适配方案：面向多个客户，后台产品设计功能型页面的尺寸统一为 1440900，按照栅格系统原则向上或向下适配。展示型页面以 1440900 为主，同时设计出极端情况（宽度为 1280 以及宽度为 1920）的效果图，力求实现前端实现效果和高保真设计图误差最小。面向公司内部的后台系统，由于各个职工电脑屏幕是统一采购、统一尺寸，所以开发适配的分辨率可以统一尺寸进行设计，这个尺寸根据公司内部采购屏幕的尺寸和分辨率选择即可（提前和前端沟通好）。\n页面框架页面框架主要分为左右栏布局和上下栏布局，还有其他的布局。左右栏布局包括顶部栏、左侧菜单栏、主体内容三大区域，其中顶部菜单栏、左侧菜单栏为固定结构，右侧主体内容根据分辨率进行动态缩放；上下栏布局包括顶部菜单栏和主体内容两大区域，其中顶部菜单栏为固定结构，主体内容进行动态缩放且需定义主体内容左右两边空白区域最小值；左右栏布局时，左侧菜单可收缩展开，收缩状态下固定宽度。\n栅格布局栅格系统的使用是为了解决自适应和响应式问题，从而更好地进行产品设计和产品开发。响应式栅格采用 24 列栅格系统实现，以满足 2，3，4，5，6 分比布局等多种情况。固定宽度 Column，将间隔 Gutter 进行动态缩放。\n\n需要栅格化处理的内容的总宽度&#x3D;23列（1列&#x3D;1宽度Column+1间隔Gutter）+1宽度Column&#x3D;24宽度Column+23间隔Gutter。\n\n谷歌规定模块和结构之间要以 8px 为基准，布局间相对间距可采用 8px 以及 8 的倍数，但一些小组件（按钮、间隔、输入框）可以以 4 为基准。栅格布局是为了辅助设计，灵活运用，不要被它所局限。\n尺寸设定一般在整体区域左上角放置产品 LOGO 及产品名称，大部分系统顶部栏高度 48+8n，侧边栏宽度 200+8n。我常用的是顶部栏高度 56px，侧边栏宽度 200px，侧边栏收缩状态宽度 56px，右侧的侧浮窗宽度 400px。\n相对间隔定义主体内容的上下左右边距，定义主体区域内各模块的边距及安全宽度，超出内容区域的部分采用区域内滚动或整屏滚动，视情况固定导航栏。\n\n标准色颜色分为品牌色、辅助色、中性色。根据不同产品的不同需求，可能也会将统计图、标签等进行统一标准色设定。\n品牌色即产品主色，产品主色的设定直接影响产品气质和直观感受，也是产品直接对外的形象。品牌色要根据产品特性、用户使用场景、产品定位等进行选取，尽量做好色彩的延伸性，可支持换肤。品牌色的应用场景包括操作状态、按钮色、可操作图标等。\n辅助色用于提示其他场景，比如成功、失败、警告、无效等。\n中性色常用于文本、背景、边框、分割线等，需要考虑深色背景和浅色背景的差异，可以选择同一色相控制透明度变化，用来表现不同的层级结构。\n其他色如统计图、数据可视化、多个标签的不同配色方案根据项目情况单独设定。\n\n标准字后台系统常用的字体：windows 系统，中文 Microsoft YaHei，英文 Arial；Mac 字体，中文 PingFang SC，英文 Helvetica；除此之外可以选择的字体还有 segoe UI、思源黑体、Hiragino Sans GB等。\n后台系统中常用字体大小为 12px、13px、14px、16px、18px、20px、24px、30px。\n行高设定，根据文字大小及使用场景设置行高，一般行高&#x3D;文字大小+6px&#x2F;8px。\n\n图标图标是 UI 设计中重要组成部分，一般分为功能图标和应用图标，以图形的方式传达概念，可以降低理解成本，使得界面更加协调美观。在后台产品中，图标的功能则更偏向辅助性，辅助用户对功能的认识。\n除了某些常用的图标，有一些专业性的操作和词汇则需要设计师进行绘制，现在比较高效方便的方法是在 iconfont 提供的图标模板上用 AI 绘制，画板 1024*1024，提供圆形、正方形、矩形形状。图标尺寸按照 8 的倍数进行延展，绘制完成后生成 svg 格式文件，提交到阿里巴巴矢量图标库的项目组里，方便前端调用，调整大小和颜色更为方便，且能够优化系统内存和性能。\n按钮按钮是后台产品进行交互设计是重要元素，提供给用户进行点击操作，是视觉上最引人注目的控件，具有一定的视觉受范性。常用按钮可分为填充按钮、线性按钮、文字按钮。\n按钮的交互状态包括默认、悬停、点击和不可用。\n按钮根据需求分为不同尺寸，大中小三个级别用在不同的场景，一般按照 8 的倍数设定。如高度分别设定为 24、32、40px。\n规范整理时要规定不同类型按钮的宽高、圆角及文字大小，同时还要将按钮的不同状态展现出来。\n填充按钮之间间距最小为 10px。\n\n导航导航的类型有很多种，常用的比如顶栏菜单、侧栏菜单、折叠菜单、下拉菜单、面包屑、分页、步骤条、时间轴、tab标签页、胶囊菜单、徽标数等。\n各类导航中的字体大小可进行统一设定。\n顶栏菜单多为一级菜单，点击切换，或作为下拉菜单的父级，将子级菜单合理分类。\n侧栏菜单为垂直导航菜单，可以内嵌子菜单。\n下拉菜单的触发方式一般有鼠标悬停和鼠标点击两种。\n步骤条引导用户按照流程来完成任务，一般步骤不得少于两步。\n分页的高度设定为 24px、30px、32px，根据应用场景适当增减内容，比如设定每页展示数据的条数、跳转至指定页等。\n面包屑用于说明层级结构，使用户明确当前所在位置，并且可以回到任一上级页面。\n徽标数用来通知用户当前有未读消息，一般出现在图标的右上角或者跟在文字后面。\n\n表单表单多由一条或多条列表项组成，单一列表项的类型有字段输入框、条件选择器。\n字段输入框的标题和输入框分布方式包括左右、上下、无标题。左右分布是常见的对齐方式，比较适合 PC 端的使用；上下分布增加了表单的整体高度，视情况选择使用；无标题经常应用在登录注册，虽然减少了面积，但是增加了理解难度。\n输入框的交互状态包括默认、输入结果、提示错误、禁用、获取焦点。\n输入框的尺寸可按照8的倍数进行设定，比如 24px、32px，也可根据系统实际情况进行设定，我常用的输入框高度为 30px，宽度视情况而定，无圆角。上下布局的多个输入框上下间距为 20px，有错误提示时候竖向增加 10px 或横向显示在输入框右侧（预留出位置）。\n表单中标题文字左对齐，输入框左对齐，标题文字距离输入框20px（多个长度不同的输入框算最长的）；标题文字右对齐，输入框左对齐，也是常用的方式。输入框内正文字体 14px，文字和左右两边边框的边距 10px。\n选择器包括单选、多选、时间选择、开关切换、下拉选择、滑块选择、旋钮等。单选框多为圆形，复选框多为方形。\n搜索框和选择框的高度为 30px 或按照 8 的倍数自行设定，通常和输入框保持一致。搜索框距离右侧按钮 4px，内部文字 14px。\n单选多选框尺寸 16*16px，多个选项横向排列间距 16px，纵向排列间距 8px。\n开关按钮外框 4020px，内部圆形 1616px。\n\n表格表格在后台产品 UI 设计中占比非常大，用来展示数据、统一管理、作为详情入口，是最清晰、高效的形式之一。在设计规范中需设定表头高度、表格行高、表格列宽范围，同时也包括表格中的按钮样式、标签样式。\n表格主要分为五大区域：选择搜索区、操作区、表头、正文、底栏。选择搜索区放置筛选框和搜索框，为用户提供按需搜索，可以大大提高用户效率；操作区指各种对表格内容进行增删改查、批量处理、配置列的动作；表头展示列标题，一般具有排序功能；正文主要展示各种各样的数据，要注意行高、对齐、分割、信息层级等，要考虑是否提供行内操作；底栏显示分页、总数统计等。\n表格信息一般主要功能为增删改查，查看和编辑是最基本的功能，表格信息支持筛选、搜索、排序、分页。对可批量操作的表格数据在第一列增加多选框。\n行高表格行高可设置为表格内字体高度的 2~3 倍，主表格会间隔显示不同颜色，用于区分不同行数据、加强视觉流引导，展开单行的内置表格可采用纯色，选中行应有视觉上的反馈。表头要和表格内容有视觉上的区分。表格行高可采用 36、40、48、60 等。\n行数表格行数太多加载速度会降低，延长用户等待时间；行数太少会导致用户不断翻页，降低使用效率。比较合适的默认表格行数是 20 或 50，用户可以根据自己需求选择默认的行数。设定行数之后，如果每页行数多于每屏行数，可在表格内引入滚动条，这时可以固定表头滚动内容。\n列宽列宽根据内容字段长短需要有不同且合理的默认值，使得表格字段有良好的展示效果。列内容的长度固定时，列宽应大于固定宽度（比如时间、MD5、SHA1）；列内容不固定时，能预判最大宽度的按照最大宽度设定列宽（比如IP地址、MAC地址、姓名），不能预判最大宽度的设定列宽按照常用宽度，多于内容省略以「…」展示，鼠标悬停出现完整内容（比如详情、描述）。\n列数表格列不应过多，列数比较多的情况下应该合理进行合并、隐藏、删除或进行优先级处理。常用的方法有引入配置列，用户可自定义展示必需列以外的其他列；只展示重要信息，下拉展开列查看完整信息；在表格中引入横向滚动条，根据实际情况选择是否要始终固定基本信息列（如第一列是文件名）和操作列（最后一列的操作）。\n对齐方式表格内的文本应按照文本类型不同进行统一规范，如金额类数值保留相同位数小数，SHA1 虽然是一串数字但是其实那并不是数据而是一串编码，所以可以像文本一样左对齐。根据文本内容不同，对齐方式也应灵活调整，可采用文本左对齐、数据右对齐、金额小数点对齐的方式。数据前面有标签的，将标签前置对齐。类似 IP 地址、MD5、SHA1、域名这样的信息，也可以根据产品需要在文本前面增加「复制」图标，方便用户调用。\n详情入口表格内部数据的详情入口，将能点击下钻查看详情的内容以不同颜色表示，同时在表格行最后一列操作按钮部分放置一个查看按钮。\n\n反馈包括弹框、侧滑框、骨架屏、全局提示、警告提示、消息提醒、加载状态等。分为模态框和非模态框，区别是是否会打断用户工作流。\n弹框又称对话框，是叠加在应用主窗口上的弹出式窗口，以对话的方式使用户参与进来。\n弹框弹框出现时，主题内容增加一层遮罩 #000，透明度 50%，避免使用双层弹框，可同时采用有关闭图标的弹框和无关闭图标的弹框，引导用户对内容进行正确操作。如果设定系统内所有弹框均可以点击弹框外区域关闭， 则需要为用户新增或编辑内容的弹框弹出二级确认的弹框，或者再次进行交互梳理。\n侧滑框侧滑框又称抽屉，出现在右侧，固定宽度 400px，高度覆盖在主题内容之上，点击侧滑框以外的区域则收起侧滑框。\n骨架屏为某些特定数据提供数据加载等待时的占位图形组合。\n全局提示建议停留时间 3s，可根据文字字数调整停留时间，文字内容限制在 30 以内。\n警告提示用不同颜色和样式展示需要关注的信息。\n通知提醒消息通知和警告信息用通知提醒框，单个消息从页面右侧以抽屉的方式划出，用户可手动关闭，或停留 3s 后自动关闭。\n缺省状态绘制不同类型的情感化插画表示缺省状态，如404、500、暂时没有数据、没有新消息等。\n页面需要一个默认的底色，错误文字使用 14px，与情感化插画间距 20px，与按钮间距 30px。\n数据可视化数据可视化部分可能是后台产品中对视觉设计要求较高的部分，使用情境为各类统计图、大屏展示页面等。\n功能型页面的数据可视化可以引入图形化设计组件，Echarts、G2、d3等；展示型页面的数据可视化则可以做得更有趣，比如立体的统计图、粒子地球效果、灵活有趣的网络拓扑图等。\n考虑到数据可视化可能会需要深色浅色不同的背景，在数据可视化统计图的色彩搭配上要注意颜色的拓展性。\n总结不管是做 C 端产品还是 B 端产品，都是为了实现用户的需求、帮用户解决问题。\n刚接触后台产品的时候，最希望能把产品做的炫酷、美观，工作中慢慢地发现项目的背后思考更为重要，产出的设计成果也应该有理有据、支撑整个设计体系。网上供大家使用和学习的资源非常多，对一些公司来说、专门去制定一套自己的后台设计规范不免显得费时费力，合理引入 antdesign 和 element 等开源的设计组件，会使得设计师以及前端事半功倍，有助于设计师把更多的精力投入到沉淀行业知识、研究产品架构、梳理交互方式和创新视觉表现上。\n","categories":["设计/UI/PS"],"tags":["设计"]},{"title":"PS 2019 笔迹提取","url":"/posts/83bf845a4a6f/","content":"\n复制图层\n\n\n\n打开色阶\n\n\n\n调整色阶使文字颜色更深\n\n\n\n打开色彩范围\n\n\n\n调整颜色容差，增加笔迹的选择范围，点击吸管，点击页面空白部分，点击确认，载入选区\n\n\n\n删除底色，如果没有效果，查看是否因为右侧图层没有把备份图层，取消勾选\n\n\n\n反转选区\n\n\n\n填充颜色\n\n\n","categories":["设计/UI/PS"],"tags":["PS"]},{"title":"webpack中complation用法","url":"/posts/b2fa485a999e/","content":"CompilationCompilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。 compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。 它会对应用程序的依赖图中所有模块， 进行字面上的编译(literal compilation)。 在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)。\nconst &#123;RawSource&#125;  = require(&#x27;webpack&#x27;).sources;const fs = require(&#x27;fs&#x27;);const &#123;promisify&#125; = require(&#x27;util&#x27;);const readFile = promisify(fs.readFile);const path = require(&#x27;path&#x27;);class Plugin1 &#123;  apply(compiler) &#123;    compiler.hooks.thisCompilation.tap(&#x27;Plugin2&#x27;,(compilation)=&gt;&#123;      // compilation也有自己的生命周期      // 可以对compilation对象上的资源进行操作      compilation.hooks.additionalAssets.tapAsync(&#x27;Plugin2&#x27;, async (callback) =&gt; &#123;                const file = await readFile(path.resolve(__dirname,&#x27;../src/b.txt&#x27;));        // 添加额外的打包资源        compilation.assets[&#x27;b.txt&#x27;] = new RawSource(file);        callback()      &#125;);    &#125;)  &#125;&#125;module.exports = Plugin1;","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"webpack中complier用法","url":"/posts/16fac1f513f8/","content":"tapabletapbale暴露了很多钩子，可以为webpack插件创建时使用\nconst &#123;SyncHook,SyncBailHook,AsyncParallelHook,AsyncSeriesHook&#125; = require(&#x27;tapable&#x27;)class Lesson &#123;  constructor()&#123;    // 初始化hooks容器    // 数组中的参数为绑定钩子回调函数的字段描述    this.hooks = &#123;      // 同步hooks,任务依次被执行      go:new SyncHook([&#x27;address&#x27;]),      // 同步hooks,一旦其中一个有返回值，后面的hooks就停止执行      go1:new SyncBailHook([&#x27;address&#x27;]),      // 异步钩子，并行执行      go2:new AsyncParallelHook([&#x27;name&#x27;,&#x27;age&#x27;]),      // 异步钩子，并行串行      go3:new AsyncSeriesHook([&#x27;name&#x27;,&#x27;age&#x27;]),    &#125;  &#125;  // 添加事件，可以同时绑定多个事件  tap()&#123;    this.hooks.go1.tap(&#x27;class&#x27;,(address)=&gt;&#123;      console.log(&#x27;class&#x27;,address)    &#125;)    this.hooks.go1.tap(&#x27;class1&#x27;,(address)=&gt;&#123;      console.log(&#x27;class1&#x27;,address)    &#125;)    // 异步钩子的两种写法    this.hooks.go2.tapAsync(&#x27;class3&#x27;,(name,age,cb)=&gt;&#123;      setTimeout(() =&gt; &#123;        console.log(&#x27;class3&#x27;,name,age);        cb()      &#125;,2000);    &#125;)    this.hooks.go2.tapPromise(&#x27;class4&#x27;,(name,age)=&gt;&#123;      return new Promise((resolve,reject)=&gt;&#123;        setTimeout(() =&gt; &#123;          console.log(&#x27;class4&#x27;,name,age);        &#125;,1000);      &#125;)    &#125;)  &#125;  //触发hooks  start()&#123;    this.hooks.go1.call(&#x27;触发时间时候传入的参数&#x27;)    this.hooks.go2.callAsync(&#x27;Gavin&#x27;,18)  &#125;&#125;const l = new Lesson();l.tap();l.start();\n\n\nCompilerCompiler 模块是 webpack 的主要引擎，它通过 CLI 传递的所有选项， 或者 Node API，创建出一个 compilation 实例。 它扩展(extend)自 Tapable 类，用来注册和调用插件。 大多数面向用户的插件会首先在 Compiler 上注册。\n在插件中使用不同的生命周期钩子来处理资源\nclass Plugin1 &#123;  apply(compiler) &#123;    compiler.hooks.initialize.tap(&#x27;initialize&#x27;,()=&gt;&#123;      console.log(&#x27;编译器对象初始化&#x27;)    &#125;)        compiler.hooks.emit.tapAsync(      &#x27;emit&#x27;,      (compilation, callback) =&gt; &#123;        setTimeout(() =&gt; &#123;          console.log(&#x27;出发emit事件&#x27;);          callback();        &#125;, 2000);      &#125;    );    compiler.hooks.afterEmit.tapPromise(      &#x27;afterEmit&#x27;,      (compilation, callback) =&gt; &#123;        return new Promise((resolve,reject)=&gt;&#123;          setTimeout(() =&gt; &#123;            console.log(&#x27;出发afterEmit事件&#x27;)          &#125;, 1000);        &#125;)      &#125;    );  &#125;&#125;module.exports = Plugin1;","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"create-react-app 脚手架分析","url":"/posts/16699b619d56/","content":"package.json&#123;  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;   // 弹出配置文件，操作不可逆  &#125;&#125;\n\n弹出配置之后自动修改package.json 文件\n&#123;  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;node scripts/start.js&quot;,    &quot;build&quot;: &quot;node scripts/build.js&quot;,    &quot;test&quot;: &quot;node scripts/test.js&quot;  &#125;,  &quot;eslintConfig&quot;: &#123;    &quot;extends&quot;: [      &quot;react-app&quot;,      &quot;react-app/jest&quot;    ]  &#125;,  &quot;browserslist&quot;: &#123;    &quot;production&quot;: [      &quot;&gt;0.2%&quot;,      &quot;not dead&quot;,      &quot;not op_mini all&quot;    ],    &quot;development&quot;: [      &quot;last 1 chrome version&quot;,      &quot;last 1 firefox version&quot;,      &quot;last 1 safari version&quot;    ]  &#125;,  &quot;babel&quot;: &#123;    &quot;presets&quot;: [      &quot;react-app&quot;    ]  &#125;dd&#125;\n\npaths 解析路径const path = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);const getPublicUrlOrPath = require(&#x27;react-dev-utils/getPublicUrlOrPath&#x27;);// Make sure any symlinks in the project folder are resolved:// https://github.com/facebook/create-react-app/issues/637// process.cwd() 当前Node.js进程执行时的工作目录  /home/supreme/Dropbox/Workspace/cra-learn/config// 项目根路径const appDirectory = fs.realpathSync(process.cwd());//path.resolve() 方法将路径或路径片段的序列解析为绝对路径。const resolveApp = relativePath =&gt; path.resolve(appDirectory, relativePath);// We use `PUBLIC_URL` environment variable or &quot;homepage&quot; field to infer// &quot;public path&quot; at which the app is served.// webpack needs to know it to put the right &lt;script&gt; hrefs into HTML even in// single-page apps that may serve index.html for nested URLs like /todos/42.// We can&#x27;t use a relative path in HTML because we don&#x27;t want to load something// like /todos/42/static/js/bundle.7289d.js. We have to know the root.// 分析publicUrl路径 默认是&quot;/&quot;const publicUrlOrPath = getPublicUrlOrPath(  process.env.NODE_ENV === &#x27;development&#x27;,  require(resolveApp(&#x27;package.json&#x27;)).homepage,  process.env.PUBLIC_URL);// 打包路径const buildPath = process.env.BUILD_PATH || &#x27;build&#x27;;// 文件扩展名const moduleFileExtensions = [  &#x27;web.mjs&#x27;,  &#x27;mjs&#x27;,  &#x27;web.js&#x27;,  &#x27;js&#x27;,  &#x27;web.ts&#x27;,  &#x27;ts&#x27;,  &#x27;web.tsx&#x27;,  &#x27;tsx&#x27;,  &#x27;json&#x27;,  &#x27;web.jsx&#x27;,  &#x27;jsx&#x27;,];// Resolve file paths in the same order as webpack// appIndexJs: resolveModule(resolveApp, &#x27;src/index&#x27;)const resolveModule = (resolveFn, filePath) =&gt; &#123;  // 判断存不存在有这样扩展名的文件  const extension = moduleFileExtensions.find(extension =&gt;    fs.existsSync(resolveFn(`$&#123;filePath&#125;.$&#123;extension&#125;`))  );  // 返回文件的绝对路径  if (extension) &#123;    return resolveFn(`$&#123;filePath&#125;.$&#123;extension&#125;`);  &#125;  // 默认返回js文件  return resolveFn(`$&#123;filePath&#125;.js`);&#125;;\n\n\nstart.js启动文件// Do this as the first thing so that any code reading it knows the right env.// 声明环境变量process.env.BABEL_ENV = &#x27;development&#x27;;process.env.NODE_ENV = &#x27;development&#x27;;// Makes the script crash on unhandled rejections instead of silently// ignoring them. In the future, promise rejections that are not handled will// terminate the Node.js process with a non-zero exit code.process.on(&#x27;unhandledRejection&#x27;, err =&gt; &#123;  throw err;&#125;);// Ensure environment variables are read.// 引入env配置文件require(&#x27;../config/env&#x27;);const fs = require(&#x27;fs&#x27;);const chalk = require(&#x27;react-dev-utils/chalk&#x27;);const webpack = require(&#x27;webpack&#x27;);const WebpackDevServer = require(&#x27;webpack-dev-server&#x27;);const clearConsole = require(&#x27;react-dev-utils/clearConsole&#x27;);const checkRequiredFiles = require(&#x27;react-dev-utils/checkRequiredFiles&#x27;);const &#123;  choosePort,  createCompiler,  prepareProxy,  prepareUrls,&#125; = require(&#x27;react-dev-utils/WebpackDevServerUtils&#x27;);const openBrowser = require(&#x27;react-dev-utils/openBrowser&#x27;);const semver = require(&#x27;semver&#x27;);const paths = require(&#x27;../config/paths&#x27;);const configFactory = require(&#x27;../config/webpack.config&#x27;);const createDevServerConfig = require(&#x27;../config/webpackDevServer.config&#x27;);const getClientEnvironment = require(&#x27;../config/env&#x27;);const react = require(require.resolve(&#x27;react&#x27;, &#123; paths: [paths.appPath] &#125;));const env = getClientEnvironment(paths.publicUrlOrPath.slice(0, -1));const useYarn = fs.existsSync(paths.yarnLockFile);const isInteractive = process.stdout.isTTY;// Warn and crash if required files are missingif (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) &#123;  process.exit(1);&#125;// Tools like Cloud9 rely on this.const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;const HOST = process.env.HOST || &#x27;0.0.0.0&#x27;;if (process.env.HOST) &#123;  console.log(    chalk.cyan(      `Attempting to bind to HOST environment variable: $&#123;chalk.yellow(        chalk.bold(process.env.HOST)      )&#125;`    )  );  console.log(    `If this was unintentional, check that you haven&#x27;t mistakenly set it in your shell.`  );  console.log(    `Learn more here: $&#123;chalk.yellow(&#x27;https://cra.link/advanced-config&#x27;)&#125;`  );  console.log();&#125;// We require that you explicitly set browsers and do not fall back to// browserslist defaults.const &#123; checkBrowsers &#125; = require(&#x27;react-dev-utils/browsersHelper&#x27;);// 选择端口号，当端口冲突的时候回自动加一checkBrowsers(paths.appPath, isInteractive)  .then(() =&gt; &#123;    // We attempt to use the default port but if it is busy, we offer the user to    // run on a different port. `choosePort()` Promise resolves to the next free port.    return choosePort(HOST, DEFAULT_PORT);  &#125;)  .then(port =&gt; &#123;    if (port == null) &#123;      // We have not found a port.      return;    &#125;        // 核心文件通过configFactory创建    const config = configFactory(&#x27;development&#x27;);    const protocol = process.env.HTTPS === &#x27;true&#x27; ? &#x27;https&#x27; : &#x27;http&#x27;;    const appName = require(paths.appPackageJson).name;    // 是否存在ts配置文件，判断是否启用TS    const useTypeScript = fs.existsSync(paths.appTsConfig);    const tscCompileOnError = process.env.TSC_COMPILE_ON_ERROR === &#x27;true&#x27;;    const urls = prepareUrls(      protocol,      HOST,      port,      paths.publicUrlOrPath.slice(0, -1)    );    const devSocket = &#123;      warnings: warnings =&gt;        devServer.sockWrite(devServer.sockets, &#x27;warnings&#x27;, warnings),      errors: errors =&gt;        devServer.sockWrite(devServer.sockets, &#x27;errors&#x27;, errors),    &#125;;    // Create a webpack compiler that is configured with custom messages.    // 创建webpack编译器    const compiler = createCompiler(&#123;      appName,      config,      devSocket,      urls,      useYarn,      useTypeScript,      tscCompileOnError,      webpack,    &#125;);    // Load proxy config    // 创建代理配置信息    const proxySetting = require(paths.appPackageJson).proxy;    const proxyConfig = prepareProxy(      proxySetting,      paths.appPublic,      paths.publicUrlOrPath    );    // Serve webpack assets generated by the compiler over a web server.    // 创建server服务器配置    const serverConfig = createDevServerConfig(      proxyConfig,      urls.lanUrlForConfig    );    // 创建服务器并监听端口    const devServer = new WebpackDevServer(compiler, serverConfig);    // Launch WebpackDevServer.    devServer.listen(port, HOST, err =&gt; &#123;      if (err) &#123;        return console.log(err);      &#125;      if (isInteractive) &#123;        clearConsole();      &#125;      if (env.raw.FAST_REFRESH &amp;&amp; semver.lt(react.version, &#x27;16.10.0&#x27;)) &#123;        console.log(          chalk.yellow(            `Fast Refresh requires React 16.10 or higher. You are using React $&#123;react.version&#125;.`          )        );      &#125;      console.log(chalk.cyan(&#x27;Starting the development server...\\n&#x27;));      openBrowser(urls.localUrlForBrowser);    &#125;);    [&#x27;SIGINT&#x27;, &#x27;SIGTERM&#x27;].forEach(function (sig) &#123;      process.on(sig, function () &#123;        devServer.close();        process.exit();      &#125;);    &#125;);    if (process.env.CI !== &#x27;true&#x27;) &#123;      // Gracefully exit when stdin ends      process.stdin.on(&#x27;end&#x27;, function () &#123;        devServer.close();        process.exit();      &#125;);    &#125;  &#125;)  // 如果操作过程中有报错退出进程  .catch(err =&gt; &#123;    if (err &amp;&amp; err.message) &#123;      console.log(err.message);    &#125;    process.exit(1);  &#125;);\n\nconfig.json// Source maps are resource heavy and can cause out of memory issue for large source files.// 是否会生成sourceMap文件 // 安装 cross-env 在package.json scripts指定命令中添加 GENERATE_SOURCEMAP=falseconst shouldUseSourceMap = process.env.GENERATE_SOURCEMAP !== &#x27;false&#x27;;const webpackDevClientEntry = require.resolve(  &#x27;react-dev-utils/webpackHotDevClient&#x27;);const reactRefreshOverlayEntry = require.resolve(  &#x27;react-dev-utils/refreshOverlayInterop&#x27;);// Some apps do not need the benefits of saving a web request, so not inlining the chunk// makes for a smoother build process.// 是否需要吧runtime文件内联在打包的js中const shouldInlineRuntimeChunk = process.env.INLINE_RUNTIME_CHUNK !== &#x27;false&#x27;;const emitErrorsAsWarnings = process.env.ESLINT_NO_DEV_ERRORS === &#x27;true&#x27;;const disableESLintPlugin = process.env.DISABLE_ESLINT_PLUGIN === &#x27;true&#x27;;// 最小转换成base64图片的大小const imageInlineSizeLimit = parseInt(  process.env.IMAGE_INLINE_SIZE_LIMIT || &#x27;10000&#x27;);// Check if TypeScript is setupconst useTypeScript = fs.existsSync(paths.appTsConfig);// Get the path to the uncompiled service worker (if it exists).const swSrc = paths.swSrc;// style files regexesconst cssRegex = /\\.css$/;const cssModuleRegex = /\\.module\\.css$/;const sassRegex = /\\.(scss|sass)$/;const sassModuleRegex = /\\.module\\.(scss|sass)$/;const hasJsxRuntime = (() =&gt; &#123;  if (process.env.DISABLE_NEW_JSX_TRANSFORM === &#x27;true&#x27;) &#123;    return false;  &#125;  try &#123;    require.resolve(&#x27;react/jsx-runtime&#x27;);    return true;  &#125; catch (e) &#123;    return false;  &#125;&#125;)();// This is the production and development configuration.// It is focused on developer experience, fast rebuilds, and a minimal bundle.// 最终返回的开发或生产环境的函数module.exports = function (webpackEnv) &#123;  const isEnvDevelopment = webpackEnv === &#x27;development&#x27;;  const isEnvProduction = webpackEnv === &#x27;production&#x27;;  // Variable used for enabling profiling in Production  // passed into alias object. Uses a flag if passed into the build command  const isEnvProductionProfile =    isEnvProduction &amp;&amp; process.argv.includes(&#x27;--profile&#x27;);  // We will provide `paths.publicUrlOrPath` to our app  // as %PUBLIC_URL% in `index.html` and `process.env.PUBLIC_URL` in JavaScript.  // Omit trailing slash as %PUBLIC_URL%/xyz looks better than %PUBLIC_URL%xyz.  // Get environment variables to inject into our app.  // 获取环境变量的方法 必须以 REACT_APP开头  const env = getClientEnvironment(paths.publicUrlOrPath.slice(0, -1));  const shouldUseReactRefresh = env.raw.FAST_REFRESH;  // common function to get style loaders  // 获取处理样式文件的loader  const getStyleLoaders = (cssOptions, preProcessor) =&gt; &#123;    const loaders = [      // 开发环境用style-loader 生产环境压缩css      isEnvDevelopment &amp;&amp; require.resolve(&#x27;style-loader&#x27;),      isEnvProduction &amp;&amp; &#123;        loader: MiniCssExtractPlugin.loader,        // css is located in `static/css`, use &#x27;../../&#x27; to locate index.html folder        // in production `paths.publicUrlOrPath` can be a relative path        options: paths.publicUrlOrPath.startsWith(&#x27;.&#x27;)          ? &#123; publicPath: &#x27;../../&#x27; &#125;          : &#123;&#125;,      &#125;,      // 将样式整合到js中      &#123;        loader: require.resolve(&#x27;css-loader&#x27;),        options: cssOptions,      &#125;,      &#123;        // Options for PostCSS as we reference these options twice        // Adds vendor prefixing based on your specified browser support in        // package.json        // 做css兼容性处理        loader: require.resolve(&#x27;postcss-loader&#x27;),        options: &#123;          // Necessary for external CSS imports to work          // https://github.com/facebook/create-react-app/issues/2677          ident: &#x27;postcss&#x27;,          plugins: () =&gt; [            require(&#x27;postcss-flexbugs-fixes&#x27;),            require(&#x27;postcss-preset-env&#x27;)(&#123;              autoprefixer: &#123;                flexbox: &#x27;no-2009&#x27;,              &#125;,              stage: 3,            &#125;),            // Adds PostCSS Normalize as the reset css with default options,            // so that it honors browserslist config in package.json            // which in turn let&#x27;s users customize the target behavior as per their needs.            postcssNormalize(),          ],          sourceMap: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment,        &#125;,      &#125;,    ].filter(Boolean);    if (preProcessor) &#123;      loaders.push(        &#123;          loader: require.resolve(&#x27;resolve-url-loader&#x27;),          options: &#123;            sourceMap: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment,            root: paths.appSrc,          &#125;,        &#125;,        &#123;          loader: require.resolve(preProcessor),          options: &#123;            sourceMap: true,          &#125;,        &#125;      );    &#125;    return loaders;  &#125;;  return &#123;    mode: isEnvProduction ? &#x27;production&#x27; : isEnvDevelopment &amp;&amp; &#x27;development&#x27;,    // Stop compilation early in production    // 开发环境出错会继续打包，因为接下来代码可能被修改    // 生产环境则立即停止打包    bail: isEnvProduction,    devtool: isEnvProduction      ? shouldUseSourceMap        ? &#x27;source-map&#x27; // 生产环境        : false      : isEnvDevelopment &amp;&amp; &#x27;cheap-module-source-map&#x27;, // 开发环境    // These are the &quot;entry points&quot; to our application.    // This means they will be the &quot;root&quot; imports that are included in JS bundle.    entry:      isEnvDevelopment &amp;&amp; !shouldUseReactRefresh        ? [            // Include an alternative client for WebpackDevServer. A client&#x27;s job is to            // connect to WebpackDevServer by a socket and get notified about changes.            // When you save a file, the client will either apply hot updates (in case            // of CSS changes), or refresh the page (in case of JS changes). When you            // make a syntax error, this client will display a syntax error overlay.            // Note: instead of the default WebpackDevServer client, we use a custom one            // to bring better experience for Create React App users. You can replace            // the line below with these two lines if you prefer the stock client:            //            // require.resolve(&#x27;webpack-dev-server/client&#x27;) + &#x27;?/&#x27;,            // require.resolve(&#x27;webpack/hot/dev-server&#x27;),            //            // When using the experimental react-refresh integration,            // the webpack plugin takes care of injecting the dev client for us.            webpackDevClientEntry,            // Finally, this is your app&#x27;s code:            paths.appIndexJs,            // We include the app code last so that if there is a runtime error during            // initialization, it doesn&#x27;t blow up the WebpackDevServer client, and            // changing JS code would still trigger a refresh.          ]        : paths.appIndexJs,    output: &#123;      // The build folder.      // 生产环境输出到目录，开发环境不输出      path: isEnvProduction ? paths.appBuild : undefined,      // Add /* filename */ comments to generated require()s in the output.      pathinfo: isEnvDevelopment,      // There will be one main bundle, and one file per asynchronous chunk.      // In development, it does not produce real files.      filename: isEnvProduction        ? &#x27;static/js/[name].[contenthash:8].js&#x27;        : isEnvDevelopment &amp;&amp; &#x27;static/js/bundle.js&#x27;,      // TODO: remove this when upgrading to webpack 5      futureEmitAssets: true,      // There are also additional JS chunk files if you use code splitting.      // 经过代码分割的文件会带上chunk的后缀，用于区分入口文件      chunkFilename: isEnvProduction        ? &#x27;static/js/[name].[contenthash:8].chunk.js&#x27;        : isEnvDevelopment &amp;&amp; &#x27;static/js/[name].chunk.js&#x27;,      // webpack uses `publicPath` to determine where the app is being served from.      // It requires a trailing slash, or the file assets will get an incorrect path.      // We inferred the &quot;public path&quot; (such as / or /my-project) from homepage.      publicPath: paths.publicUrlOrPath,      // Point sourcemap entries to original disk location (format as URL on Windows)      devtoolModuleFilenameTemplate: isEnvProduction        ? info =&gt;            path              .relative(paths.appSrc, info.absoluteResourcePath)              .replace(/\\\\/g, &#x27;/&#x27;)        : isEnvDevelopment &amp;&amp;          (info =&gt; path.resolve(info.absoluteResourcePath).replace(/\\\\/g, &#x27;/&#x27;)),      // Prevents conflicts when multiple webpack runtimes (from different apps)      // are used on the same page.      jsonpFunction: `webpackJsonp$&#123;appPackageJson.name&#125;`,      // this defaults to &#x27;window&#x27;, but by setting it to &#x27;this&#x27; then      // module chunks which are built will work in web workers as well.      // 用this来统一顶级变量      globalObject: &#x27;this&#x27;,    &#125;,    optimization: &#123;      minimize: isEnvProduction,      minimizer: [        // This is only used in production mode        // 压缩 JS        new TerserPlugin(&#123;          terserOptions: &#123;            parse: &#123;              // We want terser to parse ecma 8 code. However, we don&#x27;t want it              // to apply any minification steps that turns valid ecma 5 code              // into invalid ecma 5 code. This is why the &#x27;compress&#x27; and &#x27;output&#x27;              // sections only apply transformations that are ecma 5 safe              // https://github.com/facebook/create-react-app/pull/4234              ecma: 8,            &#125;,            compress: &#123;              ecma: 5,              warnings: false,              // Disabled because of an issue with Uglify breaking seemingly valid code:              // https://github.com/facebook/create-react-app/issues/2376              // Pending further investigation:              // https://github.com/mishoo/UglifyJS2/issues/2011              comparisons: false,              // Disabled because of an issue with Terser breaking valid code:              // https://github.com/facebook/create-react-app/issues/5250              // Pending further investigation:              // https://github.com/terser-js/terser/issues/120              inline: 2,            &#125;,            mangle: &#123;              safari10: true,            &#125;,            // Added for profiling in devtools            keep_classnames: isEnvProductionProfile,            keep_fnames: isEnvProductionProfile,            output: &#123;              ecma: 5,              comments: false,              // Turned on because emoji and regex is not minified properly using default              // https://github.com/facebook/create-react-app/issues/2488              ascii_only: true,            &#125;,          &#125;,          sourceMap: shouldUseSourceMap,        &#125;),        // This is only used in production mode        // 压缩CSS        new OptimizeCSSAssetsPlugin(&#123;          cssProcessorOptions: &#123;            parser: safePostCssParser,            map: shouldUseSourceMap              ? &#123;                  // `inline: false` forces the sourcemap to be output into a                  // separate file                  inline: false,                  // `annotation: true` appends the sourceMappingURL to the end of                  // the css file, helping the browser find the sourcemap                  annotation: true,                &#125;              : false,          &#125;,          cssProcessorPluginOptions: &#123;            preset: [&#x27;default&#x27;, &#123; minifyFontValues: &#123; removeQuotes: false &#125; &#125;],          &#125;,        &#125;),      ],      // Automatically split vendor and commons      // https://twitter.com/wSokra/status/969633336732905474      // https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366      // 使用的默认配置      splitChunks: &#123;        chunks: &#x27;all&#x27;,        name: isEnvDevelopment,      &#125;,      // Keep the runtime chunk separated to enable long term caching      // https://twitter.com/wSokra/status/969679223278505985      // https://github.com/facebook/create-react-app/issues/5358      // 分别打包runtime文件      runtimeChunk: &#123;        name: entrypoint =&gt; `runtime-$&#123;entrypoint.name&#125;`,      &#125;,    &#125;,    resolve: &#123;      // This allows you to set a fallback for where webpack should look for modules.      // We placed these paths second because we want `node_modules` to &quot;win&quot;      // if there are any conflicts. This matches Node resolution mechanism.      // https://github.com/facebook/create-react-app/issues/253      // 依赖模块查找路径      modules: [&#x27;node_modules&#x27;, paths.appNodeModules].concat(        modules.additionalModulePaths || []      ),      // These are the reasonable defaults supported by the Node ecosystem.      // We also include JSX as a common component filename extension to support      // some tools, although we do not recommend using it, see:      // https://github.com/facebook/create-react-app/issues/290      // `web` extension prefixes have been added for better support      // for React Native Web.      extensions: paths.moduleFileExtensions        .map(ext =&gt; `.$&#123;ext&#125;`)        .filter(ext =&gt; useTypeScript || !ext.includes(&#x27;ts&#x27;)),      // 定义一些别名      alias: &#123;        // Support React Native Web        // https://www.smashingmagazine.com/2016/08/a-glimpse-into-the-future-with-react-native-for-web/        &#x27;react-native&#x27;: &#x27;react-native-web&#x27;,        // Allows for better profiling with ReactDevTools        ...(isEnvProductionProfile &amp;&amp; &#123;          &#x27;react-dom$&#x27;: &#x27;react-dom/profiling&#x27;,          &#x27;scheduler/tracing&#x27;: &#x27;scheduler/tracing-profiling&#x27;,        &#125;),        ...(modules.webpackAliases || &#123;&#125;),      &#125;,      plugins: [        // Adds support for installing with Plug&#x27;n&#x27;Play, leading to faster installs and adding        // guards against forgotten dependencies and such.        PnpWebpackPlugin,        // Prevents users from importing files from outside of src/ (or node_modules/).        // This often causes confusion because we only process files within src/ with babel.        // To fix this, we prevent you from importing files out of src/ -- if you&#x27;d like to,        // please link the files into your node_modules/ and let module-resolution kick in.        // Make sure your source files are compiled, as they will not be processed in any way.        // 用于检测查找文件的范围，必须在src下面或者package.json文件        new ModuleScopePlugin(paths.appSrc, [          paths.appPackageJson,          reactRefreshOverlayEntry,        ]),      ],    &#125;,    resolveLoader: &#123;      plugins: [        // Also related to Plug&#x27;n&#x27;Play, but this time it tells webpack to load its loaders        // from the current package.        PnpWebpackPlugin.moduleLoader(module),      ],    &#125;,    module: &#123;      strictExportPresence: true,      rules: [        // Disable require.ensure as it&#x27;s not a standard language feature.        // requireEnsure不在被支持        &#123; parser: &#123; requireEnsure: false &#125; &#125;,        &#123;          // &quot;oneOf&quot; will traverse all following loaders until one will          // match the requirements. When no loader matches it will fall          // back to the &quot;file&quot; loader at the end of the loader list.          // 用于优化解析一个匹配将不在检查          oneOf: [            // TODO: Merge this config once `image/avif` is in the mime-db            // https://github.com/jshttp/mime-db            &#123;              test: [/\\.avif$/],              loader: require.resolve(&#x27;url-loader&#x27;),              options: &#123;                limit: imageInlineSizeLimit,                mimetype: &#x27;image/avif&#x27;,                name: &#x27;static/media/[name].[hash:8].[ext]&#x27;,              &#125;,            &#125;,            // &quot;url&quot; loader works like &quot;file&quot; loader except that it embeds assets            // smaller than specified limit in bytes as data URLs to avoid requests.            // A missing `test` is equivalent to a match.            //             &#123;              test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/],              loader: require.resolve(&#x27;url-loader&#x27;),              options: &#123;                limit: imageInlineSizeLimit,                name: &#x27;static/media/[name].[hash:8].[ext]&#x27;,              &#125;,            &#125;,            // Process application JS with Babel.            // The preset includes JSX, Flow, TypeScript, and some ESnext features.            &#123;              test: /\\.(js|mjs|jsx|ts|tsx)$/,              // 只处理src文件夹目录下面的文件              include: paths.appSrc,              // babel-loader的配置在package.json中添加              loader: require.resolve(&#x27;babel-loader&#x27;),              options: &#123;                customize: require.resolve(                  &#x27;babel-preset-react-app/webpack-overrides&#x27;                ),                presets: [                  [                    require.resolve(&#x27;babel-preset-react-app&#x27;),                    &#123;                      runtime: hasJsxRuntime ? &#x27;automatic&#x27; : &#x27;classic&#x27;,                    &#125;,                  ],                ],                                plugins: [                  [                    require.resolve(&#x27;babel-plugin-named-asset-import&#x27;),                    &#123;                      loaderMap: &#123;                        svg: &#123;                          ReactComponent:                            &#x27;@svgr/webpack?-svgo,+titleProp,+ref![path]&#x27;,                        &#125;,                      &#125;,                    &#125;,                  ],                  isEnvDevelopment &amp;&amp;                    shouldUseReactRefresh &amp;&amp;                    require.resolve(&#x27;react-refresh/babel&#x27;),                ].filter(Boolean),                // This is a feature of `babel-loader` for webpack (not Babel itself).                // It enables caching results in ./node_modules/.cache/babel-loader/                // directory for faster rebuilds.                cacheDirectory: true,                // See #6846 for context on why cacheCompression is disabled                cacheCompression: false,                compact: isEnvProduction,              &#125;,            &#125;,            // Process any JS outside of the app with Babel.            // Unlike the application JS, we only compile the standard ES features.            // 除了src文件下面以外的js文件            &#123;              test: /\\.(js|mjs)$/,              exclude: /@babel(?:\\/|\\\\&#123;1,2&#125;)runtime/,              loader: require.resolve(&#x27;babel-loader&#x27;),              options: &#123;                babelrc: false,                configFile: false,                compact: false,                presets: [                  [                    require.resolve(&#x27;babel-preset-react-app/dependencies&#x27;),                    &#123; helpers: true &#125;,                  ],                ],                cacheDirectory: true,                // See #6846 for context on why cacheCompression is disabled                cacheCompression: false,                                // Babel sourcemaps are needed for debugging into node_modules                // code.  Without the options below, debuggers like VSCode                // show incorrect code and set breakpoints on the wrong lines.                sourceMaps: shouldUseSourceMap,                inputSourceMap: shouldUseSourceMap,              &#125;,            &#125;,            // &quot;postcss&quot; loader applies autoprefixer to our CSS.            // &quot;css&quot; loader resolves paths in CSS and adds assets as dependencies.            // &quot;style&quot; loader turns CSS into JS modules that inject &lt;style&gt; tags.            // In production, we use MiniCSSExtractPlugin to extract that CSS            // to a file, but in development &quot;style&quot; loader enables hot editing            // of CSS.            // By default we support CSS Modules with the extension .module.css            &#123;              test: cssRegex,              exclude: cssModuleRegex,              use: getStyleLoaders(&#123;                importLoaders: 1,                sourceMap: isEnvProduction                  ? shouldUseSourceMap                  : isEnvDevelopment,              &#125;),              // Don&#x27;t consider CSS imports dead code even if the              // containing package claims to have no side effects.              // Remove this when webpack adds a warning or an error for this.              // See https://github.com/webpack/webpack/issues/6571              // 样式资源是有副作用的，不要进行treeShaking              sideEffects: true,            &#125;,            // Adds support for CSS Modules (https://github.com/css-modules/css-modules)            // using the extension .module.css            // 处理模块化样式， 文件以module.css结尾            &#123;              test: cssModuleRegex,              use: getStyleLoaders(&#123;                importLoaders: 1,                sourceMap: isEnvProduction                  ? shouldUseSourceMap                  : isEnvDevelopment,                modules: &#123;                  getLocalIdent: getCSSModuleLocalIdent,                &#125;,              &#125;),            &#125;,            // Opt-in support for SASS (using .scss or .sass extensions).            // By default we support SASS Modules with the            // extensions .module.scss or .module.sass            // 处理sassloader            &#123;              test: sassRegex,              exclude: sassModuleRegex,              use: getStyleLoaders(                &#123;                  importLoaders: 3,                  sourceMap: isEnvProduction                    ? shouldUseSourceMap                    : isEnvDevelopment,                &#125;,                &#x27;sass-loader&#x27;              ),              // Don&#x27;t consider CSS imports dead code even if the              // containing package claims to have no side effects.              // Remove this when webpack adds a warning or an error for this.              // See https://github.com/webpack/webpack/issues/6571              sideEffects: true,            &#125;,            // Adds support for CSS Modules, but using SASS            // using the extension .module.scss or .module.sass            &#123;              test: sassModuleRegex,              use: getStyleLoaders(                &#123;                  importLoaders: 3,                  sourceMap: isEnvProduction                    ? shouldUseSourceMap                    : isEnvDevelopment,                  modules: &#123;                    getLocalIdent: getCSSModuleLocalIdent,                  &#125;,                &#125;,                &#x27;sass-loader&#x27;              ),            &#125;,            // &quot;file&quot; loader makes sure those assets get served by WebpackDevServer.            // When you `import` an asset, you get its (virtual) filename.            // In production, they would get copied to the `build` folder.            // This loader doesn&#x27;t use a &quot;test&quot; so it will catch all modules            // that fall through the other loaders.            // 一些特殊文件，视频文件等，直接输出            &#123;              loader: require.resolve(&#x27;file-loader&#x27;),              // Exclude `js` files to keep &quot;css&quot; loader working as it injects              // its runtime that would otherwise be processed through &quot;file&quot; loader.              // Also exclude `html` and `json` extensions so they get processed              // by webpacks internal loaders.              exclude: [/\\.(js|mjs|jsx|ts|tsx)$/, /\\.html$/, /\\.json$/],              options: &#123;                name: &#x27;static/media/[name].[hash:8].[ext]&#x27;,              &#125;,            &#125;,            // ** STOP ** Are you adding a new loader?            // Make sure to add the new loader(s) before the &quot;file&quot; loader.          ],        &#125;,      ],    &#125;,    plugins: [      // Generates an `index.html` file with the &lt;script&gt; injected.      new HtmlWebpackPlugin(        Object.assign(          &#123;&#125;,          &#123;            inject: true,            template: paths.appHtml,          &#125;,          // 生产环境加了压缩的配置          isEnvProduction            ? &#123;                minify: &#123;                  removeComments: true,                  collapseWhitespace: true,                  removeRedundantAttributes: true,                  useShortDoctype: true,                  removeEmptyAttributes: true,                  removeStyleLinkTypeAttributes: true,                  keepClosingSlash: true,                  minifyJS: true,                  minifyCSS: true,                  minifyURLs: true,                &#125;,              &#125;            : undefined        )      ),      // Inlines the webpack runtime script. This script is too small to warrant      // a network request.      // https://github.com/facebook/create-react-app/issues/5358      // 是否要内联runtime文件      isEnvProduction &amp;&amp;        shouldInlineRuntimeChunk &amp;&amp;        new InlineChunkHtmlPlugin(HtmlWebpackPlugin, [/runtime-.+[.]js/]),      // Makes some environment variables available in index.html.      // The public URL is available as %PUBLIC_URL% in index.html, e.g.:      // &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt;      // It will be an empty string unless you specify &quot;homepage&quot;      // in `package.json`, in which case it will be the pathname of that URL.      // 解析html中的 %PUBLIC_URL%      new InterpolateHtmlPlugin(HtmlWebpackPlugin, env.raw),      // This gives some necessary context to module not found errors, such as      // the requesting resource.      // 给没有找到的模块提供更好的提示      new ModuleNotFoundPlugin(paths.appPath),      // Makes some environment variables available to the JS code, for example:      // if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; ... &#125;. See `./env.js`.      // It is absolutely essential that NODE_ENV is set to production      // during a production build.      // Otherwise React will be compiled in the very slow development mode.      // 定义环境变量      new webpack.DefinePlugin(env.stringified),      // This is necessary to emit hot updates (CSS and Fast Refresh):      // 开发环境提供热模块替换      isEnvDevelopment &amp;&amp; new webpack.HotModuleReplacementPlugin(),      // Experimental hot reloading for React .      // https://github.com/facebook/react/tree/master/packages/react-refresh      isEnvDevelopment &amp;&amp;        shouldUseReactRefresh &amp;&amp;        new ReactRefreshWebpackPlugin(&#123;          overlay: &#123;            entry: webpackDevClientEntry,            // The expected exports are slightly different from what the overlay exports,            // so an interop is included here to enable feedback on module-level errors.            module: reactRefreshOverlayEntry,            // Since we ship a custom dev client and overlay integration,            // the bundled socket handling logic can be eliminated.            sockIntegration: false,          &#125;,        &#125;),      // Watcher doesn&#x27;t work well if you mistype casing in a path so we use      // a plugin that prints an error when you attempt to do this.      // See https://github.com/facebook/create-react-app/issues/240      // 文件路径严格区分大小写      isEnvDevelopment &amp;&amp; new CaseSensitivePathsPlugin(),      // If you require a missing module and then `npm install` it, you still have      // to restart the development server for webpack to discover it. This plugin      // makes the discovery automatic so you don&#x27;t have to restart.      // See https://github.com/facebook/create-react-app/issues/186      // 监视nodemodules一旦变化会重启server      isEnvDevelopment &amp;&amp;        new WatchMissingNodeModulesPlugin(paths.appNodeModules),      // 提取css为单独的文件      isEnvProduction &amp;&amp;        new MiniCssExtractPlugin(&#123;          // Options similar to the same options in webpackOptions.output          // both options are optional          filename: &#x27;static/css/[name].[contenthash:8].css&#x27;,          chunkFilename: &#x27;static/css/[name].[contenthash:8].chunk.css&#x27;,        &#125;),      // Generate an asset manifest file with the following content:      // - &quot;files&quot; key: Mapping of all asset filenames to their corresponding      //   output file so that tools can pick it up without having to parse      //   `index.html`      // - &quot;entrypoints&quot; key: Array of files which are included in `index.html`,      //   can be used to reconstruct the HTML if necessary      new ManifestPlugin(&#123;        fileName: &#x27;asset-manifest.json&#x27;,        publicPath: paths.publicUrlOrPath,        generate: (seed, files, entrypoints) =&gt; &#123;          const manifestFiles = files.reduce((manifest, file) =&gt; &#123;            manifest[file.name] = file.path;            return manifest;          &#125;, seed);          const entrypointFiles = entrypoints.main.filter(            fileName =&gt; !fileName.endsWith(&#x27;.map&#x27;)          );          return &#123;            files: manifestFiles,            entrypoints: entrypointFiles,          &#125;;        &#125;,      &#125;),      // Moment.js is an extremely popular library that bundles large locale files      // by default due to how webpack interprets its code. This is a practical      // solution that requires the user to opt into importing specific locales.      // https://github.com/jmblog/how-to-optimize-momentjs-with-webpack      // You can remove this if you don&#x27;t use Moment.js:      // 优化momentjs      new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/),      // Generate a service worker script that will precache, and keep up to date,      // the HTML &amp; assets that are part of the webpack build.      isEnvProduction &amp;&amp;        fs.existsSync(swSrc) &amp;&amp;        new WorkboxWebpackPlugin.InjectManifest(&#123;          swSrc,          dontCacheBustURLsMatching: /\\.[0-9a-f]&#123;8&#125;\\./,          exclude: [/\\.map$/, /asset-manifest\\.json$/, /LICENSE/],          // Bump up the default maximum size (2mb) that&#x27;s precached,          // to make lazy-loading failure scenarios less likely.          // See https://github.com/cra-template/pwa/issues/13#issuecomment-722667270          maximumFileSizeToCacheInBytes: 5 * 1024 * 1024,        &#125;),      // TypeScript type checking      useTypeScript &amp;&amp;        new ForkTsCheckerWebpackPlugin(&#123;          typescript: resolve.sync(&#x27;typescript&#x27;, &#123;            basedir: paths.appNodeModules,          &#125;),          async: isEnvDevelopment,          checkSyntacticErrors: true,          resolveModuleNameModule: process.versions.pnp            ? `$&#123;__dirname&#125;/pnpTs.js`            : undefined,          resolveTypeReferenceDirectiveModule: process.versions.pnp            ? `$&#123;__dirname&#125;/pnpTs.js`            : undefined,          tsconfig: paths.appTsConfig,          reportFiles: [            // This one is specifically to match during CI tests,            // as micromatch doesn&#x27;t match            // &#x27;../cra-template-typescript/template/src/App.tsx&#x27;            // otherwise.            &#x27;../**/src/**/*.&#123;ts,tsx&#125;&#x27;,            &#x27;**/src/**/*.&#123;ts,tsx&#125;&#x27;,            &#x27;!**/src/**/__tests__/**&#x27;,            &#x27;!**/src/**/?(*.)(spec|test).*&#x27;,            &#x27;!**/src/setupProxy.*&#x27;,            &#x27;!**/src/setupTests.*&#x27;,          ],          silent: true,          // The formatter is invoked directly in WebpackDevServerUtils during development          formatter: isEnvProduction ? typescriptFormatter : undefined,        &#125;),      !disableESLintPlugin &amp;&amp;        new ESLintPlugin(&#123;          // Plugin options          extensions: [&#x27;js&#x27;, &#x27;mjs&#x27;, &#x27;jsx&#x27;, &#x27;ts&#x27;, &#x27;tsx&#x27;],          formatter: require.resolve(&#x27;react-dev-utils/eslintFormatter&#x27;),          eslintPath: require.resolve(&#x27;eslint&#x27;),          failOnError: !(isEnvDevelopment &amp;&amp; emitErrorsAsWarnings),          context: paths.appSrc,          cache: true,          cacheLocation: path.resolve(            paths.appNodeModules,            &#x27;.cache/.eslintcache&#x27;          ),          // ESLint class options          cwd: paths.appPath,          resolvePluginsRelativeTo: __dirname,          baseConfig: &#123;            extends: [require.resolve(&#x27;eslint-config-react-app/base&#x27;)],            rules: &#123;              ...(!hasJsxRuntime &amp;&amp; &#123;                &#x27;react/react-in-jsx-scope&#x27;: &#x27;error&#x27;,              &#125;),            &#125;,          &#125;,        &#125;),    ].filter(Boolean),    // Some libraries import Node modules but don&#x27;t use them in the browser.    // Tell webpack to provide empty mocks for them so importing them works.    // 避免打包一些node模块文件    node: &#123;      module: &#x27;empty&#x27;,      dgram: &#x27;empty&#x27;,      dns: &#x27;mock&#x27;,      fs: &#x27;empty&#x27;,      http2: &#x27;empty&#x27;,      net: &#x27;empty&#x27;,      tls: &#x27;empty&#x27;,      child_process: &#x27;empty&#x27;,    &#125;,    // Turn off performance processing because we utilize    // our own hints via the FileSizeReporter    // 关闭性能分析    performance: false,  &#125;;&#125;;\n\n\nbuild.jsconst measureFileSizesBeforeBuild =  FileSizeReporter.measureFileSizesBeforeBuild;const printFileSizesAfterBuild = FileSizeReporter.printFileSizesAfterBuild;const useYarn = fs.existsSync(paths.yarnLockFile);// These sizes are pretty large. We&#x27;ll warn for bundles exceeding them.const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;const isInteractive = process.stdout.isTTY;// Warn and crash if required files are missingif (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) &#123;  process.exit(1);&#125;const argv = process.argv.slice(2);const writeStatsJson = argv.indexOf(&#x27;--stats&#x27;) !== -1;// Generate configurationconst config = configFactory(&#x27;production&#x27;);// We require that you explicitly set browsers and do not fall back to// browserslist defaults.const &#123; checkBrowsers &#125; = require(&#x27;react-dev-utils/browsersHelper&#x27;);checkBrowsers(paths.appPath, isInteractive)  .then(() =&gt; &#123;    // First, read the current file sizes in build directory.    // This lets us display how much they changed later.    return measureFileSizesBeforeBuild(paths.appBuild);  &#125;)  .then(previousFileSizes =&gt; &#123;    // Remove all content but keep the directory so that    // if you&#x27;re in it, you don&#x27;t end up in Trash    fs.emptyDirSync(paths.appBuild);    // Merge with the public folder    copyPublicFolder();    // Start the webpack build    return build(previousFileSizes);  &#125;)  .then(    (&#123; stats, previousFileSizes, warnings &#125;) =&gt; &#123;      if (warnings.length) &#123;        console.log(chalk.yellow(&#x27;Compiled with warnings.\\n&#x27;));        console.log(warnings.join(&#x27;\\n\\n&#x27;));        console.log(          &#x27;\\nSearch for the &#x27; +            chalk.underline(chalk.yellow(&#x27;keywords&#x27;)) +            &#x27; to learn more about each warning.&#x27;        );        console.log(          &#x27;To ignore, add &#x27; +            chalk.cyan(&#x27;// eslint-disable-next-line&#x27;) +            &#x27; to the line before.\\n&#x27;        );      &#125; else &#123;        console.log(chalk.green(&#x27;Compiled successfully.\\n&#x27;));      &#125;      console.log(&#x27;File sizes after gzip:\\n&#x27;);      printFileSizesAfterBuild(        stats,        previousFileSizes,        paths.appBuild,        WARN_AFTER_BUNDLE_GZIP_SIZE,        WARN_AFTER_CHUNK_GZIP_SIZE      );      console.log();      const appPackage = require(paths.appPackageJson);      const publicUrl = paths.publicUrlOrPath;      const publicPath = config.output.publicPath;      const buildFolder = path.relative(process.cwd(), paths.appBuild);      printHostingInstructions(        appPackage,        publicUrl,        publicPath,        buildFolder,        useYarn      );    &#125;,    err =&gt; &#123;      const tscCompileOnError = process.env.TSC_COMPILE_ON_ERROR === &#x27;true&#x27;;      if (tscCompileOnError) &#123;        console.log(          chalk.yellow(            &#x27;Compiled with the following type errors (you may want to check these before deploying your app):\\n&#x27;          )        );        printBuildError(err);      &#125; else &#123;        console.log(chalk.red(&#x27;Failed to compile.\\n&#x27;));        printBuildError(err);        process.exit(1);      &#125;    &#125;  )  .catch(err =&gt; &#123;    if (err &amp;&amp; err.message) &#123;      console.log(err.message);    &#125;    process.exit(1);  &#125;);// Create the production build and print the deployment instructions.function build(previousFileSizes) &#123;  console.log(&#x27;Creating an optimized production build...&#x27;);  const compiler = webpack(config);  return new Promise((resolve, reject) =&gt; &#123;    compiler.run((err, stats) =&gt; &#123;      let messages;      if (err) &#123;        if (!err.message) &#123;          return reject(err);        &#125;        let errMessage = err.message;        // Add additional information for postcss errors        if (Object.prototype.hasOwnProperty.call(err, &#x27;postcssNode&#x27;)) &#123;          errMessage +=            &#x27;\\nCompileError: Begins at CSS selector &#x27; +            err[&#x27;postcssNode&#x27;].selector;        &#125;        messages = formatWebpackMessages(&#123;          errors: [errMessage],          warnings: [],        &#125;);      &#125; else &#123;        messages = formatWebpackMessages(          stats.toJson(&#123; all: false, warnings: true, errors: true &#125;)        );      &#125;      if (messages.errors.length) &#123;        // Only keep the first error. Others are often indicative        // of the same problem, but confuse the reader with noise.        if (messages.errors.length &gt; 1) &#123;          messages.errors.length = 1;        &#125;        return reject(new Error(messages.errors.join(&#x27;\\n\\n&#x27;)));      &#125;      if (        process.env.CI &amp;&amp;        (typeof process.env.CI !== &#x27;string&#x27; ||          process.env.CI.toLowerCase() !== &#x27;false&#x27;) &amp;&amp;        messages.warnings.length      ) &#123;        console.log(          chalk.yellow(            &#x27;\\nTreating warnings as errors because process.env.CI = true.\\n&#x27; +              &#x27;Most CI servers set it automatically.\\n&#x27;          )        );        return reject(new Error(messages.warnings.join(&#x27;\\n\\n&#x27;)));      &#125;      const resolveArgs = &#123;        stats,        previousFileSizes,        warnings: messages.warnings,      &#125;;      if (writeStatsJson) &#123;        return bfj          .write(paths.appBuild + &#x27;/bundle-stats.json&#x27;, stats.toJson())          .then(() =&gt; resolve(resolveArgs))          .catch(error =&gt; reject(new Error(error)));      &#125;      return resolve(resolveArgs);    &#125;);  &#125;);&#125;function copyPublicFolder() &#123;  fs.copySync(paths.appPublic, paths.appBuild, &#123;    dereference: true,    filter: file =&gt; file !== paths.appHtml,  &#125;);&#125;","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"Rollup 与 Webpack 比较","url":"/posts/2c68ca6b0823/","content":"跟随前端技术的演化当前端演化到单页应用阶段的时候,对于复杂的单页应用有两个问题需要解决,而 Webpack 就是在这时产生的.\n\n代码分割\n\n这意味着可以按需加载,不用再等待整个应用都被下载并解析完成。\n\n静态资源\n\n图片、CSS 等静态资源可以直接导入到你的 app 中，就和其它的模块、节点一样能够进行依赖管理。可以放在任意的文件夹中, Webpack 会帮助处理文件路径, 包括添加哈希值,最终输出在指定的文件夹中.\n包括 Webpack 在内的大多数打包器,都是将模块封装在函数中,通过 Webpack 实现的 require 方法,组织模块间的调用.\n而 Rollup 利用了 ES6 的模块设计,将所有的模块的代码都放在同一个位置, 因此更加精简执行速度也会更快.  Rollup 交互式解释器（REPL）\n但是同时这样也导致 Rollup 失去了代码分割的功能, 也不支持模块热替换(HMR),另一个痛点是通过插件处理大多数 CommonJS 文件的时候，一些代码将无法被翻译为 ES2015。而与之相反 Webpack 可以很好而处理.\n如何选择\n在开发应用时使用 Webpack，开发库时使用 Rollup\n\n这虽然不是绝对的,但是很多开源项目提供有经验,如果有很多的静态资源，再或者你做的东西深度依赖 CommonJS，毫无疑问选择 Webpack.\n如果你的代码基于 ES2015 模块编写，并且你做的东西是准备给他人使用的，你或许可以考虑使用 Rollup。\n对于包作者一定使用 pkg.module\n对于第三方开源库,在 ES6 模块化规范出现以前,一定要注意模块系统的区别,有人喜欢 Browserify 有人喜欢 AMD,在 UMD 出现之后有了一些改善,但是仍然无法完全信任.\n现在给你的库的 package.json 文件增加一个 “module”: “dist&#x2F;my-library.es.js” 入口，可以让你的库同时支持 UMD 与 ES2015。 Webpack 和 Rollup 都使用了 pkg.module 来尽可能的生成效率更高的代码——在一些情况下，它们都能使用 tree-shake 来精简掉你的库中未使用的部分。\n","categories":["webpack"],"tags":["webpack"]},{"title":"Tree Shaking 过程分析","url":"/posts/758146f28c04/","content":"什么是 Tree ShakingTree Shaking 是 DCE(Dead Code Elimination) 的一种实现,即清除无用代码,这个功能最早是在 Rollup 中实现的,随后 webpack 在 2.0 版本中也实现了此功能\n基本使用module.exports = &#123;  mode: &quot;production&quot;,  optimization: &#123;    usedExports: true,  &#125;,&#125;;\n\nwebpack4 添加了 sideEffects 配置属性,用于声明那些模块是没有副作用的,从而可以安全的移除.\n如上面的例子中模块中包含两个纯函数,所以可以设置 sideEffects 为 false, 可以安全的删除 square\n&#123;  &quot;name&quot;: &quot;your-project&quot;,  &quot;sideEffects&quot;: false&#125;\n\nsideEffects 可能会比 usedExports 更加有效,因为它是声明式的告诉,那些模块&#x2F;文件可以跳过.\nusedExports 依赖 terser 来检测语句中的副作用。对于如下的模块,默认不会被移除,因为不确定其中是否有副作用.虽然可以使用标注来解决,但是 sideEffect 使用的更多.\n// a.jsclass A &#123;&#125;Array.prototype.slice = () =&gt; &#123;&#125;;// 表示一个无副作用的模块,可以删除export default /*#__PURE__*/ A;\n\n实现原理Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用生成产物时，若变量没有被其它模块使用则删除对应的导出语句\nMake 收集阶段这个阶段需要分析每个文件中有那些模块被导出,把这些导出模块转换为 webpack 内部对象,并添加到当前模块依赖中\nexport const bar = &quot;bar&quot;;export const foo = &quot;foo&quot;;export default &quot;foo-bar&quot;;\n\n最终转换为三个内部对象\n\n在编译结束之后会触发回调,这时会遍历 dependencies 数组,找到所有的导出对象转换为 ExportInfo 记录在 ModuleGraph 中,至此 webpack 可以直接访问各模块的导出值.\nSeal 标记阶段标记的主要作用就是删除没有使用模块的导出语句,可以看见对于导出但是没有使用的模块会添加未使用的标记,并且不会被导出,但是标记阶段不会删除代码,删除的过程是 Terser 等压缩工具实现的\n/***/ (function (module, __webpack_exports__, __webpack_require__) &#123;  &quot;use strict&quot;;  /* unused harmony export square */  /* harmony export (immutable) */ __webpack_exports__[&quot;a&quot;] = cube;  function square(x) &#123;    return x * x;  &#125;  function cube(x) &#123;    return x * x * x;  &#125;&#125;);\n\n这一阶段会触发 optimizeDependencies,从 entry 入口文件开始遍 ModuleGraph 所有的模块\n接着遍历所有 exportInfo 数组,为每一个 exportInfo 执行 getDependencyReferencedExports 方法，确定其对应的 dependency 对象有否被其它模块使用\n被任意模块使用到的导出值，调用 exportInfo.setUsedConditionally 方法将其标记为已被使用,内部修改 exportInfo._usedInRuntime 记录导出如何被使用\n这一过程是通过 FlagDependencyUsagePlugin 插件完成的\n生成代码调用 HarmonyExportXXXDependency.Template.apply 生成代码,方法内部会读取 exportsInfo, 分别为使用和未使用的导出值创建不同的 HarmonyExportInitFragment, 保存到 initFragments 数组并循环生成代码.\n最终的的无用代码会被压缩工具删除.\n对比 Rollup与 webpack 相同 Rollup 也是基于 ES 模块化做静态分析, 但是由于打包方式不同,Rollup 的打包文件在同一作用域下,所以还可以进行流程分析.\nRollup 可以删除被引用但是没有使用的模块,但也不是所有的副作用 Rollup 都可以处理,包括:\n未使用的 class 中的方法(可以通过 enhancement 配置解决)\n对全局对象的赋值 window.a = 1\n最佳实践\n避免无意义的赋值语句\n\n// math.jsexport const a = 1;export const b = 2;// index.jsimport &#123; a, b &#125; from &quot;./index&quot;;const f = a;\n\n通过静态分析只能判断:模块导出变量是否被其它模块引用,或引用模块的主体代码中有没有出现这个变量\n另外最重要的是因为 JS 这种动态类型语言引用的 a 可能存在副作用\n\n必要的时候使用 /*__PURE__*/ 纯函数标注\n\n禁用 babel 的导入导出语句转换\n当 babel 的 module 配置为 commonjs 的时候,将不能正确识别未使用的模块\npresets: [  &quot;babel-preset-env&quot;,  &#123;    modules: &quot;commonjs&quot;,  &#125;,];\n\n将”sideEffects”属性添加到项目 package.json 文件中。\n\n使用明确的导出语句\n\n\nexport default &#123;  bar: &quot;bar&quot;,  foo: &quot;foo&quot;,&#125;;//  修改为export bar;export foo;\n\n\n使用支持 Tree Shaking 的工具包\n\n例如:使用 lodash-es 替代 lodash ，或者使用 babel-plugin-lodash 实现类似效果\n","categories":["webpack"],"tags":["webpack"]},{"title":"webpack执行流程","url":"/posts/7a682c5de361/","content":"主要流程\n初始化阶段（Initialization）:\n解析配置：Webpack 开始处理配置文件（如 webpack.config.js），包括解析入口点、加载器、插件等。初始化插件：加载并初始化配置中指定的插件。环境准备：设置编译环境，例如选择开发模式或生产模式。\n\n编译阶段（Compilation）:\n创建编译器：Webpack 创建一个编译器实例，它管理整个编译过程。创建编译对象：创建一个新的编译对象，它包含了此次编译的所有细节。读取记录：从之前的编译中读取记录（如果有），以优化编译。解析入口：根据配置的入口点，分析出所有依赖的模块。\n\n构建阶段（Building）:\n加载模块：Webpack 递归地加载每个依赖模块，这可能涉及到使用不同的加载器处理不同类型的文件。模块转换：应用加载器和插件，转换模块内容（如 TS 转 JS，SASS 转 CSS）。构建依赖图：构建模块间的依赖关系图。\n\n优化阶段（Optimization）:\n优化模块：应用各种优化策略，以减小最终资产的大小。代码分割：根据需要将代码分割成不同的块。树摇（Tree Shaking）：移除未使用的代码。\n\n输出阶段（Output）:\n生成资产：根据依赖图，Webpack 将所有模块打包成少量的打包文件（资产），通常是一个或多个 JavaScript 文件、CSS 文件和其他静态资源文件。\n\n输出资源：将生成的打包文件写入到文件系统中，通常是输出到指定的 dist 目录。\n完成阶段（Completion）:执行插件：执行各种插件的完成钩子，完成额外的任务或清理工作。输出结果：Webpack 提供编译过程的摘要和详情，如编译时间、打包后的文件大小等。监听模式：如果启用了监听模式（watch mode），Webpack 将保持活跃状态，并在源文件更改时重新编译。在这个过程中，Webpack 通过其强大的插件系统和加载器机制，提供了高度的可扩展性和灵活性，允许开发人员针对不同的需求和场景进行定制和优化。\n\n\nInitializationcli.run使用 commander 处理命令行参数\n// 重写异常退出this.program.exitOverride(async((async) =&gt; &#123;&#125;));// 监听选项 以及选项触发时的处理函数this.program.option(&quot;--no-color&quot;, &quot;Disable colors on console.&quot;);this.program.on(&quot;option:no-color&quot;, function () &#123;&#125;);// 绑定处理函数// 最终执行webpackthis.program.action(async () =&gt; &#123;  compiler = this.webpack(config.options);&#125;);\n\n创建 compiler\n\nnode_modules\\webpack\\lib\\webpack.js\n\n\nconst createCompiler = (rawOptions) =&gt; &#123;  const options = getNormalizedWebpackOptions(rawOptions);  applyWebpackOptionsBaseDefaults(options);  const compiler = new Compiler(options);  new NodeEnvironmentPlugin(&#123;    infrastructureLogging: options.infrastructureLogging,  &#125;).apply(compiler);  // 初始化所有的插件  if (Array.isArray(options.plugins)) &#123;    for (const plugin of options.plugins) &#123;      if (typeof plugin === &quot;function&quot;) &#123;        plugin.call(compiler, compiler);      &#125; else if (plugin) &#123;        plugin.apply(compiler);      &#125;    &#125;  &#125;  applyWebpackOptionsDefaults(options);  compiler.hooks.environment.call();  compiler.hooks.afterEnvironment.call();  // 注册内部依赖插件  // ExternalsPlugin  // ChunkPrefetchPreloadPlugin  // ArrayPushCallbackChunkFormatPlugin  // EnableChunkLoadingPlugin  // JsonpChunkLoadingPlugin  // ImportScriptsChunkLoadingPlugin  // EnableWasmLoadingPlugin  // CleanPlugin  // JavascriptModulesPlugin  // JsonModulesPlugin  // AssetModulesPlugin  // EntryOptionPlugin  // EntryPlugin  // RuntimePlugin  // InferAsyncModulesPlugin  // DataUriPlugin  // FileUriPlugin  // CompatibilityPlugin  // HarmonyModulesPlugin  // 模块解析和绑定：它帮助 Webpack 解析和绑定 ES6 模块的 import 和 export 语句，确保模块之间的依赖关系被正确处理。  // 树摇（Tree Shaking）：这个插件支持树摇优化，即移除未使用的模块或模块部分，以减小最终打包文件的大小。这是通过静态分析 import 和 export 语句来实现的。  // ES6 模块的原生支持：由于 ES6 模块是 JavaScript 语言的一部分，HarmonyModulesPlugin 提供了对这些模块的原生支持，无需转换为其他格式。  // 代码分割和异步加载：插件支持基于 ES6 模块的代码分割和异步加载，这有助于提高大型应用的性能。  // 与其他 Webpack 特性的集成：HarmonyModulesPlugin 与 Webpack 的其他功能（如模块热替换、代码压缩等）紧密集成。  // InferAsyncModulesPlugin  // DataUriPlugin  // FileUriPlugin  // CompatibilityPlugin  // HarmonyModulesPlugin  // AMDPlugin  // RequireJsStuffPlugin  // CommonJsPlugin  // LoaderPlugin  // NodeStuffPlugin  // APIPlugin  // ExportsInfoApiPlugin  // WebpackIsIncludedPlugin  // ConstPlugin  // UseStrictPlugin  // RequireIncludePlugin  // RequireEnsurePlugin  // RequireContextPlugin  // ImportPlugin  // ImportMetaContextPlugin  // SystemPlugin  // ImportMetaPlugin  // URLPlugin  // DefaultStatsFactoryPlugin  // DefaultStatsPresetPlugin  // DefaultStatsPrinterPlugin  // JavascriptMetaInfoPlugin  // EnsureChunkConditionsPlugin  // RemoveEmptyChunksPlugin  // MergeDuplicateChunksPlugin  // FlagIncludedChunksPlugin  // SideEffectsFlagPlugin  // FlagDependencyExportsPlugin  // FlagDependencyUsagePlugin  // InnerGraphPlugin  // MangleExportsPlugin  // ModuleConcatenationPlugin  // SplitChunksPlugin  // RuntimeChunkPlugin  // NoEmitOnErrorsPlugin  // RealContentHashPlugin  // WasmFinalizeExportsPlugin  // DeterministicModuleIdsPlugin  // DeterministicChunkIdsPlugin  // DefinePlugin  // SizeLimitsPlugin  // TemplatedPathPlugin  // RecordIdsPlugin  // WarnCaseSensitiveModulesPlugin  // AddManagedPathsPlugin  // ResolverCachePlugin  WorkerPlugin;  new WebpackOptionsApply().process(options, compiler);  compiler.hooks.initialize.call();  return compiler;&#125;;\n\ncompiler.run()this.hooks.beforeRun.callAsync(this, (err) =&gt; &#123;  this.hooks.run.callAsync(this, (err) =&gt; &#123;    this.readRecords((err) =&gt; &#123;      this.compile(onCompiled);    &#125;);  &#125;);&#125;);\n","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"webpack核心概念","url":"/posts/dce700bcd907/","content":"安装推荐就近安装，即安装在项目中，不要安装在全局中\n通过 npx webpack -v 查看项目中 webpack 版本\nnrm 镜像源管理\nyarn add nrm\n查看镜像源列表\nnrm ls\n测速\nnrm test taobao\n常用工具clean-webpack-pluginhttps://www.npmjs.com/package/clean-webpack-plugin\nsource-mapcheap-module-source-map 用于生产环境，不能暴露源码\neval-cheap-module-source-map 开发环境中使用\n&#123;  devtool:&#x27;cheap-module-source-map&#x27;&#125;\n\ndevServer 和热模块更新安装devServer\nyarn add -D webpack-dev-server\n\nwebpack.config.js 中添加配置项  \ncontentBase 只有需要在访问静态文件时候使用，默认下面三个配置项都可以不写\ndevServer: &#123;  contentBase: path.join(__dirname, &#x27;dist&#x27;),  compress: true,  port: 9000&#125;\n\npackage.json 中添加启动命令\n&#123;  &quot;scripts&quot;:&#123;    &quot;server&quot;: &quot;webpack-dev-server --open&quot;  &#125;&#125;\n\n开启hmr\n1.配置webpack-dev-server2.devServer配置hot:true3.plugins hotModuleeReplaceMentPlugin4.js 文件中添加hmr代码\nwebpack.config.js 中添加\nconst webpack = require(&#x27;webpack&#x27;)module.exports = &#123;  devServer: &#123;  ...  hot:true  &#125;,  plugins: [    ...    new webpack.NamedModulesPlugin(),    new webpack.HotModuleReplacementPlugin()  ]&#125;\n\nindex.js 增加代码\nif (module.hot) &#123;  module.hot.accept(&#x27;./print.js&#x27;, function() &#123;    console.log(&#x27;Accepting the updated printMe module!&#x27;);   printMe();  &#125;)&#125;\n\nentrystring : 所有的资源打包成一个chunk,输出一个bundle文件，默认的名称是main.js\narray: 多入口，所有的文件也只会被打包成一个chunk,通常只在配置html的HMR时使用\nobject 多入口，有几个入口文件就可以形成几个chunk,输出几个bundle文件，文件的名称时对象中的key，每个key后面可以写一个数组，可以将数组中的文件打包成一个bundle,(参照dll的用法)\noutputfilename 输出的文件名称，可以指定目录和文件名 js/[name].js\npublicpath 所有资源引入时候的公共路径，会拼在资源路径的前面作为基础路径， publicpath:/,img/a.png &#x3D;&gt; /img/a.png, 注意：不是资源的输出路径\nchunkFilename 非入口chunk的名称，通过动态import引入的文件名称通过id的形式命名，从0开始，依次递增，通常会使用webpackchunkname来重命名\nlibrary 会将chunk文件用一个变量接受，暴露给全局使用\nlibraryTarget 指明以那种方式引入,window把输入的变量添加到浏览器全局环境window[name]=xxx, global把输入的变量添加到node全局环境global[name]=xxx,commonjs以commonjs模块化规范引入，通常配合dll使用 \n与 devserver 中的 publicpath 区别\noutput 中的 publicpath\n这是一个在使用按需加载和引入外部资源（图片,文件等）非常重要的属性，如果设置了一个错误的值，当加载这些资源时会报404错误\n这个配置项指定了输出目录在浏览器中引用时的公共路径（publicpath）,一个相对路径被解析为相对于HTML页面或&lt;base&gt;标签\n\n 标签为页面上的所有链接规定默认地址或默认目标。\n\n相对服务器的路径，相对与协议的路径，或绝对路径都是有可能的甚至有时是必须的，换句话说，在CDN 托管静态资源\n在运行时或loader处理时，每一个URL的前缀都会被色设置配置项中的值，这就是为什么在很多例子中这个配置项被设置为 / 的原因\nwebpack-dev-server 也需要从publicPath获取信息，使用它来确定从何处提供输出文件。\nmodule.exports = &#123;  //...  output: &#123;    // One of the below    publicPath: &#x27;https://cdn.example.com/assets/&#x27;, // CDN (always HTTPS)    publicPath: &#x27;//cdn.example.com/assets/&#x27;, // CDN (same protocol)    publicPath: &#x27;/assets/&#x27;, // server-relative    publicPath: &#x27;assets/&#x27;, // relative to HTML page    publicPath: &#x27;../assets/&#x27;, // relative to HTML page    publicPath: &#x27;&#x27;, // relative to HTML page (same directory)  &#125;&#125;;\n\ndevServer 中的 publicpath\n打包的文件可以在浏览器的这个目录下面得到\n如果服务跑在 http://localhost:8080，打包的文件为bundle.js，publicPath为 /, 可以在 http://localhost:8080/bundle.js访问到打包文件\n如果 publicPath 改为 /assets/, 那么可以在 http://localhost:8080/assets/bundle.js访问，也可以把 publicPath 改为 http://localhost:8080/assets/\n这说明了 devServer.publicPath 与 output.publicPath 是一致的\n@babel&#x2F;polyfill  @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime-corejs2@babel&#x2F;preset-env 只会转换新语法，但是不会转换新的api,比如 Array.from\n需要 @babel&#x2F;polyfill 转换新的api,但是 @babel&#x2F;polyfill 会全量引入，不能按需引入\n可以通过 babel.rc 配置文件来实现 \n&#123;  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      // This option was removed in v7 by just making it the default.在新版本中已经移除，无需添加      // &#123;      //   &quot;useBuiltIns&quot;: &quot;usage&quot;      // &#125;    ]  ]&#125;\n\n但是@babel&#x2F;preset-env也存在问题，虽然会按需引入但是每个文件如果有重复的方法，都会被编译成相同的代码引入，文件多的时候会让冗余的代码越来越多\n@babel&#x2F;runtime-corejs2 是一个随着 @babel&#x2F;plugin-transform-runtime 一起时使用的运行时依赖，会把重复的函数覆盖为 @babel&#x2F;runtime-corejs2 中的引用\n@babel&#x2F;runtime-corejs2 仅仅是一个包含着函数的包，把函数以模块化的形式引入, 要安装到生产依赖中\n.babelrc\n&#123;  &quot;plugins&quot;: [    [      &quot;@babel/plugin-transform-runtime&quot;,      &#123;        &quot;corejs&quot;: 3      &#125;    ]  ]&#125;\n\n\ntreeshakingwebpack4 production 默认开启，需要引入的库使用commonjs 模块化规范\n如 loadsh-es\n全局引入provide-plugin\nplugins: [  new webpack.ProvidePlugin(&#123;    $: &#x27;jquery&#x27;,  &#125;)]\n\n多入口文件的每一个都会被引入jquery，所以需要提取公共代码\n动态加载@babel&#x2F;plugin-syntax-dynamic-import\nDynamic Imports\n需要指明webpackChunkName才能被单独打包\nimport(   /* webpackChunkName: &quot;my-jquery&quot; */   &#x27;jquery&#x27; )   .then((&#123; default: $ &#125;) =&gt; &#123;     console.log($)     return $(&#x27;body&#x27;);   &#125;)\n\n代码分割SplitChunksPlugin 代替原来的 commonChunksPlugin\n\nsplitChunks.chunks\n\nasync表示只从异步加载得模块（动态加载import()）里面进行拆分initial表示只从入口模块进行拆分all表示以上两者都包括\n\nsplitChunks.maxInitialRequests\n\n每个入口的并发请求数, 如果拆出的包的个数大于maxInitialRequests，则不会把较小的包单独拆出\n\nsplitChunks.maxInitialRequests\n\n动态引入的模块，最多拆分的数量\ncss分割css-minimizer-webpack-plugin\n压缩css代码MiniCssExtractPlugin\n可视化分析webpack-bundle-analyzer\n","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"发布一个npm包","url":"/posts/7b1df0314d16/","content":"注册账号npm注册 记得要去邮箱确认，不然发布的时候回报错\n也可以使用命令行的方式\nnpm adduser#注册并登录npm login\n\n\n登录成功提示 Logged in as xxx on https://registry.npmjs.org/.\n\n创建一个包一个最小的包，只需要一个package.json文件,可以用npm init来生成这个文件\n&#123;  &quot;name&quot;: &quot;@noopn/log&quot;,  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;keywords&quot;: [    &quot;log&quot;,    &quot;logger&quot;,    &quot;console&quot;  ],  &quot;license&quot;: &quot;MIT&quot;&#125;\n\n其中有一些字段是必须的：\nname： 包的名字，你可能看到我用了 @noopn/log 这样的名字,这表示会创建一个在我们用户名 scope（作用范围） 下的一个包。这个叫做 scoped package。它允许我们将已经被其他包使用的名称作为包名，比如说，log 包 已经在 npm 中存在。比如 @angular/core 和 @angular/http。\nversion: 版本号，以便开发人员在安全地更新包版本的同时不会破坏其余的代码。npm 使用的版本系统被叫做 SemVer，是 Semantic Versioning 的缩写。\n\n给定版本号 MAJOR.MINOR.PATCH，增量规则如下：  MAJOR 版本号的变更说明新版本产生了不兼容低版本的 API 等，  MINOR 版本号的变更说明你在以向后兼容的方式添加功能  PATCH 版本号的变更说明你在新版本中做了向后兼容的 bug 修复.\n\n发布现在准备好可以使用 npm publish 发布了，但不兴的是会得到一个错误\nnpm ERR! publish Failed PUT 402npm ERR! code E402npm ERR! You must sign up for private packages : @noopn/log\n\nScoped packages 会被自动发布为私有包，因为这样不但对我们这样的独立用户有用，而且它们也被公司用于在项目之间共享代码。我们想让每个人都可以使用这个模块.使用下面这个命令：\nnpm publish --access=public\n\n成功之后会看见 + @noopn/log@0.0.1 \n渐入佳境虽然发布了我们的第一个包，但是现在还不能向别人展示我们的代码，那这个地方就是github\n首先新建一个项目\n\n让我们把本地项目和远程项目关联起来\n# 跟踪新文件,或者说将内容从工作目录添加到暂存区git add .# 将暂存区内容添加到本地仓库中。git commit -m &quot;xx&quot;# 拉去远程代码git pull origin master# 提交代码git push -u origin master\n\n在添加了新的内容之后，升级一下包的版本,并重新发布\nnpm version batchnpm publish","categories":["webpack"],"tags":["工程化","npm"]},{"title":"实现一个loader","url":"/posts/12a348d54925/","content":"WEEBPACK LOADER\n简单loader配置webpack.config，webpace5提供默认的entry和output所以无需配置\nmodule.exports = &#123;  module:&#123;    rules:[&#123;      test:/\\.js$/,      use:[&#x27;my-loader&#x27;,&#x27;my-loader1&#x27;,&#x27;my-loader2&#x27;]    &#125;]  &#125;,  mode:&#x27;production&#x27;,  // webpack5 提供resolveLoader可以配置loader的查找目录  resolveLoader: &#123;    modules: [&#x27;node_modules&#x27;,path.resolve(__dirname,&#x27;loader&#x27;)],  &#125;,&#125;\n\n实现loader loader/my-loader loader/my-loader1 loader/my-loader2\n// 同步方法在loader解析时执行// 也就是use数组中的loader从右向左执行module.exports = function(content)&#123;  console.log(111);  return content;&#125;// pitch 方法在loader加载时执行// 也就是use数组中的loader从左向右执行module.exports.pitch = function()&#123;  console.log(&#x27;p111&#x27;)&#125;\n\n同步loader和异步loader同步写法\nmodule.exports = function(content)&#123;  this.callback(null,content);&#125;\n\n异步写法,仍然按顺序依次执行，不会改变loader执行顺序\nmodule.exports = function(content)&#123;  var callback = this.async();  setTimeout(()=&gt;&#123;    callback(null,content)  &#125;,3000)&#125;\n\n\n获取loader的options为loader添加options\n&#123;module.exports = &#123;  module:&#123;    rules:[&#123;      test:/\\.js$/,      use:[&#123;         loader:&#x27;my-loader&#x27;,         options:&#123;          test:&#x27;1231&#x27;         &#125;              &#125;,&#x27;my-loader1&#x27;,&#x27;my-loader2&#x27;]    &#125;]  &#125;&#125;\n\nconst  &#123; getOptions &#125;  = require(&#x27;loader-utils&#x27;);const  &#123; validate &#125;  = require(&#x27;schema-utils&#x27;);const schema = &#123;  type: &#x27;object&#x27;,  properties: &#123;    test: &#123;      type: &#x27;string&#x27;,    &#125;  &#125;&#125;;module.exports = function(content)&#123;  const options = getOptions(this);  console.log(options);  validate(schema, options, &#123;    // 需要校验的loader名称    name: &#x27;my-loader&#x27;,    baseDataPath: &#x27;options&#x27;,  &#125;);  this.callback(null,content);&#125;\n\n\n实现一个loader添加webpack.config.json配置\nconst path = require(&#x27;path&#x27;);module.exports = &#123;  module:&#123;    rules:[&#123;      test:/\\.js$/,      loader:&#x27;babelLoader&#x27;,      options:&#123;        &quot;presets&quot;: [&quot;@babel/preset-env&quot;]      &#125;    &#125;]  &#125;,  mode:&#x27;production&#x27;,  resolveLoader: &#123;    modules: [&#x27;node_modules&#x27;,path.resolve(__dirname,&#x27;loader&#x27;)],  &#125;,&#125;\n\nloader\nconst  &#123; getOptions &#125;  = require(&#x27;loader-utils&#x27;);const  &#123; validate &#125;  = require(&#x27;schema-utils&#x27;);const &#123;promisify&#125; = require(&#x27;util&#x27;)const babel = require(&#x27;@babel/core&#x27;);const schema = &#123;  type: &#x27;object&#x27;,  properties: &#123;    persets:&#123;      type:&#x27;array&#x27;    &#125;  &#125;&#125;;module.exports = function(content)&#123;  const options = getOptions(this);  const callback = this.async();  validate(schema, options, &#123;    // 需要校验的loader名称    name: &#x27;babelLoader&#x27;,    baseDataPath: &#x27;options&#x27;,  &#125;);  console.log(options);  const transfrom =  promisify(babel.transform);  transfrom(content,options)    .then((&#123;code&#125;) =&gt;callback(null,code))&#125;","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"实现一个plugin","url":"/posts/47f705e57f3c/","content":"通过plugin拷贝额外资源const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const glob = require(&quot;glob&quot;)const &#123;promisify&#125; = require(&#x27;util&#x27;);const readFile = promisify(fs.readFile);const &#123;RawSource&#125;  = require(&#x27;webpack&#x27;).sources;const  &#123; validate &#125;  = require(&#x27;schema-utils&#x27;);const schema = &#123;  &quot;type&quot;: &#x27;object&#x27;,  &quot;properties&quot;: &#123;    &quot;from&quot;: &#123;      &quot;type&quot;: &#x27;string&#x27;,    &#125;,    &quot;to&quot;: &#123;      &quot;type&quot;: &#x27;string&#x27;,    &#125;,    &quot;ignore&quot;: &#123;      &quot;type&quot;: &#x27;array&#x27;,    &#125;,    // 不允许有其他属性    &quot;additionalProperties&quot;: false  &#125;&#125;;class CopyfilePlugin &#123;  constructor(options=&#123;&#125;)&#123;    // 验证参数    validate(schema, options);    this.options = options;  &#125;  apply(compiler) &#123;    compiler.hooks.thisCompilation.tap(&#x27;CopyfilePlugin&#x27;,(compilation)=&gt;&#123;      compilation.hooks.additionalAssets.tapAsync(&#x27;CopyfilePlugin&#x27;, (callback) =&gt; &#123;        const &#123;from,to,ignore&#125; = this.options;        // 获取系统运行时的文件目录        const &#123;context&#125; = compiler.options;        // 获取from的绝对路径        const fromRelative = path.resolve(context,from,&#x27;*.*&#x27;);        // 获取from文件夹的文件        // 排除不需要的文件        const filePaths =  glob.sync(fromRelative,&#123;          ignore:[&#x27;**/index.html&#x27;]        &#125;)        filePaths.forEach(async (filePath)=&gt;&#123;          const file = await readFile(filePath);          // 获取文件名称          const filename = path.basename(filePath);          // 添加额外的打包资源          compilation.assets[filename] = new RawSource(file);        &#125;)        callback()      &#125;);    &#125;)  &#125;&#125;module.exports  =CopyfilePlugin;","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"实现一个简易 webpack","url":"/posts/f135d4253edb/","content":"webpack 的执行流程\n初始化 Compiler: new Webpack(config) 得到 Compiler 对象\n开始编译，调用 Compiler 对象 run 方法开始编译。\n确定入口，根据配置中的 entry 找出所有入口文件\n编译模块，从入口出发，调用所有配置的 Loader 对模块进行编译，找出该模块依赖的模块，递归直到所有的模块被加载进来。\n完成模块编译：在经过第四步使用 Loader 编译完所有模块之后，得到了每个模块被编译后的最终内容以及他们之间的依赖关系。\n输出资源:根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表。（注意：这步是可以修改输出内容的最后机会）\n输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。\n\n做一些准备工作想要打包总要有个项目吧，让我们着手准备一些项目文件\n\nsrc，目录是项目的源文件，包含了一个工具方法util/add.js\nconst add = (a, b) =&gt; a + b;export default add;\n\n还有另一个打印方法 log.js 有一个更深层的依赖文件\nimport bind from &quot;./util/bind&quot;;const log = bind(console.log, console);export default log;\n\n在项目的入口文件中，引入并使用这两个方法\nimport add from &quot;./util/add&quot;;import log from &quot;./log&quot;;const count = add(1, 2);log(count);\n\n下面我们需要添加打包命令，就像 create-react-app 做的一样，我们想通过一个npm build命令打包, 所以通过 npm init -y初始化了package.json文件并添加了一个脚本\n&#123;  &quot;name&quot;: &quot;my-webpack&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;node scripts/build&quot;  &#125;&#125;\n\n显然我们并没有用于打包的可执行脚本，所以要创建一个，放在scripts/build.js文件夹下面\n正如上一小结流程描述的一样，我们通过一个自定义的myWebpack方法，传入配置后生成了compiler对象\nconst webpack = require(&quot;../lib/myWebpack&quot;);const config = require(&quot;../config/webpack.config&quot;);const compiler = webpack(config);compiler.run();\n\nmyWebpack文件是主要要去实现的功能，我们暂时先建一个空文件，那么剩下的就只有这个webpack.config.js配置文件了,简单的给一些必须配置\nconst path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;../src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;../dist&quot;),    filename: &quot;main.js&quot;,  &#125;,&#125;;\n\n解析入口文件依赖并编译代码myWebpack.js\nconst fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const &#123; parse &#125; = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const &#123; transformFromAst &#125; = require(&quot;@babel/core&quot;);const webpack = (config) =&gt; &#123;  return new Compiler(config);&#125;;class Compiler &#123;  constructor(options = &#123;&#125;) &#123;    this.options = options;  &#125;  run() &#123;    const &#123; entry &#125; = this.options;    // 获取node进程执行的目录    const cwdPath = process.cwd();    // 因为readFile中使用相对路径是以node进程执行时的路径作为基准路径    // 可能有查不到文件报错的情况，这里使用path.resolve转换成绝对路径    const relativeEntryPath = path.resolve(__dirname, entry);    const file = fs.readFileSync(relativeEntryPath, &quot;utf-8&quot;);    // 把文件内容转换成ast抽象语法树    // https://www.babeljs.cn/docs/babel-parser    const ast = parse(file, &#123;      sourceType: &quot;module&quot;,    &#125;);    // 收集入口文件依赖    const deps = [];    // 分析ast中的依赖关系保存奥依赖中    traverse(ast, &#123;      ImportDeclaration: (&#123; node &#125;) =&gt; &#123;        // 获取到依赖文件的引用路径        const traverseModulePath = node.source.value;        // 转换为绝对路径        const relativePath = path.resolve(cwdPath, &quot;src&quot;, traverseModulePath);        deps.push(relativePath);      &#125;,    &#125;);    // 编译代码，从ast编译为es5    const &#123; code &#125; = transformFromAst(ast, null, &#123;      presets: [&quot;@babel/preset-env&quot;],    &#125;);    console.log(code);  &#125;&#125;module.exports = webpack;\n\n深层递归，生成依赖关系图虽然我们拿到了入口文件的依赖，但显然是不够的，依赖的文件可能还有自己的依赖，需要递归的去获取\n可以把递归解析依赖的方法，抽取成公共方法\nconst fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const &#123; parse &#125; = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const &#123; transformFromAst &#125; = require(&quot;@babel/core&quot;);const webpack = (config) =&gt; &#123;  return new Compiler(config);&#125;;class Compiler &#123;  constructor(options = &#123;&#125;) &#123;    this.options = options;  &#125;  analysis(entry) &#123;    // 获取node进程执行的目录    const cwdPath = process.cwd();    // 因为readFile中使用相对路径是以node进程执行时的路径作为基准路径    // 可能有查不到文件报错的情况，这里使用path.resolve转换成绝对路径    const relativeEntryPath = path.resolve(cwdPath, &quot;src&quot;, entry);    const file = fs.readFileSync(relativeEntryPath, &quot;utf-8&quot;);    // 把文件内容转换成ast抽象语法树    // https://www.babeljs.cn/docs/babel-parser    const ast = parse(file, &#123;      sourceType: &quot;module&quot;,    &#125;);    // 收集入口文件依赖    const deps = &#123;&#125;;    // 分析ast中的依赖关系保存到依赖中    traverse(ast, &#123;      ImportDeclaration: (&#123; node &#125;) =&gt; &#123;        // 获取到依赖文件的引用路径        const traverseModulePath = node.source.value + &quot;.js&quot;;        // 转换为绝对路径        const relativePath = path.resolve(cwdPath, &quot;src&quot;, traverseModulePath);        deps[traverseModulePath] = relativePath;      &#125;,    &#125;);    // 编译代码，从ast编译为es5    const &#123; code &#125; = transformFromAst(ast, null, &#123;      presets: [&quot;@babel/preset-env&quot;],    &#125;);    return &#123;      code,      deps,      entry,    &#125;;  &#125;  run() &#123;    const &#123; entry &#125; = this.options;    // 保存加载的模块    let module = [];    let index = 0;    let parseModule = this.analysis(entry);    module.push(parseModule);    while ((parseModule = module[index])) &#123;      const &#123; deps &#125; = parseModule;      Object.keys(deps).forEach((depPath) =&gt; &#123;        parseModule = this.analysis(depPath);        module.push(parseModule);      &#125;);      index++;    &#125;    // 把各模块依赖关系从数据形式转换成对象的形式，方便使用    module = module.reduce((o, item) =&gt; &#123;      o[item.entry] = &#123;        deps: item.deps,        code: item.code,      &#125;;      return o;    &#125;, &#123;&#125;);  &#125;&#125;module.exports = webpack;\n\n生成代码我们需要用刚才创建好的依赖关系图来动态加载我们的代码\nclass Compiler &#123;  generate(module) &#123;    /**     * 入口文件     * var _add = _interopRequireDefault(require(&quot;./util/add&quot;));     * var _log = _interopRequireDefault(require(&quot;./log&quot;));     * function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;     * var count = (0, _add[&quot;default&quot;])(1, 2);     */    /**     * 模块文件     * Object.defineProperty(exports, &quot;__esModule&quot;, &#123;     *  value: true     * &#125;);     * exports[&quot;default&quot;] = void 0;     * var bind = require(&#x27;./util/bind&#x27;);     * var log = bind(console.log, console);     * var _default = log;     * exports[&quot;default&quot;] = _default;     */    const js = `        (function(modules)&#123;            //加载入口文件            var fn = function(path)&#123;                var code = modules[path].code;                // 提供给模块内部使用的require                var require = function(path)&#123;                    return fn(path+&#x27;.js&#x27;);                &#125;                const exports = &#123;&#125;;                // 根据commonjs规范包装模块的方法                (function(exports,require,code)&#123;                    // eval方法中的字符串在运行时会向上级作用于查找需要的变量                    eval(code)                &#125;)(exports,require,code);                // 导出给下一个模块使用                return exports;             &#125;            // 加载入口文件            fn(&#x27;$&#123;this.options.entry&#125;&#x27;)        &#125;)($&#123;JSON.stringify(module)&#125;)        `;    const filename = path.resolve(      this.options.output.path,      this.options.output.filename    );    fs.writeFileSync(filename, js, &quot;utf-8&quot;);  &#125;&#125;\n\n把关系图直接变成函数声明由于用了JSON.stringify所以生成的文件中各个模块都是以字符串的形式保存，需要用eval执行\n所以我们选择另一种处理方法，直接拼接出字符串形式的模块依赖表，这样在生成文件的时候可以直接变成可执行函数\n下面是优化过的完整代码\nclass Compiler &#123;  constructor(options = &#123;&#125;) &#123;    this.options = options;  &#125;  analysis(entry) &#123;    // 获取node进程执行的目录    const cwdPath = process.cwd();    // 因为readFile中使用相对路径是以node进程执行时的路径作为基准路径    // 可能有查不到文件报错的情况，这里使用path.resolve转换成绝对路径    const relativeEntryPath = path.resolve(cwdPath, &quot;src&quot;, entry);    const file = fs.readFileSync(relativeEntryPath, &quot;utf-8&quot;);    // 把文件内容转换成ast抽象语法树    // https://www.babeljs.cn/docs/babel-parser    const ast = parse(file, &#123;      sourceType: &quot;module&quot;,    &#125;);    // 收集入口文件依赖    const deps = &#123;&#125;;    // 分析ast中的依赖关系保存到依赖中    traverse(ast, &#123;      ImportDeclaration: (&#123; node &#125;) =&gt; &#123;        // 获取到依赖文件的引用路径        const traverseModulePath = node.source.value + &quot;.js&quot;;        // 转换为绝对路径        const relativePath = path.resolve(cwdPath, &quot;src&quot;, traverseModulePath);        deps[traverseModulePath] = relativePath;      &#125;,    &#125;);    // 编译代码，从ast编译为es5    let &#123; code &#125; = transformFromAst(ast, null, &#123;      presets: [&quot;@babel/preset-env&quot;],    &#125;);    code = `            (function(exports,require)&#123;                $&#123;code&#125;            &#125;)        `;    return &#123;      code,      deps,      entry,    &#125;;  &#125;  run() &#123;    const &#123; entry &#125; = this.options;    // 保存加载的模块    let module = [];    let index = 0;    let parseModule = this.analysis(entry);    module.push(parseModule);    while ((parseModule = module[index])) &#123;      const &#123; deps &#125; = parseModule;      Object.keys(deps).forEach((depPath) =&gt; &#123;        parseModule = this.analysis(depPath);        module.push(parseModule);      &#125;);      index++;    &#125;    let moduleString = &quot;&#123;&quot;;    module.forEach((m) =&gt; &#123;      moduleString += `&quot;$&#123;m.entry&#125;&quot;:$&#123;m.code&#125;,`;    &#125;);    moduleString += &quot;&#125;&quot;;    this.generate(moduleString);  &#125;  generate(moduleString) &#123;    /**     * 入口文件     * var _add = _interopRequireDefault(require(&quot;./util/add&quot;));     * var _log = _interopRequireDefault(require(&quot;./log&quot;));     * function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;     * var count = (0, _add[&quot;default&quot;])(1, 2);     */    /**     * 模块文件     * Object.defineProperty(exports, &quot;__esModule&quot;, &#123;     *  value: true     * &#125;);     * exports[&quot;default&quot;] = void 0;     * var bind = require(&#x27;./util/bind&#x27;);     * var log = bind(console.log, console);     * var _default = log;     * exports[&quot;default&quot;] = _default;     */    const js = `        (function(modules)&#123;            function require(path)&#123;                var exports = &#123;&#125;;                modules[path+&#x27;.js&#x27;](exports,require)                return exports;            &#125;            // 加载入口文件            modules[&#x27;$&#123;this.options.entry&#125;&#x27;](&#123;&#125;,require)        &#125;)($&#123;moduleString&#125;)        `;    const filename = path.resolve(      this.options.output.path,      this.options.output.filename    );    fs.writeFileSync(filename, js, &quot;utf-8&quot;);  &#125;&#125;\n","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"开发环境处理","url":"/posts/dd1b8adb81f3/","content":"处理htmlhtml-webpack-plugin\nnpm i --save-dev html-webpack-plugin@next //webpack5\n\nplugins: [  new HtmlWebpackPlugin(&#123;    template:&#x27;**.html&#x27;  &#125;)]\n\n处理样式yarn add -D sass-node less-loader css-loader style-loader\n\ncss-loader  style-loader sass-loader\n&#123;  module: &#123;    rules: [      &#123;        test: /\\.scss$/,        use: [          &#x27;style-loader&#x27;,          &#123;              loader: &#x27;css-loader&#x27;,              options: &#123;                  minimize: false, //压缩css代码, 默认false                  import: true, //禁止或启用@import, 默认true                  url: true, //控制url/image-set的解析，会处理成require引入              &#125;          &#125;        , &#x27;sass-loader&#x27;]      &#125;    ]  &#125;,&#125;\n\n\n\n处理图片资源yarn add -D url-loader file-laoder\n\n// 小图片以bash64的方式输出// 可以处理通过import引入的样式中的图片，js文件中引入的图片文件// 如果图片大于指定大小会默认交给file-loader处理// file-loader 会使用options中的配置&#123;  test: /\\.(png|jpe?g|gif)$/i,  use: [    &#123;      loader: &#x27;url-loader&#x27;,      options: &#123;        limit: 5 * 1024,        outputPath: &#x27;assets&#x27;,        name: &#x27;[hash:8].[ext]&#x27;,      &#125;    &#125;  ]&#125;,// 处理html中的图片// 把html字符串中的图片引变成require的形式，// 最终还是需要使用file-loader 和 url-loader来处理// 如果生成的src是[object Module]需要关闭，url-loader的模块化规范&#123;  test: /\\.html$/i,  use: [&#123;    loader: &#x27;html-loader&#x27;,  &#125;]&#125;,\n\n处理字体资源&#123;  // exclude:/\\.xx$/  test: /\\.(ttf|eot|svg|woff|woff2)$/,  loader:&#x27;file-loader&#x27;,  options:&#123;    name:&#x27;[path][name].[ext]&#x27;  &#125;  &#125;\n\n简单的devServer搭建yarn add -D webpack-dev-server\n\nwebpack.config.js 可能因为 webpack-dev-server与webpack版本不匹配导致错误\ndevServer:&#123;  compress: true,  contentBase: path.join(__dirname, &#x27;dist&#x27;),  open:true&#125;\n\n可以通过单独的server.js文件来使用\nconst webpackDevServer = require(&#x27;webpack-dev-server&#x27;);const webpack = require(&#x27;webpack&#x27;);const config = require(&#x27;./webpack.config.js&#x27;);const options = &#123;  contentBase: &#x27;./dist&#x27;,  publicPath: &#x27;/&#x27;,  hot: true,  writeToDisk: true,  open: true&#125;;webpackDevServer.addDevServerEntrypoints(config, options);const compiler = webpack(config);const server = new webpackDevServer(compiler, options);server.listen(9000, &#x27;localhost&#x27;, () =&gt; &#123;  console.log(&#x27;dev server listening on port 9000&#x27;);&#125;);\n\n\nfriendly-errors-webpack-plugin[https://www.npmjs.com/package/friendly-errors-webpack-plugin]添加桌面通知该插件没有桌面通知的原生支持，需要引入node-notifier，这样就可以了 。\nvar NotifierPlugin = require(&#x27;friendly-errors-webpack-plugin&#x27;);var notifier = require(&#x27;node-notifier&#x27;);var ICON = path.join(__dirname, &#x27;icon.png&#x27;); new NotifierPlugin(&#123;    onErrors: (severity, errors) =&gt; &#123;      if (severity !== &#x27;error&#x27;) &#123;        return;      &#125;      const error = errors[0];      notifier.notify(&#123;        title: &quot;Webpack error&quot;,        message: severity + &#x27;: &#x27; + error.name,        subtitle: error.file || &#x27;&#x27;,        icon: ICON      &#125;);    &#125;  &#125;)]\n","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"执行文件分析","url":"/posts/3e7e8a2a1c61/","content":"同步模块加载流程webpack4 和 webpack5 同步模块加载流程基本相同\n\n默认执行入口文件\n查找模块缓存\n如果没有缓存创建缓存对象，否则直接返回\n创建模块后执行模块\n通过__webpack_require__.r为模块添加module标识\n如果有模块依赖通过__webpack_require__重新执行步骤 （1）\n把导出结果添加到__webpack_exports__ ,default 属性上\n导出到下一个模块使用\n\nwebpack4 通过闭包以参数的形式导入，webpack5 则是直接写在作用于内部\nwebpack4 模块的返回值直接添加到exprots对象中，webpack5的返回值则是通过函数，类似注入的形式添加\nwebapck4 同步模块(function(modules) &#123; // webpackBootstrap \t// 模块的缓存 \tvar installedModules = &#123;&#125;; \t// 核心require方法 \tfunction __webpack_require__(moduleId) &#123; \t\t// 如果存在缓存直接返回 \t\tif(installedModules[moduleId]) &#123; \t\t\treturn installedModules[moduleId].exports; \t\t&#125; \t\t// 创建一个新的module并放入的缓存中 \t\tvar module = installedModules[moduleId] = &#123; \t\t\ti: moduleId, \t\t\tl: false, \t\t\texports: &#123;&#125; \t\t&#125;; \t\t// 执行模块函数    // 导出的对象会被添加到module.exports对象中 \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);    // 标识为loading状态 \t\tmodule.l = true; \t\t// 返回模块中导出的对象 \t\treturn module.exports; \t&#125; \t// expose the modules object (__webpack_modules__)  // 所有的模块对象 \t__webpack_require__.m = modules; \t// expose the module cache  // 被缓存的模块对象 \t__webpack_require__.c = installedModules; \t// 在导出对象上定义 __esModule 属性，es6模块化规范 \t__webpack_require__.r = function(exports) &#123; \t\tif(typeof Symbol !== &#x27;undefined&#x27; &amp;&amp; Symbol.toStringTag) &#123; \t\t\tObject.defineProperty(exports, Symbol.toStringTag, &#123; value: &#x27;Module&#x27; &#125;); \t\t&#125; \t\tObject.defineProperty(exports, &#x27;__esModule&#x27;, &#123; value: true &#125;); \t&#125;;  \t// 加载入口文件并导出  // __webpack_require_方法上添加一个静态属性s,标识入口文件模块索引 \treturn __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;); &#125;)/************************************************************************/ (&#123;&quot;./src/app.js&quot;:  (function(module, __webpack_exports__, __webpack_require__) &#123;    __webpack_require__.r(__webpack_exports__);    console.log(&#x27;app&#x27;)    function App()&#123;&#125;;    __webpack_exports__[&quot;default&quot;] = (App)  &#125;),&quot;./src/index.js&quot;:  (function(module, __webpack_exports__, __webpack_require__) &#123;  __webpack_require__.r(__webpack_exports__);    var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&quot;./src/app.js&quot;);    Object(_app__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;])();    console.log(&quot;index.js&quot;);  &#125;) &#125;);\n\n\nwebpack5 同步模块(() =&gt; &#123; \t&quot;use strict&quot;;  // 类似react hooks的写法,直接在内部作用域中定义并执行 \tvar __webpack_modules__ = (&#123;    &quot;./src/app.js&quot;:      ((__unused_webpack_module, __webpack_exports__, __webpack_require__) =&gt; &#123;        __webpack_require__.r(__webpack_exports__);        // 在指定的对象上面添加属性        __webpack_require__.d(__webpack_exports__, &#123;          // 定义一个函数不会使用到未初始化的变量          &quot;default&quot;: () =&gt; (__WEBPACK_DEFAULT_EXPORT__)        &#125;);        console.log(&#x27;app&#x27;);        function App()&#123;&#125;        const __WEBPACK_DEFAULT_EXPORT__ = (App);      &#125;),    &quot;./src/index.js&quot;:      ((__unused_webpack_module, __webpack_exports__, __webpack_require__) =&gt; &#123;        __webpack_require__.r(__webpack_exports__);        var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&quot;./src/app.js&quot;);        // ???????        (0,_app__WEBPACK_IMPORTED_MODULE_0__.default)();        console.log(&quot;index.js&quot;);      &#125;)  &#125;);  // 模块缓存  var __webpack_module_cache__ = &#123;&#125;;  // __webpack_require__没有变化 \tfunction __webpack_require__(moduleId) &#123; \t\t// Check if module is in cache \t\tif(__webpack_module_cache__[moduleId]) &#123; \t\t\treturn __webpack_module_cache__[moduleId].exports; \t\t&#125; \t\tvar module = __webpack_module_cache__[moduleId] = &#123; \t\t\t// no module.id needed \t\t\t// no module.loaded needed \t\t\texports: &#123;&#125; \t\t&#125;; \t \t\t// Execute the module function \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__); \t \t\t// Return the exports of the module \t\treturn module.exports; \t&#125; \t \t(() =&gt; &#123; \t\t// define getter functions for harmony（和谐） exports    //  \t\t__webpack_require__.d = (exports, definition) =&gt; &#123; \t\t\tfor(var key in definition) &#123;        // 如果exports没有想添加的属性时 \t\t\t\tif(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) &#123;          // 在exports上添加注入的属性 \t\t\t\t\tObject.defineProperty(exports, key, &#123; enumerable: true, get: definition[key] &#125;); \t\t\t\t&#125; \t\t\t&#125; \t\t&#125;; \t&#125;)(); \t \t// hasOwnProperty简写 \t(() =&gt; &#123; \t\t__webpack_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop)) \t&#125;)(); \t  // 添加Module标识 \t(() =&gt; &#123; \t\t__webpack_require__.r = (exports) =&gt; &#123; \t\t\tif(typeof Symbol !== &#x27;undefined&#x27; &amp;&amp; Symbol.toStringTag) &#123; \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, &#123; value: &#x27;Module&#x27; &#125;); \t\t\t&#125; \t\t\tObject.defineProperty(exports, &#x27;__esModule&#x27;, &#123; value: true &#125;); \t\t&#125;; \t&#125;)(); \t \t \t// startup \t// Load entry module and return exports \t// This entry module can&#x27;t be inlined because the eval devtool is used. \tvar __webpack_exports__ = __webpack_require__(&quot;./src/index.js&quot;); \t &#125;)();\n\n\n\n\n\nwebpack4异步模块加载过程\n定义全局的变量 webpackJsonp用于接受异步的chunk,重写了webpackJsonp.push方法，在异步chunk被push的时候会调用 webpackJsonpCallback\n\n__webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;); 执行入口文件\n\n在缓存中能查到直接返回\n创建一个初始化的模块对象，并加入到缓存中\n执行模块对应的函数 –&gt; 进入下面环节\n执行结束后模块加载状态标记为以完成\n\n\n如果文件中依赖了异步的chunk,会通过 __webpack_require__.e(chunk名称)方法引入\n\n__webpack_require__.e 创建promises[]用于保存异步模块创建的Promise\n如果缓存中有正在pending中的模块，则把 Promise 对象添加到数组中\n创建Promise对象 保存 [resolve, reject, Promise]\n创建script标签append到head标签中，  (pending中，执行入口文件后面的方法)\n异步模块加载完成后自动执行，调用 window[“webpackJsonp”] push 方法，执行webpackJsonpCallback函数\n把异步chunk创建prosmie对象时的resolve函数添加到resolves数组中\n在缓存中把异步chunk标记为完成（0）\n在模块集合中添加新加载的异步模块\n在全局的数组webpackJsonp添加异步加载的模块\n循环执行resolve方法，全部执行后执行Promise.all的then方法\n\n\n__webpack_require__.bind(null, &quot;./src/app.js&quot;)加载刚刚添加到模块集合中的异步模块\n\n\n(function(modules) &#123; \t// 加载异步模块成功后的回调函数 \tfunction webpackJsonpCallback(data) &#123; \t\tvar chunkIds = data[0]; \t\tvar moreModules = data[1]; \t\t// add &quot;moreModules&quot; to the modules object, \t\t// then flag all &quot;chunkIds&quot; as loaded and fire callback \t\tvar moduleId, chunkId, i = 0, resolves = []; \t\tfor(;i &lt; chunkIds.length; i++) &#123; \t\t\tchunkId = chunkIds[i]; \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;        // 把模块请求promise的resolve函数添加到数组中 \t\t\t\tresolves.push(installedChunks[chunkId][0]); \t\t\t&#125;      // 标记模块已经加载完成 \t\t\tinstalledChunks[chunkId] = 0; \t\t&#125;    //在模块集合中添加异步请求的模块 \t\tfor(moduleId in moreModules) &#123; \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; \t\t\t\tmodules[moduleId] = moreModules[moduleId]; \t\t\t&#125; \t\t&#125;    // 异步模块的信息添加到全局的jsonpArray中 \t\tif(parentJsonpFunction) parentJsonpFunction(data); \t\twhile(resolves.length) &#123; \t\t\tresolves.shift()(); \t\t&#125; \t&#125;; \t// The module cache \tvar installedModules = &#123;&#125;; \t// object to store loaded and loading chunks \t// undefined = chunk not loaded, null = chunk preloaded/prefetched \t// Promise = chunk loading, 0 = chunk loaded  // 标识模块加载的4个状态 \tvar installedChunks = &#123; \t\t&quot;main&quot;: 0 \t&#125;; \t// script path function \tfunction jsonpScriptSrc(chunkId) &#123; \t\treturn __webpack_require__.p + &quot;&quot; + (&#123;&#125;[chunkId]||chunkId) + &quot;.js&quot; \t&#125; \t// require方法无变化 \tfunction __webpack_require__(moduleId) &#123; \t\tif(installedModules[moduleId]) &#123; \t\t\treturn installedModules[moduleId].exports; \t\t&#125; \t\tvar module = installedModules[moduleId] = &#123; \t\t\ti: moduleId, \t\t\tl: false, \t\t\texports: &#123;&#125; \t\t&#125;; \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__); \t\tmodule.l = true; \t\treturn module.exports; \t&#125; \t// 这个文件只包含入口chunk \t// 额外的chunks使用chunk loading函数 \t__webpack_require__.e = function requireEnsure(chunkId) &#123; \t\tvar promises = []; \t\t// JSONP chunk loading for javascript    // 检查已经安装的包中有没有当前模块 \t\tvar installedChunkData = installedChunks[chunkId]; \t\tif(installedChunkData !== 0) &#123; // 0 means &quot;already installed&quot;. \t\t\t// a Promise means &quot;currently loading&quot;.      // 4个状态中只有Promise为真 \t\t\tif(installedChunkData) &#123; \t\t\t\tpromises.push(installedChunkData[2]); \t\t\t&#125; else &#123; \t\t\t\t// setup Promise in chunk cache \t\t\t\tvar promise = new Promise(function(resolve, reject) &#123; \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject]; \t\t\t\t&#125;);        // installedChunkData = [resolve, reject,Promise] \t\t\t\tpromises.push(installedChunkData[2] = promise); \t\t\t\t// 开始加载异步模块 \t\t\t\tvar script = document.createElement(&#x27;script&#x27;); \t\t\t\tvar onScriptComplete; \t\t\t\tscript.charset = &#x27;utf-8&#x27;; \t\t\t\tscript.timeout = 120; \t\t\t\tif (__webpack_require__.nc) &#123; \t\t\t\t\tscript.setAttribute(&quot;nonce&quot;, __webpack_require__.nc); \t\t\t\t&#125; \t\t\t\tscript.src = jsonpScriptSrc(chunkId); \t\t\t\t// create error before stack unwound to get useful stacktrace later \t\t\t\tvar error = new Error(); \t\t\t\tonScriptComplete = function (event) &#123; \t\t\t\t\t// avoid mem leaks in IE.          // 避免IE内存泄漏 \t\t\t\t\tscript.onerror = script.onload = null; \t\t\t\t\tclearTimeout(timeout); \t\t\t\t\tvar chunk = installedChunks[chunkId]; \t\t\t\t\tif(chunk !== 0) &#123; \t\t\t\t\t\tif(chunk) &#123; \t\t\t\t\t\t\tvar errorType = event &amp;&amp; (event.type === &#x27;load&#x27; ? &#x27;missing&#x27; : event.type); \t\t\t\t\t\t\tvar realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src; \t\t\t\t\t\t\terror.message = &#x27;Loading chunk &#x27; + chunkId + &#x27; failed.\\n(&#x27; + errorType + &#x27;: &#x27; + realSrc + &#x27;)&#x27;; \t\t\t\t\t\t\terror.name = &#x27;ChunkLoadError&#x27;; \t\t\t\t\t\t\terror.type = errorType; \t\t\t\t\t\t\terror.request = realSrc; \t\t\t\t\t\t\tchunk[1](error); \t\t\t\t\t\t&#125; \t\t\t\t\t\tinstalledChunks[chunkId] = undefined; \t\t\t\t\t&#125; \t\t\t\t&#125;; \t\t\t\tvar timeout = setTimeout(function()&#123; \t\t\t\t\tonScriptComplete(&#123; type: &#x27;timeout&#x27;, target: script &#125;); \t\t\t\t&#125;, 120000); \t\t\t\tscript.onerror = script.onload = onScriptComplete; \t\t\t\tdocument.head.appendChild(script); \t\t\t&#125; \t\t&#125; \t\treturn Promise.all(promises); \t&#125;; \t// expose the modules object (__webpack_modules__) \t__webpack_require__.m = modules; \t// expose the module cache \t__webpack_require__.c = installedModules; \t// define __esModule on exports \t__webpack_require__.r = function(exports) &#123; \t\tif(typeof Symbol !== &#x27;undefined&#x27; &amp;&amp; Symbol.toStringTag) &#123; \t\t\tObject.defineProperty(exports, Symbol.toStringTag, &#123; value: &#x27;Module&#x27; &#125;); \t\t&#125; \t\tObject.defineProperty(exports, &#x27;__esModule&#x27;, &#123; value: true &#125;); \t&#125;; \t// __webpack_public_path__ \t__webpack_require__.p = &quot;&quot;; \t// on error function for async loading \t__webpack_require__.oe = function(err) &#123; console.error(err); throw err; &#125;;\t// 定义全局变量 \tvar jsonpArray = window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []; \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\t// push方法会调用webpackJsonpCallback \tjsonpArray.push = webpackJsonpCallback; \tjsonpArray = jsonpArray.slice(); \tfor(var i = 0; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]); \tvar parentJsonpFunction = oldJsonpFunction;  // 加载入口模块 \treturn __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;); &#125;)/************************************************************************/ (&#123;    &quot;./src/index.js&quot;:      (function(module, exports, __webpack_require__) &#123;      __webpack_require__.e(0)        .then(__webpack_require__.bind(null, &quot;./src/app.js&quot;))        .then(module=&gt;&#123;(module.default)()&#125;);        console.log(&quot;index.js&quot;);    &#125;) &#125;);\n\n&#x2F;0.js\n(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[0],&#123;&quot;./src/app.js&quot;:(function(module, __webpack_exports__, __webpack_require__) &#123;  __webpack_require__.r(__webpack_exports__);  console.log(&#x27;app&#x27;);  function App()&#123;&#125;;  __webpack_exports__[&quot;default&quot;] = (App);  &#125;)&#125;]);","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"生产环境处理","url":"/posts/ee47704b4322/","content":"提取css文件webpack4中可以使用 mini-css-extract-plugin\ncss兼容新处理postcss-loader 需要安装 postcss-preset-env\n配置postcss.config.js\nmodule.exports = &#123;  plugins: [    require(&#x27;postcss-preset-env&#x27;),  ]&#125;\n添加浏览器版本配置文件 .browserslistrc\n[production]&gt; 1%ie 10[modern]last 1 chrome version\n\n在webpack.config.js中使用loader\npost默认使用的是 .browserslistrc 生产环境的配置，开发环境需要手动修改 process.env.NODE_ENV=&#39;devlopment&#39; 和 webpack.config.js中的mode没有关系\n压缩css**css-minimizer-webpack-plugin**直接使用无需配置\n编译时检查语法规则eslint-webpack-plugin\n一定要在webpack.config.js中配置 exclude: /node_modules/,只检查自己的代码\neslint-plugin-react-hooks 在react-hooks中使用\njs兼容处理配置babel-loader 需要安装@babel/core 添加 .babelrc 文件\n使用 preset-env 同样存在问题\n&#123;  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      &#123;        // 把用到的polyfill按需引入，依赖core-js        &quot;useBuiltIns&quot;: &quot;useage&quot;,        &quot;corejs&quot;:3      &#125;    ],    &quot;@babel/preset-typescript&quot;,    &quot;@babel/preset-react&quot;,    &quot;@babel/plugin-transform-runtime&quot;  ]&#125;\n\n压缩html添加html-webpack-plugin配置项\nnew HtmlWebpackPlugin(&#123;  template: path.resolve(__dirname, &#x27;src/index.html&#x27;),  minify:&#123;    collapseWhitespace: true,// 移除空白    removeComments: true,// 移除注释  &#125;&#125;)\n\n","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"调试webpack代码","url":"/posts/77cda891fa0b/","content":"通过浏览器调试修改package.json配置\n&quot;scripts&quot;: &#123;  &quot;start&quot;: &quot;node --inspect-brk ./node_modules/webpack/bin/webpack.js&quot;,&#125;\n\n打开浏览器 chrome:&#x2F;&#x2F;inspect&#x2F;#devices\n\n点击inspect进行调试\n","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"配置优化","url":"/posts/40f37b34d706/","content":"HMR 模块热替换当一个模块改变时避免所有的模块都被重新编译一次，应该只更新修改的模块\n通过 hot:true 开启hmr，此时样式文件(.css .scss) 可以进行热模块替换，style-loader内部的实现，但是js文件没有开启热替换，而且html的文件也不能更新了\n因为热替换阻止了刷新，通过修改webpack.config.js 入口配置entry: [&#39;./src/index.js&#39;,&#39;./src/index.html&#39;],,可以重新开启index.html的刷新功能\n另外 html文件不需要热替换的功能，因为每个入口只对应一个文件，一定要重新加载\n.js文件的热替换不能是入口文件\nif (module.hot) &#123;  module.hot.accept(&#x27;./print.js&#x27;, function() &#123;    console.log(&#x27;Accepting the updated printMe module!&#x27;);    printMe();  &#125;)&#125;\n\nsource-map提供源代码到编译后代码映射的方案，可以追踪源代码的位置 通过devtool配置\n[inline-|hidden-|eval][nosources-][cheap-[module-]]source-map\ninline 构建速度快\nsource-map 能提示错误代码准确信息，和源代码中准确位置，会单独生成一个文件\ninline-source-map source-map会内嵌到生成的js文件中，只生成一个内联的source-map ，能提示错误代码准确信息，和源代码中准确位置\neval-source-map source-map会内嵌到生成的js文件中,每个文件都会生成对应的source-map，可以提示错误原因，但不能追踪到源代码位置，只会定位到编译后的错误位置\nhidden-source-map source-map文件会单独生成，可以提示错误原因，但不能追踪到源代码位置，只会定位到编译后的错误位置\ncheap-source-map 在外部单独生成，只能提示到行，如果代码在一行中，不能准确的定位\ncheap-module-source-map 在外部单独生成 与 cheap-source-map 类似,会将loader的source-map加入\nnosources-source-map 可以提供作物信息，但是不能定位到错误位置，源代码和编译后代码都不可以\n数度快慢: eval&#x3D;&gt; inline &#x3D;&gt; cheap\n开发环境：cheap-source-map  速度快    eval-cheap-source-map    eval-source-map 🆚  调试友好    source-map    cheap-module-source-map    cheap-source-map\n生产环境  简单调试，  内联会让体积变大  nosources-source-map 全部隐藏代码，在线上环境使用🆚  hidden-source-map  只隐藏源代码\n  source-map 🆚,单独生成文件且便于调试\noneOf用于提升构建的速度，只要有一个loader匹配到就不会继续匹配\n&#123;  module: &#123;    rules: [      &#123;        //...        // 指定优先级，都会先被这个loader处理        enforce:&#x27;pre&#x27;      &#125;，      &#123;        oneOf:[          // 其他的loader        ]      &#125;    ]  &#125;&#125;\n\n\n缓存在编译文件的时候，如果依赖文件没有改变，则直接使用编译好的缓存文件，无需所有文件都重新编译\n&#123;  test: /\\.js$/i,  use: [&#123;    loader: &#x27;babel-loader&#x27;,    options:&#123;      cacheDirectory:true    &#125;  &#125;],&#125;,\n\n文件资源的缓存 \n\nhash 如果都使用hash的话，即每次修改任何一个文件，所有文件名的hash至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效.\n\nchunkhash chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。动态import也受chunkhash的影响.\n\n\n因为我们是将样式作为模块import到JavaScript文件中的，所以它们的chunkhash是一致的,这样就会有个问题，只要对应css或则js改变，与其关联的文件hash值也会改变，但其内容并没有改变呢，所以没有达到缓存意义。固contenthash的用途随之而来。\n\ncontenthash是针对文件内容级别的，只有你自己模块的内容变了，那么hash值才改变\n\ntree-shaking使用es6模块化规范，开启production模式，webpack会自动启用tree-shaking\nwebpack.config.js 中添加sideEffects:false表示所有的代码都没有副作用，如果标记为false, 全局引入的文件(polyfile),或没有通过模块化使用的css,都会被删除\n可以通过一个数组来标记不需要处理的资源 sideEffects:[&#39;*.css&#39;]\n代码分割 code-split生成chunk的几种方式\n\n多页面entry生成多个chunk\n异步组件生成chunk\ncode split\n\n// 将node-modules 中代码单独打包成// 分析多入口文件中有没有公共的依赖，会把依赖单独打包optimization: &#123;  splitChunks: &#123;    chunks: &#x27;all&#x27;  &#125;&#125;,\n\n懒加载 预加载dynamic-imports\nbabel-loader会自动处理 dynamic-imports语法， 如果eslint提示错误，在.eslintrc中添加&quot;parser&quot;: &quot;babel-eslint&quot;\nPWAwork-box -&gt; workbox-webpack-plugin\nyarn add -D workbox-webpack-plugin\n\nwebpack.config.js 中添加插件和配置项\n&#123;  plugins:[    //...    new GenerateSW(&#123;      // 帮助serviceWork快速启动，      // 删除旧的serverwork      clientsClaim:true,      skipWaiting:true    &#125;)  ]&#125;\n\n注册servicework\n在入口文件index.js中\nif (&#x27;serviceWorker&#x27; in navigator) &#123;  window.addEventListener(&#x27;load&#x27;, () =&gt; &#123;    navigator.serviceWorker.register(&#x27;./service-worker.js&#x27;)      .then(() =&gt; &#123;        console.log(&#x27;注册成功&#x27;);      &#125;)      .catch(() =&gt; &#123;        console.log(&#x27;注册失败&#x27;);      &#125;);  &#125;);&#125;\n\n如果eslint不支持全局变量,在.eslinrc添加&#123;env:browser: true,&#125;\n多进程打包thread-loader\n进程的启用会占用时间（大约600ms），只有复杂的任务处理的时候才会有明显的效果\nexternals 忽略某些资源在webpack.config.js中添加externals\nmodule.exports = &#123;  //...  externals: &#123;    jquery: &#x27;jQuery&#x27;  &#125;&#125;;\n\n和dll的区别是，externals并没有打包文件，需要通过cdn的方式引入进来，dll只是把指定的包单独打包，并通过插件把单独打包的文件重新引入\ndll对第三方的库，进行单独打包 webpack5不适用\n通过两份配置，可以避免每次对第三方的库重新打包\nwebpack.dll.js\nconst path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = &#123;  entry:&#123;    lodash:[&#x27;lodash&#x27;],    jquery:[&#x27;jquery&#x27;],    moment:[&quot;moment&quot;]  &#125;,  output:&#123;    // 生成文件的名称    filename:&#x27;[name]_[contenthash:8].js&#x27;,    path:path.resolve(__dirname,&#x27;dll&#x27;),    // 单独打包的库对外暴露的名称    library: &quot;[name]_[fullhash]&quot;  &#125;,  plugins:[    new webpack.DllPlugin(&#123;      context: __dirname,      // 映射单独打包的库的名称      name: &#x27;[name]_[fullhash]&#x27;,      // 生成的manifest文件      path:path.resolve(__dirname,&#x27;dll/[name]_manifest.json&#x27;)    &#125;)  ],  mode:&#x27;production&#x27;&#125;\n\nwebpack.config.js\n使用 add-asset-html-webpack-plugin把单独打包的资源引入\nmodule.export = &#123;  plugins:[    new webpack.DllReferencePlugin(&#123;      // 存在于manifest文件中的包，不会被打包\t\t\tmanifest: require(path.resolve(__dirname,&#x27;dll/moment_manifest.json&#x27;))    &#125;),    new webpack.DllReferencePlugin(&#123;\t\t\tmanifest: require(path.resolve(__dirname,&#x27;dll/lodash_manifest.json&#x27;))    &#125;),    new webpack.DllReferencePlugin(&#123;\t\t\tmanifest: require(path.resolve(__dirname,&#x27;dll/jquery_manifest.json&#x27;))\t\t&#125;),    new AddAssetHtmlPlugin(&#123;      filepath: path.resolve(__dirname, &#x27;./dll/*.js&#x27;),    &#125;)  ]&#125;\n\noptimization&#123;  optimization: &#123;    minimize: true,    // https://webpack.docschina.org/plugins/terser-webpack-plugin/    minimizer: [new TerserPlugin(&#123;      cache:true,// 开启缓存      parallel:true,//多进程打包      sourceMap:true //启用source-map    &#125;)],   splitChunks: &#123;      // async表示只从异步加载得模块（动态加载import()）里面进行拆分      // initial表示只从入口模块进行拆分      // all表示以上两者都包括      chunks: &#x27;async&#x27;, //all       minSize: 1024 * 30 , //分割chunk的最小大小，大于30kb才会被提取      minRemainingSize: 0,      maxSize: 0,// 没有最大限制      minChunks: 1, // 至少被引用一次      // 按需加载的时候并行加载文件的最大个数      // 可以理解为针对一个模块拆分后的个数，包括模块本身      // import()文件本身算一个请求      // 并不算js以外的公共资源请求比如css      // 如果同时有两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来      // 一个按需加载的包最终被拆分成 n 个包，maxAsyncRequests 就是用来限制 n 的最大值。      maxAsyncRequests: 30,       maxInitialRequests: 30, //入口js文件最大请求数量      enforceSizeThreshold: 50000,      name: true, // 可以使用命名规则      cacheGroups: &#123;        // node_module中的包会被引入到defaultVendors包中        defaultVendors: &#123;          test: /[\\\\/]node_modules[\\\\/]/,          priority: -10,          // 如果当前打包的模块和之前的是同一个就会复用，而不是重复打包          reuseExistingChunk: true,        &#125;,        default: &#123;          minChunks: 2,          priority: -20,          reuseExistingChunk: true,        &#125;,      &#125;,      // 将当前模块中记录的其他模块的hash单独打包成一个文件      // 因为如果main.js 引用 a.js,main.js中会保存a.js打包时生成的cotenthash      // 如果a.js发生改变则contenthash发生改变，那么main.js的contenthash也会改变      // 代码分割的时候一定要加      runtimeChunk:()=&gt; &#123;        name:entrypoint=&gt;`runtime-$&#123;entrypoint.name&#125;`      &#125;    &#125;,  &#125;,&#125;","categories":["webpack"],"tags":["工程化","webpack"]},{"title":"FSM 有限状态机","url":"/posts/70ac5eab3c93/","content":"有限状态机有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机（英语：finite-state automation，缩写：FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。\n特点\n状态总数（state）是有限的。\n\n任一时刻，只处在一种状态之中。\n\n某种条件下，会从一种状态转变（transition）到另一种状态。\n\n每个状态都是一个机器，所有机器接受的输入是一致的\n\n状态机的本身是没有状态的，如果用函数来表示的话，应该是纯函数。\n\n每一个状态机都知道自己的下一个状态\n每个机器都有确定的下一个状态 （Moore）\n每个机器根据输入决定下一个状态 （Mealy）\n\n\n案例网页上有一个菜单元素。鼠标悬停的时候，菜单显示；鼠标移开的时候，菜单隐藏。如果使用有限状态机描述，就是这个菜单只有两种状态（显示和隐藏），鼠标会引发状态转变。\n本案例中的状态机其实就是摩尔状态机，每个状态都有确定的下一个状态，而存在的问题就是状态和行为是耦合的。\n&lt;body&gt;&lt;div id = &#x27;box1&#x27;&gt;1&lt;/div&gt;&lt;div id = &#x27;box2&#x27; style=&quot;display:none&quot;&gt;2&lt;/div&gt;&lt;script&gt;    var menu = &#123;    // 当前状态    currentState: &#x27;hide&#x27;,    // 绑定事件    initialize: function (dom) &#123;      dom.addEventListener(&#x27;mouseover&#x27;,this.transition.bind(this))      dom.addEventListener(&#x27;mouseout&#x27;,this.transition.bind(this))    &#125;,    // 状态转换    transition: function (event) &#123;      switch (this.currentState) &#123;        case &quot;hide&quot;:          this.currentState = &#x27;show&#x27;;          document.getElementById(&#x27;box2&#x27;).style.display =&#x27;block&#x27;          break;        case &quot;show&quot;:          this.currentState = &#x27;hide&#x27;;          document.getElementById(&#x27;box2&#x27;).style.display =&#x27;none&#x27;          break;        default:          console.log(&#x27;Invalid State!&#x27;);          break;      &#125;    &#125;  &#125;;  menu.initialize(document.getElementById(&#x27;box1&#x27;));  &lt;/script&gt;&lt;/body&gt;\n\n查找字符串尝试在一个字符串中找到 abcd\n需要注意的是在每次状态迁移之后，一定要把上一个的状态置为false,因为状态转移之后与上一个状态再没有任何关系\nconst machine = (str) =&gt; &#123;  let foundA = false;  let foundB = false;  let foundC = false;  for (let s of str) &#123;    if (s === &#x27;a&#x27;) &#123;      foundA = true;    &#125; else if (s === &#x27;b&#x27; &amp;&amp; foundA) &#123;      foundA = false;      foundB = true;    &#125; else if (s === &#x27;c&#x27; &amp;&amp; foundB) &#123;      foundB = false;      foundC = true;    &#125; else if (s === &#x27;d&#x27; &amp;&amp; foundC) &#123;      foundC = false;      return true;    &#125; else &#123;      foundA = false;      foundB = false;      foundC = false;    &#125;  &#125;  return false;&#125;console.log(machine(&#x27;abbccd&#x27;))\n\n查找字符串 函数式状态机显而易见的好处是，状态机本身没有状态，所以无需在维护状态\n需要注意的一点是，每一个函数返回的是start(s),因为遇到ababcd这种情况时，第二个a可以当做字符串的开头，如果直接返回start会跳过这一步的判断\nconst start = (s) =&gt; &#123;  if (s === &#x27;a&#x27;) return foundB;  return start;&#125;const foundB = (s) =&gt; &#123;  if (s === &#x27;b&#x27;) return foundC;  return start(s);&#125;const foundC = (s) =&gt; &#123;  if (s === &#x27;c&#x27;) return foundD;  return start(s);&#125;const foundD = (s) =&gt; &#123;  if (s === &#x27;d&#x27;) return end;  return start(s)&#125;const end = () =&gt; end;let state = start;for (let s of &#x27;ababcd&#x27;) &#123;  state = state(s);&#125;console.log(state === end)\n\n\n有效数字问题","categories":["算法","常见算法与数学"],"tags":["算法","有限状态机"]},{"title":"动态规划","url":"/posts/fd3784f3d1c4/","content":"什么样的问题可以使用动态规划\n计数\n\n到达一个位置有多少中走法\n有多少种方式选出 k 个数使其和使 sum\n\n\n求最大值最小值\n\n从左下角到右下角路径的最大数字和\n最长上升子序列长度\n\n\n存在性 博弈性\n\n取石子游戏，先手是否必胜\n能不能选出 k 个数使其和是 sum\n\n\n\n问题描述一起提动态规划，可能最先想到的就是硬币问题，这也是动态规划的最常见问题。\n你有三种硬币，面值分别为 2 元，5 元，7 元，每种硬币数量足够多。买一本书须要 27 元，如何使用最少的硬币组合正好可以付清 27 元\n从直觉上我们可能会这样尝试：\n\n因为要最够少的硬币，那就尽量选择大的面额\n\n拿 3 个 7 元硬币，还剩 6 元，发现如果使用 5 元硬币不能凑够 6 元，所以选择用 3 个两元硬币\n\n我想到的结果是 2 元，2 元，2 元，7 元，7 元，7 元 6 枚硬币\n\n但正确的结果是 5 元，5 元，5 元，5 元，7 元 5 枚硬币\n\n\n问题所在\n我们通过直觉的分析，并不是正确的思路，因为不能通过数学的方式证明。\n下面来学习一下动态规划，通常动态规划有四个组成部分\n确定状态① 状态是动态规划中最重要的概念\n② 常见的，动态规划解题时会创建一个数组，数组的每个元素f[i]或者f[i][j]代表什么,类似数学中的  \n③ 确定状态时关键的两个概念\n&amp;ensp;&amp;ensp;1） 最后一步\n&amp;ensp;&amp;ensp;以题目为例，随算我们不知道最少的方式是什么，但它肯定是由  这么多硬币加一起组成的，这些硬币加在一起的面值是 27\n&amp;ensp;&amp;ensp;其中一定会有一枚最后取到的硬币\n&amp;ensp;&amp;ensp;除去这枚硬币，前面的硬币面值是 \n&amp;ensp;&amp;ensp;这其中有两个非常重要的关键点：\n\n&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;a. 不关心前面 枚硬币如何拼出 的面值，可能有 1 种方法，也可能有 100 种，虽然现在不知道（最后一枚硬币面值）,(最少使用的硬币数量)，但可以肯定的是我们用了枚硬币，拼出了 的面值。\n&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;b. 为什么前面一定是枚硬币，而不能更少？ 因为我们假设的是最优策略，如果前面可以用少于枚硬币，组成 的面值，那么加上最后一枚硬币，总硬币的数量还是小于,与最初假设的最优策略 枚硬币相违背。换句话说，对于拼出的面值，需要使用  枚硬币，这仍然是一个最优策略。\n&amp;ensp;&amp;ensp;2） 子问题\n&amp;ensp;&amp;ensp;通过上面的分析问题变成，拼出的面值，最少需要多少硬币\n&amp;ensp;&amp;ensp;原问题是拼出的面值，最少需要多少硬币\n&amp;ensp;&amp;ensp;可以发现问题本身没有变化，但是规模更小，这就是子问题的意义\n&amp;ensp;&amp;ensp;为了简化定义，设定状态  最少用多少硬币拼出\n\n回顾一下如何抽象出状态的：我们先考虑最后一步，提取出除了最后一步之后的子问题，发现子问题和原问题，都是求最少硬币数量，原问题求的是拼除的最少硬币数量，子问题是拼出的最少硬币数量。所以我们用 表示最少硬币数量的结果，用  表示需要求解的面值。\n\n&amp;ensp;&amp;ensp;到目前为止，我们还是不知道最后那个的硬币是多少，但它只可能是 2，5，或者 7，所以：\n&amp;ensp;&amp;ensp;如果 ,则  最后一枚硬币为 2\n&amp;ensp;&amp;ensp;如果 ,则  最后一枚硬币为 5\n&amp;ensp;&amp;ensp;如果 ,则  最后一枚硬币为 7\n&amp;ensp;&amp;ensp;所以需要的最少硬币数，就是上面三种情况中的最小值\n\n&ensp;&ensp;\n\n\n递归求解\n通过上面的分析，找到了最小硬币数量的表示方法\n从硬币总额的角度思考：\na. 如果求解总额&gt;=7,最后一个硬币，可以是 2，5，7\nb. 如果求解总额&gt;=5,最后一个硬币，可以是 2，5\nc. 如果求解总额&gt;=2,最后一个硬币，可以是 2\nb. 边界情况总额是 0， 结果返回 0，0 元需要 0 枚硬币\nfunction fn(x) &#123;  if (x === 0) return 0;  var res = Infinity;  if (x &gt;= 7) &#123;    res = Math.min(fn(x - 2) + 1, fn(x - 5) + 1, fn(x - 7) + 1);  &#125; else if (x &gt;= 5) &#123;    res = Math.min(fn(x - 2) + 1, fn(x - 5) + 1);  &#125; else if (x &gt;= 2) &#123;    res = fn(x - 2) + 1;  &#125;  return res;&#125;\n\n从最后一枚硬币角度考虑：\nfunction fn(x) &#123;  if (x === 0) return 0;  var res = Infinity;  //最后一枚硬币是7  if (x &gt;= 7) &#123;    res = Math.min(fn(x - 7) + 1, res);  &#125;  if (x &gt;= 5) &#123;    res = Math.min(fn(x - 5) + 1, res);  &#125;  if (x &gt;= 2) &#123;    res = Math.min(fn(x - 2) + 1, res);  &#125;  return res;&#125;\n\n存在的问题：递归做了大量的重复计算，指数级的时间复杂度，所以需要通过将已经计算的结果保存下来，并改变计算顺序，这就是动态规划的状态转移方程\n\n转移方程转移方程通常在分析子问题的时候已经分析清楚，对于任意 X\n\n但是想避免使用递归还需要下面的两个分析过程\n初始条件和边界情况\n如果,,小于 0 怎么办\n\n用正无穷来表示不能拼出某个值 \n\n\n\n\n\n初始条件，用转移方程算不出来的需要定义，,所以需要定义边界情况。\n\n计算顺序计算顺序的分析是解决避免递归问题的根本原因。\n递归是从大到小计算的在计算  时，，， 都不知道，要只有执行到,才能得到第一个计算结果，且直接过程中没有保存执行结果，导致每一个结果都需要重复计算。可以通过缓存计算结果优化递归。\n所以我们可以从小到大计算从而避免递归，动态规划计算顺序的核心思路就是下一次计算时所用的值，在上一步已经计算过且被缓存\n初始条件\n依次计算，，\n当计算到 时，，， 都已经计算过，且能拿到计算结果。\n\n\n\nF(i)\n最小硬币数量\n\n\n\nF(0)\n0 &#x2F;&#x2F;金额为 0 不能由硬币组成\n\n\nF(1)\n1 &#x2F;&#x2F;\n\n\nF(2)\n1 &#x2F;&#x2F;\n\n\nF(3)\n2 &#x2F;&#x2F;\n\n\nF(4)\n2 &#x2F;&#x2F;\n\n\n…\n…\n\n\nF(27)\n3 &#x2F;&#x2F;\n\n\n动态规划求解\nfunction fn(x) &#123;  if (x === 0) return 0;  var stack = [0],    i = 1;  for (; i &lt;= x; ++i) &#123;    stack[i] = Math.min(      (stack[i - 2] === undefined ? Infinity : stack[i - 2]) + 1,      (stack[i - 5] === undefined ? Infinity : stack[i - 5]) + 1,      (stack[i - 7] === undefined ? Infinity : stack[i - 7]) + 1    );  &#125;  if (stack[i - 1] === Infinity) &#123;    return -1;  &#125;  return stack[i - 1];&#125;\n\nfunction fn(x) &#123;  if (x === 0) return 0;  var stack = [0],    i = 1;  for (; i &lt;= x; ++i) &#123;    // 如果硬币面额数量不确定，其实就是循环两两比较    stack[i] = Math.min(      stack[i - 2] === undefined ? Infinity : stack[i - 2] + 1,      stack[i] === undefined ? Infinity : stack[i]    );    stack[i] = Math.min(      stack[i - 5] === undefined ? Infinity : stack[i - 5] + 1,      stack[i] === undefined ? Infinity : stack[i]    );    stack[i] = Math.min(      stack[i - 7] === undefined ? Infinity : stack[i - 7] + 1,      stack[i] === undefined ? Infinity : stack[i]    );  &#125;  if (stack[i - 1] === Infinity) &#123;    return -1;  &#125;  return stack[i - 1];&#125;\n\n相关题目详解最值型动态规划\n零钱兑换\n乘积最大子数组\n求和型动态规划\n不同路径\nn 个骰子的点数\n存在型动态规划\n跳跃游戏\n","categories":["算法","常见算法与数学"],"tags":["算法","动态规划"]},{"title":"kmp算法","url":"/posts/c675d649ef42/","content":"字符串匹配是计算机的基本任务之一。Knuth-Morris-Pratt算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。\n匹配逻辑\nkmp 算法的关键点在于，当匹配串（pattern）下一个字符不再匹配的时候，不会盲目的移动到原串的下一位继续从头判断，而是利用已知信息跳到一个合理的位置继续匹配。\n已知信息，前缀&#x2F;后缀首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。\n以”ABCDABD”为例：\n“A”的前缀和后缀都为空集，共有元素的长度为0；\n“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；\n“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；\n“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；\n“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；\n“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；\n“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。\n另一个重要的信息是，对于匹配串的任意一个位置而言，由该位置发起的下一个匹配点位置其实与原串无关。 \nABCDABD 匹配串中的两个AB分别为匹配串的前缀和后缀，当最后一个D没有匹配的时候，他会跳转到第三个字符C的位置尝试匹配，因为他们有相同的前缀，因此合理跳转匹配额位置的本质就是找到上一个前缀和后缀的位置\n因为匹配点与源串无关，所以可以预先准备出一个部分匹配表\n部分匹配表首先需要两个指针来记录匹配位置\n用一个next数组来保存部分匹配值\n由于第一个匹配字符一定从索引0开始，所以吧比配置初始化为0，那么i为前一个字符，j为后一字符\nlet i = 0, j = 1;const next = [0]for(;j &lt; pattern.length;j++)&#123;&#125;\n\n\n一但，下一个字符pattern[j]与上一个字符pattern[i]不在匹配，需要在之前遍历过的字符中查找与当前pattern[j]相同的字符\n可以看做是，匹配串中一对相同的前缀和后缀,如果没有则继续向前查找，直到i指针回到初始位置\nwhile(i&gt;0 &amp;&amp;　pattern[i]！==pattern[j]) &#123;  i = next[i-1]&#125;\n\n有疑问的点可能在于，为什么不是依次判断之前每一个值，而是直接调到了匹配值的位置\ni为0的意义是从0索引到i索引的这个字符串，找不到一对相同的前缀和后缀，因此下个位置必然没有可复用的子串，只需要跳到开头位置重新匹配。\n如果pattern[j]与pattern[i]匹配，那么两个指针同时向后面移动，并记录新的位置\n所以完整的代码为\nlet i=0;j=1;const next = [0];for(;j &lt; pattern.length;j++)&#123;  while(i&gt;0 &amp;&amp;　pattern[i]！==pattern[j]) &#123;    i = next[i-1]  &#125;  if(pattern[i]===pattern[j]) i++  next[j]=i;&#125;\n匹配实现在拿到了部分匹配表之后，可以通过一个循环依次向后匹配\nm为原字符串指针，n为匹配串指针\n如果两个字符匹配，两个指针都向后移动一位\nlet m=0;let n=0;for(;m&lt;sourceString.length;m++)&#123;  if (sourceString[m] === pattern[n]) n++&#125;\n\n如果不同则需要利用匹配表移动到最近的可复用的匹配位置，如图一中的事例\n当 abeabf中的f与原串不在匹配，通过匹配表next[n-1]查找之前的子串中是否有可复用的位置，如果复用位置不匹配，则继续回溯之前的位置\nwhile(n&gt;0 &amp;&amp; sourceString[m] === pattern[n]) n = next[n-1]\n\n如果n 指针与匹配串长度相同，表示已经匹配成功则返回\n完整的代码为\nlet m = 0;let n = 0;for(;m&lt;sourceString.length;m++) &#123;  while (n &gt; 0 &amp;&amp; sourceString[m] !== pattern[n]) &#123;    n = next[n - 1];  &#125;  if (sourceString[m] === pattern[n]) n++  if (n === pattern.length) return m - n + 1;&#125;return -1;\n\nkmpleetcode 28.实现 strStr()\nconst kmp = (haystack, needle) =&gt; &#123;  if (needle.length == 0) return 0;  const next = [0];  for (let i = 0, j = 1; j &lt; needle.length; j++) &#123;    while (i &amp;&amp; needle[j] !== needle[i]) &#123;      i = next[i - 1];    &#125;    if (needle[j] === needle[i]) i++;    next[j] = i;  &#125;  let m = 0;  let n = 0;  for(;m&lt;sourceString.length;m++) &#123;    while (n &gt; 0 &amp;&amp; haystack[m] !== needle[n]) &#123;      n = next[n - 1];    &#125;    if (haystack[m] === needle[n]) n++    if (n === needle.length) return m - n + 1;  &#125;  return -1;&#125;","categories":["算法","常见算法与数学"],"tags":["算法","kmp算法"]},{"title":"字典树","url":"/posts/52c4a7003ee5/","content":"树的种类二叉树，索引树，红黑树，btree,B+tree,字典树，哈夫曼\n结构特点\n一定会有一个根节点root\n\n每一个元素都被称为node\n\n除了root节点，其余的节点都会被分成n个互不相交的集合\n\n最末尾的节点，叫做叶子节点，其他节点叫子节点\n\n深度：从根节点到叶子节点的最多的个数\n\n度： 和深度的概念不同，分为出度（有多少个节点指向其他节点），和入度（有多少节点指向自己）\n\n\n字典树Trie Tree 又称为单词查找树，哈希树的变种，常用于统计，查找搜索引擎中用于分词，词频统计（DF&#x2F;IDF）,自动补全等机制。\n查找效率高：其核心思想是利用公共前缀来减少查询时间。\n对于英文可以按常规字典树进行处理，因为英文只有二十六个字母，最多有26层\n但是对于中文不能直接使用，因为不同的文字过多，同一层级的分支过多\n字典树的实现class Trie &#123;    constructor() &#123;        // 根节点        this.root = Object.create(null);        // 叶子节点标识        this.end = Symbol(&#x27;end&#x27;);    &#125;    //创建一颗树的方法    insert(str) &#123;        let root = this.root;        for (let s of str) &#123;            if (root[s] === undefined) &#123;                root[s] = Object.create(null);            &#125;            root = root[s];        &#125;        root[this.end] = true;    &#125;    //查找是否存在某个单词    find(str) &#123;        let root = this.root;        for (let s of str) &#123;            if (root[s] === undefined) &#123;                return false;            &#125;            root = root[s];        &#125;        // 可以查到字符串中的每个字符，且最后一个字母是一个结束符        return !!root[this.end]    &#125;&#125;\n\n对于如何可以查找出现次数最多的单词，只需要为节点增加更多的信息\n把上面基础示例中的结束标识符，修改一下，把值改为单词的出现次数，通过递归找到出现次数最多的单词\nclass Trie &#123;    constructor() &#123;        // 根节点        this.root = Object.create(null);        // 叶子节点标识        this.$ = Symbol(&#x27;$&#x27;);    &#125;    //创建一颗树的方法    insert(str) &#123;        let root = this.root;        for (let s of str) &#123;            if (root[s] === undefined) &#123;                root[s] = Object.create(null);            &#125;            root = root[s];        &#125;        if (!root[this.$]) root[this.$] = 0;        root[this.$]++    &#125;    findMost() &#123;        let root = this.root;        //用于记录出现次数最多的单词        let mostWord = [];        let max = 0;        const find = (word, root) =&gt; &#123;            if (root[this.$] &amp;&amp; root[this.$] == max) &#123;                mostWord.push(word);            &#125;            if (root[this.$] &amp;&amp; root[this.$] &gt; max) &#123;                max = root[this.$];                mostWord = [word];            &#125;            for (let s in root) &#123;                find(word + s, root[s]);            &#125;        &#125;        find(&#x27;&#x27;, root);        return &#123;            max,            mostWord        &#125;    &#125;&#125;\n\n通过字典树做自动提示\n如果其中一个节点没有匹配到，返回null\n如果最后一个节点之后还有子树，递归子树找出所有匹配字符串\nclass Trie &#123;    constructor() &#123;        // 根节点        this.root = Object.create(null);        // 叶子节点标识        this.$ = Symbol(&#x27;$&#x27;);    &#125;    //创建一颗树的方法    insert(str) &#123;        let root = this.root;        for (let s of str) &#123;            if (root[s] === undefined) &#123;                root[s] = Object.create(null);            &#125;            root = root[s];        &#125;        // 不需要关心是否有多个        root[this.$] = true;    &#125;    auto(str) &#123;        const autonode = [];        let root = this.root;        if (!str) return autonode;        for (let s of str) &#123;            console.log(s);            if (root[s] === undefined) &#123;                return autonode;            &#125;            root = root[s];        &#125;        const each = (word, root) =&gt; &#123;            if (root[this.$]) autonode.push(word)            for (let s in root) &#123;                each(word + s, root[s]);            &#125;        &#125;        each(str + &#x27;&#x27;, root)        return autonode;    &#125;&#125;\n","categories":["算法","常见算法与数学"],"tags":["算法","字典树"]},{"title":"二叉树","url":"/posts/6477f25bd014/","content":"二叉树可以算是最基础的数据类型。\n很多复杂的数据结构都是基于二叉树的，比如 红黑树（二叉搜索树）、多叉树、二叉堆、图、字典树、并查集、s 线段树 等等。\n二叉树可以代表一种递归的思维方式,比如 回溯算法、BFS 算法、动态规划 本质上也是把具体问题抽象成树结构。\n树的概念    1   / \\  2   3 /   / \\4   5   6   /     \\  7       8\n\n\n每个节点下方直接相连的节点称为子节点，上方直接相连的节点称为父节点。比方说节点 3 的父节点是 1，左子节点是 5，右子节点是 6；节点 5 的父节点是 3，左子节点是 7，没有右子节点。\n\n我们称最上方那个没有父节点的节点 1 为根节点，称最下层没有子节点的节点 4、7、8 为叶子节点。\n\n从根节点到最下方叶子节点经过的节点个数为二叉树的最大深度&#x2F;高度，上面这棵树的最大深度是 4，即从根节点 1 到叶子节点 7 或 8 的路径上的节点个数。\n\n满二叉树: 每一层节点都是满的, 假设深度为 h，那么总节点数就是 2^h - 1。\n       1     /   \\    2     3   / \\   / \\  4   9 5   6 / \\ / \\/ \\ / \\10 11 7 12 13 8 14\n\n完全二叉树： 二叉树的每一层的节点都紧凑靠左排列，且除了最后一层，其他每层都必须是满的, 满二叉树就是特殊的完全二叉树。也可以说 完全二叉树的左右子树也是完全二叉树。 或 完全二叉树的左右子树中，至少有一棵是满二叉树。\n       1     /   \\    2     3   / \\   / \\  4   9 5   6 / \\ / \\10 1 7 2\n\n二叉搜索树：对于树中的每个节点，其左子树的每个节点的值都要小于这个节点的值，右子树的每个节点的值都要大于这个节点的值。为左小右大的特性，可以让我们在 BST 中快速找到某个节点，或者找到某个范围内的所有节点，这是 BST 的优势所在。\n    7   / \\  4   9 / \\   \\1   8   10\n\n遍历方式层序遍历一层一层地遍历二叉树,显然先访问的节点需要先处理，而左右节点暂时用不到需要先存起来，自然想到用队列来处理。\nvar levelOrderTraverse = function (root) &#123;  if (root === null) &#123;    return;  &#125;  var q = [];  q.push(root);  while (q.length !== 0) &#123;    var cur = q.shift();    // 访问 cur 节点    console.log(cur.val);    // 把 cur 的左右子节点加入队列    if (cur.left !== null) &#123;      q.push(cur.left);    &#125;    if (cur.right !== null) &#123;      q.push(cur.right);    &#125;  &#125;&#125;;\n\n这种方式存在的问题就是不知道是第几层，因此可以使用额外的变量来记录。\nvar levelOrderTraverse = function (root) &#123;  if (root === null) &#123;    return;  &#125;  let q = [];  q.push(root);  // 记录当前遍历到的层数（根节点视为第 1 层）  let depth = 1;  while (q.length !== 0) &#123;    let sz = q.length;    // 使用额外的变量，记录每层的节点个数    // 也可以直接复制q队列，这样可以避免 shift 操作的O(n) 时间复杂度    for (let i = 0; i &lt; sz; i++) &#123;      let cur = q.shift();      // 访问 cur 节点，同时知道它所在的层数      console.log(&quot;depth = &quot; + depth + &quot;, val = &quot; + cur.val);      // 把 cur 的左右子节点加入队列      if (cur.left !== null) &#123;        q.push(cur.left);      &#125;      if (cur.right !== null) &#123;        q.push(cur.right);      &#125;    &#125;    depth++;  &#125;&#125;;\n\n同理还可以添加更多的下信息，现在只知道整个树的层数，还可以为每个节点维护他的层数, 一般称作路径的权重，即从根节点到当前的节点。\nfunction State(node, depth) &#123;  this.node = node;  this.depth = depth;&#125;var levelOrderTraverse = function (root) &#123;  if (root === null) &#123;    return;  &#125;  // @visualize bfs  var q = [];  // 根节点的路径权重和是 1  q.push(new State(root, 1));  while (q.length !== 0) &#123;    var cur = q.shift();    // 访问 cur 节点，同时知道它的路径权重和    console.log(&quot;depth = &quot; + cur.depth + &quot;, val = &quot; + cur.node.val);    // 把 cur 的左右子节点加入队列    if (cur.node.left !== null) &#123;      q.push(new State(cur.node.left, cur.depth + 1));    &#125;    if (cur.node.right !== null) &#123;      q.push(new State(cur.node.right, cur.depth + 1));    &#125;  &#125;&#125;;\n\n递归遍历先深入到一个分支中，在逐层的返回。\n// 二叉树的遍历框架var traverse = function (root) &#123;  if (root === null) &#123;    return;  &#125;  // 前序位置  traverse(root.left);  // 中序位置  traverse(root.right);  // 后序位置&#125;;\n\n但是在不同的位置写代码，获取到的信息是不同的，所谓的前中后，是相对于根节点的先后。\n\n前序遍历： 根节点 &#x3D;&gt; 左节点 &#x3D;&gt; 右节点， 代码位置写在接入左树之前，因此先访问根节点，在访问左树的根节点。对于一个子树，只有左子树遍历完成后，才回去处理右子树，可以看作是进入一个二叉树节点的时候执行\n\n中序遍历： 左节点 &#x3D;&gt; 根节点 &#x3D;&gt; 右节点，代码会一直递归调用到左子树的左叶子节点，当左叶子节点访问完毕后，会弹出当前的调用栈，而上一个调用栈正是左节点的父节点，也就是根节点,可以看作是二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。\n\n后序遍历： 左节点 &#x3D;&gt; 右节点 &#x3D;&gt; 根节点，代码会一直递归调用到左子树的右叶子节点，当左右子节点访问完毕后，会弹出当前的调用栈，而上一个调用栈正是右节点的父节点，也就是根节点,可以看作是离开一个二叉树节点的时候执行。\n\n\n而递归遍历常用于寻找最短路径， [二叉树最小&#x2F;大深度], [二叉树直径],递归和遍历各有优势，遍历的思想是配合外部变量，递归则是将问题分解为子问题。\n有一些问题虽然是在二叉树的遍历模型下，但是需要根据条件进入不同的分支处理，并在其中穿插其他的逻辑代码。 [二叉树展开为链表] [填充每个节点的下一个右侧节点指针]\n二叉树的序列化层序遍历这应该是最容易想到的一种方法，就像 LeetCode 题目给出的可视化数据一样，将每一层的数据依次放入到数组中，就可以对二叉树序列化，但是需要注意的是要保留空节点，这样才能描述每一层节点之间的关系\nvar serialize = function (root) &#123;  if (root === null) return [];  const queue = [root];  const res = [];  while (queue.length) &#123;    const first = queue.shift();    res.push(first === null ? first : first.val);    if (first !== null) queue.push(first.left, first.right);  &#125;  return res;&#125;;var deserialize = function (data) &#123;  if (data.length === 0) return null;  let index = 0;  let root = new TreeNode(data[index++]);  let queue = [root];  while (data[index] !== undefined) &#123;    const node = queue.shift();    const left = data[index++];    const right = data[index++];    node.left = left === null ? left : new TreeNode(left);    node.right = right === null ? right : new TreeNode(right);    if (left !== null) queue.push(node.left);    if (right !== null) queue.push(node.right);  &#125;  return root;&#125;;\n\n二叉树的唯一性","categories":["算法","常见算法与数学"],"tags":["算法","二叉树"]},{"title":"133. 克隆图","url":"/posts/91c819c2446f/","content":"LeetCode注意： 执行测试用例的时候，不会每次都在一个新的全局作用域中执行，需要注意变量的声明位置，防止污染代码执行\n第一步 实现图的深度遍历 DFSconst cloneGraph = (node)=&gt;&#123;  if(!node) return node;  const dfs = (node) =&gt; &#123;    console.log(node.val);    node.isVisit = true;    node.neighbors.forEach(n =&gt; &#123;        if(!n.isVisit) dfs(n);    &#125;);  &#125;  dfs(node);&#125;\n\n第二步 克隆节点并保存const cloneGraph = (node)=&gt;&#123;  if(!node) return node;  const map = new Map();  const dfs = (node) =&gt; &#123;    map.set(node,new Node(node.val))    node.neighbors.forEach(n =&gt; &#123;      if(!map.get(n)) dfs(n);    &#125;);  &#125;  dfs(node);&#125;\n\n第三步 添加节点间关系const cloneGraph = (node)=&gt;&#123;  if(!node) return node;  const map = new Map();  const dfs = (node) =&gt; &#123;    map.set(node,new Node(node.val))    node.neighbors.forEach(n =&gt; &#123;      if(!map.get(n)) dfs(n);      map.get(node).neighbors.push(map.get(n));    &#125;);  &#125;  dfs(node);  return map.get(node)&#125;\n\n变形写法在传参的过程中添加更多的信息\nvar cloneGraph = function (node) &#123;  const map = new Map();  const cloneNode = new Node(node.val);  map.set(node.val, cloneNode)  const dfs = (cloneNode, node, neighbors) =&gt; &#123;    for (let n of node.neighbors) &#123;      if (map.has(n.val)) &#123;        neighbors.push(map.get(n.val))      &#125; else &#123;        const cloneNode = new Node(n.val)        neighbors.push(cloneNode)        map.set(n.val, cloneNode)        dfs(cloneNode, n, cloneNode.neighbors)      &#125;    &#125;  &#125;  dfs(cloneNode, node, cloneNode.neighbors)  return cloneNode;&#125;;\n\n广度优先遍历BFSconst cloneGraph = (node) =&gt; &#123;  if (!node) return node;  const map = new Map();  const stack = [node];  let clone = null;  while (stack.length) &#123;    const last = stack.pop();    if (!map.get(last)) &#123;      clone = new Node(last.val);      map.set(last, clone);    &#125; else &#123;      clone = map.get(last)    &#125;    last.neighbors.forEach(n =&gt; &#123;      if (!map.get(n)) &#123;        const temp = new Node(n.val);        clone.neighbors.push(temp);        map.set(n, temp);        stack.unshift(n);      &#125; else &#123;        clone.neighbors.push(map.get(n));      &#125;    &#125;)  &#125;  return map.get(node);&#125;\n\n广度优先遍历优化const cloneGraph = (node) =&gt; &#123;  if (!node) return node;  const map = new Map();  const stack = [node];  // 默认克隆第一个节点  map.set(node, new Node(node.val));    while (stack.length) &#123;    const next = stack.pop();    next.neighbors.forEach(n =&gt; &#123;      if (!map.get(n)) &#123;        map.set(n, new Node(n.val));        stack.unshift(n);      &#125;       //上一步已经在map中保存了节点，可以直接使用      map.get(next).neighbors.push(map.get(n));    &#125;)  &#125;  return map.get(node);&#125;","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"14.最长公共前缀","url":"/posts/df69775e95cb/","content":"LeetCode需要注意的坑\n公共的意思是数组中所有项公共的部分，[&quot;aa&quot;,&#39;aabb&#39;,&#39;aabbcc&#39;],最长公共前缀是aa,而不是aabb,因为并不是每一项都包含aabb\n\n最长公共前缀而不是最长公共子串，[&quot;xbbcc&quot;,&quot;xaabbcc&quot;,&quot;xbbccdd&quot;],最长公共前缀是x,最长公共子串 bbcc\n\n在输入的数组长度为0时返回空字符串\n\n\n1.纵向扫描纵向扫描是最容易想到的方法步骤为：\n\n依次遍历每一个数组，检查同一列上的字符是否相同\n如果相同记录并累加字符串结果，遍历下一列\n如果不同跳出循环，返回结果\n\n\nvar longestCommonPrefix = function (strs) &#123;    if (!strs.length) return &#x27;&#x27;;    var result = &#x27;&#x27;, //记录公共前缀结果        i = 0, //表示字符串索引，从第一位开始检查        j = 1, // 输入数组的索引        str = strs[0]; //输入数组中的第一个    for (i = 0; i &lt; str.length; i++) &#123;        for (j = 1; j &lt; strs.length; j++) &#123;            if (strs[j][i] !== str[i]) return result;        &#125;        result += str[i]    &#125;    return result;&#125;\n\n复杂度分析\n\n时间复杂度：，其中  是字符串数组中的字符串的平均长度， 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。\n\n空间复杂度：。使用的额外空间复杂度为常数。\n\n\n2.横向扫描\n依次遍历字符串数组中的每个字符串，把前两个公共前缀的结果和输入数组中的下一个进行比较，数组遍历完成后即得到结果\n如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。\n\n\nvar longestCommonPrefix = function (strs) &#123;    if (!strs.length) return &#x27;&#x27;;    var i = 0,        len = strs.length - 1,        result = strs[0];    for (; i &lt; len; i++) &#123;        var temp = prefixCompare(result, strs[i + 1]);        if(!temp) return temp;        result = temp;    &#125;    return result;&#125;// 找出两个字符串的最大公共前缀function prefixCompare(first, second) &#123;    var i = 0, //索引        len = first.length;    for (; i &lt; len; i++) &#123;        if (first[i] !== second[i]) return first.substring(0, i);    &#125;    return first;&#125;\n\n复杂度分析\n\n时间复杂度：O(mn)，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。\n\n空间复杂度：O(1)。使用的额外空间复杂度为常数。\n\n\n3.分治注意到 的计算满足结合律，有以下结论：\n\n\n其中是字符串的最长公共前缀，\n基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题 可以分解成两个子问题,与,其中。对两个子问题分别求解，然后对两个子问题的解计算最长公共前缀，即为原问题的解。\n\nvar longestCommonPrefix = function (strs) &#123;    if (!strs.length) return &#x27;&#x27;;    if (strs.length &lt; 2) return strs[0];    var mid = Math.floor(strs.length / 2),        left = strs.slice(0, mid),        right = strs.slice(mid);    return prefixCompare(longestCommonPrefix(left), longestCommonPrefix(right))&#125;// 找出两个字符串的最大公共前缀function prefixCompare(first, second) &#123;    var i = 0, //索引        len = first.length;    for (; i &lt; len; i++) &#123;        if (first[i] !== second[i]) return first.substring(0, i);    &#125;    return first;&#125;\n\n复杂度分析\n\n时间复杂度：O(mn)，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。\n\n空间复杂度：，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。空间复杂度主要取决于递归调用的层数，层数最大为 ，每层需要 m 的空间存储返回结果。\n\n\n4.二分法显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用 minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值 mid，判断每个字符串的长度为 mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于 mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。\n\nvar longestCommonPrefix = function (strs) &#123;    if (!strs.length) return &#x27;&#x27;;    var minlength = Math.min.apply(null, strs.map(item =&gt; item.length)),        low = 0,        high = minlength;    while (low &lt; high) &#123;        var mid = ~~((high - low + 1) / 2 + low);        if (prefixCompare(strs, mid)) &#123;            low = mid;        &#125; else &#123;            high = mid - 1;        &#125;    &#125;    return strs[0].substring(0, low);&#125;function prefixCompare(strs, mid) &#123;    var str0 = strs[0].substring(0, mid);    var count = strs.length;    for (var i = 1; i &lt; count; i++) &#123;        var str = strs[i];        for (var j = 0; j &lt; mid; j++) &#123;            if (str0[j] != str[j]) &#123;                return false;            &#125;        &#125;    &#125;    return true;&#125;\n\n复杂度分析\n\n时间复杂度：，其中 mm 是字符串数组中的字符串的最小长度，nn 是字符串的数量。二分查找的迭代执行次数是 ，每次迭代最多需要比较  个字符，因此总时间复杂度是 .\n\n空间复杂度：。使用的额外空间复杂度为常数。\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"141.环形链表","url":"/posts/53bb29c4adf3/","content":"LeetCode暴力解法 哈希表把每一个遇到的节点都保存下来\n\n如果当前节点为null表示没有环，返回false\n\n如果在map中当前节点存在则表示有环，否则存下当前节点\n\n\nvar hasCycle = function (head) &#123;    var map = new Map();    while(head!==null)&#123;        if(map.get(head)===head)&#123;            return true;        &#125;        map.set(head,head);        head = head.next;    &#125;    return false;&#125;;\n\n复杂度分析\n\n时间复杂度：，其中  是链表中的节点数。最坏情况下我们需要遍历每个节点一次。\n\n空间复杂度：，其中  是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。\n\n\n快慢指针「Floyd 判圈算法」(又称龟兔赛跑算法)。\nvar hasCycle = function (head) &#123;    var fast = head;    var slow = head;    while (fast !== null &amp;&amp; fast.next !== null) &#123;        fast = fast.next.next;        slow = slow.next;        if (fast === slow) return true;    &#125;    return false;&#125;;\n\nvar hasCycle = function (head) &#123;    if (head===null || head.next===null) return false;    var fast = head.next;    var slow = head;    while (fast!==slow) &#123;        if (fast===null || fast.next===null) return false;        fast = fast.next.next;        slow = slow.next;    &#125;    return true;&#125;;\n\n复杂度分析\n\n时间复杂度：,当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动  轮。\n\n空间复杂度：，我们只使用了两个指针的额外空间。\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"142.形链表2","url":"/posts/aa73c7d52381/","content":"LeetCode暴力解法 哈希表保存每一个节点判断\nvar detectCycle = function(head) &#123;   var map = new Map();   var cur = head;    while(cur!==null)&#123;        if(map.get(cur)===cur)&#123;            return cur;        &#125;        map.set(cur,cur);        cur = cur.next;    &#125;    return null;&#125;;\n\n复杂度分析\n\n时间复杂度： \n\n空间复杂度： \n\n\n双指针快慢指针同时移动，第一次相遇后，定义新指针为头节点，新指针和慢指针同时移动，再次相遇时的节点为入环节点\n通过数学演变来确认双指针的正确性,如下图\n\n\n设慢指针的移动速度为，快指针的移动速度为,用 来表示走过的步数\n\n那么慢指针走到相遇点的时候走过,快指针走过了\n\n可以得到 \n\n所以从相遇点到入环点的步数和从头节点到入环的步数是相同的\n\n\nvar detectCycle = function(head) &#123;    var fast = head;    var slow = head;    var res = head;    while(fast!==null &amp;&amp; fast.next!==null)&#123;        fast = fast.next.next;        slow = slow.next;        if(slow===fast)&#123;            while(res!==fast)&#123;                res = res.next;                fast = fast.next;            &#125;            return res;        &#125;    &#125;    return null;&#125;;\n\n复杂度分析\n\n时间复杂度： \n\n空间复杂度： \n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"152.乘积最大子数组","url":"/posts/13f7c7661100/","content":"LeetCode动态规划确定状态最后一步\n只考虑最后一步，为   ，很好理解，就是最后一个元素，稍稍复杂一点\n因为本题不是求和，较小的值在下一次计算后（加上一个数或减去一个数）仍然是较小的值，但是乘法收到正负符号的影响，一个负数乘以另一个负数，可以是一个正数，所以这个 应该考虑正负的情况\n子问题\n由上面的分析，原问题为数组 子数组城际的最大值，除去最后一步之后子问题为  子数组的乘积最大值\n所以用  来表示子数组乘积最大值\n转移方程根据确定状态的分析 ， 为上一步的最大值，考虑到正负符号的影响，应该同时保存最大值和最小值，因为最小值乘以  可能变为最大值\n\n\n初始条件和边界情况初始化 \n 用于记录最大值\n\n计算顺序，，\n\n var maxProduct = function (nums) &#123;    var n = nums.length,        // 初始化第一个        // 考虑到f[1]依赖f[0]的结果至少要初始化一组数据        f = [            [nums[0], nums[0]]        ],        i = 1,        res = nums[0];    for (; i &lt; n; i++) &#123;        if (f[i - 1][0] == 0) &#123;            f[i] = [nums[i], nums[i]]        &#125; else &#123;            var min = Math.min(f[i - 1][0] * nums[i], f[i - 1][1] * nums[i], nums[i]);            var max = Math.max(f[i - 1][0] * nums[i], f[i - 1][1] * nums[i], nums[i]);            f[i] = [min, max];        &#125;        if (f[i][1] &gt; res) res = f[i][1];    &#125;    return res&#125;;\n\n优化\n删除无用的代码\n\nif (f[i - 1][0] == 0) &#123;    f[i] = [nums[i], nums[i]]&#125;\n\n最初考虑到num[i+1]===0的情况，会将f[i+1]最小值，最大值都变为0，会使后面的循环计算都为0，但无需有这种担心，因为Math.min(f[i - 1][0] * nums[i], f[i - 1][1] * nums[i], nums[i]); 最大值最小值的计算都有nums[i]的比较，并不会使后面的运算一直为0\n这里还需要考虑为什么需要用nums[i]，对于数组[-2,-3,0,2-2]\n\n\n\n循环\n值\n\n\n\n初始化\nf[0] &#x3D; [-2,-2]，最大值最小值都为第一个数\n\n\n1\nf[1] &#x3D; [6,-3]，有最小值并不是乘积得出的情况，而是元素本身就是最小值\n\n\n2\nf[2] &#x3D; [0,0]，遇到零的情况\n\n\n3\nf[3] &#x3D; [2,0]，最大值为元素本身，并不是乘积\n\n\n4\nf[4] &#x3D; [0,-4]\n\n\nvar maxProduct = function (nums) &#123;    var n = nums.length,        f = [            [nums[0], nums[0]]        ],        i = 1,        res = nums[0];    for (; i &lt; n; i++) &#123;            var min = Math.min(f[i - 1][0] * nums[i], f[i - 1][1] * nums[i], nums[i]);            var max = Math.max(f[i - 1][0] * nums[i], f[i - 1][1] * nums[i], nums[i]);            f[i] = [min, max];        if (f[i][1] &gt; res) res = f[i][1];    &#125;    return res&#125;;\n\n\n优化数储存，可以发现我们每次存下来的最大值最小值，只会用在下一次的计算中，所以并不需要额外的空间把每一个结果保存下来，只需要三个变量\n\n\n\n\n变量\n作用\n\n\n\nmax\n临时储存上一次的最大值\n\n\nmin\n临时储存上一次的最小值\n\n\nres\n保存最终结果的最大值\n\n\nvar maxProduct = function (nums) &#123;    var n = nums.length,        max = nums[0],        min = nums[0],        i = 1,        res = nums[0];    for (; i &lt; n; i++) &#123;        var _min = Math.min(min * nums[i], max * nums[i], nums[i]);        var _max = Math.max(min * nums[i], max * nums[i], nums[i]);        // 防止相互影响        min = _min;        max = _max;        if (max &gt; res) res = max;    &#125;    return res&#125;;\n\n通过判断是否负数，交换两个元素\n初始化时min=1,max=1,巧妙的从下表为0的位置遍历\n\n\nvar maxProduct = function (nums) &#123;    var n = nums.length,        max = 1,        min = 1,        res=-Infinity;    for (var i=0; i &lt; n; i++) &#123;        if(nums[i]&lt; 0)&#123;            var temp = max;            max = min;            min = temp;        &#125;        var min = Math.min(min* nums[i], nums[i]);        var max = Math.max(max*nums[i], nums[i]);        if (max &gt; res) res = max;    &#125;    return res&#125;;\n\n复杂度分析\n\n时间复杂度：程序一次循环遍历了 ，故渐进时间复杂度为 。\n\n空间复杂度：优化后只使用常数个临时变量作为辅助空间，与  无关，故渐进空间复杂度为  \n\n\n","categories":["算法","关联题目"],"tags":["算法","动态规划","关联题目"]},{"title":"2. 两数相加","url":"/posts/eaf2240be526/","content":"LeetCode给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807\n\n分析\n\n观察题目可能会思考，如何实现进位，和从低位开始依次相加？\n进位可以通过一个变量来控制\n按位相加其实就是从链表的根节点依次相加，因为l1,l2两个链表表示的数字是从地位到高位。\n\n\n基于以上分析何以做一个简单的实现\n简单实现 var addTwoNumbers = function (l1, l2) &#123;    //新链表    var head = &#123;        next: null    &#125;    //头指针    var cur = head;    //当前为的和    var sum = 0;    //进位    var curry = 0;    while (l1 !== null || l2 !== null) &#123;        if (l1 &amp;&amp; l2) &#123;            sum = (l1.sum + l2.sum + curry) % 10;            curry = (l1.sum + l2.sum + curry) / 10 | 0;            l1 = l1.next;            l2 = l2.next;        &#125;        if (l1 &amp;&amp; !l2) &#123;            sum = l1.sum            l1 = l1.next;        &#125;        if (!l1 &amp;&amp; l2) &#123;            sum = l2.sum            l2 = l2.next;        &#125;        cur.next = &#123;            sum: sum,            next: null        &#125;        cur = cur.next;    &#125;    return head.next&#125;;\n\n处理边界虽然上面的代码可以正确输出 7 -&gt; 0 -&gt; 8 的新链表，但是存在很多问题\n\n有一个链表为空时没有判断 如果l1===null 应该直接返回 l2 无需关新 l2 是否为空\n\n边界判断如果是 [5],[5] 这样的两个链表求和时，没有在while中判断carry是否为有值，不应该直接跳出循环。\n\n边界判断如果是 [1],[999] 这样的两个链表求和时,即使[1].next===null, 也需要每次循环判断是否需要进位\n\n\nvar addTwoNumbers = function (l1, l2) &#123;    // 判断边界条件    if (l1 === null) return l2;    if (l2 === null) return l1;    var head = &#123;        next: null    &#125;    var cur = head;    var sum = 0;    var carry = 0;    //有进位是需要继续处理    while (l1 !== null || l2 !== null || carry) &#123;        if (l1 &amp;&amp; l2) &#123;            sum = (l1.sum + l2.sum + carry) % 10;            carry = (l1.sum + l2.sum + carry) / 10 | 0;            l1 = l1.next;            l2 = l2.next;        &#125; else &#123;            if (!l1 &amp;&amp; !l2) &#123;                sum = carry;                carry = 0;            &#125;            // 处理[999]+[1] 的情况，即使另一个链表为空，也需要注意是否回合当链表的值，产生进位的情况            if (l1 &amp;&amp; !l2) &#123;                sum = (l1.sum + carry) % 10;                //位运算取强制转换位整数 等同于Math.floor()                carry = (l1.sum + carry) / 10 | 0;                l1 = l1.next;            &#125;            if (!l1 &amp;&amp; l2) &#123;                sum = (l2.sum + carry) % 10;                carry = (l2.sum + carry) / 10 | 0;                l2 = l2.next;            &#125;        &#125;        cur.next = &#123;            sum: sum,            next: null        &#125;        cur = cur.next;    &#125;    return head.next&#125;;\n\n优化算法\n清除重复计算,有大量重复的求和与求进位的运算\nsum = (l2.sum + carry) % 10;carry = (l2.sum + carry) / 10 | 0;\n相似的条件语句，我们分别判断 l1 &amp;&amp; !l2 和 !l1 &amp;&amp; l2 等情况，其实只需要关心，是否l1 !== null || l2 !== null, 如果其中一个链表先位null，它的值可以用0来代替，从而避免大量重复计算\n\n经过上面一条的优化，边界条件carry,只需要在循环结束时判断一次即可\n\n\nvar addTwoNumbers = function (l1, l2) &#123;    var head = &#123;            next: null        &#125;,        cur = head,        carry = 0;    while (l1 !== null || l2 !== null) &#123;        var x = l1 !== null ? l1.val : 0,            y = l2 !== null ? l2.val : 0,            sum = x + y + carry;        carry = sum / 10 | 0;        cur.next = &#123;            val: sum % 10,            next: null        &#125;        cur = cur.next;        l1 = l1 !== null ? l1.next : l1        l2 = l2 !== null ? l2.next : l2    &#125;    if (carry &gt; 0) &#123;        cur.next = &#123;            val: carry,            next: null        &#125;    &#125;    return head.next&#125;;\n\n复杂度分析\n\n时间复杂度： ，假设  和  分别表示  和  的长度，上面的算法最多重复 次。\n\n空间复杂度：。使用的额外空间复杂度为常数。\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"20. 有效的括号","url":"/posts/656e35ee6198/","content":"LeetCode给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n\n输入: &quot;()&quot;输出: true\n\n输入: &quot;(]&quot;输出: false\n\n1.使用栈判断括号的有效性可以使用「栈」这一数据结构来解决。\n我们对给定的字符串 s 进行遍历，当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。\n当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希映射（HashMap）存储每一种括号。哈希映射的键为右括号，值为相同类型的左括号。\n在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。\n注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。\n\n\n    var map = &#123;    &quot;(&quot;: &quot;)&quot;,    &quot;[&quot;: &quot;]&quot;,    &quot;&#123;&quot;: &quot;&#125;&quot;,&#125;var isValid = function (s) &#123;    var stack = [],        i = 0,        length = s.length;    if (length % 2 === 1) return false;    for (; i &lt; length; i++) &#123;        if (map[stack[0]] !== s[i]) &#123;            stack.unshift(s[i])        &#125; else &#123;            stack.shift();        &#125;    &#125;    console.log(stack)    return !stack.length&#125;;\n\n复杂度分析\n\n时间复杂度：，其中  是字符串  的长度。\n\n空间复杂度：，其中  表示字符集，本题中字符串只包含 6 种括号，。栈中的字符数量为 ，而哈希映射使用的空间为  ，相加即可得到总空间复杂度。\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"21.合并两个有序链表","url":"/posts/89472f2ca2f7/","content":"LeetCode1.暴力解题迭代需要的数据结构\n\n返回结果为合并后的链表，所以需要一个链表保存合并后的结果，prehead=&#123;next:null&#125;\n在链表合并的时候需要知道在什么位置插入节点，所以需要一个指针 prev=&#123;&#125; 指向当前插入位置的节点\n最后需要l1,l2两个合并的链表\n\n注意\n\n链表可能为空即: l1=null\n\n思路\n\n需要一个占位节点，即：prehead=&#123;val:-1,next:null&#125;, l1,l2,prev=prehead,都指向数据中的第一个节点\n\n\n\n比较l1,l2当前节点的值，把prehead.next指向值小的节点，同时把prehead = prehead.next,l2 = l2.next的指针移动到下一个节点，用于下一次比较\n\n\n\n依次比较直到链表l1.next===null, l2.next===null\n\n\nvar mergeTwoLists = function (l1, l2) &#123;    var prehead = &#123;        next: null    &#125;;    var prev = prehead    while (l1 || l2) &#123;        if (l1 &amp;&amp; l2) &#123;            if (l1.val &lt;= l2.val) &#123;                prev.next = l1;                prev = prev.next;                l1 = l1.next;            &#125; else &#123;                prev.next = l2;                prev = prev.next;                l2 = l2.next;            &#125;        &#125;        if (!l1 &amp;&amp; l2) &#123;            prev.next = l2;            prev = prev.next;            l2 = l2.next;        &#125;        if (!l2 &amp;&amp; l1) &#123;            prev.next = l1;            prev = prev.next;            l1 = l1.next;        &#125;    &#125;    return prehead.next;&#125;;\n\n\n2.优化迭代\n在比较的过程中，l1,l2中最多有一个会先为空。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。\n\nvar mergeTwoLists = function (l1, l2) &#123;    var prehead = &#123;        next: null    &#125;;    var prev = prehead    while (l1 &amp;&amp; l2) &#123;        if (l1.val &lt;= l2.val) &#123;            prev.next = l1;            l1 = l1.next;        &#125; else &#123;            prev.next = l2;            l2 = l2.next;        &#125;        prev = prev.next;    &#125;    prev = prev.next;    prev.next = l1 ? l1 : l2;    return prehead.next;&#125;;\n\n复杂度分析\n\n时间复杂度：,  和  分别为两个链表的长度。因为每次循环迭代中， 和  只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 。\n\n空间复杂度： 。我们只需要常数的空间存放若干变量。\n3.算法思维 递归解法识别结构，为什么可以使用递归？\n因为题目是求的合并，假如的第一个节点小于的第一个节点，问题可以转化为,即list1.next 和 list2 的合并，其结果为list[0].next \n\n如果 L1 或者 L2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。\n判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。\n如果两个链表有一个为空，递归结束。\n\nvar mergeTwoLists = function (l1, l2) &#123;    if (l1 === null) return l2;    if (l2 === null) return l1;    if (l1.val &lt;= l2.val) &#123;        l1.next = mergeTwoLists(l1.next, l2);        return l1;    &#125; else &#123;        l2.next = mergeTwoLists(l1, l2.next);        return l2;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。\n\n空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)。\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"26. 删除排序数组中的重复项","url":"/posts/738e7796b813/","content":"LeetCode描述：\n给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n注意\n\n在 原地 删除重复出现的元素，表示必须在原数组上操作\n方法返回的是一个长度，表示过滤后的个数，但并不代表是过滤后的数组长度。\n//给定 nums = [0,0,1,1,1,2,2,3,3,4],//函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。//你不需要考虑数组中超出新长度后面的元素。\n为什么返回数值是整数，但输出的答案是数组呢?输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n所以，这就是为什么返回的是一个长度，判别结果是一个数组的原因。下面这中写法由于没有修改原数组所以错误：var removeDuplicates = function (nums) &#123;    return nums.filter((num, index) =&gt; index === nums.indexOf(num)).length;&#125;;\n\n1.暴力解法逐个删除\n正向逐位依次和下一位比较，如果相等把当前位删除，因为必须在原数组上操作，所以是使用splice方法。\n因为使用 splice 方法对元素组删除，所以正向比较时需要注意数组的长度，如果删除了数组项，数组长度需要减1。\n\n var removeDuplicates = function (nums) &#123;    var len = nums.length-1,    i=0;    for (; i &lt;len; i++) &#123;        if (nums[i] === nums[i + 1]) &#123;            nums.splice(i, 1);            // 因为splice改变了数组的长度，所以数组长度需要减1            len--;            // 在删除了数组项之后，下次还需要在当前为比较            i--        &#125;    &#125;    return nums.length;&#125;;\n\n\n根据上面注释可以换一种写法\n\nvar removeDuplicates = function (nums) &#123;    var len = nums.length-1,    i=0;    for (; i &lt;len;) &#123;        if (nums[i] === nums[i + 1]) &#123;            nums.splice(i, 1);            len--;        &#125;else&#123;            i++        &#125;    &#125;    return nums.length;&#125;;\n\n\n因为正向遍历需要考虑删除数组项对长度的影响，所以考虑反向遍历。\n\nvar removeDuplicates = function (nums) &#123;    var i = nums.length - 1;    for (; i &gt; 0; i--) &#123;        if (nums[i] === nums[i - 1]) &#123;            nums.splice(i, 1)        &#125;    &#125;    return nums.length;&#125;;\n\n2.双指针\n注意到最终结果的生成方式，是用返回的数组长度（length）遍历原数组，所以原数组不需要完全是过滤后的结果，只需要前length项是过滤后的结果即可。\n使用 i , j 两个指针，i指针表示过滤后的数组索引，j表示遍历时的索引\n如果 nums[i]!==nums[j], j指针向后移动，继续遍历，如果nums[i]===nums[j], i之后向后移动，并且要把nums[j]赋值给nums[i+1];\n\nvar removeDuplicates = function (nums) &#123;    var i = 0,        j = 1,        len = nums.length;    for (; j &lt; len; j++) &#123;        if (nums[i] !== nums[j]) &#123;            i++;            nums[i] = nums[j]        &#125;    &#125;    // 因为i是索引，最后要返回长度所以+1    return i + 1;&#125;;","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"27. 移除元素","url":"/posts/df050af05208/","content":"LeetCode描述：\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n注意:\n\n在 原地 删除重复出现的元素，表示必须在原数组上操作\n\n方法返回的是一个长度，表示过滤后的个数，但并不代表是过滤后的数组长度。\n  //给定 nums = [0,1,2,2,3,0,4,2], val = 2,//函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。//注意这五个元素可为任意顺序。//你不需要考虑数组中超出新长度后面的元素。\n\n为什么返回数值是整数，但输出的答案是数组呢?输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n  // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n\n1.暴力解法 逐个删除  var removeElement = function (nums, val) &#123;    var i = 0,        len = nums.length;    for (; i &lt; len; i++) &#123;        if (nums[i] === val) &#123;            nums.splice(i, 1)            len--;            i--;        &#125;    &#125;    return len;&#125;;\n\n2. 双指针\n当 nums[j]与给定的值相等时，递增 j以跳过该元素。只要 nums[j]!==val,就复制 nums[j]到 nums[i]并同时递增两个索引。重复这一过程，直到 j到达数组的末尾，该数组的新长度为 i。\n\n此解法和(26)删除排序数组中的重复项相似\n\n\nvar removeElement = function (nums, val) &#123;    var i = 0,        j = 0,        len = nums.length;    for (; j &lt; len; j++) &#123;        if (nums[j] !== val) &#123;            nums[i] = nums[j];            i++        &#125;    &#125;    return i;&#125;;\n\n复杂度分析\n\n时间复杂度：，假设数组总共有  个元素， 和  最多遍历 次。\n\n空间复杂度：\n\n\n3. 双指针 交换位置\n考虑数组包含很少的要删除的元素的情况。例如，，，，，,。之前的算法会对前四个元素做不必要的复制操作。似乎没有必要将 ，，，这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。\n\nvar removeElement = function (nums, val) &#123;    var i = 0,        j = nums.length;    while (i &lt; j) &#123;        if (nums[i] === val) &#123;            nums[i] = nums[j - 1];            j--;        &#125; else &#123;            i++        &#125;    &#125;    return i;&#125;;\n\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"28. 实现 strStr()","url":"/posts/d174a22c5452/","content":"LeetCode描述：\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n说明：\n+    输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2\n+    输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1\n\n当 needle 是空字符串时我们应当返回 0，这与C语言的 strstr() 以及 Java，javascript的 indexOf() 定义相符。\n\n1.双指针\n首先，只有子串的第一个字符跟 needle 字符串第一个字符相同的时候才需要比较。\n\n\n\n其次，可以一个字符一个字符比较，一旦不匹配了就立刻终止。\n\n\n\n注意在遇到不匹配位时，重置指针的位置\n\n\n\n返回字串的开始位置\n\n\n    var strStr = function (haystack, needle) &#123;    if (needle == &#x27;&#x27;) return 0;    var i = 0,        j = 0,        haystackLength = haystack.length,        needleLength = needle.length;    while (i !== haystack.length) &#123;        // 剩余长度不足字串长度跳出        if (haystackLength - i &lt; needleLength) return -1;        while (haystack[j + i] === needle[j]) &#123;            j++            if (j === needleLength) &#123;                return i;            &#125;        &#125;        //不满足时重置索引        j = 0;        i++;    &#125;    return -1&#125;;\n\n复杂度分析\n\n时间复杂度：最坏时间复杂度 ，最好  \n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"3. 无重复字符的最长子串","url":"/posts/09a990dc322c/","content":"LeetCode\n\n注意\n\n暴力解法var lengthOfLongestSubstring = function (s) &#123;    if (s.length == 0) return 0;    var len = 1;    for (var i = 0; i &lt; s.length; i++) &#123;        var str = s[i];        for (var j = i + 1; j &lt; s.length; j++) &#123;            var nstr = s[j];            var mark = false;            for (var k = 0; k &lt; str.length; k++) &#123;                if (str[k] === nstr) &#123;                    mark = true;                    break                &#125;            &#125;            if (mark === false) &#123;                str += nstr;                if (str.length &gt; len) len = str.length;            &#125; else &#123;                break;            &#125;        &#125;    &#125;    return len;&#125;;\n\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n暴力解法优化通过map缓存已经查找过的值\n */var lengthOfLongestSubstring = function (s) &#123;    if (s.length == 0) return 0;    var len = 1;    for (var i = 0; i &lt; s.length; i++) &#123;        var map = &#123;            length: 1        &#125;;        map[s[i]] = true;        for (var j = i + 1; j &lt; s.length; j++) &#123;            var nstr = s[j];            if (!map[nstr]) &#123;                map[nstr] = true;                map.length++;                if (map.length &gt; len) len = map.length            &#125; else &#123;                break;            &#125;        &#125;    &#125;    return len;&#125;;\n\n\n复杂度分析\n\n时间复杂度：,\n\n空间复杂度：,时间换空间\n\n\n窗口移动\n如果下一个字符和之前的字符重复，则重复字符之前的字符都被舍弃\n\n每次读取新字符，判断一次当前位置到舍弃位置的长度是否比之前的总长度大\n\n\nvar lengthOfLongestSubstring = function (s) &#123;    if (s == &#x27;&#x27;) return 0;    if (s == &#x27; &#x27;) return 1;    var map = &#123;        start: 0,        end: 0,        len: 0    &#125;    for (var i = 0; i &lt; s.length; i++) &#123;        if (map[s[i]] !== undefined &amp;&amp; map[s[i]] &gt; map.start) &#123;            map.start = map[s[i]];        &#125;        map[s[i]] = i + 1;        map.end = i + 1;        map.len = Math.max(map.end - map.start, map.len)    &#125;    return map.len;&#125;;\n\n\n复杂度分析\n\n时间复杂度：,\n\n空间复杂度：,时间换空间\n\n\n优化窗口移动var lengthOfLongestSubstring = function (s) &#123;    let map = new Map(),        //i为上面方法的start指针        i = 0,        j = 0,        max = 0;    for (j = 0; j &lt; s.length; j++) &#123;        if (map.has(s[j])) &#123;            //如果存在，当前这个值对应的索引不能比start指针小            i = Math.max(map.get(s[j]) + 1, i)        &#125;        map.set(s[j], j);        max = Math.max(max, j - i + 1)        console.log(map, i, max);    &#125;    return max;&#125;;","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"332.零钱兑换","url":"/posts/d6c4bdaabf75/","content":"LeetCode动态规划详解动态规划注意\n\n边界情况amount===0时返回0，0元需要0枚硬币\n\nstack[i - coins[j]] stack[i] 需要判断为undefined的情况，因为JavaScript中Math.min(undefined)===NaN需要特殊处理，用Infinity占位，在使用Math.min(1,Infinity) 可以取得最小值\n\n返回时需要判断不能匹配的情况，如果当前位置为Infinity表示不能匹配\n\n\nvar coinChange = function (coins, amount) &#123;    // 边界情况    if (amount === 0) return 0;    // 初始化    var stack = [0],        n = coins.length,        i, j, a, b;    for (i = 1; i &lt;= amount; i++) &#123;        //f[i] = min&#123;f(i-coins[0]),f(i-coins[1]),...,f(i-coins[j])&#125;        for (j = 0; j &lt; n; j++) &#123;            a = stack[i - coins[j]] === undefined ? Infinity : stack[i - coins[j]];            b = stack[i] === undefined ? Infinity : stack[i];            stack[i] = Math.min(a, b)        &#125;    &#125;    if (stack[i - 1] === Infinity) &#123;        return -1;    &#125;    return stack[i - 1]&#125;;\n\n另一种优雅的边界处理方式\n\n默认stack[i] = Infinity 避免了上面判断 stack[i] === undefined的情况\n\ni &gt;= coins[j] 时才会比较，如果硬币的面额比需要凑出的总金额还要大，显然不需要比较，从而避免上面stack[i - coins[j]] === undefined的情况\n\nstack[i - coins[j]] !== Infinity 表示如果上一步的结果是Infinity,也就是上一步没有办法凑出指定面额，那下一步也凑不出指定面额，在Javascript中虽然可以不写这一步，只会增加依次赋值操作，但在其他语言中如 C++,如果不加判断Integer.MAX_VALUE+1可能会溢出\n\n\nfunction coinChange(coins, amount) &#123;    if (amount === 0) return 0;    var stack = [0],        n = coins.length,        i, j;    for (i = 1; i &lt;= amount; ++i) &#123;        stack[i] = Infinity;        for (j = 0; j &lt; n; j++) &#123;            if (i &gt;= coins[j] &amp;&amp; stack[i - coins[j]] !== Infinity) &#123;                stack[i] = Math.min(stack[i - coins[j]] + 1, stack[i])            &#125;        &#125;    &#125;    if (stack[i - 1] === Infinity) &#123;        return -1;    &#125;    return stack[i - 1];&#125;\n复杂度分析\n\n时间复杂度：，其中  是金额， 是面额数。我们一共需要计算  个状态， 为题目所给的总金额。对于每个状态，每次需要枚举 n个面额来转移状态，所以一共需要  的时间复杂度。\n\n空间复杂度： 数组长度等于金额的大小\n\n\n","categories":["算法","关联题目"],"tags":["算法","动态规划","关联题目"]},{"title":"344.反转字符串","url":"/posts/a4a1367d3c29/","content":"LeetCode注意\n原生APIvar reverseString = function()&#123;    return s.reverse();&#125;\n\n循环从前向后两两交换字母位置,n为数组s的长度，那么只需要n/2次就可以调换所有的顺序\nvar reverseString = function (s) &#123;    var len = s.length,        middle = Math.ceil(s.length / 2),        i = 0;    for (; i &lt; middle; i++) &#123;        var temp = s[i];        s[i] = s[len - i - 1];        s[len - i - 1] = temp;    &#125;    return s;&#125;;\n双指针与循环方法相似，需要left,right两个指针，分别向中间移动，当两个指针相等时，交换完成\nvar reverseString = function (s) &#123;    var left = 0,        right = s.length - 1;    while (left &lt;= right) &#123;        var temp = s[left];        s[left] = s[right];        s[right] = temp;        left++;        right--;    &#125;    return s;&#125;\n\n复杂度分析\n\n时间复杂度： 只需要遍历  次。\n\n空间复杂度： 不需要额外空间\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"35. 搜索插入位置","url":"/posts/c488f9cc87d7/","content":"搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n输入: [1,3,5,6], 2输出: 1\n\n注意\n\n如果数组中已经存在相同的数字，插入位置是当前数字的前一位输入: [1,3,5,6], 5输出: 2\n\n暴力解法var searchInsert = function (nums, target) &#123;    var i = 0,        len = nums.length;    // 处理边界    if (nums[len - 1] &lt; target) return len;    if (nums[len - 1] === target) return len - 1;    for (; i &lt; len - 1; i++) &#123;        if (nums[i] === target) return i;        if (nums[i] &lt; target &amp;&amp; nums[i + 1] &gt; target) &#123;            return i + 1;        &#125;    &#125;&#125;;\n\n二分法此题很容易想到用二分法解决，如果在一个给定范围的数组中查询某一项，大概率可以使用二分法。\n思路\n\n定义左下标left,和右下标right\n计算mid=Math.floor(left+right),向下取整保证下表位整数\n根据nums[mid]值来判断，如果nums[mid]===target 返回mid，如果nums[mid]&lt;target说明mid左侧值全都比mid小，下次比较时只需要关心mid右侧值，所以left变为mid的下一位，left=mid+1. 同理，nums[mid]&gt;target 只需要关心mid左侧值，right=mid-1\n最后如果没有和mid相等的情况是返回left即位插入的位置.\n\n\n\n为什么可以使用left作为返回结果？因为向下取整所以在相邻位置时left===mid\n\nvar searchInsert = function (nums, target) &#123;    var len = nums.length,        left = 0,        right = (0, len - 1);    while (left &lt;= right) &#123;        mid = Math.floor((right + left) / 2)        if (nums[mid] === target) &#123;            return mid;        &#125;        if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125;        if (nums[mid] &gt; target) &#123;            right = mid - 1        &#125;    &#125;    return left;&#125;;\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"38. 外观数列","url":"/posts/201d9aa46a3f/","content":"LeetCode注意\n\n处理边界情况，当n==1返回&#39;1&#39;\n\n暴力解法  循环+使用栈结构使用数组来处理统计字符个数\nvar countAndSay = function (n) &#123;    if (n === 1) return &#x27;1&#x27;;    var res = &#x27;1&#x27;,        i = 1;    for (; i &lt; n; i++) &#123;        var str = &#x27;&#x27;;        var count = 0;        var stack = [];        for (var j = 0; j &lt; res.length; j++) &#123;            if (stack[0] !== undefined &amp;&amp; stack[0] !== res[j]) &#123;                str += stack.length + stack[0];                stack = [];            &#125;            stack.push(res[j])        &#125;        if (stack.length) &#123;            str += stack.length + stack[0];        &#125;        res = str;    &#125;    return res;&#125;;\n\n优化 双指针在处理字符个数时有个很通用且巧妙的解法，使用双指针来统计连续字符串出现的个数\n计数二进制子串\nvar countAndSay = function (n) &#123;    if (n === 1) return &#x27;1&#x27;;    var res = &#x27;1&#x27;;    for (var i = 1; i &lt; n; i++) &#123;        var j = 0;        var temp = &#x27;&#x27;;        for (var k = 0; k &lt; res.length; k++) &#123;            if (res[j] !== res[k]) &#123;                temp += String(k - j) + res[j];                j = k;            &#125;        &#125;        temp += String(k - j) + res[j];        res = temp;    &#125;    return res;&#125;;\n\n递归可以把循环n时改为递归的形式\nvar countAndSay = function (n) &#123;    if (n === 1) return &#x27;1&#x27;;    var res = countAndSay(n - 1);    var j = 0;    var temp = &#x27;&#x27;;    for (var k = 0; k &lt; res.length; k++) &#123;        if (res[j] !== res[k]) &#123;            temp += String(k - j) + res[j];            j = k;        &#125;    &#125;    temp += String(k - j) + res[j];    return temp&#125;;\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"43.字符串相乘","url":"/posts/a2c889f73400/","content":"LeetCode\nBigInt不能和Math对象中的方法一起使用；不能和任何Number实例混合运算。\nvar multiply = function(num1, num2) &#123;  return BigInt(num1) * BigInt(num2) + &#x27;&#x27;;&#125;\n\n竖向相乘算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：\n\n乘数 num1 位数为 M，被乘数 num2 位数为 N， num1 * num2 结果 res 最大总位数为 M+N\n\nnum1[i] * num2[j] 的结果为 tmp(位数为两位，”0x”,”xy”的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]\n\n\n\nvar multiply = function (num1, num2) &#123;    const stack = new Array(num1.length + num2.length).fill(0);    let res = &#x27;&#x27;;    for (let i = num1.length - 1; i &gt;= 0; i--) &#123;        for (let j = num2.length - 1; j &gt;= 0; j--) &#123;            const sum = stack[i + j + 1] + num1[i] * num2[j];            stack[i + j + 1] = sum % 10;            stack[i + j] += sum / 10 &gt;&gt; 0;        &#125;    &#125;    let make = false;    for (let i = 0; i &lt; stack.length; i++) &#123;        if (!make &amp;&amp; stack[i] === 0) &#123;            continue;        &#125;        make = true;        res += stack[i];    &#125;    return res || &#x27;0&#x27;&#125;;\n\n把边界情况与0相乘单独处理\nvar multiply = function (num1, num2) &#123;    if (num1 === &#x27;0&#x27; || num2 === &#x27;0&#x27;) &#123;        return &#x27;0&#x27;    &#125;    const stack = new Array(num1.length + num2.length).fill(0);    let res = &#x27;&#x27;;    for (let i = num1.length - 1; i &gt;= 0; i--) &#123;        for (let j = num2.length - 1; j &gt;= 0; j--) &#123;            const sum = stack[i + j + 1] + num1[i] * num2[j];            stack[i + j + 1] = sum % 10;            stack[i + j] += sum / 10 &gt;&gt; 0;        &#125;    &#125;    for (let i = 0; i &lt; stack.length; i++) &#123;        if (i == 0 &amp;&amp; stack[i] === 0) &#123;            continue;        &#125;        res += stack[i];    &#125;    return res;&#125;;\n\n复杂度分析\n\n时间复杂度：, 分别为 num1 和 num2 的长度。\n\n空间复杂度： 用于存储计算结果。\n\n\n多项式相乘","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"46.全排列","url":"/posts/e79718be30c7/","content":"LeetCode回溯法\n\nfunction permute(nums) &#123;  const res = [];  const  set = new Set();  function dfs(set)&#123;      if(set.size===nums.length)&#123;          res.push([...set]);      &#125;      for(let k of nums)&#123;          if(set.has(k))&#123;              continue;          &#125;          set.add(k);          dfs(set);          set.delete(k)      &#125;  &#125;  dfs(set);  return res;&#125;;\n\n位置交换回溯法在进入下一次递归时，并没有标注循环位置，所以nums中的元素每一个都要通过Set集合判断一次\n如果不使用Set数据结构，时间复杂度更高\n位置交换，是通过在一次循环把第一个元素更换为其他剩余元素，在第一个元素固定下来后，后面的元素进行全排列\nfunction swap(arr, a, b) &#123;    const temp = arr[a];    arr[a] = arr[b];    arr[b] = temp;&#125;function permute(nums) &#123;    const res = [];    function dfs(n) &#123;        if (n === nums.length - 1) &#123;            res.push([...nums]);        &#125;        for (let i = n; i &lt; nums.length; i++) &#123;            swap(nums, i, n)            dfs(n + 1);            swap(nums, i, n)        &#125;    &#125;    dfs(0);    return res;&#125;;\n位置交换稍微调整发现在最后只有一个元素的时候，还是进行了递归\n所以提前判断剩余数组是否满足递归条件，如果只剩下一个元素就结束递归\n使用一下es6数组元素交换的方法\nfunction permute(nums) &#123;  const res = [];  function dfs(n) &#123;      for (let i = n; i &lt; nums.length; i++) &#123;          [nums[i], nums[n]] = [nums[n], nums[i]];          if (n + 1 &gt; nums.length - 1) &#123;              res.push([...nums]);              continue;          &#125;          dfs(n + 1);          [nums[i], nums[n]] = [nums[n], nums[i]];      &#125;  &#125;  dfs(0);  return res;&#125;;\n\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"53.最大子序和","url":"/posts/75cf116449fa/","content":"LeetCode暴力解法 窗口移动\n指定窗口大小，初始窗口大小为1。\n向右移动窗口并计算窗口内的元素和，直到窗口移动到数组尾部结束。\n在移动的过程中，比较窗口内的和是否比上一次大，如果比上一次大记录最大值。\n扩大窗口大小，并重复上面过程，直到窗口大小与数组大小相同，并返回最大值。\n\n\nvar maxSubArray = function (nums) &#123;    var sum;    for (var i = 0; i &lt; nums.length; i++) &#123;        for (var j = 0; j + i &lt; nums.length; j++) &#123;            var temp = 0;            for (var k = 0; k &lt; i + 1; k++) &#123;                temp += nums[j + k];            &#125;            if (sum === undefined) sum = temp            if (temp &gt; sum) sum = temp;        &#125;    &#125;    return sum;&#125;;\n\n复杂度分析\n\n时间复杂度：,时间复杂度较高，数据量大的时候可能通不过测试。\n\n空间复杂度：\n\n\n暴力解法优化\n不需要确认窗口大小，只需要每次遍历到数组结尾即可\n也可以理解为线改变窗口大小遍历，下一次移动启示位置之后重新遍历窗口大小\n\n\nvar maxSubArray = function (nums) &#123;  var sum;  for (var i = 0; i &lt; nums.length; i++) &#123;      var temp = 0;      for (var j = i; j &lt; nums.length; j++) &#123;          temp += nums[j];          if (temp &gt; sum || sum === undefined) sum = temp;      &#125;  &#125;  return sum;&#125;;\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n动态规划我们用 代表 nums[i]，用  代表以第  个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：\n\n\n因此我们只需要求出每个位置的 ，然后返回  数组中的最大值即可。那么我们如何求  呢？我们可以考虑 单独成为一段还是加入  对应的那一段，这取决于 和的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：\n\n\n关键在于 子数组最大值的求法，为什么两两比较的最大值是最终最大字串的值？\n\n首先需要舍弃索引的概念，并不需要通过索引区间记录哪个区间字串的和最大\n每一次的结果是基于上一次的最大值比较的,从长度等于1开始，所以取和中最大的就是子数组中的最大的原因就在于此，因为上一次的结果就是最优解（最大值），所以本次只需要比较一次就可以了\n最后每次更新保存最终最大值的变量就可以了\n\nvar maxSubArray = function (nums) &#123;    var sum_endof_here = nums[0];    var sum_far_from = nums[0];    for (var i = 1; i &lt; nums.length; i++) &#123;        // 只有在当前值大于之前的和时，之前的值才会被丢弃，        // 否则前面的值无论怎样波动增大或减小，但此时此刻加上当前值，就是当前子数组的最大值        sum_endof_here = Math.max(nums[i], nums[i] + sum_endof_here);        sum_far_from = Math.max(sum_far_from, sum_endof_here);    &#125;    return sum_far_from;&#125;;\n\nvar maxSubArray = function (nums) &#123;    var sum_endof_here = 0;    var sum_far_from = nums[0];    for (var i = 0; i &lt; nums.length; i++) &#123;        // 等同于 if(sum_endof_here&gt;0)&#123;&#125;       if(sum_endof_here+ nums[i]&gt;nums[i])&#123;        sum_endof_here = sum_endof_here+ nums[i]       &#125;else&#123;        sum_endof_here = nums[i];       &#125;       sum_far_from = Math.max(sum_far_from,sum_endof_here)    &#125;    return sum_far_from;&#125;;\n\n\n时间复杂度： 只需要遍历一次数组就可以得到结果。\n\n空间复杂度：\n\n\n分治","categories":["算法","关联题目"],"tags":["算法","动态规划","关联题目"]},{"title":"55.跳跃游戏","url":"/posts/47d4d9613623/","content":"LeetCode动态规划详解确定状态最后一步考虑青如果能跳到最后一个位置,\n那必须满足这样的关系：\n\n如果是从位置上跳过来，必须能先跳到位置\n\n位置上表示的步数大小必须大于或等于从到最后位置,即\n\n\n子问题把能否跳到位置的问题，转化位能否跳到位置的问题\n且 问题规模缩小\n状态最终可以确定状态： 表示能否到最后位置\n转移方程\n通过最后一步的分析, 位置必须能到达，且位置  的步数与位置的和必须大于等于最后位置的索引 ,所以有 \n\n如何找到  是通过循环  ,只要可以找到一个满足的条件，那么\n\n最终转移方程为 \n\n\n**注意:**为什么不能只找最近的进行判断？因为能否到达  受之前所有能到达位置的影响，而且最近的可到达位置，并不一定能到最终位置，例如 [3,0,0,5,0,0,1,0,1]\n初始条件和边界情况位置0为true\n运算顺序\n设  表示青蛙不能跳到石头 \n\n\n\n初始化 f[0]==true\n\n计算 f[1],f[2]....,f[n-1]\n\n返回结果为 f[n-1]\n\n\nvar canJump = function (nums) &#123;    var f = [true],        n = nums.length;    for (var j = 1; j &lt; n; j++) &#123;        f[j] = false;        for (var i = 0; i &lt; j; i++) &#123;            if (f[i] &amp;&amp; i + nums[i] &gt;= j) &#123;                f[j] = true;                break;            &#125;        &#125;    &#125;    return f[n - 1];&#125;;\n\n复杂度分析\n\n时间复杂度：,每次需要重复遍历已经遍历过的元素所以，\n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"58. 最后一个单词的长度","url":"/posts/24089337ee25/","content":"LeetCode解法一\n因为是从查找最后一个单词，考虑从后向前匹配\n\n因为有以一个或多个空字符串结尾的情况，所以如果先遇到空字符串则跳过，从遇到的第一个字符串开始基数，再次遇到空格则返回结果\n\n注意边界的处理，如果字符串为空，返回0\n\n\nvar lengthOfLastWord = function (s) &#123;    // 边界处理    if (s === &#x27;&#x27;) return 0    var i = s.length - 1;    var res = 0;    for (; i &gt;= 0; i--) &#123;        if (s[i] === &#x27; &#x27; &amp;&amp; res !== 0) &#123;            return res;        &#125;        else if(s[i] !== &#x27; &#x27;)&#123;            res++;        &#125;        //跳过空字符串的情况    &#125;    return res;&#125;;\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n方法二var lengthOfLastWord = function(s) &#123;    if(s===&#x27;&#x27;) return 0    return s.trim().split(&#x27; &#x27;).pop().length;&#125;;","categories":["算法","关联题目"],"tags":["算法","关联题目","字符串"]},{"title":"62.不同路径","url":"/posts/1871f6b1c45d/","content":"LeetCode动态规划解法确定状态最后一步无论机器人用多少种方式到达右下角，最后的一步只能是向下或者向右\n右下角的坐标为 \n那么它的上一步一定是在  或 \n子问题如果有种方式走到 ，有 种方式走到，那么走到的方式为种\n\n为什么可以是种\n\n满足加法需要保证两点:\n\n无重复，机器人不坑能从的位置走到的位置，不会有重复路线\n\n无遗漏，机器人只能从其他两个位置走到最终位置，在没有其他的方式\n\n\n所以问题就可以转化为有多少种方式走到或的位置，并求两者之和\n子问题缩小了元问题的规模，可以忽略最右边一列，或最下面一列，这也是子问题的作用\n状态最终可以确定状态： f[i][j]为机器人有多少种方式走到右下角(i,j)\n转移方程\n初始条件和边界情况\n初始条件： f[0][0]=1机器人只有一种方式到左上角，也就是不动\n\n边界条件： 第一行和第一列只有一种走法，一直向右或一直向下,因为第一行没有上面的格子，不能从上面走到下面，第一列没有左边的格子，不能从左边走到右边，所以f[0-&gt;i][0]=1 f[0][0-&gt;j]=1，其他的格子都可以使用状态转移方程\n\n\n计算顺序\nf[0][0]=1\n\n计算第0行： f[0][0],f[0][1],…,f[0][j-1]\n\n计算第1行： f[1][0],f[1][1],…,f[1][j-1]\n\n计算第i-1行： f[i-1][0],f[i-1][1],…,f[i-1][j-1]\n\n\n计算顺序并是不里所当然，或是为了循环方便，如下图所示:\n\nB格子在计算i-1行时刚刚算过，A格子在上面一步计算i-2行时计算过，所以可以计算出f[i-1][j-2]为最终返回结果\nvar uniquePaths = function (m, n) &#123;    var i, j, arr = [];    for (i = 0; i &lt; m; i++) &#123;        for (j = 0; j &lt; n; j++) &#123;            if (i === 0 || j === 0) &#123;                Array.isArray(arr[i]) ? arr[i][j] = 1 : arr[i] = [1]            &#125; else &#123;                arr[i][j] = arr[i - 1][j] + arr[i][j - 1];            &#125;        &#125;    &#125;    return arr[i - 1][j - 1];&#125;;\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"65.有效数字","url":"/posts/6f15572531c1/","content":"LeetCode条件判断维护了三个状态\n\n有 e|E 的时候，!hasE用于判断这是第一次遇到 e|E 这个字符，因为 e|E 只能有一个，hasNum表示遇到 e|E 的时候前面必须有一个数字\n后面一句 hasNum = false 排除了 +2e 以 e|E 结尾的情况\n\n有 . 的时候，.一定在 e|E 的前面，所以判断!hasE，.只可能有一个，所以isFloat为false\n\n\nvar isNumber = function (s) &#123;  // 是否存在e,  var hasE = false;  var hasNum = false;  var isFloat = false;  for (let i = 0; i &lt; s.length; i++) &#123;    var c = s[i];    // 符号只能在首位，或者E|e 的后一位    if (      (c == &quot;+&quot; || c == &quot;-&quot;) &amp;&amp;      (i == 0 || s[i - 1] === &quot;e&quot; || s[i - 1] === &quot;E&quot;)    ) &#123;      //e只能有一个，e的前面必须是数字    &#125; else if ((c === &quot;e&quot; || c === &quot;E&quot;) &amp;&amp; !hasE &amp;&amp; hasNum) &#123;      hasE = true;      hasNum = false;    &#125; else if (c === &quot;.&quot; &amp;&amp; !isFloat &amp;&amp; !hasE) &#123;      isFloat = true;    &#125; else if (/[0-9]/.test(c)) &#123;      hasNum = true;    &#125; else &#123;      return false;    &#125;  &#125;  return hasNum;&#125;;\n\n有限状态机确定有限状态自动机\n一个有效数字可以分为一下几个部分 ：\n\n符号位，即 + - 两种符号\n整数部分，即由若干字符 0-9 组成的字符串\n小数点\n小数部分，其构成与整数部分相同\n指数部分，其中包含开头的字符 e（大写小写均可）、可选的符号位，和整数部分\n\n每个部分都不是必需的，但也受一些额外规则的制约：\n\n如果符号位存在，其后面必须跟着数字或小数点。\n小数点的前后两侧，至少有一侧是数字。\n\n根据上面的分析可以把一个有效数字分为下面几个状态:\n\n符号位\n整数部分\n左侧有整数的小数点\n左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）\n小数部分\n字符 e\n指数部分的符号位\n指数部分的整数部分\n\n\nvar isNumber = function (s) &#123;  const State = &#123;    STATE_INITIAL: &quot;STATE_INITIAL&quot;, // 初始状态    STATE_INT_SIGN: &quot;STATE_INT_SIGN&quot;, // 符号位    STATE_INTEGER: &quot;STATE_INTEGER&quot;, //整数部分    STATE_POINT: &quot;STATE_POINT&quot;, // 左侧有整数的小数点    STATE_POINT_WITHOUT_INT: &quot;STATE_POINT_WITHOUT_INT&quot;, //左侧无整数的小数点    STATE_FRACTION: &quot;STATE_FRACTION&quot;, //小数部分    STATE_EXP: &quot;STATE_EXP&quot;, //字符e    STATE_EXP_SIGN: &quot;STATE_EXP_SIGN&quot;, //指数部分的符号位    STATE_EXP_NUMBER: &quot;STATE_EXP_NUMBER&quot;, //指数部分的整数部分    STATE_END: &quot;STATE_END&quot;, //结束状态  &#125;;  const CharType = &#123;    CHAR_NUMBER: &quot;CHAR_NUMBER&quot;,    CHAR_EXP: &quot;CHAR_EXP&quot;,    CHAR_POINT: &quot;CHAR_POINT&quot;,    CHAR_SIGN: &quot;CHAR_SIGN&quot;,    CHAR_ILLEGAL: &quot;CHAR_ILLEGAL&quot;,  &#125;;  const toCharType = (ch) =&gt; &#123;    if (!isNaN(ch)) &#123;      return CharType.CHAR_NUMBER;    &#125; else if (ch.toLowerCase() === &quot;e&quot;) &#123;      return CharType.CHAR_EXP;    &#125; else if (ch === &quot;.&quot;) &#123;      return CharType.CHAR_POINT;    &#125; else if (ch === &quot;+&quot; || ch === &quot;-&quot;) &#123;      return CharType.CHAR_SIGN;    &#125; else &#123;      return CharType.CHAR_ILLEGAL;    &#125;  &#125;;  const transfer = new Map();  const initialMap = new Map();  initialMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);  initialMap.set(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);  initialMap.set(CharType.CHAR_SIGN, State.STATE_INT_SIGN);  transfer.set(State.STATE_INITIAL, initialMap);  const intSignMap = new Map();  intSignMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);  intSignMap.set(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);  transfer.set(State.STATE_INT_SIGN, intSignMap);  const integerMap = new Map();  integerMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);  integerMap.set(CharType.CHAR_EXP, State.STATE_EXP);  integerMap.set(CharType.CHAR_POINT, State.STATE_POINT);  transfer.set(State.STATE_INTEGER, integerMap);  const pointMap = new Map();  pointMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);  pointMap.set(CharType.CHAR_EXP, State.STATE_EXP);  transfer.set(State.STATE_POINT, pointMap);  const pointWithoutIntMap = new Map();  pointWithoutIntMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);  transfer.set(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);  const fractionMap = new Map();  fractionMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);  fractionMap.set(CharType.CHAR_EXP, State.STATE_EXP);  transfer.set(State.STATE_FRACTION, fractionMap);  const expMap = new Map();  expMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);  expMap.set(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);  transfer.set(State.STATE_EXP, expMap);  const expSignMap = new Map();  expSignMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);  transfer.set(State.STATE_EXP_SIGN, expSignMap);  const expNumberMap = new Map();  expNumberMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);  transfer.set(State.STATE_EXP_NUMBER, expNumberMap);  const length = s.length;  let state = State.STATE_INITIAL;  for (let i = 0; i &lt; length; i++) &#123;    const type = toCharType(s[i]);    if (!transfer.get(state).has(type)) &#123;      return false;    &#125; else &#123;      state = transfer.get(state).get(type);    &#125;  &#125;  return (    state === State.STATE_INTEGER ||    state === State.STATE_POINT ||    state === State.STATE_FRACTION ||    state === State.STATE_EXP_NUMBER ||    state === State.STATE_END  );&#125;;\n\n函数式有限状态机const start = (c) =&gt; &#123;  const type = toCharType(c);  if (type === CharType.CHAR_NUMBER) return integer;  if (type === CharType.CHAR_POINT) return pointWithoutInt;  if (type === CharType.CHAR_SIGN) return intSign;  return end;&#125;;const integer = (c) =&gt; &#123;&#125;;const pointWithoutInt = () =&gt; &#123;&#125;;const intSign = () =&gt; &#123;&#125;;const end = () =&gt; end;\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"771.宝石与石头","url":"/posts/a815a2022933/","content":"LeetCode暴力解法暴力法的思路很直观，遍历字符串 SS，对于 SS 中的每个字符，遍历一次字符串 JJ，如果其和 JJ 中的某一个字符相同，则是宝石。\nvar numJewelsInStones = function (J, S) &#123;    var result = 0,        i = 0,        j = 0,        jlen = J.length,        slen = S.length;    for (; i &lt; slen; i++) &#123;        var s = S[i];        for (j = 0; j &lt; jlen; j++) &#123;            if (J[j] === s) &#123;                result++;            &#125;        &#125;    &#125;    return result;&#125;;\n\n复杂度分析\n\n时间复杂度： ,  为字符串的长度，为字符串 的长度\n\n空间复杂度： \n\n\n使用map结构遍历字符串 JJ，使用哈希集合存储其中的字符，然后遍历字符串 SS，对于其中的每个字符，如果其在哈希集合中，则是宝石。\nvar numJewelsInStones = function (J, S) &#123;    var map = &#123;&#125;,        result = 0,        i = 0,        j = 0,        jlen = J.length,        slen = S.length;    for (;i&lt;jlen;i++)&#123;        map[J[i]] = J[i];    &#125;    for(;j&lt;slen;j++)&#123;        if(S[j]===map[S[j]])&#123;            result++;        &#125;    &#125;    return result;&#125;;\n\nvar numJewelsInStones = function (J, S) &#123;    var map = new Map(),        result = 0,        i = 0,        j = 0,        jlen = J.length,        slen = S.length;    for (;i&lt;jlen;i++)&#123;        map.set(J[i],J[i]);    &#125;    for(;j&lt;slen;j++)&#123;        if(map.get(S[j]))&#123;            result++;        &#125;    &#125;    return result;&#125;;\n\n复杂度分析\n\n时间复杂度： ,  为字符串的长度，为字符串 的长度\n\n空间复杂度： \n\n\n"},{"title":"O(03).数组中重复的数字","url":"/posts/e771ddaee295/","content":"LeetCode\n\n注意\n\n暴力解法使用 map 或 set\nvar findRepeatNumber = function (nums) &#123;  var map = new map();  for (let n of nums) &#123;    if (map[n]) return n;    map[n] = true  &#125;&#125;;\n\n原地替换\n题目描述 (长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 ), 说明每个元素都应该与自己的下标相等，都有自己的位置\n\n通过循环把每个元素放回自己的位置，如果发现被相同的元素占用，表示重复\n\n\nvar findRepeatNumber = function (nums) &#123;  var index = 0;  while (nums[index] !== undefined) &#123;    var temp = nums[index];    if (temp === index) &#123; index += 1; continue &#125;;    if (nums[temp] === temp) return temp;    nums[index] = nums[temp];    nums[temp] = temp;  &#125;  return -1;&#125;;\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"O11.旋转数字最小数字","url":"/posts/1f6135d8a216/","content":"LeetCode二分查找\n通过上图直观的分析出旋转数字的一些特点\n\n最右边的值只能小于等于最左边的值\n\n如果一个值比最右边的值小，那么最小值一定在这个值左边或是这个值本身\n\n如果最左边的值比其中一个值大，那么最小值一定在这个值右边\n\n\n var minArray = function (numbers) &#123;  var left = 0,      right = numbers.length - 1,      mid = Math.floor(right / 2);  while (left &lt; right) &#123;      if (numbers[mid] &lt; numbers[right]) &#123;          right = mid;      &#125; else if (numbers[mid] === numbers[right]) &#123;          right--;      &#125; else if (numbers[mid] &gt; numbers[right]) &#123;          left = mid + 1;      &#125;      mid = Math.floor((left + right) / 2)  &#125;  return numbers[left];&#125;;\n\n\n什么左边的值比其中一个值大的时候，这个值不能是最小值\n因为我们先处理了右半区的比较，会使得最右边值先到达最小值\n\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"O53.0～n-1中缺失的数字","url":"/posts/c0dab2eedc6f/","content":"LeetCode\n\n注意\n\n\n清楚题目的意思，有一个数字不在数组中，是返回这个数字的本身，而不是索引。[0]长度为1，取值范围是[0,1]其中1不在数组中，所以返回1\n\n暴力解法var missingNumber = function(nums) &#123;    var i=0;    var len = nums.length;    for(var i=0;i&lt;len;i++)&#123;        if(nums[i]!==i)&#123;            return i;        &#125;    &#125;    return i;&#125;;\n\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n二分法var missingNumber = function (nums) &#123;    var left = 0;    var right = nums.length-1;    var middle = Math.floor((left + right) / 2)    while (left &lt;= right) &#123;        if (nums[middle] === middle) &#123;            left = middle + 1;        &#125; else &#123;            right = middle-1;        &#125;        middle = Math.floor((left + right) / 2)    &#125;    return left&#125;;\n复杂度分析\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"O60.n个骰子的点数","url":"/posts/0a326e7e0339/","content":"LeetCode\n\n注意： 请仔细理解骰子点数，和点数和的概念。骰子点数表示当前第 n 个骰子的点数，为 1 到 6 之间的一个数。 点数和表示投出的 n 个骰子的点数之和。\n\n暴力解法只有一个骰子的情况，循环每一个点数，存到数组中\n数组的位置即数组的索引表示的是点数和，只有一个骰子的时候点数和为骰子点数本身,每种点数和出现的次数为1\nvar arr = [];for (var i = 1; i &lt;= 6; i++) &#123;    arr[i] = 1;&#125;\n\n当有两个骰子的时候，点数和最大为 12，即两个骰子都取最大点数 6 的时候\n统计每种点数和出现的次数，需要两个嵌套循环，表示在两个骰子中各取一个点数加和\n如果数组索引等于点数和的位置为 undefined,表示还没有这种点数和的情况，那就把当前位置赋值为1，表示这种点数和出现的次数为1\n如果已经存在，就在原有的值上加1，表示又找到一种点数和相同的情况\nvar arr = [];for (var i = 1; i &lt;= 6; i++) &#123;    for (var j = 1; j &lt;= 6; j++) &#123;        var sum = i + j;        if (arr[sum] === undefined) arr[sum] = 0;        arr[sum] += 1;    &#125;&#125;\n\n对于n个骰子，我们需要n层嵌套的循环，所以使用递归来实现不定层数的嵌套循环\nvar arr = [];var n = 2;function recursion(loop, sum) &#123;  if (loop &lt;= n) &#123;    for (var i = 1; i &lt;= 6; i++) &#123;      recursion(loop + 1, sum + i);      if (loop !== n) continue;      if (arr[sum + i] === undefined) arr[sum + i] = 0;      arr[sum + i]++;    &#125;  &#125;&#125;recursion(1, 0)\n\n需要注意的是如果当前层数不是第n层是不需要向数组中添加个数的\n也就是递归到最底层，之后才开始计算各点数和\n注意不能使用 return 而需要使用 continue 因为return使得函数直接退出，for 循环不能全部执行\n下面的写法也可以写成\nvar arr = [];var n = 2;function recursion(loop, sum) &#123;    if (loop &gt; n) &#123;        if (arr[sum] === undefined) arr[sum] = 0;        arr[sum]++;        return arr;    &#125;    for (var i = 1; i &lt;= 6; i++) &#123;        recursion(loop + 1, sum + i);    &#125;&#125;recursion(1, 0)\n\n最后只要计算数组中的每个值，即点数和对应的次数在总次数中的占比就可以了\n因为次嵌套，所以 总次数为 \nfunction twoSum(n) &#123;    var arr = [];    var mount = Math.pow(6, n)    function recursion(loop, sum) &#123;        if (loop &gt; n) &#123;            if (arr[sum] === undefined) arr[sum] = 0;            arr[sum]++;            return arr;        &#125;        for (var i = 1; i &lt;= 6; i++) &#123;            recursion(loop + 1, sum + i);        &#125;    &#125;    recursion(1, 0);    var res = [];    for (var i = 0; i &lt; arr.length; i++) &#123;        if (arr[i] !== undefined) &#123;            res.push(Number((arr[i] / mount).toFixed(5)))        &#125;    &#125;    return res;&#125;\n\n复杂度分析\n\n时间复杂度：,指数时间复杂度而且容易超时。\n\n空间复杂度： 点数和共有  种\n\n\n动态规划function twoSum(n) &#123;    var arr = [];    var mount = Math.pow(6, n)    function recursion(loop, sum) &#123;        if (loop &gt; n) &#123;            if (arr[sum] === undefined) arr[sum] = 0;            arr[sum]++;            return arr;        &#125;        for (var i = 1; i &lt;= 6; i++) &#123;            recursion(loop + 1, sum + i);        &#125;    &#125;    recursion(1, 0);    var res = [];    for (var i = 0; i &lt; arr.length; i++) &#123;        if (arr[i] !== undefined) &#123;            res.push(Number((arr[i] / mount).toFixed(5)))        &#125;    &#125;    return res;&#125;\n\nfunction twoSum(n) &#123;    var sum = Math.pow(6, n);    var f = [];    f.push([], new Array(6 + 1).fill(1, 1));    for (var i = 2; i &lt;= n; i++) &#123;        if (f[i] === undefined) f[i] = [];        for (var j = i; j &lt;= 6 * i; j++) &#123;            if (f[i][j] === undefined) f[i][j] = 0            for (var k = 1; k &lt;= 6; k++) &#123;                f[i][j] += f[i - 1][j - k] || 0            &#125;        &#125;    &#125;    var res = []    var arr = f[n];    var len = f[n].length    for (var i = 0; i &lt; len; i++) &#123;        if (arr[i] == undefined) continue;        res.push(Number((arr[i] / sum).toFixed(5)));    &#125;    return res;&#125;\n\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"LeetCode 二叉树展开为链表","url":"/posts/13ae1e52470a/","content":"二叉树展开为链表\n思考可以很自然想到的是需要一个递归，因为他需要先序遍历我们会直接进入到每个左边子树的左节点。但是这经过的右子树是暂时用不到的，所以需要想办法把他们存起来，在稍后使用\n\n\nconst flatten = (root) =&gt; &#123;  if (root === null) return root;  const stack = [];  const dig = (root) =&gt; &#123;    if (root === null) return;    const right = root.right;    root.right = null;    // 暂存右节点    if (right !== null) stack.push(right);    // 将左节点放到有节点上    // 并先序遍历继续递归向下    if (root.left !== null) &#123;      root.right = root.left;      root.left = null;      dig(root.right);    &#125; else &#123;      // 如果已经没有下面的节点      // 从队列中取出最后的右子树遍历      const next = stack.pop();      if (next == undefined) return;      root.right = next;      dig(next);    &#125;  &#125;;  dig(root);  return root;&#125;;\n\n还可以思考用 O(1) 的空间复杂度，解决这个问题。既然不能用额外的储存空间，那么可以考虑将用到的信息放在树的节点上操作。\n题目要求是以先序遍历的顺序，并且通用右指针相连，对于右指针相连这个问题我们可以弱化它，因为这可以通过节点交换很容易的完成。\n而以先序遍历顺序返回，并不意味着一定要先访问根节点，只要处理之后的链表的顺序是先序遍历就可以了，所以对于一个只有三个节点的子树来说，将右节点接在左节点的后面就是先序遍历。\n那要如何保证在访问根节点的时候，左右子树都是一个处理好的链表，我们会想到后序遍历，因为在访问某个节点的时候，他的左右子树都已经在后序遍历的代码位置处理成了链表，可以直接拼接。\n所以可以写出下面的框架\n\n\nconst dig = (root) =&gt; &#123;  if (root === null) return;  dig(root.left);  dig(root.right);  // 处理左右节点&#125;;const flatten = (root) =&gt; &#123;  if (root === null) return root;  dig(root);  return root;&#125;;\n\n思考一些具体的细节，当一个节点的左节点不存在的时候，可以直接跳过，因为它只有一个右节点的话不需要处理，或者右节点已经处理成一个链表。\n而当一个左节点存在的时候，需要能获取到左节点这个链表中的最后一个，才能和右节点相连，最后还需要交换左右节点。\n\n\nconst dig = (root) =&gt; &#123;  if (root === null) return;  dig(root.left);  dig(root.right);  let last = root.left;  // 左节点不存在，直接返回  if (last === null) return;  // 获取最后一个节点  while (last.right) &#123;    last = last.right;  &#125;  // 交换左右子树  last.right = root.right;  root.right = root.left;  root.left = null;&#125;;const flatten = (root) =&gt; &#123;  if (root === null) return root;  dig(root);  return root;&#125;;\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"LeetCode 二叉树最小/大深度","url":"/posts/8e3fe34f62a9/","content":"二叉树最小深度\n二叉树最大深度\n思考容易想到的是通过 DFS 遍历携带深度信息，记录深度最大值或最小值。\nvar minDepth = function (root) &#123;  if (root === null) &#123;    return 0;  &#125;  // 记录最小深度（根节点到最近的叶子节点的距离）  let minDepthValue = Infinity;  // 记录当前遍历到的节点深度  let currentDepth = 0;  const traverse = function (root) &#123;    if (root === null) &#123;      return;    &#125;    // 前序位置进入节点时增加当前深度    currentDepth++;    // 如果当前节点是叶子节点，更新最小深度    if (root.left === null &amp;&amp; root.right === null) &#123;      minDepthValue = Math.min(minDepthValue, currentDepth);    &#125;    traverse(root.left);    traverse(root.right);    // 后序位置离开节点时减少当前深度    currentDepth--;  &#125;;  // 从根节点开始 DFS 遍历  traverse(root);  return minDepthValue;&#125;;\n\n也可以想到为了避免全局定义深度变量，可以把深度放到递归的参数中，下面是最大深度的解法：\nconst dig = (root, length) =&gt; &#123;  if (root == null) return length;  return Math.max(dig(root.left, length + 1), dig(root.right, length + 1));&#125;;var maxDepth = function (root) &#123;  if (root === null) return 0;  // 由于退出条件是在叶子节点的左或右的null节点  // 因此深度会被多加1, 所以开始计数从0开始，可以满足条件  return dig(root, 0);&#125;;\n\n但是当用这种思路解决最小深度时，就会遇到问题。\n因为是求最小深度，因此递归到叶子节点拿到的高度，是一个无效值，它可能被一个更小的值取代。\n但是子树如果为 null,不能参与计算，因此下面的逻辑当遍历到叶子节点时，仍然递归进入空节点，导致空的子树被算作 1 的长度 返回错误的结果。\n接下来，如果只有左子树，或者右子树，是不会进入退出逻辑的，这会导致递归无法被正确的处理，当只有其中一个子树的时候，要正确处理子树的返回值。\nconst dig = (root, length) =&gt; &#123;  // 避免递归进入空节点  // + if(!node.left &amp;&amp; !node.right) return deep;  // - if (root == null) return length;  // 当只有一个子树的时候，给空的子树一个默认值 Infinity  // 因为有值的子树，一定会进入推出逻辑返回一个当前深度值  // + let left = Infinity,right=Infinity;  // + if(node.left)  left =  dfs(node.left, deep + 1);  // + if(node.right) right = dfs(node.right, deep + 1);  // - return Math.min(dig(root.left, length + 1), dig(root.right, length + 1));  return Math.min(left, right);&#125;;var maxDepth = function (root) &#123;  if (root === null) return 0;  // 从 1 开始计数  // + return dig(root, 1);  // - return dig(root, 0);&#125;;\n\n优化观察解题思路，是通过传递一个深度参数进行递归，也就是说这是从根节点开始计数，如果从叶子节点开始计数，就可以避免参数的传递。\n最大深度计算：\nvar maxDepth = function (root) &#123;    if (root === null) return 0;    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1&#125;;\n\n最小深度计算：\nvar minDepth = function (root) &#123;  if (root === null) return 0;  let left = minDepth(root.left);  let right = minDepth(root.right);  // 解决左右子树其中一个为空的情况  if (left === 0) return right + 1;  if (right === 0) return left + 1;  return Math.min(left, right) + 1;&#125;;\n\n对于最小深度，还可以考虑用 BFS 层序遍历来优化，因为最小深度，是要找到第一个叶子节点所在的深度，而不需要像 DFS 那样，每一个分支走到头才知道哪一条路径是最短的。\nvar minDepth = function (root) &#123;  let deep = 0;  if (root === null) return deep;  let queue = [root];  let len;  while ((len = queue.length)) &#123;    deep++;    const q = queue.concat([]);    queue = [];    while (len--) &#123;      const node = q.pop();      if (node.left === null &amp;&amp; node.right === null) return deep;      if (node.right) queue.push(node.right);      if (node.left) queue.push(node.left);    &#125;  &#125;  return deep;&#125;;\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"LeetCode 二叉树直径","url":"/posts/6a338e4e2cab/","content":"二叉树直径\n思考可以观察到两个现象\n\n直径可能并不会经过根节点\n所谓的直径就是某个节点的左子树深度加右子树深度最长的一条\n\n那既然是获取最长的子树，是不能能套用一个之前的求 二叉树最大深度 的方法, 思考以下可以使用下面这个框架么\n这可能行不通，因为提出了 maxDeep 方法导致调用时，只能作用在根节点的左右子树。替他节点无法调用这个模式递归。\nconst maxDeep = (root) =&gt; &#123;  if (root === null) return 0;  return Math.max(maxDeep(root.left), maxDeep(root.right)) + 1;&#125;;var diameterOfBinaryTree = function (root) &#123;  //...&#125;;\n\n既然这样就放到内部去做, 但是这种框架面临的问题是，返回值只有一个，希望可以知道左右子树的最大深度，又要保留着已经遍历过的子树的最大直径。\nvar diameterOfBinaryTree = function (root) &#123;  if (root === null) return 0;  let l = diameterOfBinaryTree(root.left);  let r = diameterOfBinaryTree(root.right);  // return Math.max(l + r, l, r) + 1;&#125;;\n\n那就再引入一个额外的变量去保存，最大直径，让递归可以专注与子树的最大深度\nvar diameterOfBinaryTree = function (root) &#123;  if (root === null) return 0;  let max = 0;  const dig = (root) =&gt; &#123;    if (root === null) return 0;    let left = dig(root.left);    let right = dig(root.right);    max = Math.max(max, left + right);    return Math.max(left, right) + 1;  &#125;;  dig(root);  return max;&#125;;\n\n再来看一下，其实用前序遍历也可以实现，但是需要每经历一个节点，就要获取以下当前节点的左右子树的最大深度。\n这是因为前序遍历只能获取当前节点的信息，而后序遍历则可以携带上一个节点返回的信息。\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"LeetCode 填充每个节点的下一个右侧节点指针","url":"/posts/0d16fafcd38e/","content":"填充每个节点的下一个右侧节点指针\n思考相同层级的操作可以想到的是层序遍,但是题目中有一个问题没有说清楚,下一个右侧节点表示紧邻的右侧节点,空节点也算是一个节点,换句话说空节点不能跳过\n在思考一下其中的细节,需要清楚一层有多少个节点，这样才能准确遍历到一层的末尾, 链接的时候空的节点不能跳过，因为这也是合法的节点。\nconst connect = (root) =&gt; &#123;  if (root === null) return null;  const queue = [root];  while (queue.length) &#123;    // 记录每一层的长度    let len = queue.length;    while (len--) &#123;      const node = queue.shift();      if (len &amp;&amp; node) node.next = queue[0];      // 不需要判断空节点      if (node) queue.push(node.left, node.right);    &#125;  &#125;  return root;&#125;;\n\n这个问题也可以用,递归来解决,因为它可以抽象成更小的子问题，也就是链接两个节点，需要知道的是哪些节点是需要链接的。\n如果盲目的套用递归框架就会困惑，在另外一个子树的节点，怎么能获取到呢。\nconst connect = (root) =&gt; &#123;  if (root === null) return root;  if (root.left) root.next = root.right;  // 无法获取另外子树的节点  return root;&#125;;\n\n所以需要指明，那两个节点需要链接，这也是一个先序遍历的模型，但是子问题需要传递更多的信息。\nconst dig = (left, right) =&gt; &#123;  // 链接两个节点  if (left) left.next = right;  if (left) dig(left.left, left.right);  if (right) dig(right.left, right.right);  // 不同子树中需要连接的节点  if (left &amp;&amp; right) dig(left.right, right.left);&#125;;const connect = (root) =&gt; &#123;  if (root === null) return root;  dig(root.left, root.right);  return root;&#125;;\n","categories":["算法","关联题目"],"tags":["算法","关联题目"]},{"title":"图","url":"/posts/ca6c7a2ea945/","content":"图的相关术语图是网络结构的抽象模型。是一组由边连接的节点（或顶点）\n任何二元关系都可以用图来表示。\n数学上表示为 , 表示一组顶点， 表示一组边，连接中的顶点\n\n相关概念\n由一条边连接在一起的顶点称为相邻顶点。比如，A 和B 是相邻的，A 和D 是相邻的，A 和C 是相邻的，A 和E 不是相邻的。\n\n一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此A 的度为3；E和其他两个顶点相连，因此E 的度为2。\n\n路径是顶点v1, v2, …, vk 的一个连续序列，其中vi 和vi+1 是相邻的。以上一示意图中的图为例，其中包含路径A B E I 和A C D G。\n\n简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如A D C A（最后一个顶点重新回到A）\n\n如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。\n\n\n有向图 无向图图可以是无向的（边没有方向）或是有向的（有向图）。第一张图是无向图，下面这张是有向图\n\n如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和D 是强连通的，而A 和B 不是强连通的。\n图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。\n\n应用\n搜索图中的一个特定顶点或搜索一条特定边\n\n寻找图中的一条路径（从一个顶点到另一个顶点\n\n寻找两个顶点之间的最短路径，以及环检测。\n\n\n图的表示邻接矩阵每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。\n如果索引为i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则array[i][j] &#x3D;&#x3D;&#x3D; 0，如下图所示。\n\n由于不是强连通图（每两个节点间都存在路径），所以数组中有大量的0\n给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。\n邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，修改二维数组不够灵活。\n邻接表邻接表由图中每个顶点的相邻顶点列表所组成。\n存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。\n\n对大多数问题来说都是更好的选择\n但要找出顶点 v 和 w 是否相邻，使用邻接矩阵会比较快\n关联矩阵关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，\n使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1\n否则，array[v][e] === 0\n\n关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存。\n创建Graph 类类的结构\n图是否有向，默认无无向图 ①\n\n使用一个数组来储存顶点的名字 ②\n\n使用一个字典来储存邻接表，字典将会使用顶点的名字作为键，邻接顶点列表作为值 ③\n\n\nclass Graph &#123;  constructor(isDirected = false) &#123;    this.isDirected = isDirected; // ①    this.vertices = []; // ②    this.adjList = new Map(); // ③  &#125;&#125;\n\n插入顶点方法\n如果顶点不存 ④ 在顶点列表中添加节点 ⑤ \n\n在邻接表中为该顶点创建空数组 ⑥\n\n\naddVertex(v) &#123;  if (!this.vertices.has(v)) &#123; // ④    this.vertices.push(v); // ⑤     this.adjList.add(v, []); // ⑥  &#125;&#125;\n\n建立链接方法\n如果建立链接的两个点不在顶点列表中，要先填入顶点列表\n\n将 w 加入到 v 的邻接表中，表示添加了一条自顶点 v 到顶点 w 的边\n\n无向图需要添加一条自 w 到 v 的边\n\n\naddEdge(v, w) &#123;  if (!this.adjList.has(v)) &#123;    this.addVertex(v);  &#125;  if (!this.adjList.has(w)) &#123;    this.addVertex(w);  &#125;  this.adjList.get(v).push(w);  if (!this.isDirected) &#123;    this.adjList.get(w).push(v);  &#125;&#125;\n\n请注意我们只是往数组里新增元素，因为数组已经在行 ⑥ 被初始化了\n\n取值一个返回顶点列表，另一个返回邻接表\ngetVertices() &#123;  return this.vertices;&#125;getAdjList() &#123;  return this.adjList;&#125;\n\n测试class Graph &#123;  constructor(isDirected = false) &#123;    this.isDirected = isDirected; // &#123;1&#125;    this.vertices = []; // &#123;2&#125;    this.adjList = new Map(); // &#123;3&#125;  &#125;  addVertex(v) &#123;    if (!this.vertices.includes(v)) &#123; // &#123;5&#125;      this.vertices.push(v); // &#123;6&#125;      this.adjList.set(v, []); // &#123;7&#125;    &#125;  &#125;  addEdge(v, w) &#123;    if (!this.adjList.has(v)) &#123;      this.addVertex(v);    &#125;    if (!this.adjList.has(w)) &#123;      this.addVertex(w);    &#125;    this.adjList.get(v).push(w);    if (!this.isDirected) &#123;      this.adjList.get(w).push(v);    &#125;  &#125;  getVertices() &#123;    return this.vertices;  &#125;  getAdjList() &#123;    return this.adjList;  &#125;  toString() &#123;    let s = &#x27;&#x27;;    for (let i = 0; i &lt; this.vertices.length; i++) &#123; // &#123;15&#125;      s += `$&#123;this.vertices[i]&#125; -&gt; `;      const neighbors = this.adjList.get(this.vertices[i]); // &#123;16&#125;      for (let j = 0; j &lt; neighbors.length; j++) &#123; // &#123;17&#125;        s += `$&#123;neighbors[j]&#125; `;      &#125;      s += &#x27;\\n&#x27;; // &#123;18&#125;    &#125;    return s;  &#125;&#125;const graph = new Graph();const myVertices = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;]; // &#123;12&#125;for (let i = 0; i &lt; myVertices.length; i++) &#123; // &#123;13&#125;  graph.addVertex(myVertices[i]);&#125;graph.addEdge(&#x27;A&#x27;, &#x27;B&#x27;); // &#123;14&#125;graph.addEdge(&#x27;A&#x27;, &#x27;C&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;D&#x27;);graph.addEdge(&#x27;C&#x27;, &#x27;D&#x27;);graph.addEdge(&#x27;C&#x27;, &#x27;G&#x27;);graph.addEdge(&#x27;D&#x27;, &#x27;G&#x27;);graph.addEdge(&#x27;D&#x27;, &#x27;H&#x27;);graph.addEdge(&#x27;B&#x27;, &#x27;E&#x27;);graph.addEdge(&#x27;B&#x27;, &#x27;F&#x27;);graph.addEdge(&#x27;E&#x27;, &#x27;I&#x27;);console.log(graph.toString());\n\n图的遍历有两种算法可以对图进行遍历：广度优先搜索（breadth-first search，BFS） 和 深度优先搜索（depth-first search，DFS）\n图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等。\n图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。\n完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。\n为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。\n广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构，如下表所示。\n\n\n\n算法\n数据结构\n描述\n\n\n\n深度优先搜索\n栈\n将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问\n\n\n广度优先搜索\n队列\n将顶点存入队列，最先入队列的顶点先被探索\n\n\n广度优先遍历队列结构是广度优先遍历的精髓\n从起点节点开始相邻的节点会被添加到队列中\n因为队列有先进先出的性质，所以相邻的节点在遍历队列的时候会先被拿到，从而是实现了广度优先遍历\n下一个关键点是如何知道节点没有被重复访问，解决办法是给访问过的节点打一个标记，如果下次访问相同的节点就跳过\nWHITE: 表示没有被访问过 GARY: 访问过但是没有遍历子节点 BALCK: 节点和子结点都被访问过\n// startVertex 指定遍历的起点function breadthFirstSearch(graph, startVertex, callback) &#123;  // 拿到节点列表  const vertices = graph.getVertices()  // 拿到邻接表结构  const adjList = graph.getAdjList();  //标记是否访问过 默认所有节点都是白色没有访问过  const color = &#123;&#125;  for (var i = 0; i &lt; vertices.length; i++) &#123;    color[vertices[i]] = &quot;WHITE&quot;  &#125;  // 创建一个队列  const queue = [];  queue.push(startVertex);  while (queue.length) &#123;    const node = queue.shift();    const nabor = adjList.get(node)    color[node] = &#x27;GARY&#x27;;    for (let v of nabor) &#123;      if(color[v] === &#x27;WHITE&#x27;)&#123;        color[v] = &quot;GARY&quot;        queue.push(v);      &#125;    &#125;    color[v] = &quot;BLACK&quot;    console.log(node);  &#125;&#125;breadthFirstSearch(graph,myVertices[0])\n\n使用广度优先寻找最短路径因为使用了广度优先，所以会先访问距离为1的节点，然后是距离为2的节点，路径长的那一条线路，因为同一个节点被访问过，所以不会被记录，从而记录的都是每个节点到起点的最短路径\n// startVertex 指定遍历的起点function breadthFirstSearch(graph, startVertex, callback) &#123;  // 拿到节点列表  const vertices = graph.getVertices()  // 拿到邻接表结构  const adjList = graph.getAdjList();  //标记是否访问过 默认所有节点都是白色没有访问过  const color = &#123;&#125;  // 距离  const distance = &#123;&#125;;  // 回溯节点 标识上一个节点是什么  const predecessors = &#123;&#125;  for (let i = 0; i &lt; vertices.length; i++) &#123;    color[vertices[i]] = &quot;WHITE&quot;  &#125;  // 创建一个队列  const queue = [];  queue.push(startVertex);  // 初始化默认距离，和回溯节点  for(let i = 0; i &lt; vertices.length; i++)&#123;    distance[vertices[i]] = 0;    predecessors[vertices[i]] = null  &#125;  while (queue.length) &#123;    const node = queue.shift();    const nabor = adjList.get(node)    color[node] = &#x27;GARY&#x27;;    for (let v of nabor) &#123;      if (color[v] === &#x27;WHITE&#x27;) &#123;        // 上级节点的最短路进        distance[v] = distance[node] + 1;        // 指定当前节点的上级节点        predecessors[v] = node;        color[v] = &quot;GARY&quot;        queue.push(v);      &#125;    &#125;  &#125;  console.log(    distance,    predecessors  )&#125;breadthFirstSearch(graph, myVertices[0])\n\n通过生成的前溯表以及所有的节点我们可以生成每个节点到头节点的最短路径\n// 遍历每一个节点for (let v of myVertices) &#123;  const path = [];  // 如果当前节点不是头节点，就存入上一个节点  for (let w = v; w !== null; w = shortestPathA.predecessors[w]) &#123;    path.push(w);  &#125;  let s = path.pop();  //反向拼接每一个节点  while (path.length) &#123;    s += &#x27;-&#x27; + path.pop()  &#125;  console.log(s);&#125;\n\n深度优先遍历因为深度优先需要把一条路径遍历到底，所以拿到的节点需要继续遍子结点\n所以深度优先的精髓就是栈的结构，拿到的子结点加入栈中，由于栈先进先出可以继续访问下层的子结点\nconst fn = function (graph) &#123;  const vertices = graph.getVertices();  const adjList = graph.getAdjList();  const color = &#123;&#125;;  for (let v of vertices) &#123;    color[v] = &quot;WHITE&quot;;  &#125;  // 栈结构  const stack = [];  stack.unshift(vertices[0]);  // 如果栈不为空就继续遍历  while (stack.length) &#123;    const v = stack.shift();    // 如果没有访问过就访问子结点    if (color[v] === &quot;WHITE&quot;) &#123;      color[v] = &#x27;GARY&#x27;;      // 获取到子结点 放入栈中      const nabor = adjList.get(v);      for (let vn of nabor.reverse()) &#123;        stack.unshift(vn);      &#125;    &#125;  &#125;&#125;fn(graph)\n\n这种写法可以实现遍历，但是不方便统计某个节点的子结点是否全部遍历，也就是置成BLACK\n另一个关键点，函数递归调用也可以调用栈，保存每个函数的调用帧, 所以深度优先也常用递归来解决\nconst fn = function (graph) &#123;  const vertices = graph.getVertices();  const adjList = graph.getAdjList();  const color = &#123;&#125;;  for (let v of vertices) &#123;    color[v] = &quot;WHITE&quot;;  &#125;  depthFirstSearch(vertices[0], adjList, color);&#125;const depthFirstSearch = function (v, adjList, color) &#123;  const nabor = adjList.get(v);  if (color[v] === &#x27;WHITE&#x27;) &#123;  console.log(v);    color[v] = &#x27;GARY&#x27;    for (let vn of nabor) &#123;      depthFirstSearch(vn, adjList, color);    &#125;    // 子结点遍历完成之后标记为黑色    color[v] === &#x27;BLACK&#x27;  &#125;&#125;fn(graph)\n\n加入节点信息在遍历图的时候加入更多的节点信息\n1.每个节点的发现时间，到达某个节点经历的步数2.每个节点的访问时间，某个节点所有子结点都被访问过的步数3.节点的前溯节点表\nconst depthFirstSearch = function (v, adjList, color, find, visit, back, time) &#123;  const nabor = adjList.get(v);  if (color[v] === &#x27;WHITE&#x27;) &#123;    find[v] = ++(time.t);    color[v] = &#x27;GARY&#x27;    for (let vn of nabor) &#123;      back[vn] = v;      depthFirstSearch(vn, adjList, color, find, visit, back, time);    &#125;    color[v] === &#x27;BLACK&#x27;    visit[v] = ++(time.t);  &#125;&#125;const fn = function (graph,) &#123;  const vertices = graph.getVertices();  const adjList = graph.getAdjList();  const color = &#123;&#125;;  const find = &#123;&#125;;// 发现时间  const visit = &#123;&#125;;// 访问时间  const back = &#123;&#125;;// 回溯时间  const time = &#123; t: 0 &#125;//用于计时  for (let v of vertices) &#123;    color[v] = &quot;WHITE&quot;;    //初始化    find[v] = 0;    visit[v] = 0;    back[v] = null;  &#125;  depthFirstSearch(vertices[0], adjList, color, find, visit, back, time);  return &#123;    find, visit, back, time  &#125;&#125;fn(graph)\n\n通过深度优先搜索拓扑排序有些任务需要按顺序执行，而且不同的任务会公用一些子任务，编排这些有序任务被成为拓扑排序\n\n这些任务形成了有向无环图，通过上面一节添加的节点信息，生成这些任务的执行顺序\n首先生成图\ngraph = new Graph(true); // 有向图myVertices = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;];for (i = 0; i &lt; myVertices.length; i++) &#123;    graph.addVertex(myVertices[i]);&#125;graph.addEdge(&#x27;A&#x27;, &#x27;C&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;D&#x27;);graph.addEdge(&#x27;B&#x27;, &#x27;D&#x27;);graph.addEdge(&#x27;B&#x27;, &#x27;E&#x27;);graph.addEdge(&#x27;C&#x27;, &#x27;F&#x27;);graph.addEdge(&#x27;F&#x27;, &#x27;E&#x27;);\n\n添加节点信息\nconst depthFirstSearch = function (v, adjList, color, find, visit, back, time) &#123;      const nabor = adjList.get(v);      if (color[v] === &#x27;WHITE&#x27;) &#123;        find[v] = ++(time.t);        color[v] = &#x27;GARY&#x27;        for (let vn of nabor) &#123;          back[vn] = v;          depthFirstSearch(vn, adjList, color, find, visit, back, time);        &#125;        color[v] === &#x27;BLACK&#x27;        visit[v] = ++(time.t);      &#125;    &#125;    const fn = function (graph,) &#123;      const vertices = graph.getVertices();      const adjList = graph.getAdjList();      const color = &#123;&#125;;      const find = &#123;&#125;;// 发现时间      const visit = &#123;&#125;;// 访问时间      const back = &#123;&#125;;// 回溯时间      const time = &#123; t: 0 &#125;//用于计时      for (let v of vertices) &#123;        color[v] = &quot;WHITE&quot;;        //初始化        find[v] = 0;        visit[v] = 0;        back[v] = null;      &#125;      // 因为有向图，每个节点不一定能到达其他节点      for(let v of vertices)&#123;        depthFirstSearch(v, adjList, color, find, visit, back, time);      &#125;      return &#123;        find, visit, back, time      &#125;    &#125;    fn(graph)\n\n通过节点信息经行拓扑排序,按照访问时间从大到小\nObject.entries(visit).sort((it, it2) =&gt; it2[1] - it1[1])","categories":["算法","数据结构"],"tags":["算法","数据结构","图"]},{"title":"栈","url":"/posts/0fa718cef75e/","content":"有两种类似于数组的数据结构在添加和删除元素时更为可控，它们就是栈和队列。\n栈数据结构栈是一种遵从后进先出（LIFO）原则的有序集合\nclass stack &#123;    constructor() &#123;        this.items = [];    &#125;    push(...elements) &#123;        return this.items.push(...elements)    &#125;    pop() &#123;        return this.items.pop()    &#125;    peek() &#123;        return this.items[this.items.length - 1];    &#125;    isEmpty() &#123;        return Boolean(this.items.length)    &#125;    clear() &#123;        this.items = [];    &#125;    size() &#123;        return this.items.length;    &#125;&#125;\n\n对于大量数据的使用使用一个对象来存储数据，查询效率更高\nclass stack &#123;    constructor() &#123;        this.count = 0;        this.items = &#123;&#125;;    &#125;    push(...elements) &#123;        this.items[this.count] = elements;        this.count++;    &#125;    pop() &#123;        if (this.isEmpty()) &#123;            return undefined;        &#125;        this.count--;        const element = this.items[this.count]        delete this.items[this.count]        return element;    &#125;    peek() &#123;        if (isEmpty()) &#123;            return undefined;        &#125;        return this.items[this.count - 1];    &#125;    isEmpty() &#123;        return this.count === 0;    &#125;    clear() &#123;        this.items = &#123;&#125;;        this.count = 0;    &#125;    size() &#123;        return this.count + 1;    &#125;    toString() &#123;        if (this.isEmpty()) &#123;            return &#x27;&#x27;;        &#125;        let objString = `$&#123;this.items[0]&#125;`; // &#123;1&#125;        for (let i = 1; i &lt; this.count; i++) &#123; // &#123;2&#125;            objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`; // &#123;3&#125;        &#125;        return objString;    &#125;&#125;\n\n私有属性&#x2F;方法新的提案通过#来声明私有属性\n现阶段通过设置 Proxy 来禁止对类属性的访问\n进制转换十进制转二进制\nfunction decimalToBinary(decNumber) &#123;  const remStack = new Stack();  let number = decNumber;  let rem;  let binaryString = &#x27;&#x27;;  while (number &gt; 0) &#123; // &#123;1&#125;    rem = Math.floor(number % 2); // &#123;2&#125;    remStack.push(rem); // &#123;3&#125;    number = Math.floor(number / 2); // &#123;4&#125;  &#125;  while (!remStack.isEmpty()) &#123; // &#123;5&#125;    binaryString += remStack.pop().toString();  &#125;  return binaryString;&#125;\n\n和其他任意的进制转换\nfunction convert(decNumber, base) &#123;  const remStack = [];  const digs = &#x27;0123456789abcdefghijklmnopqrstuvwxyz&#x27;  let number = decNumber;  let rem;  let binaryString = &#x27;&#x27;;  while (number &gt; 0) &#123;    rem = Math.floor(number % base);    remStack.push(rem);    number = Math.floor(number / base);  &#125;  while (!remStack.isEmpty()) &#123; // &#123;5&#125;    binaryString += digs[remStack.pop()];    return binaryString;  &#125;&#125;\n\n","categories":["算法","数据结构"],"tags":["算法","数据结构","栈"]},{"title":"队列和双端队列","url":"/posts/733653913063/","content":"队列数据结构队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。\n创建队列通过双指针标明队列的头尾\nclass Queue &#123;    constructor() &#123;        this.count = 0;        this.lowestCount = 0;        this.items = &#123;&#125;;    &#125;    enqueue(element) &#123;        this.items[this.count] = element;        this.count++;    &#125;    dequeue() &#123;        if (this.isEmpty()) &#123;            return undefined;        &#125;        const result = this.items[this.lowestCount];        delete this.items[this.lowestCount];        this.lowestCount++;        return result;     &#125;    peek() &#123;        if (this.isEmpty()) &#123;            return undefined;        &#125;        return this.items[this.lowestCount];    &#125;    isEmpty() &#123;        return this.count - this.lowestCount === 0;    &#125;    size() &#123;        return this.count - this.lowestCount;    &#125;    clear() &#123;        this.items = &#123;&#125;;        this.count = 0;        this.lowestCount = 0;    &#125;    toString() &#123;        if (this.isEmpty()) &#123;            return &#x27;&#x27;;        &#125;        let objString = `$&#123;this.items[this.lowestCount]&#125;`;        for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123;            objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`;        &#125;        return objString;    &#125;&#125;\n\n双端队列数据结构双端队列（deque，或称double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列。\n双端队列的一个常见应用是存储一系列的撤销操作\n在头部插入的时候为了保证头部索引为0，类似数组的性质，也可以把所有的元素都向后移动一位\nclass Deque &#123;    constructor() &#123;        this.count = 0;        this.lowestCount = 0;        this.items = &#123;&#125;;    &#125;    addFront(element) &#123;        this.lowestCount--;        this.items[this.lowestCount] = element;    &#125;    addBack(element) &#123;        this.items[this.count] = element;        this.count++;    &#125;    removeFront() &#123;        if (this.isEmpty()) return;        const ele = this.items[this.lowestCount];        delete this.items[this.lowestCount];        this.lowestCount++;        return ele;    &#125;    removeBack() &#123;        if (this.isEmpty()) return;        const ele = this.items[this.count];        delete this.items[this.count];        this.lowestCount--;        return ele;    &#125;    peekFront() &#123;        return this.items[this.lowestCount];    &#125;    peekBack() &#123;        return this.items[this.count - 1];    &#125;    isEmpty() &#123;        return this.count === this.lowestCount    &#125;    size() &#123;        return this.count - this.lowestCount    &#125;    clear() &#123;        this.count = 0;        this.lowestCount = 0;        this.items = &#123;&#125;;    &#125;&#125;\n\n循环队列队列模拟循环队列，击鼓传花问题\n规则：有五位玩家，从第一位开始游戏，每轮游戏传7次，结束后花在谁手里，谁就被淘汰，从下一个人继续开始\n\n把玩家加入到上面创建好的队列中\n\nconst player = [&#x27;John&#x27;, &#x27;Jack&#x27;, &#x27;Camila&#x27;, &#x27;Ingrid&#x27;, &#x27;Carl&#x27;];const queue = new Queue();for (let p of player) &#123;    queue.enqueue(p);&#125;\n\n\n\ngame函数执行，表示游戏开始，输入每轮传花次数7，最终返回获胜玩家\n每次传花经过的人，添加到队列尾部，形成一个循环队列，循环停止时，队列头部的就是拿到花的人，被淘汰即从头部移除\n\n\nfunction game(queue, nums) &#123;    while (queue.size() &gt; 1) &#123;        for (let i = 0; i &lt; nums; i++) &#123;            queue.enqueue(queue.dequeue());        &#125;        console.log(&quot;淘汰==&quot; + queue.dequeue())    &#125;    console.log(&#x27;获胜==&#x27; + queue.peek());&#125;game(queue, 7)\n\n解决回文数可以通过栈这种数据结构解决\n本章也可以使用双端队列解决，先把字符串插入到双端队列中，通过while循环检查头部元素和尾部元素是否相同，不同则跳出\nJavaScript 任务队列在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处理所有的任务，称为事件循环。\n浏览器要负责多个任务，如渲染HTML、执行JavaScript 代码、处理用户交互（用户输入、鼠标点击等）、执行和处理异步请求\n","categories":["算法","数据结构"],"tags":["算法","数据结构","队列"]},{"title":"链表","url":"/posts/052762c3e747/","content":"单向链表class CreateNode &#123;  constructor(value) &#123;    this.value = value;    this.next = null;  &#125;&#125;class LinkedList &#123;  constructor() &#123;    // 内部使用头节点便于控制    this._head = &#123; next: null &#125;;    // 对外头节点    this.count = 0;  &#125;  push(node) &#123;    let cur = this._head;    // 找到链表中的最后一个    while (cur.next !== null) &#123;      cur = cur.next;    &#125;    this.count += 1;    cur.next = node;  &#125;  // 把指定位置元素移除  removeAt(index) &#123;    if (index &lt; 0 || index &gt;= this.count) return undefined;    let cur = this._head;    let res = null;    let count = 0;    // 拿到目标节点的前一个节点    while (index !== count) &#123;      cur = cur.next;      count++;    &#125;    // 保存目标节点    res = cur.next;    // 拼接后面的节点    cur.next = cur.next.next;    this.count -= 1;    return res;  &#125;  // 查找指定位置元素  getItem(index) &#123;    let count = 0;    if (index &lt; 0 || index &gt;= this.count) return undefined;    let cur = this._head;    while (count !== index) &#123;      cur = cur.next;      count++;    &#125;    return cur.next;  &#125;  // 在任意位置插入元素  insert(index, node) &#123;    // 边界处理,因为可以在最有一个节点之后插入,所以不需要判断index和长度项等的情况    if (index &lt; 0 || index &gt; this.count) return;    //插入元素是在指定位置元素的前面插入    let cur = this._head;    let count = 0;    // 找到插入位置的节点,把新节点链接到当前节点    while (index !== count) &#123;      cur = cur.next;      count += 1;    &#125;    // 保存下一个节点    const next = cur.next;    cur.next = node;    node.next = next;    this.count += 1;  &#125;  // 返回一个元素的位置  indexOf(node) &#123;    let count = 0;    let cur = this.head;    while (cur !== null) &#123;      if (node === cur) return count;      cur = cur.next;      count += 1;    &#125;    return -1;  &#125;  // 移除某个元素  remove(node) &#123;    const index = this.insert(node);    return this.removeAt(index);  &#125;  // 获取头节点  getHead() &#123;    return this._head.next;  &#125;&#125;const list = new LinkedList();list.push(new CreateNode(1))list.push(new CreateNode(2))list.push(new CreateNode(3))list.insert(3, new CreateNode(4))console.log(list.getHead())\n\n\n双向链表class CreateNode &#123;  constructor(value) &#123;    this.value = value;    this.next = null;    this.prev = null;  &#125;&#125;class DoublyLinkedList &#123;  constructor() &#123;    // 添加头节点信息    this._head = &#123;      next: null,      prev: null    &#125;;    this.count = 0;  &#125;  push(node) &#123;    let cur = this._head;    // 找到链表中的最后一个    while (cur.next !== null) &#123;      cur = cur.next;    &#125;    // 没有初始化头节点的时候不需要指明prev    if (this._head.next !== null) &#123;      node.prev = cur;    &#125;    cur.next = node;    this.count += 1;    return this.count;  &#125;  // 把指定位置元素移除  removeAt(index) &#123;    if (index &lt; 0 || index &gt;= this.count) return undefined;    let cur = this._head;    let res = null;    let count = 0;    // 拿到目标节点的前一个节点    while (index !== count) &#123;      cur = cur.next;      count++;    &#125;    // 保存需要返回的目标节点    res = cur.next;    // 移除之后要修复后一个节点的prev指针    // 需要把修复prev的操作放在前面,因为下一步保存的时候仍然保留了,后一个节点的错误引用    cur.next.next.prev = cur    // 拼接后面的节点    cur.next = cur.next.next;    this.count -= 1;    return res;  &#125;  // 查找指定位置元素  getItem(index) &#123;    let count = 0;    if (index &lt; 0 || index &gt;= this.count) return undefined;    let cur = this._head;    while (count !== index) &#123;      cur = cur.next;      count++;    &#125;    return cur.next;  &#125;  // 在任意位置插入元素  insert(index, node) &#123;    // 边界处理,因为可以在最有一个节点之后插入,所以不需要判断index和长度项等的情况    if (index &lt; 0 || index &gt; this.count) return;    //插入元素是在指定位置元素的前面插入    let cur = this._head;    let count = 0;    // 找到插入位置的节点,把新节点链接到当前节点    while (index !== count) &#123;      cur = cur.next;      count += 1;    &#125;    // 对节点的引用应该是先修复指针,在赋值    // 保存下一个节点    const next = cur.next;    // 下一个节点的prev;    next.prev = node;    // 新节点的next    node.next = next;    // 新节点的prev    node.prev = cur;    // 前一个节点的next    cur.next = node;    this.count += 1;  &#125;  // 返回一个元素的位置  indexOf(node) &#123;    let count = 0;    let cur = this.head;    while (cur !== null) &#123;      if (node === cur) return count;      cur = cur.next;      count += 1;    &#125;    return -1;  &#125;  // 移除某个元素  remove(node) &#123;    const index = this.insert(node);    return this.removeAt(index);  &#125;  // 获取头节点  getHead() &#123;    return this._head.next;  &#125;&#125;\n\n循环链表和前面两种链表相比,循环链表需要拿到,返回的那个头节点,用于判断是否是最后一个节点\nclass CreateNode &#123;  constructor(value) &#123;    this.value = value;    this.next = null;  &#125;&#125;class CircularLinkedList &#123;  constructor() &#123;    this._head = &#123;      next: null,    &#125;;    this.count = 0;  &#125;  push(node) &#123;    let cur = null;    // 没有初始化头节点则    if (this.getHead() == null) &#123;      cur = this._head;      // 最有一个节点指向自己      node.next = node;    &#125; else &#123;      // 如果已经有了头节点,保存头节点用于修复指针      const head = this.getHead();      cur = head;      while (cur.next !== head) &#123;        cur = cur.next;      &#125;      node.next = head;    &#125;    cur.next = node;    this.count += 1;    return this.count;  &#125;  // 把指定位置元素移除  removeAt(index) &#123;    if (index &lt; 0 || index &gt;= this.count) return undefined;    // 保存下真实的头节点    const head = this.getHead()    let cur = this._head;    let res = null;    let count = 0;    // 拿到目标节点的前一个节点    while (index !== count) &#123;      cur = cur.next;      count++;    &#125;    // 保存需要返回的目标节点    res = cur.next;    // 如果是头节点    if (index === 0) &#123;      // 拿到最后一个节点,修复next指针      const tail = this.getItem(this.count - 1);      tail.next = cur.next.next;      cur.next = cur.next.next;    &#125;    // 如果被移除的节点是最后一个节点    else if (index === this.count - 1) &#123;      cur.next = head;    &#125; else &#123;      cur.next = cur.next.next;    &#125;    this.count -= 1;    return res;  &#125;  // 查找指定位置元素  getItem(index) &#123;    let count = 0;    if (index &lt; 0 || index &gt;= this.count) return undefined;    let cur = this._head;    while (count !== index) &#123;      cur = cur.next;      count++;    &#125;    return cur.next;  &#125;  // 在任意位置插入元素  insert(index, node) &#123;    // 边界处理,因为可以在最有一个节点之后插入,所以不需要判断index和长度项等的情况    if (index &lt; 0 || index &gt; this.count) return;    //插入元素是在指定位置元素的前面插入    const head = this.getHead();    let cur = this._head;    let count = 0;    // 找到插入位置的节点,把新节点链接到当前节点    while (index !== count) &#123;      cur = cur.next;      count += 1;    &#125;    // 末尾插入要修复next    if (index === this.count - 1) &#123;      node.next = head;    &#125;    // 头部插入    if (index === 0) &#123;      const tail = this.getItem(this.count - 1);      tail.next = node;    &#125;    const next = cur.next;    cur.next = node;    node.next = next;    this.count += 1;  &#125;  // 返回一个元素的位置  indexOf(node) &#123;    let count = 0;    let cur = this.head;    while (count &lt; this.count) &#123;      if (node === cur) return count;      cur = cur.next;      count += 1;    &#125;    return -1;  &#125;  // 移除某个元素  remove(node) &#123;    const index = this.insert(node);    return this.removeAt(index);  &#125;  // 获取头节点  getHead() &#123;    return this._head.next;  &#125;&#125;","categories":["算法","数据结构"],"tags":["算法","数据结构","链表"]},{"title":"集合","url":"/posts/70e91da5d313/","content":"Set集合的实现class Set &#123;  constructor() &#123;    this.set = &#123; &quot;a&quot;: 1, __proto__: &#123; b: 1 &#125; &#125;;  &#125;  has(element) &#123;    return Object.prototype.hasOwnProperty.call(this.set, element)  &#125;  add(element) &#123;    if (!this.has(element)) &#123;      this.set[element] = element;      return true;    &#125;    return false;  &#125;  delete(element) &#123;    if (this.has(element)) &#123;      Reflect.deleteProperty(this.set, element)      return true;    &#125;    return false;  &#125;  clear() &#123;    this.items = &#123;&#125;;  &#125;  size() &#123;    return Reflect.ownKeys(this.set).length  &#125;  values() &#123;    return Object.values(this.items);  &#125;&#125;\n\n集合运算\n并集\n\nfunction union(A, B) &#123;  const set = new Set();  A.values().forEach(v =&gt; &#123;    set.add(v)  &#125;);  B.values().forEach(v =&gt; &#123;    set.add(v)  &#125;);  return set;&#125;\n\n\n交集\n\nfunction intersection(A, B) &#123;  const set = new Set();  A.values().forEach(item =&gt; &#123;    if (B.has(item)) &#123;      set.add(item);    &#125;  &#125;);  return set;&#125;\n\n\n差集\n\nA与B的差集表示存在于A，但是不存在于B\nB与A的差集表示存在于B，但是不存在于A\nfunction differenceSet(A, B) &#123;  const set = new Set();  A.values().forEach(item =&gt; &#123;    if (!B.has(item)) &#123;      set.add(item);    &#125;  &#125;);  return set;&#125;\n\n只需要遍历集合长度较小的一个即可\nfunction differenceSet(A, B) &#123;  const set = new Set();  let smallSet = A;  let bigSet = B;  if (smallSet.values().length &gt; bigSet.values().length) &#123;    smallSet = B;    bigSet = A;  &#125;  smallSet.values().forEach(item =&gt; &#123;    if (!bigSet.has(item)) &#123;      set.add(item);    &#125;  &#125;);  return set;&#125;\n\n\n子集\n\nfunction childSet(A, B) &#123;  return B.values().every(item =&gt; A.has(item))&#125;\n\n","categories":["算法","数据结构"],"tags":["算法","数据结构","集合"]},{"title":"ReactHooks没有魔法只是数组","url":"/posts/90febc06ed69/","content":"Hooks规则Hooks在使用的时候有两条铁律：\n\n不要在循环，条件语句，深层函数调用Hooks\n\n只在React函数组件中调用Hooks\n\n\nuseState实现下面代码只是一个demo，是为了让我们理解hooks大概是怎么运作的。这不是 React 中的真正内部实现。\nstate初始化创建两个空数组，分别用来存放 setters 和 state，将 指针 指到 0 的位置：\n\n组件首次render当首次render这个函数组件的时候。\n每一个 useState 调用，当 首次 执行的时候，在 setter 数组里加入一个 setter 函数(和对应的数组index关联)；然后，将 state 加入对应的 state 数组里：\n\n组件后续(非首次)render后续组件的每次render，指针都会重置为 0 ，每调用一次 useState，都会返回指针对应的两个数组里的 state 和 setter，然后将指针位置 +1。\n\nsetter调用处理每一个 setter 函数，都关联了对应的指针位置。当调用某个 setter 函数式，就可以通过这个函数所关联的指针，找到对应的 state，修改state数组里对应位置的值：\n\n为什么hooks的调用顺序不能变呢？useState 是在一个 条件分支里。看看这样引入的bug。\nlet firstRender = true;function RenderFunctionComponent() &#123;  let initName;  if(firstRender)&#123;    [initName] = useState(&quot;Rudi&quot;);    firstRender = false;  &#125;  const [firstName, setFirstName] = useState(initName);  const [lastName, setLastName] = useState(&quot;Yardley&quot;);  return (    &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;/Button&gt;  );&#125;\n\n第一次render\n第一个render之后，我们的两个state，firstName 和 lastName 都对应了正确的值。接下来看看组件第二次render的时候，会发生什么情况。\n第二次render\n第二次render之后，我们的两个state， firstName和 lastName 都成了 Rudi。这显然是错误的，必须要避免这样使用hooks！但是这也给我们演示了，hooks的调用顺序，为什么不能改变。\nreact团队明确强调了hooks的2个使用原则，如果不按照这些原则来使用hooks，将会导致我们数据的不一致性！\n将hooks的操作想象成数组的操作，你可能不太会违背这些原则\nOK，现在你应该清楚，为什么我们不能在条件块或者循环语句里调用hooks了。因为调用hooks的过程中，我们是在操作数组上的指针，如果你在多次render中，改变了hooks的调用顺序，将导致数组上的指针和组件里的 useState 不匹配，从而返回错误的 state 以及 setter 。\n","categories":["React"],"tags":["React"]},{"title":"React作为UI运行时","url":"/posts/daba6559d597/","content":"宿主树宿主树是对UI的描述，类似用json描述组织架构树一样。\n但比常说的vdom的概念要更具体一点，并不是广义的结构描述模型，宿主树就是由具体的节点实例构成的。\n宿主树通常有它自己的命令式 API 。而 React 就是它上面的那一层。\n基于宿主树有两个最关键的部分：\n\n稳定性，因为宿主树是对UI的描述，所以不会大范围改变，相对稳定。\n通用型，每个UI的样式和交互行为，都可以拆分成可复用的最小单位。\n\n最重要的一点是，React的宿主树是随时间变化的树，通过时间数据，完成对宿主实力的操作。\n宿主实例宿主实例就是我们通常所说的 DOM 节点 — 就像当你调用 document.createElement(‘div’) 时获得的对象。\nReact会帮助你调用宿主实例的API,完成对实例的操作\n渲染器帮助React与宿主树通信以及如何管理宿主实例。React DOM、React Native都可以叫做渲染器。\n通常渲染有两种模式：\n\n直接对宿主实例的修改，也就是突变模式\n克隆宿主树并对宿主树顶级子树，也就是变化的树中的根节点进行操作，由于宿主树的不可变性，使得多线程更加容易。\n\n元素对于React来说，宿主实例就是React元素。即一个普通的javaScript对象。\n但React元素并不是一直存在，它会在删除和创建之间循环\n而且具有不可变性，不可以因为UI的改变而直接修改React元素，而是要重新创建它。\n所以React元素可以描述UI在特定时间点的样子，因为它不会再改变。\n入口每一个 React 渲染器都有一个“入口”。正是那个特定的 API 让我们告诉 React ，将特定的 React 元素树渲染到真正的宿主实例中去。\nReact DOM 的入口就是 ReactDOM.render\n协调React需要精确的处理渲染之间的细微差别，例如同时调用两次ReactDOM.render()\nReactDOM.render(  &lt;button className=&quot;blue&quot; /&gt;,  document.getElementById(&#x27;container&#x27;));// ... 之后 ...// 应该替换掉 button 宿主实例吗？// 还是在已有的 button 上更新属性？ReactDOM.render(  &lt;button className=&quot;red&quot; /&gt;,  document.getElementById(&#x27;container&#x27;));\n\n如果简单来做，需要删除掉原有的宿主实例，重新创建这个代价的巨大的。\n所以，通过协模块来处理React元素映射到宿主树的过程。上面的例子中React会更新className属性，而不是重新创建宿主实例。\nlet domNode = domContainer.firstChild;// 更新已有的宿主实例domNode.className = &#x27;red&#x27;;\n\n换句话说，React 需要决定何时更新一个已有的宿主实例来匹配新的 React 元素，何时该重新创建新的宿主实例。\n所以如果相同的元素类型在同一个地方先后出现两次，React 会重用已有的宿主实例。\n下面例子很好的解释了跟新还是创建\n// let domNode = document.createElement(&#x27;button&#x27;);// domNode.className = &#x27;blue&#x27;;// domContainer.appendChild(domNode);ReactDOM.render(  &lt;button className=&quot;blue&quot; /&gt;,  document.getElementById(&#x27;container&#x27;));// 能重用宿主实例吗？能！(button → button)// domNode.className = &#x27;red&#x27;;ReactDOM.render(  &lt;button className=&quot;red&quot; /&gt;,  document.getElementById(&#x27;container&#x27;));// 能重用宿主实例吗？不能！(button → p)// domContainer.removeChild(domNode);// domNode = document.createElement(&#x27;p&#x27;);// domNode.textContent = &#x27;Hello&#x27;;// domContainer.appendChild(domNode);ReactDOM.render(  &lt;p&gt;Hello&lt;/p&gt;,  document.getElementById(&#x27;container&#x27;));// 能重用宿主实例吗？能！(p → p)// domNode.textContent = &#x27;Goodbye&#x27;;ReactDOM.render(  &lt;p&gt;Goodbye&lt;/p&gt;,  document.getElementById(&#x27;container&#x27;));\n\n对于子树来说会先判断父元素是否需要重新创建，在对每一个子元素重复执行这个过程。\n条件对于父元素来说前后两次渲染的子元素可能不同\nfunction Form(&#123; showMessage &#125;) &#123;  let message = null;  if (showMessage) &#123;    message = &lt;p&gt;I was just added here!&lt;/p&gt;;  &#125;  return (    &lt;dialog&gt;      &#123;message&#125;      &lt;input /&gt;    &lt;/dialog&gt;  );&#125;\n\n不管 showMessage 是 true 还是 false ，在渲染的过程中  总是在第二个孩子的位置且不会改变。\n这样一来输入框中的状态就不会丢失了。\n列表比较树中同一位置的元素类型对于是否该重用还是重建相应的宿主实例往往已经足够。\n但这只适用于当子元素是静止的并且不会重排序的情况。在上面的例子中，即使 message 不存在，我们仍然知道输入框在消息之后，并且再没有其他的子元素。\n而当遇到动态列表时，我们不能确定其中的顺序总是一成不变的。\nReact 只会对其中的每个元素进行更新而不是将其重新排序。这样做会造成性能上的问题和潜在的 bug 。例如，当商品列表的顺序改变时，原本在第一个输入框的内容仍然会存在于现在的第一个输入框中 — 尽管事实上在商品列表里它应该代表着其他的商品！\n这就是为什么每次当输出中包含元素数组时，React 都会让你指定一个叫做 key 的属性。\nfunction ShoppingList(&#123; list &#125;) &#123;  return (    &lt;form&gt;      &#123;list.map(item =&gt; (        &lt;p key=&#123;item.productId&#125;&gt;          You bought &#123;item.name&#125;          &lt;br /&gt;          Enter how many do you want: &lt;input /&gt;        &lt;/p&gt;      ))&#125;    &lt;/form&gt;  )&#125;\n\n在渲染前后当key仍然相同时，React会重用先前的宿主实例，然后重新排序其兄弟元素。\n给key赋予什么值最好呢？最好的答案就是：一个元素不会改变即使它在父元素中的顺序被改变\n纯净在 React 中，幂等性比纯净性更加重要。\n在 React 组件中不允许有用户可以直接看到的副作用。换句话说，仅调用函数式组件时不应该在屏幕上产生任何变化。\n控制反转控制反转 (Inversion of control) 并不是一项新的技术，是 Martin Fowler 教授提出的一种软件设计模式。那到底什么被反转了？获得依赖对象的过程被反转了。控制反转 (下文统一简称为 IoC) 把传统模式中需要自己通过 new 实例化构造函数，或者通过工厂模式实例化的任务交给容器。通俗的来理解，就是本来当需要某个类（构造函数）的某个方法时，自己需要主动实例化变为被动，不需要再考虑如何实例化其他依赖的类，只需要依赖注入 (Dependency Injection, 下文统一简称为 DI), DI 是 IoC 的一种实现方式。所谓依赖注入就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。所以 IoC 和 DI 是从不同的角度的描述的同一件事情，就是通过引入 IoC 容器，利用依赖注入的方式，实现对象之间的解耦。\n\n组件不仅仅只是函数，它与宿主树紧密相连加上组件自身的状态提供更多的信息，包括时事件交互等。React可以知道组件的存，如果手动调用需要自己构建这些特性。\n\n组件类型参与协调 组件的类型决定了组件是否需要渲染。\n\nReact 能够推迟协调。 如果让 React 控制调用你的组件，它能做很多有趣的事情。例如，它可以让浏览器在组件调用之间做一些工作，这样重渲染大体量的组件树时就不会阻塞主线程。想要手动编排这个过程而不依赖 React 的话将会十分困难。\n\n更好的可调试性。 如果组件是库中所重视的一等公民，我们就可以构建丰富的开发者工具，用于开发中的自省。\n\n\n惰性求值function Page(&#123; currentUser, children &#125;) &#123;  if (!currentUser.isLoggedIn) &#123;    return &lt;h1&gt;Please login&lt;/h1&gt;;  &#125;  return (    &lt;Layout&gt;      &#123;children&#125;    &lt;/Layout&gt;  );&#125;\n\n&lt;Page&gt;  &#123;Comments()&#125;&lt;/Page&gt;\n\n如果是手动调用组件，即使Page并不会返回Comments的内容，但是Comments还是会被渲染。使我们的代码变得不那么脆弱。\n状态宿主实例能够拥有所有相关的局部状态：focus、selection、input 等等。我们想要在渲染更新概念上相同的 UI 时保留这些状态。\n我们也想可预测性地摧毁它们，当我们在概念上渲染的是完全不同的东西时。局部状态是如此有用，以至于 React 让你的组件也能拥有它。 组件仍然是函数但是 React 用对构建 UI 有好处的许多特性增强了它。在树中每个组件所绑定的局部状态就是这些特性之一。\n一致性即使我们想将协调过程本身分割成非阻塞的工作块，我们仍然需要在同步的循环中对真实的宿主实例进行操作。这样我们才能保证用户不会看见半更新状态的 UI ，浏览器也不会对用户不应看到的中间状态进行不必要的布局和样式的重新计算。\n这也是为什么 React 将所有的工作分成了“渲染阶段”和“提交阶段”的原因。渲染阶段 是当 React 调用你的组件然后进行协调的时段。在此阶段进行干涉是安全的且在未来这个阶段将会变成异步的。提交阶段 就是 React 操作宿主树的时候。而这个阶段永远是同步的。\n缓存当父组件通过 setState 准备更新时，React 默认会协调整个子树。因为 React 并不知道在父组件中的更新是否会影响到其子代，所以 React 默认保持一致性。\n当树的深度和广度达到一定程度时，你可以让 React 去缓存子树并且重用先前的渲染结果。 useMemo() Hooks\n默认情况下，React 不会故意缓存组件。许多组件在更新的过程中总是会接收到不同的 props ，所以对它们进行缓存只会造成净亏损。\n原始模型React 并没有使用Proxy的系统来支持细粒度的更新。换句话说，任何在顶层的更新只会触发协调而不是局部更新那些受影响的组件。\n这样的设计是有意而为之的。对于 web 应用来说交互时间是一个关键指标，而通过遍历整个模型去设置细粒度的监听器只会浪费宝贵的时间。此外，在很多应用中交互往往会导致或小（按钮悬停）或大（页面转换）的更新，因此细粒度的订阅只会浪费内存资源。\nReact 的设计原则之一就是它可以处理原始数据。如果你拥有从网络请求中获得的一组 JavaScript 对象，你可以将其直接交给组件而无需进行预处理。没有关于可以访问哪些属性的问题，或者当结构有所变化时造成的意外的性能缺损。React 渲染是 O(视图大小) 而不是 O(模型大小) ，并且你可以通过 windowing 显著地减少视图大小。\n有那么一些应用细粒度订阅对它们来说是有用的 — 例如股票代码。这是一个极少见的例子，因为“所有的东西都需要在同一时间内持续更新”。虽然命令式的方法能够优化此类代码，但 React 并不适用于这种情况。同样的，如果你想要解决该问题，你就得在 React 之上自己实现细粒度的订阅。\n注意，即使细粒度订阅和“反应式”系统也无法解决一些常见的性能问题。 例如，渲染一棵很深的树（在每次页面转换的时候发生）而不阻塞浏览器。改变跟踪并不会让它变得更快 — 这样只会让其变得更慢因为我们执行了额外的订阅工作。另一个问题是我们需要等待返回的数据在渲染视图之前。在 React 中，我们用并发渲染来解决这些问题。\n批量更新function Parent() &#123;  let [count, setCount] = useState(0);  return (    &lt;div onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;      Parent clicked &#123;count&#125; times      &lt;Child /&gt;    &lt;/div&gt;  );&#125;function Child() &#123;  let [count, setCount] = useState(0);  return (    &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;      Child clicked &#123;count&#125; times    &lt;/button&gt;  );&#125;\n当事件被触发时，子组件的 onClick 首先被触发（同时触发了它的 setState ）。然后父组件在它自己的 onClick 中调用 setState 。\n如果 React 立即重渲染组件以响应 setState 调用，最终我们会重渲染子组件两次：\n*** 进入 React 浏览器 click 事件处理过程 ***Child (onClick)  - setState  - re-render Child // 😞 不必要的重渲染Parent (onClick)  - setState  - re-render Parent  - re-render Child*** 结束 React 浏览器 click 事件处理过程 ***\n\n第一次 Child 组件渲染是浪费的。并且我们也不会让 React 跳过 Child 的第二次渲染因为 Parent 可能会传递不同的数据由于其自身的状态更新。\n这就是为什么 React 会在组件内所有事件触发完成后再进行批量更新的原因：\n*** 进入 React 浏览器 click 事件处理过程 ***Child (onClick)  - setStateParent (onClick)  - setState*** Processing state updates                     ***  - re-render Parent  - re-render Child*** 结束 React 浏览器 click 事件处理过程  ***\n\n组件内调用 setState 并不会立即执行重渲染。相反，React 会先触发所有的事件处理器，然后再触发一次重渲染以进行所谓的批量更新。\n调用树React 与通常意义上的编程语言进行时不同因为它针对于渲染 UI 树，这些树需要保持“活性”，这样才能使我们与其进行交互。在第一次 ReactDOM.render() 出现之前，DOM 操作并不会执行。\n这也许是对隐喻的延伸，但我喜欢把 React 组件当作 “调用树” 而不是 “调用栈” 。当我们调用完 Article 组件，它的 React “调用树” 帧并没有被摧毁。我们需要将局部状态保存以便映射到宿主实例的某个地方。\n这些“调用树”帧会随它们的局部状态和宿主实例一起被摧毁，但是只会在协调规则认为这是必要的时候执行。如果你曾经读过 React 源码，你就会知道这些帧其实就是 Fibers 。\nFibers 是局部状态真正存在的地方。当状态被更新后，React 将其下面的 Fibers 标记为需要进行协调，之后便会调用这些组件。\n","categories":["React"],"tags":["React"]},{"title":"useEffect指南","url":"/posts/4af037980b34/","content":"每次渲染时，UseEffect 都是一个新的自己每次重新渲染的时，useEffect 都会重新执行，而且如果没有添加依赖项数组的时候，每个 useEffect 都是全新的\n而且 useEffect 内部用到的变量都是属于，当前此次执行时捕获到的变量，所以如下：\nfunction Counter() &#123;  const [count, setCount] = useState(0);  function handleAlertClick() &#123;    setTimeout(() =&gt; &#123;      alert(&quot;You clicked on: &quot; + count);    &#125;, 3000);  &#125;  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt;      &lt;button onClick=&#123;handleAlertClick&#125;&gt;Show alert&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n点击 alert 按钮之后快速点击 click 按钮，在定时器结束之后并不会弹出修改后的值，而是弹出在点击 alert 时 useEffect 捕获到的状态\n如果你想读取一个过去或是未来的值，你可以用一个 Ref 去保存，因此对数据的操作不是在 react 的默认行为中，这样虽然显得代码不够干净，但可以确认是需要这样做。\nuseEffect 中的清理React 只会在浏览器绘制后运行 effects。这使得你的应用更流畅因为大多数 effects 并不会阻塞屏幕的更新。Effect 的清除同样被延迟了。上一次的 effect 会在重新渲染后被清除\n执行的过程应该是: 渲染新 UI -&gt; 清除旧的 Effect -&gt; 执行新的 Effect\n清除函数只能读取到在旧的 Effect 执行时捕获到的变量\nEffect 依赖React 它统一描述了初始渲染和之后的更新，React 会根据我们当前的 props 和 state 同步到 DOM，useEffect 使你能够根据 props 和 state 同步 React tree 之外的东西，也包括常说的副作用。\n如果你试图写一个 effect 会根据是否第一次渲染而表现不一致，可能违背了 React 初衷\n但是如果诚实的告诉了 Effect 依赖，还可能存在问题:\nuseEffect(() =&gt; &#123;  const id = setInterval(() =&gt; &#123;    setCount(count + 1);  &#125;, 1000);  return () =&gt; clearInterval(id);&#125;, [count]);\n\n由于依赖项的改变定时器被清除\n有两种方法可以解决，使用 setState 回调函数，或者使用 useReducer, 如果 useReducer 还需要依赖其他的内部变量，可以吧 useReducer 放到函数组建内部定义\n有的时候可能会觉得一个函数不会变换，所以没有加到依赖中，但事实上\nfunction SearchResults() &#123;  const [query, setQuery] = useState(&quot;react&quot;);  function getFetchUrl() &#123;    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;  &#125;  async function fetchData() &#123;    const result = await axios(getFetchUrl());    setData(result.data);  &#125;  useEffect(() =&gt; &#123;    fetchData();  &#125;, []);&#125;\n\n函数依赖的参数可能在其他的方法中变化\n简单处理的话可以吧相关的函数都放到 useEffect 中，而依赖项只是简单的 query\n另外也可以吧 getFetchUrl 放到组件外部，把 query 当做参数传入，或者使用 useCallback 包裹 getFetchUrl\n竞态问题class Article extends Component &#123;  state = &#123;    article: null,  &#125;;  componentDidMount() &#123;    this.fetchData(this.props.id);  &#125;  componentDidUpdate(prevProps) &#123;    if (prevProps.id !== this.props.id) &#123;      this.fetchData(this.props.id);    &#125;  &#125;  async fetchData(id) &#123;    const article = await API.fetchArticle(id);    this.setState(&#123; article &#125;);  &#125;  // ...&#125;\n\n如果 componentDidUpdate 中的请求比 componentDidMount 中的请求慢，那么更新中的请求数据会被初始化的请求数据覆盖\n我们想做的是，可以打断旧的更新\nfunction Article(&#123; id &#125;) &#123;  const [article, setArticle] = useState(null);  useEffect(() =&gt; &#123;    let didCancel = false;    async function fetchData() &#123;      const article = await API.fetchArticle(id);      if (!didCancel) &#123;        setArticle(article);      &#125;    &#125;    fetchData();    return () =&gt; &#123;      didCancel = true;    &#125;;  &#125;, [id]);&#125;\n","categories":["React"],"tags":["React"]},{"title":"react中的keep-alive","url":"/posts/e4780bfdf1cc/","content":"什么是 keep alivekeep-alive是vue内置的一个组件，而这个组件的作用就是能够缓存不活动的组件，一般情况下，组件进行切换的时候，默认会进行销毁，如果有需求，某个组件切换后不进行销毁，而是保存之前的状态，那么就可以利用keep-alive来实现。\n这对于某些路由切换等场景非常好用，例如，如果我们需要实现一个列表页和详情页，但在用户从详情页返回列表的时候，我们不希望重新请求接口获取，也不希望重置列表的过滤、排序等条件，那这时就可以对列表页的组件用 keep-alive 包裹一下，这样，当路由切换时，会将这个组件“失活”并缓存起来，而不是直接卸载掉。\n最简单的方案大部分开发者可能都会直接使用 display: none 来将 DOM 隐藏：\n&lt;div style=&#123;shouldHide ? &#123;display: &#x27;none&#x27;&#125; : &#123;&#125;&#125;&gt;  &lt;Foo/&gt;&lt;/div&gt;\n\n虽然在视觉上实现了keep-alive,但并没有真正的移除组件,所以导致转场动画难（TransitionGroup）以实现\n使用 Portals Api 实现 keep-alivePortals Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。\nimport React, &#123; useEffect, useState,useRef, useCallback &#125; from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;const KeepAlive = (props)=&gt;&#123;  // 创建DOM元素用于缓存react子元素  const [targetElement] = useState(()=&gt;document.createElement(&#x27;div&#x27;));  // 用于挂载缓存的子元素  const containerRef = useRef(null)  // 通过外层属性判断是否需要渲染自元素  useEffect(()=&gt;&#123;    if (props.active) &#123;      containerRef.current.appendChild(targetElement)    &#125; else &#123;      try &#123;        containerRef.current.removeChild(targetElement)      &#125; catch (e) &#123;&#125;    &#125;  &#125;,[    props.active,    targetElement  ])    return (    &lt;&gt;      &lt;div ref=&#123;containerRef&#125; /&gt;      &#123;ReactDOM.createPortal(props.children, targetElement)&#125;    &lt;/&gt;  )&#125;const Count = ()=&gt;&#123;  const [count,setCount]=  useState(1);  const addCount = useCallback(()=&gt;&#123;    setCount(state=&gt;state+1);  &#125;,[    setCount  ])  return (&lt;div&gt;    &lt;div onClick=&#123;addCount&#125;&gt;+1&lt;/div&gt;    &lt;div&gt;      &#123;count&#125;    &lt;/div&gt;  &lt;/div&gt;)&#125;const App = ()=&gt;&#123;  const [shouldHide,setShouldHide] = useState(false);    const toggleVisable = useCallback(()=&gt;&#123;    setShouldHide(state=&gt;!state)  &#125;,[    setShouldHide  ])  return (    &lt;div&gt;      &lt;div&gt;xxx&lt;/div&gt;      &lt;div onClick=&#123;toggleVisable&#125;&gt;显示隐藏&lt;/div&gt;      &lt;KeepAlive active=&#123;!shouldHide&#125;&gt;        &lt;Count/&gt;      &lt;/KeepAlive&gt;    &lt;/div&gt;  )&#125;export default App;\n\n用懒加载优化 Portals 方案目前我们的 Conditional 组件还有一点小小的瑕疵：当组件初次渲染时，不论当前的 active 是 true 还是 false ， Conditional 组件都会将 props.children 渲染。这对大型应用可能会带来非常明显的性能问题\nconst KeepAlive = (props)=&gt;&#123;  const [targetElement] = useState(()=&gt;document.createElement(&#x27;div&#x27;));  const containerRef = useRef(null);  const activeMark = useRef(false);  //一旦第一次加载后，会被标记为true,已加载并不会再改变  activeMark.current = activeMark.current || props.active;  useEffect(()=&gt;&#123;    if (props.active) &#123;      containerRef.current.appendChild(targetElement)    &#125; else &#123;      try &#123;        containerRef.current.removeChild(targetElement)      &#125; catch (e) &#123;&#125;    &#125;  &#125;,[    props.active,    targetElement  ])  return (    &lt;&gt;      &lt;div ref=&#123;containerRef&#125; /&gt;      &#123;        activeMark.current &amp;&amp; ReactDOM.createPortal(props.children, targetElement)      &#125;    &lt;/&gt;  )&#125;\n\nPortals 方案一些存在的问题\n需要手动控制 active ，不能直接基于子组件销毁&#x2F;创建的生命周期事件\n\n缺少失活&#x2F;激活的生命周期事件，子组件无法感知自己是不是被缓存起来了\n\n依赖了 ReactDOM ，对 SSR 不够友好\n\n\n另一种实现思路我们希望使用的时候可以像一个普通组件一样使用, 使用了KeepAlive包裹的组件将会被缓存\n&#123;show &amp;&amp; (  &lt;KeepAlive&gt;    &lt;Counter /&gt;  &lt;/KeepAlive&gt;)&#125;\n\n实现Wrapper组件通过一个外层的高阶组件缓存需要被keep-alive组件的信息\n提供一个keep方法并发放到下层组件中，用于收集kepp-alive组件信息\n把组件挂载到一个节点上\nimport React, &#123; createContext, useCallback, useRef, useState,memo, useEffect, useContext, useLayoutEffect &#125; from &#x27;react&#x27;const KeepAliveContext = createContext()export const AliveScope = memo((props) =&gt; &#123;  const nodes = useRef(&#123;&#125;);  const [cache,setCache] = useState(&#123;&#125;);  const promiseThen = useRef([]);    useLayoutEffect(()=&gt;&#123;    while(promiseThen.current.length) &#123;      const [resolve,id] = promiseThen.current.pop();      resolve(nodes.current[id]);    &#125;  &#125;,[    cache,  ])  const keep = useCallback((id,children)=&gt;(    new Promise(resolve=&gt;&#123;      setCache(cache=&gt; (&#123;...cache,[id]:children&#125;));      promiseThen.current.push([resolve,id])    &#125;)  ),[setCache]);    return (    &lt;KeepAliveContext.Provider value=&#123;keep&#125;&gt;      &#123;props.children&#125;      &#123;Object.entries(cache).map(([id, children]) =&gt; (        &lt;div          key=&#123;id&#125;          ref=&#123;node =&gt; &#123;            nodes.current[id] = node          &#125;&#125;        &gt;          &#123;children&#125;        &lt;/div&gt;      ))&#125;    &lt;/KeepAliveContext.Provider&gt;  )&#125;)\n\nkeep-alive组件的实现通过id找到缓存的组件，并append到指定的节点上\nconst KeepAlive = memo((&#123;id,children&#125;)=&gt;&#123;  const keep = useContext(KeepAliveContext);  const mountRef= useRef(null);  useEffect(()=&gt;&#123;     (async ()=&gt;&#123;      const element = await keep(id,children);      console.log(element);      mountRef.current &amp;&amp; mountRef.current.appendChild(element)    &#125;)()  &#125;,[    id,    children,    keep  ])  return (&lt;div ref = &#123;mountRef&#125;&gt;&lt;/div&gt;)&#125;)\n\n","categories":["React"],"tags":["React"]},{"title":"函数式组件与类组件有何不同？","url":"/posts/8133b19578e4/","content":"性能问题可以忽略性能主要取决于代码的作用，而不是选择函数式还是类组件。在我们的观察中，尽管优化策略各有略微不同，但性能差异可以忽略不计。\nhooks慢是因为在渲染中创建了函数么\n现在浏览器中闭包与类没有明显的性能差别，除非在极端的情况下，hooks在两点上更有效率\n\n避免了类组件实例化，和constructor中绑定时间处理函数的消耗\n\n常规代码使用hooks不需要过深的组件树嵌套，在封装的基础库中使用高阶组建，渲染props和context很常见\n\n\n传统上，React内联函数的性能问题主要与如何在子组件中为每个渲染断点shouldComponentUpdate传递新的回调有关。 \nHooks 使用三个HooksApi来解决\n\nuseCallback 在每次渲染中保持了相同的句柄引用，所以shouldComponentUpdate继续工作\n\nuseMemo 控制子组件何时渲染，不在需要prueCompnent\n\nuseReducer 避免了需要吧会掉函数传递过深\n\n\n类组件存在的问题下面模拟在点击一个按钮之后发送一个关注请求\nindex.js\nimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import ProfilePageFunction from &#x27;./ProfilePageFunction&#x27;;import ProfilePageClass from &#x27;./ProfilePageClass&#x27;;class App extends React.Component &#123;  state = &#123;    user: &#x27;Dan&#x27;,  &#125;;  render() &#123;    return (      &lt;&gt;        &lt;label&gt;          &lt;b&gt;Choose profile to view: &lt;/b&gt;          &lt;select            value=&#123;this.state.user&#125;            onChange=&#123;e =&gt; this.setState(&#123; user: e.target.value &#125;)&#125;          &gt;            &lt;option value=&quot;Dan&quot;&gt;Dan&lt;/option&gt;            &lt;option value=&quot;Sophie&quot;&gt;Sophie&lt;/option&gt;            &lt;option value=&quot;Sunil&quot;&gt;Sunil&lt;/option&gt;          &lt;/select&gt;        &lt;/label&gt;        &lt;h1&gt;Welcome to &#123;this.state.user&#125;’s profile!&lt;/h1&gt;        &lt;p&gt;          &lt;ProfilePageFunction user=&#123;this.state.user&#125; /&gt;          &lt;b&gt; (function)&lt;/b&gt;        &lt;/p&gt;        &lt;p&gt;          &lt;ProfilePageClass user=&#123;this.state.user&#125; /&gt;          &lt;b&gt; (class)&lt;/b&gt;        &lt;/p&gt;        &lt;p&gt;          Can you spot the difference in the behavior?        &lt;/p&gt;      &lt;/&gt;    )  &#125;&#125;const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);\n\nClassCompnent\nimport React from &#x27;react&#x27;;class ProfilePage extends React.Component &#123;  showMessage = () =&gt; &#123;    alert(&#x27;Followed &#x27; + this.props.user);  &#125;;  handleClick = () =&gt; &#123;    setTimeout(this.showMessage, 3000);  &#125;;  render() &#123;    return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;;  &#125;&#125;export default ProfilePage;\n\n再点击按钮三秒之后会弹出关注的姓名，但是如果在点击之后马上修改下啦列表的值，那么三秒之后显示的是修改之后的值，这显然史有问题的\n\n造成这个问题的原因就是this是不断在改变的，虽然在第一次渲染结束的时候，已经为setTimeout的回调函数传入了类方法showMessage，但是当点击按钮之后迅速切换下拉框，state的改变会导致组建重新加载，这时子组件会接受到一个过于新的props, 而setTimeout中的回调函数并没有与之前的旧的props绑定，而是直接读取了，this中较新的props\n也许你会想使bind，但是这并不起作用,当读取props的时候，this中的props已经被修改，bind只是绑定了类方法的执行上下文，但是并没有固定为上一次的this\nclass ProfilePage extends React.Component &#123;  constructor(props) &#123;    super(props);    this.showMessage = this.showMessage.bind(this);    this.handleClick = this.handleClick.bind(this);  &#125;  showMessage() &#123;    alert(&#x27;Followed &#x27; + this.props.user);  &#125;  handleClick() &#123;    setTimeout(this.showMessage, 3000);  &#125;  render() &#123;    return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;;  &#125;&#125;\n\n类组件问题解决方法也许你会想到绑定回调函数之前先把用到的props缓存起来\nclass ProfilePage extends React.Component &#123;  showMessage = (user) =&gt; &#123;    alert(&#x27;Followed &#x27; + user);  &#125;;  handleClick = () =&gt; &#123;    const &#123;user&#125; = this.props;    setTimeout(() =&gt; this.showMessage(user), 3000);  &#125;;  render() &#123;    return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;;  &#125;&#125;\n\n这种方法使得代码明显变得更加冗长，并且随着时间推移容易出错。如果我们需要的不止是一个props怎么办？如果我们还需要访问state怎么办？如果 showMessage 调用了另一个方法，然后那个方法中读取了 this.props.something 或者 this.state.something，我们又将遇到同样的问题。然后我们不得不将this.props和this.state以函数参数的形式在被showMessage调用的每个方法中一路传递下去。\n所以我们想到用闭包的方式解决props不能被保存的问题\nclass ProfilePage extends React.Component &#123;  render() &#123;    // Capture the props!    const props = this.props;    // Note: we are *inside render*.    // These aren&#x27;t class methods.    const showMessage = () =&gt; &#123;      alert(&#x27;Followed &#x27; + props.user);    &#125;;    const handleClick = () =&gt; &#123;      setTimeout(showMessage, 3000);    &#125;;    return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;;  &#125;&#125;\n\n既然只需要在render函数中定义各种函数，所以自然想到，可以省略class,直接使用函数式组件\nfunction ProfilePage(&#123; user &#125;) &#123;  const showMessage = () =&gt; &#123;    alert(&#x27;Followed &#x27; + user);  &#125;;  const handleClick = () =&gt; &#123;    setTimeout(showMessage, 3000);  &#125;;  return (    &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;  );&#125;\n\n而hooks其实就是捕获了state中的值\nfunction MessageThread() &#123;  const [message, setMessage] = useState(&#x27;&#x27;);  const showMessage = () =&gt; &#123;    alert(&#x27;You said: &#x27; + message);  &#125;;  const handleSendClick = () =&gt; &#123;    setTimeout(showMessage, 3000);  &#125;;  const handleMessageChange = (e) =&gt; &#123;    setMessage(e.target.value);  &#125;;  return (    &lt;&gt;      &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt;      &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt;    &lt;/&gt;  );&#125;\n\nHooks与未来值上面我们已经能拿到一个状态的过去值，但是如何能拿到一个状态的未来值\n我们在一个effect内部执行赋值操作以便让ref的值只会在DOM被更新后才会改变。这确保了我们的变量突变不会破坏依赖于可中断渲染的时间切片和 Suspense等特性。\nfunction ProfilePage(props) &#123;  const ref = useRef(null);  const showMessage = () =&gt; &#123;    alert(&quot;Followed &quot; + ref.current.user);  &#125;;  useEffect(() =&gt; &#123;    ref.current =&#123;user:props.user&#125;;  &#125;, [props,ref]);  const handleClick = () =&gt; &#123;    setTimeout(showMessage, 3000);  &#125;;  return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;;&#125;\n\n总结所谓的“陈旧的闭包”问题的出现多是由于错误的假设了“函数不会改变”或者“props永远是一样的”。事实并非如此。\n函数捕获了他们的props和state —— 因此它们的标识也同样重要。这不是一个bug，而是一个函数式组件的特性。例如，对于useEffect或者useCallback来说，函数不应该被排除在“依赖数组”之外。（正确的解决方案通常是使用上面说过的useReducer或者useRef）\n","categories":["React"],"tags":["React"]}]